{
  "generatedSource": [
    {
      "filename": "Cargo.toml",
      "content": "[workspace]\n\nresolver = \"2\"\nmembers = [\n  \"packages/contract-monkey/src\",\n  \"packages/contract-giraffe/src\",\n  \"packages/contract-bee/src\",\n  \"packages/contract-coin/src\",\n  \"packages/contract-swarm/src\",\n  \"packages/contract-hydra/src\",\n  \"packages/contract-monkey-branch/src\",\n  \"packages/contract-bridge/src\",\n  \"packages/contract-golden-gate/src\",\n  \"packages/contract-gold/src\",\n  \"packages/contract-silver/src\",\n  \"packages/contract-rhodium/src\",\n  \"packages/contract-hive/src\",\n  \"packages/contract-transaction/src\",\n  \"packages/contract-block/src\",\n  \"packages/contract-blockchain/src\",\n  \"packages/contract-polkadot/src\",\n  \"packages/contract-peer-review/src\",\n  \"packages/contract-cardano/src\",\n  \"packages/contract-bear/src\",\n  \"packages/contract-beer/src\",\n  \"packages/contract-lock/src\",\n  \"packages/contract-marmalade/src\",\n  \"packages/contract-super-marmalade/src\",\n  \"packages/contract-hyper-marmalade/src\",\n  \"packages/contract-game/src\",\n  \"packages/contract-unifiers/src\",\n]\nexclude = [\n  \".cargo\",\n  \"target\"\n]\n\n[workspace.dependencies]\nink = { version = \"5.0.0\", default-features = false }",
      "contentHash": "493f9edbbcf9e90c6f4fb1c8ec53c7a8f8e2ba54db08fb7cbe50208c67f5b4af",
      "noWriteIfExists": false
    },
    {
      "filename": "ITEMS.md",
      "content": "# Items\n\nIn this document we list all **items** (or _elements_) and **recipes** that can be found in the game. We also provide some explanation of the most important game mechanics revolving around items and recipes.\n\n## Buying\n\n**Buying an item**: Players may at any time call the game contract, transfer some value in the call, and receive items equal to the value transferred. The price of an item is calculated as follows:\n\nFor starters, each **item** has a **tier**. The item tier is a **positive integer number**. The game always has a **buy offer**, which is a tuple of (**native token price**, **received tier points**). When the player **buys**, they indirectly buy tier points, and may receive `floor(received_tier_points / tier)` items. The game only considers `floor(transfered_value / native_token_price)` amount of money transfered in, and the remainder is lost (or donated to the contract, however you want to see it).\n\n## Items\n\n* **Monkey** (`1`): We need a description here\n* **Giraffe** (`1`): We need a description here\n* **Bee** (`1`): We need a description here\n* **Coin** (`1`): We need a description here\n* **Swarm** (`2`): We need a description here\n* **Hydra** (`2`): We need a description here\n* **Monkey Branch** (`2`): We need a description here\n* **Bridge** (`2`): We need a description here\n* **Golden Gate** (`2`): We need a description here\n* **Gold** (`1`): We need a description here\n* **Silver** (`1`): We need a description here\n* **Rhodium** (`1`): We need a description here\n* **Hive** (`1`): We need a description here\n* **Transaction** (`1`): We need a description here\n* **Block** (`1`): We need a description here\n* **Blockchain** (`1`): We need a description here\n* **Polkadot** (`1`): We need a description here\n* **Peer Review** (`1`): We need a description here\n* **Cardano** (`2`): We need a description here\n* **Bear** (`1`): We need a description here\n* **Beer** (`2`): We need a description here\n* **Lock** (`2`): We need a description here\n* **Marmalade** (`1`): We need a description here\n* **Super Marmalade** (`2`): We need a description here\n* **Hyper Marmalade** (`2`): We need a description here\n\n## Recipes\n\n* **Make Swarm** (`1 + 1 -> 2`) - **Bee** + **Bee** -> **Swarm**: \n* **Make Hydra** (`1 + 1 -> 2`) - **Giraffe** + **Giraffe** -> **Hydra**: \n* **Make Monkeybranch** (`1 + 2 -> 2`) - **Monkey** + **Hydra** -> **Monkey Branch**: \n* **Make Bridge** (`2 + 2 -> 2`) - **Monkey Branch** + **Monkey Branch** -> **Bridge**: \n* **Make Goldengate** (`1 + 2 -> 2`) - **Coin** + **Bridge** -> **Golden Gate**: \n* **Make Cardano** (`1 + 1 -> 2`) - **Blockchain** + **Peer Review** -> **Cardano**: \n* **Make Beer** (`1 + 1 -> 2`) - **Bee** + **Bear** -> **Beer**: \n* **Make Lock** (`1 + 1 -> 2`) - **Silver** + **Silver** -> **Lock**: \n* **Make Supermarmalade** (`1 + 1 -> 2`) - **Marmalade** + **Marmalade** -> **Super Marmalade**: \n* **Make Hypermarmalade** (`2 + 2 -> 2`) - **Super Marmalade** + **Super Marmalade** -> **Hyper Marmalade**: \n",
      "contentHash": "cad9ac75418ef042ac17d0d8dfaab87f8c63abf7ee6aa9c7b31c0dc6f98ffe71",
      "noWriteIfExists": false
    },
    {
      "filename": "package.json",
      "content": "{\n  \"name\": \"@siocode/not-a-bird\",\n  \"version\": \"0.0.1\",\n  \"private\": true,\n  \"workspaces\": [\n    \"packages/*\"\n  ],\n  \"dependencies\": {\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\",\n    \"rxjs\": \"7.8.1\",\n    \"@polkadot/api\": \"11.0.2\",\n    \"@polkadot/api-contract\": \"11.0.2\",\n    \"leva\": \"0.9.35\",\n    \"@unique-nft/accounts\": \"^0.3.7\",\n    \"@unique-nft/sdk\": \"^0.7.4\",\n    \"bulma\": \"1.0.0\",\n    \"listr2\": \"8.2.1\"\n  },\n  \"devDependencies\": {\n    \"@types/react\": \"18.2.79\",\n    \"@types/react-dom\": \"18.2.25\",\n    \"chalk\": \"4\",\n    \"chokidar\": \"3.6.0\",\n    \"concurrently\": \"8.2.2\",\n    \"esbuild\": \"0.20.2\",\n    \"fs-extra\": \"11.2.0\",\n    \"sass\": \"1.75.0\",\n    \"typescript\": \"5.4.5\",\n    \"prettier\": \"^3.2.5\"\n  },\n  \"scripts\": {\n    \"c:monkey\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-monkey/src/Cargo.toml\",\n    \"c:giraffe\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-giraffe/src/Cargo.toml\",\n    \"c:bee\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-bee/src/Cargo.toml\",\n    \"c:coin\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-coin/src/Cargo.toml\",\n    \"c:swarm\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-swarm/src/Cargo.toml\",\n    \"c:hydra\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-hydra/src/Cargo.toml\",\n    \"c:monkey-branch\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-monkey-branch/src/Cargo.toml\",\n    \"c:bridge\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-bridge/src/Cargo.toml\",\n    \"c:golden-gate\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-golden-gate/src/Cargo.toml\",\n    \"c:gold\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-gold/src/Cargo.toml\",\n    \"c:silver\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-silver/src/Cargo.toml\",\n    \"c:rhodium\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-rhodium/src/Cargo.toml\",\n    \"c:hive\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-hive/src/Cargo.toml\",\n    \"c:transaction\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-transaction/src/Cargo.toml\",\n    \"c:block\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-block/src/Cargo.toml\",\n    \"c:blockchain\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-blockchain/src/Cargo.toml\",\n    \"c:polkadot\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-polkadot/src/Cargo.toml\",\n    \"c:peer-review\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-peer-review/src/Cargo.toml\",\n    \"c:cardano\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-cardano/src/Cargo.toml\",\n    \"c:bear\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-bear/src/Cargo.toml\",\n    \"c:beer\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-beer/src/Cargo.toml\",\n    \"c:lock\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-lock/src/Cargo.toml\",\n    \"c:marmalade\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-marmalade/src/Cargo.toml\",\n    \"c:super-marmalade\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-super-marmalade/src/Cargo.toml\",\n    \"c:hyper-marmalade\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-hyper-marmalade/src/Cargo.toml\",\n    \"c:unifiers\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-unifiers/src/Cargo.toml\",\n    \"c:game\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-game/src/Cargo.toml\",\n    \"build:contracts\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-game/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-monkey/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-giraffe/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-bee/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-coin/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-swarm/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-hydra/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-monkey-branch/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-bridge/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-golden-gate/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-gold/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-silver/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-rhodium/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-hive/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-transaction/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-block/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-blockchain/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-polkadot/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-peer-review/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-cardano/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-bear/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-beer/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-lock/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-marmalade/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-super-marmalade/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-hyper-marmalade/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-unifiers/src/Cargo.toml\",\n    \"build\": \"npm run -w @not-a-bird/app-game build\",\n    \"serve\": \"npm run -w @not-a-bird/app-game serve\"\n  }\n}",
      "contentHash": "b24538d0ac577602ade45b30bd9ad228c460cc8e99406e378382f846ec64169d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bear/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bear/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-bear\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Bear'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "c5e820e944f8315655113d3a7309f6e7465579ed7c6357322e52050973c595aa",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bear/README.md",
      "content": "# Bear - Contract\n\nThis is a Bear contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "2e39386436559c232cef064aa2d58095f11999f380fd440efa3b2d39d87cf757",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bear/src/Cargo.toml",
      "content": "[package]\nname = \"bear\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "60704033e05fab4c47ecb60980d99ac3d6e1c490d027c3edccb837a47a885d8e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bear/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod bear {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Bear' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BearContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BearContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BearContract {\n        /// Creates a new PSP-22 compatible Bear Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Bear\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBEAR\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "ba8baed7d9751f9e5b4991eed8f7eab8a28db0a9e8b92213b9e2b4d694fa80c4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bee/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bee/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-bee\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Bee'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "df64f208eb3b5902955f976d625a85877511581920afa69e625468e37ae766f7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bee/README.md",
      "content": "# Bee - Contract\n\nThis is a Bee contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "42ba68de5e5347dd40443ff01fbc82bff826ab61e61a2d8b482bfb9fcbd772cd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bee/src/Cargo.toml",
      "content": "[package]\nname = \"bee\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "0e85afa1508d8f9529c480efd872ee6597794bf4bf28e4ec631ee91e5e2b8b4f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bee/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod bee {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Bee' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BeeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BeeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BeeContract {\n        /// Creates a new PSP-22 compatible Bee Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Bee\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBEE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "e6b381ec395d4a73d7050366847ebafbdba846a0e928311c565777102fb9a63d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-beer/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-beer/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-beer\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Beer'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "005d88ee68ee7a19518883da7c4b28740ed8cc718f5b528a8d7d4ecc38e555b3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-beer/README.md",
      "content": "# Beer - Contract\n\nThis is a Beer contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "6556596f4bcae348b32f702943fa832f42ecd2004c10804c33cde99e376c20bf",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-beer/src/Cargo.toml",
      "content": "[package]\nname = \"beer\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "4a35c94ae27cf7cc8f4d0f876e2d61353fe0b6b9493a06041c0a725fdce40be5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-beer/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod beer {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Beer' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BeerContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BeerContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BeerContract {\n        /// Creates a new PSP-22 compatible Beer Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Beer\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBEER\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "03ed0a6783e40fddd1cfc547f4feff517236da1093a0937861f1a1ddf2219ce7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-block/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-block/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-block\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Block'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "334d2d40813210cc72b266c9c2ad222b3e1ad182859785be9182f074baca289c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-block/README.md",
      "content": "# Block - Contract\n\nThis is a Block contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "13895fe29965cbd074b5c51b99dd9cf6b75a3cc4525ed46d83d51d37069f596e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-block/src/Cargo.toml",
      "content": "[package]\nname = \"block\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "f0e3a9150f2b7779226738fbaa6c128b225e9d1328025468eb34c029a8bb6c5f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-block/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod block {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Block' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BlockContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BlockContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BlockContract {\n        /// Creates a new PSP-22 compatible Block Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Block\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBLOCK\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "ee63644084ebc5d51b9b7a588f6911248a9186ed5634c784c1ec04c58779505b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-blockchain/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-blockchain/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-blockchain\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Blockchain'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "16670b267ea062759434a9ab7b70ad03b8a6b2d4a50d6ff9820a9c73aec6c2fd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-blockchain/README.md",
      "content": "# Blockchain - Contract\n\nThis is a Blockchain contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "89fd1eb1fc51bb576e9928b8589b28db9f874a64ba7ea17c7110262b532e8d29",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-blockchain/src/Cargo.toml",
      "content": "[package]\nname = \"blockchain\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "069aabba9bacef8822abdac9bf53a26022ceafdf37f3c8e153a8e155917112c7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-blockchain/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod blockchain {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Blockchain' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BlockchainContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BlockchainContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BlockchainContract {\n        /// Creates a new PSP-22 compatible Blockchain Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Blockchain\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBLOCKCHAIN\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "e10b499f0e6887309e713178a1d92558b718bcc9c298f4b1d7a0a32af1b14695",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bridge/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bridge/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-bridge\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Bridge'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "71e57b82fb51c0038e7815d651f794f959d29392f62e22fe9bd87602c88fbcc6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bridge/README.md",
      "content": "# Bridge - Contract\n\nThis is a Bridge contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "48c4e7c5c8fc03815d109d8ac28bfffb8c64584ab278c92c7038d07d8208d2f2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bridge/src/Cargo.toml",
      "content": "[package]\nname = \"bridge\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "822034f54388ed73573ab7cb52ac11802c17abc0060991b0055a86da5f10fcc7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bridge/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod bridge {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Bridge' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BridgeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BridgeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BridgeContract {\n        /// Creates a new PSP-22 compatible Bridge Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Bridge\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBRIDGE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "a6216ae4fa6ca4dbfab290d7f1d6580fe363373f9c626b2efdfc28713394c49f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cardano/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cardano/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-cardano\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Cardano'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "6cd90711295a05aba86bdc6cbd519d49351c793cfc191565d6b7623dd622c51d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cardano/README.md",
      "content": "# Cardano - Contract\n\nThis is a Cardano contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "e50327f0e5f343e9bad8e9c4531ef3b6173917ffc7473062bc1d24260f1cfcb9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cardano/src/Cargo.toml",
      "content": "[package]\nname = \"cardano\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "a70bc88fa4d69eec39df5bca97c6e17c7f332659e98bdb548c8336c9901027c0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cardano/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod cardano {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Cardano' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct CardanoContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for CardanoContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl CardanoContract {\n        /// Creates a new PSP-22 compatible Cardano Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Cardano\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MCARDANO\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "6289ff33bfd827f122a875fa42a3ac292a47726f123ab7a1503faf188945e79c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-coin/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-coin/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-coin\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Coin'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "c01f7f0195c293e8b2637c9ddfa32450c159c21145e74c16d991e6dd3d9d54aa",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-coin/README.md",
      "content": "# Coin - Contract\n\nThis is a Coin contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "bf8289471baa5931743abce48670040b5cdc475561d9e9fe8c51e3ee88953a6d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-coin/src/Cargo.toml",
      "content": "[package]\nname = \"coin\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "8f30cc841cfd8df72c67fc0ab25254dfc3ff5936b80bd983bb7cf83699e52cc6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-coin/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod coin {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Coin' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct CoinContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for CoinContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl CoinContract {\n        /// Creates a new PSP-22 compatible Coin Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Coin\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MCOIN\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "f9ae3f6a1e24162d0676552b60bcee822aea852b2ff6a213a23c27e8a68e2a37",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-giraffe/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-giraffe/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-giraffe\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Giraffe'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "9ab37aa292aea97759eb079afc0a1ed13cbbe07c2146a9c1c9a66437b8a0647c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-giraffe/README.md",
      "content": "# Giraffe - Contract\n\nThis is a Giraffe contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "ccfc0ee2c15d5195774e45cd40e7ff8df5eca00da502cc996a2b5c26757ea7a8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-giraffe/src/Cargo.toml",
      "content": "[package]\nname = \"giraffe\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "dd2c9f669ee88d2a3c3fa2d9bcd351cff275320990a81c87a55b38d68c80ff10",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-giraffe/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod giraffe {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Giraffe' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct GiraffeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for GiraffeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl GiraffeContract {\n        /// Creates a new PSP-22 compatible Giraffe Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Giraffe\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MGIRAFFE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "97471cd37cff0add32955f7bb977a44a2d706dcc2ffb827144ef20d75b0a5c7e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-gold/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-gold/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-gold\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Gold'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "f11aa5053c746bfe2fdacafa76749ec8151de17909ceda192f5037ca4a35789b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-gold/README.md",
      "content": "# Gold - Contract\n\nThis is a Gold contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "bd6c32971670789fc6782a9cfe64761d704716d704be3802ef74930e5f6c5038",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-gold/src/Cargo.toml",
      "content": "[package]\nname = \"gold\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "4744d485a69314636ce0e6d4696b8cf4ef151005920d947d59d4f9f8419e0bb2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-gold/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod gold {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Gold' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct GoldContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for GoldContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl GoldContract {\n        /// Creates a new PSP-22 compatible Gold Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Gold\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MGOLD\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "1bf31f1ecfc78be555541f6e8ef6c1c49bb7f6baad45650add82608c72cff88d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-golden-gate/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-golden-gate/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-golden-gate\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'GoldenGate'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "b95c1f9f8e48798c34791591167ab62fb6d5395b13c049c90ea8a8d24db4cedb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-golden-gate/README.md",
      "content": "# GoldenGate - Contract\n\nThis is a GoldenGate contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "1932e4513aa7b3da879888bdca7c5de11d1a34f7e3649d352a57f5d424402415",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-golden-gate/src/Cargo.toml",
      "content": "[package]\nname = \"golden_gate\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "45e0b56582c45d117111235d4157c37653da5ead7f7bdd653adcca73648bdaf6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-golden-gate/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod golden_gate {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'GoldenGate' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct GoldenGateContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for GoldenGateContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl GoldenGateContract {\n        /// Creates a new PSP-22 compatible Golden Gate Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Golden Gate\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MGOLDEN_GATE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "23ac764ea4341d18eecb7c8ccd8f50f3345fc47501b55c825b431fb7ab63cf87",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hive/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hive/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-hive\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Hive'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "cde7ec20c8f10435404d021925ec77007917a7799215340fb137b4df5d399a4c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hive/README.md",
      "content": "# Hive - Contract\n\nThis is a Hive contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "5d576fb4fe865a41e413953672d12eeaa28ccfee5e18ab4147e746a45ebb1838",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hive/src/Cargo.toml",
      "content": "[package]\nname = \"hive\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "d2605dfba42a28e60498eec922d6552b3969807793e9ca93959a86ae9416ff07",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hive/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod hive {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Hive' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct HiveContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for HiveContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl HiveContract {\n        /// Creates a new PSP-22 compatible Hive Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Hive\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MHIVE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "75a37fd20ceeef476e2a4d0211bca5cb91ce270bfccd24f0423de052e67582f3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hydra/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hydra/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-hydra\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Hydra'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "d5c05fa62915939b813e1f02a41a0e99aec48e5975679a2b4743c975b61ee065",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hydra/README.md",
      "content": "# Hydra - Contract\n\nThis is a Hydra contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "fc131ebe193171c5b792e3af19b11f593e30fdcd7855e412b6c271bff00890e3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hydra/src/Cargo.toml",
      "content": "[package]\nname = \"hydra\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "0caaa876a93b04705396fb01474a007f16eb92f9e0848e7db129845bbfcb646f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hydra/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod hydra {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Hydra' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct HydraContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for HydraContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl HydraContract {\n        /// Creates a new PSP-22 compatible Hydra Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Hydra\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MHYDRA\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "554fd625c7aad4eb6923da13783e140e5266b806e7ca2ef8a0ed536cbae5f8c4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hyper-marmalade/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hyper-marmalade/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-hyper-marmalade\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'HyperMarmalade'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "8feef154feadcea3438aa5d5f49d5fab1de4c7c1fec641a2b776f9f2a4b4d52a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hyper-marmalade/README.md",
      "content": "# HyperMarmalade - Contract\n\nThis is a HyperMarmalade contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "e240856fc2104866007c6a789a5b5a82ec9d3c7e5733f42425850c4e131ec145",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hyper-marmalade/src/Cargo.toml",
      "content": "[package]\nname = \"hyper_marmalade\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "6d473bef655c2a15d2c817b95b09af4d9182e61d3672757513c0ecc762ae2cec",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hyper-marmalade/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod hyper_marmalade {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'HyperMarmalade' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct HyperMarmaladeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for HyperMarmaladeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl HyperMarmaladeContract {\n        /// Creates a new PSP-22 compatible Hyper Marmalade Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Hyper Marmalade\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MHYPER_MARMALADE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "6753c6db33c3eb29dfc8db32451852a6b1b0a1869132d8cfa68bd6d0b81b6686",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lock/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lock/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-lock\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Lock'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "e71f4face98093d848aec0167212897a7201f7dbdb908474cab088641ca23116",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lock/README.md",
      "content": "# Lock - Contract\n\nThis is a Lock contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "97e2cdf1b9ddefa6f3f76a74ae5048a2bb5c30e507d9dc691db7a831272a1f04",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lock/src/Cargo.toml",
      "content": "[package]\nname = \"lock\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "c31f2a897a0978d62d065789d4f771b45818e06358e8118727c874b4434b12ef",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lock/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod lock {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Lock' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct LockContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for LockContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl LockContract {\n        /// Creates a new PSP-22 compatible Lock Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Lock\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MLOCK\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "762fcad080ea449dc8f5d8938548b3e69474e6392dcaf2f5a7ba19090244590a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-marmalade/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-marmalade/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-marmalade\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Marmalade'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "3327b1212b5a102bf1ccf62522ec1ca06606766d15cd1956d4fa359105f0bc89",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-marmalade/README.md",
      "content": "# Marmalade - Contract\n\nThis is a Marmalade contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "e2212a2d07aea142b29abfc5e594eb20b8d85fc2c413b556b7ab71b801a0bc86",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-marmalade/src/Cargo.toml",
      "content": "[package]\nname = \"marmalade\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "183944a233218611a90c6e110398a59bdf193992556d7331a39490d79c2ae9be",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-marmalade/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod marmalade {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Marmalade' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct MarmaladeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for MarmaladeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl MarmaladeContract {\n        /// Creates a new PSP-22 compatible Marmalade Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Marmalade\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MMARMALADE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "3b48dd0d6a151f3c6fcd8d3e397c4d90c174cd8384f4df59998e57f9d345cd04",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monkey-branch/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monkey-branch/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-monkey-branch\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'MonkeyBranch'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "eb787efb08b5fc8bc11996e01d17bec955550d8492f78250a384059252156cb0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monkey-branch/README.md",
      "content": "# MonkeyBranch - Contract\n\nThis is a MonkeyBranch contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "5e1f576f11911a96a603d73bf315812c43381903a7b86a00f1c7232ccfa7c5f4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monkey-branch/src/Cargo.toml",
      "content": "[package]\nname = \"monkey_branch\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "7000c0a534a43b8262b003e2e77f00c504293d5a11328f12d1833dac4add41b3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monkey-branch/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod monkey_branch {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'MonkeyBranch' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct MonkeyBranchContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for MonkeyBranchContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl MonkeyBranchContract {\n        /// Creates a new PSP-22 compatible Monkey Branch Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Monkey Branch\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MMONKEY_BRANCH\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "ed0fd02a3347786423250507fe073cc5c6fdd5ee2d856bb7c4b2f125f5402e5d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monkey/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monkey/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-monkey\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Monkey'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "de14ebeaea51e73d0f1747dcee917bc533e3ea4a72ec5a723216ab77b5c8ff0d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monkey/README.md",
      "content": "# Monkey - Contract\n\nThis is a Monkey contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "0fe44480ded17f5789b1971f83f2f32ddc380bb8d46300682eb8afbae74c3462",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monkey/src/Cargo.toml",
      "content": "[package]\nname = \"monkey\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "7f6f7dabf709af47b4eb4a27d330ee0dfd4dabd8cfe0896733088724015c9c92",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monkey/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod monkey {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Monkey' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct MonkeyContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for MonkeyContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl MonkeyContract {\n        /// Creates a new PSP-22 compatible Monkey Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Monkey\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MMONKEY\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "c61a23b45a84087b3389cc01e039cd04a59ef2d3aec7bf670ee1ca6b366b7c6e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-peer-review/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-peer-review/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-peer-review\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'PeerReview'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "4f32783a421fe39c823946001632ce16944ee59eac0309737d5c084560c796b1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-peer-review/README.md",
      "content": "# PeerReview - Contract\n\nThis is a PeerReview contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "ed19b9c3427d248e4eee1a77c43607a2317d9ded59c7fc7cfb440e1f73e7ac0c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-peer-review/src/Cargo.toml",
      "content": "[package]\nname = \"peer_review\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "d6979f10e0b8b3d93bcd4ad72a74ecb5f9679af23d008c1b81921ff749680dad",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-peer-review/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod peer_review {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'PeerReview' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct PeerReviewContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for PeerReviewContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl PeerReviewContract {\n        /// Creates a new PSP-22 compatible Peer Review Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Peer Review\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MPEER_REVIEW\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "8bf2a8521b9992f770255b4837641cfbae5aff1b43b8e5fca0dc6683195b73f4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-polkadot/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-polkadot/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-polkadot\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Polkadot'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "cd9d8d09b5e590980bf26d85a3731eb15ff8f0bceefe5932c807b244c8f9d207",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-polkadot/README.md",
      "content": "# Polkadot - Contract\n\nThis is a Polkadot contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "9b0fa293dc49386b4cfa6be13f796490255812517a493d54d3df339e251f5fbf",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-polkadot/src/Cargo.toml",
      "content": "[package]\nname = \"polkadot\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "4a2d079862b27c896f4a4be1ef2577e4b00e21b7a5e03ba2d92ca853d495cf3a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-polkadot/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod polkadot {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Polkadot' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct PolkadotContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for PolkadotContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl PolkadotContract {\n        /// Creates a new PSP-22 compatible Polkadot Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Polkadot\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MPOLKADOT\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "417a9d721c82f963d8a402427273d2d39ed5850c01429d1866b15f1c4147a42b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rhodium/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rhodium/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-rhodium\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Rhodium'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "a57bffc26e2a9520d4d747f8e9fabc068aef6311f8903aef05e05df1e127bb3c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rhodium/README.md",
      "content": "# Rhodium - Contract\n\nThis is a Rhodium contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "d2a98c179a3e4fb60c62738edd955f8f680ed3b673d6f2682ff4d3f9653ad832",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rhodium/src/Cargo.toml",
      "content": "[package]\nname = \"rhodium\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "414c27a3b895c0eb8b7988bc34570a47f14b7ddeaa8dbaa568a0aa7aa6719880",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rhodium/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod rhodium {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Rhodium' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct RhodiumContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for RhodiumContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl RhodiumContract {\n        /// Creates a new PSP-22 compatible Rhodium Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Rhodium\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MRHODIUM\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "eea946d93632fa8112601b0879b9cd9f757cdc8093b7d694f8fe36bacb73369e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-silver/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-silver/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-silver\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Silver'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "6e2dc39f3f1b81b1564e86d365de304326de8538b07d469f1700076fad8c3dc2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-silver/README.md",
      "content": "# Silver - Contract\n\nThis is a Silver contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "36d6a2d5374bde49dff6544ba9e5153176d7e8057e81e4b4f2aa4ef0369fd04d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-silver/src/Cargo.toml",
      "content": "[package]\nname = \"silver\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "1ee2ed8aa6a8e3b8e0d946fcc2163cd36eb1f5e3fdb951f2a62f5a97f52ccf8d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-silver/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod silver {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Silver' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SilverContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SilverContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SilverContract {\n        /// Creates a new PSP-22 compatible Silver Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Silver\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSILVER\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "e9c3798061df660990fdb101970902e4351570120a3ab9758b94fd6ed9f077fe",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-super-marmalade/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-super-marmalade/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-super-marmalade\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'SuperMarmalade'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "7b75ec668e54bab3a27e0e970cae537d6f14844eec2035ab1e6ca8dbb946c60b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-super-marmalade/README.md",
      "content": "# SuperMarmalade - Contract\n\nThis is a SuperMarmalade contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "23c60316bfbc481ae784edfa0f7c056817f0dec14204a823768399cd4959f806",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-super-marmalade/src/Cargo.toml",
      "content": "[package]\nname = \"super_marmalade\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "ebd07d2637898d5e1f8db47c9210ab93a6c0505087d298601a578558540b0e8c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-super-marmalade/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod super_marmalade {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'SuperMarmalade' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SuperMarmaladeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SuperMarmaladeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SuperMarmaladeContract {\n        /// Creates a new PSP-22 compatible Super Marmalade Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Super Marmalade\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSUPER_MARMALADE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "e6eebe1bc30c4fdaa8160d45ad2db8958e01d74ed77a1af303726e1cd02b7f22",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-swarm/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-swarm/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-swarm\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'SWARM'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "a3d7be01a635940b781898b92e55bbdcb051e116932166f58a17e1067adf3ab0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-swarm/README.md",
      "content": "# SWARM - Contract\n\nThis is a SWARM contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "1db21a4f0eaffb851bfe93889c36e943a319589e6642f01c984cab99b4b51534",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-swarm/src/Cargo.toml",
      "content": "[package]\nname = \"swarm\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "df2924d132cabcce9275dec8e7982775dd93f4fd566ce6daf782cc501a78be94",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-swarm/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod swarm {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'SWARM' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SwarmContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SwarmContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SwarmContract {\n        /// Creates a new PSP-22 compatible Swarm Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Swarm\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSWARM\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "c8f6fa88bd917a4812e3617390c3dfc8c38b1f6422100cb35bbc2466baee2dc7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-transaction/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-transaction/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-transaction\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Transaction'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "bfc0a12319e481e9d6795e19d4ef48234ba06899e12abbfa1452960817e1a491",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-transaction/README.md",
      "content": "# Transaction - Contract\n\nThis is a Transaction contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "23d86b5a34010d8861080333bf0f25821954fd175aac4e20d068dbc3decc3571",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-transaction/src/Cargo.toml",
      "content": "[package]\nname = \"transaction\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "976dc687c50ea89a82fc48fbc36c7e1f6a9c81686cb73d40ca810f771f7a4635",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-transaction/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod transaction {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Transaction' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct TransactionContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for TransactionContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl TransactionContract {\n        /// Creates a new PSP-22 compatible Transaction Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Transaction\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MTRANSACTION\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "ddddd002a817db1b6730b448836b9ee1d6e35d4f335acf1ec975fce7c78a9534",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-unifiers/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-unifiers/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-unifiers\",\n    \"description\": \"The Game Contract of the game Unifiers\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "394aadf17341df2cbcfceda609096b5d5f15fa7e8b12c0b53323f402fd797d4f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-unifiers/README.md",
      "content": "# Unifiers - Game Contract\n\nThis is the **main outer contract** that the **game logic** interacts with.",
      "contentHash": "5ed8906052112c082200b96d9d322863a5b38d18c40e6f8c0c138e678d0822e0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-unifiers/src/Cargo.toml",
      "content": "[package]\nname = \"unifiers\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "8d18f99d5d06f990db4eef7f7ba554e6754e650209a0fa2522d7b10ce220a726",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-unifiers/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n/// A game created with the help of the Unifiers group\n#[ink::contract]\npub mod unifiers {\n    pub use ink::prelude::string::String;\n    pub use ink::prelude::format;\n    pub use ink::storage::Mapping;\n    use ink::{\n        env::{\n            call::{build_call, ExecutionInput, Selector},\n            CallFlags, DefaultEnvironment,\n        },\n    };\n\n    /** Error type for the game contract for Unifiers */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        Custom(String),\n        ElementContractError(String),\n        InkError(ink::primitives::LangError),\n        FatalError(String),\n        ElementContractIsNotLocked,\n        ElementContractAlreadyLocked,\n        NotTheOwner,\n        OwnerAlreadySet,\n        BuyOfferIsNotSet,\n        InsufficientBuyTransferredValue,\n        InvalidRecipe,\n        NotEnoughElements,\n        InvalidElement,\n    }\n\n    #[ink(storage)]\n    pub struct GameContract {\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        element_contract_ids: Mapping<u32, AccountId>,\n        buy_offer_price_native_tokens: u128,\n        buy_offer_reward_tier_points: u128,\n        buy_offer_is_set: bool,\n    }\n\n    struct Element {\n        id: u32,\n        name: &'static str,\n        description: &'static str,\n        tier: u32,\n    }\n\n    struct Recipe {\n        id: u32,\n        a: u32,\n        b: u32,\n        c: u32,\n    }\n\n    const ELEMENT_MONKEY: Element = Element {\n        id: 0,\n        name: \"Monkey\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_GIRAFFE: Element = Element {\n        id: 1,\n        name: \"Giraffe\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_BEE: Element = Element {\n        id: 2,\n        name: \"Bee\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_COIN: Element = Element {\n        id: 3,\n        name: \"Coin\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_SWARM: Element = Element {\n        id: 4,\n        name: \"SWARM\",\n        description: \"We need a description here\",\n        tier: 2,\n    };\n    const ELEMENT_HYDRA: Element = Element {\n        id: 5,\n        name: \"Hydra\",\n        description: \"We need a description here\",\n        tier: 2,\n    };\n    const ELEMENT_MONKEY_BRANCH: Element = Element {\n        id: 6,\n        name: \"MonkeyBranch\",\n        description: \"We need a description here\",\n        tier: 2,\n    };\n    const ELEMENT_BRIDGE: Element = Element {\n        id: 7,\n        name: \"Bridge\",\n        description: \"We need a description here\",\n        tier: 2,\n    };\n    const ELEMENT_GOLDEN_GATE: Element = Element {\n        id: 8,\n        name: \"GoldenGate\",\n        description: \"We need a description here\",\n        tier: 2,\n    };\n    const ELEMENT_GOLD: Element = Element {\n        id: 9,\n        name: \"Gold\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_SILVER: Element = Element {\n        id: 10,\n        name: \"Silver\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_RHODIUM: Element = Element {\n        id: 11,\n        name: \"Rhodium\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_HIVE: Element = Element {\n        id: 12,\n        name: \"Hive\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_TRANSACTION: Element = Element {\n        id: 13,\n        name: \"Transaction\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_BLOCK: Element = Element {\n        id: 14,\n        name: \"Block\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_BLOCKCHAIN: Element = Element {\n        id: 15,\n        name: \"Blockchain\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_POLKADOT: Element = Element {\n        id: 16,\n        name: \"Polkadot\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_PEER_REVIEW: Element = Element {\n        id: 17,\n        name: \"PeerReview\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_CARDANO: Element = Element {\n        id: 18,\n        name: \"Cardano\",\n        description: \"We need a description here\",\n        tier: 2,\n    };\n    const ELEMENT_BEAR: Element = Element {\n        id: 19,\n        name: \"Bear\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_BEER: Element = Element {\n        id: 20,\n        name: \"Beer\",\n        description: \"We need a description here\",\n        tier: 2,\n    };\n    const ELEMENT_LOCK: Element = Element {\n        id: 21,\n        name: \"Lock\",\n        description: \"We need a description here\",\n        tier: 2,\n    };\n    const ELEMENT_MARMALADE: Element = Element {\n        id: 22,\n        name: \"Marmalade\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_SUPER_MARMALADE: Element = Element {\n        id: 23,\n        name: \"SuperMarmalade\",\n        description: \"We need a description here\",\n        tier: 2,\n    };\n    const ELEMENT_HYPER_MARMALADE: Element = Element {\n        id: 24,\n        name: \"HyperMarmalade\",\n        description: \"We need a description here\",\n        tier: 2,\n    };\n    const RECIPE_MAKE_SWARM: Recipe = Recipe {\n        id: 0,\n        a: 2,\n        b: 2,\n        c: 4,\n    };\n    const RECIPE_MAKE_HYDRA: Recipe = Recipe {\n        id: 1,\n        a: 1,\n        b: 1,\n        c: 5,\n    };\n    const RECIPE_MAKE_MONKEYBRANCH: Recipe = Recipe {\n        id: 2,\n        a: 0,\n        b: 5,\n        c: 6,\n    };\n    const RECIPE_MAKE_BRIDGE: Recipe = Recipe {\n        id: 3,\n        a: 6,\n        b: 6,\n        c: 7,\n    };\n    const RECIPE_MAKE_GOLDENGATE: Recipe = Recipe {\n        id: 4,\n        a: 3,\n        b: 7,\n        c: 8,\n    };\n    const RECIPE_MAKE_CARDANO: Recipe = Recipe {\n        id: 5,\n        a: 15,\n        b: 17,\n        c: 18,\n    };\n    const RECIPE_MAKE_BEER: Recipe = Recipe {\n        id: 6,\n        a: 2,\n        b: 19,\n        c: 20,\n    };\n    const RECIPE_MAKE_LOCK: Recipe = Recipe {\n        id: 7,\n        a: 10,\n        b: 10,\n        c: 21,\n    };\n    const RECIPE_MAKE_SUPERMARMALADE: Recipe = Recipe {\n        id: 8,\n        a: 22,\n        b: 22,\n        c: 23,\n    };\n    const RECIPE_MAKE_HYPERMARMALADE: Recipe = Recipe {\n        id: 9,\n        a: 23,\n        b: 23,\n        c: 24,\n    };\n\n    fn find_item(index: u32) -> Option<Element> {\n        if index == 0 {\n            return Some(ELEMENT_MONKEY);\n        }\n        if index == 1 {\n            return Some(ELEMENT_GIRAFFE);\n        }\n        if index == 2 {\n            return Some(ELEMENT_BEE);\n        }\n        if index == 3 {\n            return Some(ELEMENT_COIN);\n        }\n        if index == 4 {\n            return Some(ELEMENT_SWARM);\n        }\n        if index == 5 {\n            return Some(ELEMENT_HYDRA);\n        }\n        if index == 6 {\n            return Some(ELEMENT_MONKEY_BRANCH);\n        }\n        if index == 7 {\n            return Some(ELEMENT_BRIDGE);\n        }\n        if index == 8 {\n            return Some(ELEMENT_GOLDEN_GATE);\n        }\n        if index == 9 {\n            return Some(ELEMENT_GOLD);\n        }\n        if index == 10 {\n            return Some(ELEMENT_SILVER);\n        }\n        if index == 11 {\n            return Some(ELEMENT_RHODIUM);\n        }\n        if index == 12 {\n            return Some(ELEMENT_HIVE);\n        }\n        if index == 13 {\n            return Some(ELEMENT_TRANSACTION);\n        }\n        if index == 14 {\n            return Some(ELEMENT_BLOCK);\n        }\n        if index == 15 {\n            return Some(ELEMENT_BLOCKCHAIN);\n        }\n        if index == 16 {\n            return Some(ELEMENT_POLKADOT);\n        }\n        if index == 17 {\n            return Some(ELEMENT_PEER_REVIEW);\n        }\n        if index == 18 {\n            return Some(ELEMENT_CARDANO);\n        }\n        if index == 19 {\n            return Some(ELEMENT_BEAR);\n        }\n        if index == 20 {\n            return Some(ELEMENT_BEER);\n        }\n        if index == 21 {\n            return Some(ELEMENT_LOCK);\n        }\n        if index == 22 {\n            return Some(ELEMENT_MARMALADE);\n        }\n        if index == 23 {\n            return Some(ELEMENT_SUPER_MARMALADE);\n        }\n        if index == 24 {\n            return Some(ELEMENT_HYPER_MARMALADE);\n        }\n        None\n    }\n\n    fn find_recipe(index: u32) -> Option<Recipe> {\n        if index == 0 {\n            return Some(RECIPE_MAKE_SWARM);\n        }\n        if index == 1 {\n            return Some(RECIPE_MAKE_HYDRA);\n        }\n        if index == 2 {\n            return Some(RECIPE_MAKE_MONKEYBRANCH);\n        }\n        if index == 3 {\n            return Some(RECIPE_MAKE_BRIDGE);\n        }\n        if index == 4 {\n            return Some(RECIPE_MAKE_GOLDENGATE);\n        }\n        if index == 5 {\n            return Some(RECIPE_MAKE_CARDANO);\n        }\n        if index == 6 {\n            return Some(RECIPE_MAKE_BEER);\n        }\n        if index == 7 {\n            return Some(RECIPE_MAKE_LOCK);\n        }\n        if index == 8 {\n            return Some(RECIPE_MAKE_SUPERMARMALADE);\n        }\n        if index == 9 {\n            return Some(RECIPE_MAKE_HYPERMARMALADE);\n        }\n        None\n    }\n\n\n    impl Default for GameContract {\n        fn default() -> Self {\n            let element_contract_ids = Mapping::new();\n            Self {\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                element_contract_ids,\n                buy_offer_price_native_tokens: 0,\n                buy_offer_reward_tier_points: 0,\n                buy_offer_is_set: false,\n            }\n        }\n    }\n\n    impl GameContract {\n        /// Creates a new PSP-22 compatible Lava Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        /// Sets the owner of the contract\n        #[ink(message)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::OwnerAlreadySet);\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        /// Locks the contract id of an element\n        #[ink(message)]\n        pub fn lock_element_contract(&mut self, element_id: u32, element_contract_id: AccountId) -> Result<(), Error> {\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::NotTheOwner);\n            }\n            if self.element_contract_ids.contains(element_id) {\n                return Err(Error::ElementContractAlreadyLocked);\n            }\n            self.element_contract_ids.insert(element_id, &element_contract_id);\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn balance_of_element(&self, element_id: u32) -> Result<u128, Error> {\n            let element_contract_id = self.element_contract_ids.get(element_id).unwrap_or(AccountId::from([0xFF; 32]));\n            if element_contract_id == AccountId::from([0xFF; 32]) {\n                return Err(Error::ElementContractIsNotLocked);\n            }\n            let call_result = build_call::<DefaultEnvironment>()\n                .call(element_contract_id)\n                .exec_input(\n                    ExecutionInput::new(Selector::new(\n                            // Selector of PSP22::balance_of -> 0x6568382f\n                            [0x65, 0x68, 0x38, 0x2f]\n                        ))\n                        .push_arg(&self.env().caller()) // owner: AccountId parameter\n                )\n                .returns::<u128>()\n                .try_invoke();\n            match call_result {\n                Ok(okresult) => match okresult {\n                    Ok(result) => Ok(result),\n                    Err(reserr) => Err(Error::InkError(reserr))\n                },\n                Err(_) => Err(Error::FatalError(String::from(\"Error invoking PSP22::balance_of\")))\n            }\n        }\n\n        #[ink(message)]\n        pub fn set_buy_offer(&mut self, price: u128, reward_tier_points: u128) -> Result<(), Error> {\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::NotTheOwner);\n            }\n            self.buy_offer_price_native_tokens = price;\n            self.buy_offer_reward_tier_points = reward_tier_points;\n            self.buy_offer_is_set = true;\n            Ok(())\n        }\n        \n        #[ink(message)]\n        pub fn buy_offer(&self) -> Result<(u128, u128), Error> {\n            Ok((self.buy_offer_price_native_tokens, self.buy_offer_reward_tier_points))\n        }\n\n        #[ink(message, payable)]\n        pub fn buy(&mut self, element_id: u32) -> Result<(), Error> {\n            if !self.buy_offer_is_set {\n                return Err(Error::BuyOfferIsNotSet);\n            }\n\n            let val = self.env().transferred_value();\n\n            if val < self.buy_offer_price_native_tokens {\n                return Err(Error::InsufficientBuyTransferredValue);\n            }\n\n            let buy_count = val.checked_div(self.buy_offer_price_native_tokens).unwrap_or(0);\n\n            if buy_count == 0 {\n                return Err(Error::InsufficientBuyTransferredValue);\n            }\n\n            // TODO: Add element tiers and calculate number of received items based on that\n            let reward_tier_points = self.buy_offer_reward_tier_points.checked_mul(buy_count).unwrap_or(0);\n\n            if reward_tier_points == 0 {\n                return Err(Error::FatalError(String::from(\"Error calculating reward tier points, possible overflow\")));\n            }\n\n            let element_contract_id = self.element_contract_ids.get(element_id).unwrap_or(AccountId::from([0xFF; 32]));\n\n            if element_contract_id == AccountId::from([0xFF; 32]) {\n                return Err(Error::ElementContractIsNotLocked);\n            }\n\n            let element = find_item(element_id);\n\n            if element.is_none() {\n                return Err(Error::InvalidElement);\n            }\n\n            let el = element.unwrap();\n\n            let reward_items: u128 = reward_tier_points.checked_div(el.tier.into()).unwrap_or(0);\n\n            if reward_items == 0 {\n                return Err(Error::InsufficientBuyTransferredValue);\n            }\n\n            let call_result = build_call::<DefaultEnvironment>()\n                .call(element_contract_id)\n                .call_flags(CallFlags::TAIL_CALL)\n                .exec_input(\n                    ExecutionInput::new(Selector::new(\n                            // Selector of ElementContract::mint -> 0x21615d0f\n                            [0x21, 0x61, 0x5d, 0x0f]\n                        ))\n                        .push_arg::<AccountId>(self.env().caller()) // owner: AccountId parameter\n                        .push_arg::<u128>(reward_items) // value: u128 parameter\n                )\n                .returns::<()>()\n                .try_invoke();\n            match call_result {\n                Ok(okresult) => match okresult {\n                    Ok(_) => Ok(()),\n                    Err(reserr) => Err(Error::InkError(reserr))\n                },\n                Err(fatalerr) => Err(Error::FatalError(format!(\"Error invoking ElementContract::mint: {:?}\", fatalerr)))\n            }\n        }\n\n        #[ink(message)]\n        pub fn craft(&mut self, recipe_id: u32) -> Result<(), Error> {\n            let recipe = find_recipe(recipe_id);\n\n            if recipe.is_none() {\n                return Err(Error::InvalidRecipe);\n            }\n\n            let rec = recipe.unwrap();\n\n            let element_a_index = rec.a;\n            let element_b_index = rec.b;\n            let element_c_index = rec.c;\n\n            let element_a_contract_id = self.element_contract_ids.get(element_a_index).unwrap_or(AccountId::from([0xFF; 32]));\n            let element_b_contract_id = self.element_contract_ids.get(element_b_index).unwrap_or(AccountId::from([0xFF; 32]));\n            let element_c_contract_id = self.element_contract_ids.get(element_c_index).unwrap_or(AccountId::from([0xFF; 32]));\n\n            let element_a_balance = self.balance_of_element(element_a_index).unwrap_or(0);\n            let element_b_balance = self.balance_of_element(element_b_index).unwrap_or(0);\n\n            if element_a_contract_id == AccountId::from([0xFF; 32]) || element_b_contract_id == AccountId::from([0xFF; 32]) || element_c_contract_id == AccountId::from([0xFF; 32]) {\n                return Err(Error::ElementContractIsNotLocked);\n            }\n\n            if element_a_balance == 0 || element_b_balance == 0 {\n                return Err(Error::NotEnoughElements);\n            }\n\n            // Burn calls to element contracts\n            let call_result_a = build_call::<DefaultEnvironment>()\n                .call(element_a_contract_id)\n                .call_flags(CallFlags::ALLOW_REENTRY)\n                .exec_input(\n                    ExecutionInput::new(Selector::new(\n                            // Selector of ElementContract::burn -> 0x100fa9ca\n                            [0x10, 0x0f, 0xa9, 0xca]\n                        ))\n                        .push_arg::<AccountId>(self.env().caller()) // owner: AccountId parameter\n                        .push_arg::<u128>(1) // value: u128 parameter\n                )\n                .returns::<Result<(), Error>>()\n                .try_invoke();\n            \n            let call_result_b = build_call::<DefaultEnvironment>()\n                .call(element_b_contract_id)\n                .call_flags(CallFlags::ALLOW_REENTRY)\n                .exec_input(\n                    ExecutionInput::new(Selector::new(\n                            // Selector of ElementContract::burn -> 0x100fa9ca\n                            [0x10, 0x0f, 0xa9, 0xca]\n                        ))\n                        .push_arg::<AccountId>(self.env().caller()) // owner: AccountId parameter\n                        .push_arg::<u128>(1) // value: u128 parameter\n                )\n                .returns::<Result<(), Error>>()\n                .try_invoke();\n            \n            match call_result_a {\n                Ok(okresult1) => match okresult1 {\n                    Ok(_) => (),\n                    Err(reserr1) => return Err(Error::InkError(reserr1))\n                },\n                Err(fatalerr1) => return Err(Error::FatalError(format!(\"Error invoking ElementContract::burn (1 / 3): {:?}\", fatalerr1)))\n            }\n\n            match call_result_b {\n                Ok(okresult2) => match okresult2 {\n                    Ok(_) => (),\n                    Err(reserr2) => return Err(Error::InkError(reserr2))\n                },\n                Err(fatalerr2) => return Err(Error::FatalError(format!(\"Error invoking ElementContract::burn (2 / 3): {:?}\", fatalerr2)))\n            }\n            \n            // Mint call to element contract\n            let call_result_c = build_call::<DefaultEnvironment>()\n                .call(element_c_contract_id)\n                .call_flags(CallFlags::TAIL_CALL)\n                .exec_input(\n                    ExecutionInput::new(Selector::new(\n                            // Selector of ElementContract::mint -> 0x21615d0f\n                            [0x21, 0x61, 0x5d, 0x0f]\n                        ))\n                        .push_arg::<AccountId>(self.env().caller()) // owner: AccountId parameter\n                        .push_arg::<u128>(1) // value: u128 parameter\n                )\n                .returns::<Result<(), Error>>()\n                .try_invoke();\n    \n            match call_result_c {\n                Ok(okresult3) => match okresult3 {\n                    Ok(_) => Ok(()),\n                    Err(reserr3) => Err(Error::InkError(reserr3))\n                },\n                Err(fatalerr3) => Err(Error::FatalError(format!(\"Error invoking ElementContract::mint (3 / 3): {:?}\", fatalerr3)))\n            }\n            \n        }\n    }\n\n}",
      "contentHash": "f65e3ec7de560822ff6978eaf9a584da02a5a533d9879ff2fae3cc5c6ab353fa",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/deployer/copy-contracts.js",
      "content": "const fs = require('fs');\nconst path = require('path');\n\nconst POSSIBLE_TARGET_INK_DIRS = [\n    \"../../target/ink\",\n    \"../../../target/ink\",\n    \"target/ink\",\n];\nconst POSSIBLE_CONTRACTS_V1_README_MD_FILES = [\n    \"../../contracts.v1/README.md\",\n    \"../../../contracts.v1/README.md\",\n    \"contracts.v1/README.md\",\n]\n\nconst realTargetInkIndex = POSSIBLE_TARGET_INK_DIRS.findIndex((dir) => fs.existsSync(dir));\nconst targetInkDir = POSSIBLE_TARGET_INK_DIRS[realTargetInkIndex];\n\nconsole.log(`Copying contracts from ${POSSIBLE_TARGET_INK_DIRS[realTargetInkIndex]} ...`);\n\nconst realContractsV1ReadmeMdIndex = POSSIBLE_CONTRACTS_V1_README_MD_FILES.findIndex((file) => fs.existsSync(file));\nconst contractsV1ReadmeMd = POSSIBLE_CONTRACTS_V1_README_MD_FILES[realContractsV1ReadmeMdIndex];\nconst contractsV1Dir = path.join(path.dirname(contractsV1ReadmeMd), \"artifacts\");\n\nconsole.log(`Copying contracts into ${contractsV1Dir} ...`);\n\nif(!fs.existsSync(contractsV1Dir)) {\n    fs.mkdirSync(contractsV1Dir, { recursive: true });\n}\n\nconst itemMonkeyPath = path.join(targetInkDir, 'monkey/monkey.contract');\nconst itemGiraffePath = path.join(targetInkDir, 'giraffe/giraffe.contract');\nconst itemBeePath = path.join(targetInkDir, 'bee/bee.contract');\nconst itemCoinPath = path.join(targetInkDir, 'coin/coin.contract');\nconst itemSwarmPath = path.join(targetInkDir, 'swarm/swarm.contract');\nconst itemHydraPath = path.join(targetInkDir, 'hydra/hydra.contract');\nconst itemMonkeyBranchPath = path.join(targetInkDir, 'monkey-branch/monkey-branch.contract');\nconst itemBridgePath = path.join(targetInkDir, 'bridge/bridge.contract');\nconst itemGoldenGatePath = path.join(targetInkDir, 'golden-gate/golden-gate.contract');\nconst itemGoldPath = path.join(targetInkDir, 'gold/gold.contract');\nconst itemSilverPath = path.join(targetInkDir, 'silver/silver.contract');\nconst itemRhodiumPath = path.join(targetInkDir, 'rhodium/rhodium.contract');\nconst itemHivePath = path.join(targetInkDir, 'hive/hive.contract');\nconst itemTransactionPath = path.join(targetInkDir, 'transaction/transaction.contract');\nconst itemBlockPath = path.join(targetInkDir, 'block/block.contract');\nconst itemBlockchainPath = path.join(targetInkDir, 'blockchain/blockchain.contract');\nconst itemPolkadotPath = path.join(targetInkDir, 'polkadot/polkadot.contract');\nconst itemPeerReviewPath = path.join(targetInkDir, 'peer-review/peer-review.contract');\nconst itemCardanoPath = path.join(targetInkDir, 'cardano/cardano.contract');\nconst itemBearPath = path.join(targetInkDir, 'bear/bear.contract');\nconst itemBeerPath = path.join(targetInkDir, 'beer/beer.contract');\nconst itemLockPath = path.join(targetInkDir, 'lock/lock.contract');\nconst itemMarmaladePath = path.join(targetInkDir, 'marmalade/marmalade.contract');\nconst itemSuperMarmaladePath = path.join(targetInkDir, 'super-marmalade/super-marmalade.contract');\nconst itemHyperMarmaladePath = path.join(targetInkDir, 'hyper-marmalade/hyper-marmalade.contract');\nconst gameUnifiersPath = path.join(targetInkDir, 'unifiers/unifiers.contract');\n\nif(fs.existsSync(itemMonkeyPath)) {\n    console.log(`Copying monkey ...`);\n    fs.copyFileSync(itemMonkeyPath, path.join(contractsV1Dir, 'monkey.contract.json'));\n} else {\n    console.log(`monkey not found`);\n}\nif(fs.existsSync(itemGiraffePath)) {\n    console.log(`Copying giraffe ...`);\n    fs.copyFileSync(itemGiraffePath, path.join(contractsV1Dir, 'giraffe.contract.json'));\n} else {\n    console.log(`giraffe not found`);\n}\nif(fs.existsSync(itemBeePath)) {\n    console.log(`Copying bee ...`);\n    fs.copyFileSync(itemBeePath, path.join(contractsV1Dir, 'bee.contract.json'));\n} else {\n    console.log(`bee not found`);\n}\nif(fs.existsSync(itemCoinPath)) {\n    console.log(`Copying coin ...`);\n    fs.copyFileSync(itemCoinPath, path.join(contractsV1Dir, 'coin.contract.json'));\n} else {\n    console.log(`coin not found`);\n}\nif(fs.existsSync(itemSwarmPath)) {\n    console.log(`Copying swarm ...`);\n    fs.copyFileSync(itemSwarmPath, path.join(contractsV1Dir, 'swarm.contract.json'));\n} else {\n    console.log(`swarm not found`);\n}\nif(fs.existsSync(itemHydraPath)) {\n    console.log(`Copying hydra ...`);\n    fs.copyFileSync(itemHydraPath, path.join(contractsV1Dir, 'hydra.contract.json'));\n} else {\n    console.log(`hydra not found`);\n}\nif(fs.existsSync(itemMonkeyBranchPath)) {\n    console.log(`Copying monkey-branch ...`);\n    fs.copyFileSync(itemMonkeyBranchPath, path.join(contractsV1Dir, 'monkey-branch.contract.json'));\n} else {\n    console.log(`monkey-branch not found`);\n}\nif(fs.existsSync(itemBridgePath)) {\n    console.log(`Copying bridge ...`);\n    fs.copyFileSync(itemBridgePath, path.join(contractsV1Dir, 'bridge.contract.json'));\n} else {\n    console.log(`bridge not found`);\n}\nif(fs.existsSync(itemGoldenGatePath)) {\n    console.log(`Copying golden-gate ...`);\n    fs.copyFileSync(itemGoldenGatePath, path.join(contractsV1Dir, 'golden-gate.contract.json'));\n} else {\n    console.log(`golden-gate not found`);\n}\nif(fs.existsSync(itemGoldPath)) {\n    console.log(`Copying gold ...`);\n    fs.copyFileSync(itemGoldPath, path.join(contractsV1Dir, 'gold.contract.json'));\n} else {\n    console.log(`gold not found`);\n}\nif(fs.existsSync(itemSilverPath)) {\n    console.log(`Copying silver ...`);\n    fs.copyFileSync(itemSilverPath, path.join(contractsV1Dir, 'silver.contract.json'));\n} else {\n    console.log(`silver not found`);\n}\nif(fs.existsSync(itemRhodiumPath)) {\n    console.log(`Copying rhodium ...`);\n    fs.copyFileSync(itemRhodiumPath, path.join(contractsV1Dir, 'rhodium.contract.json'));\n} else {\n    console.log(`rhodium not found`);\n}\nif(fs.existsSync(itemHivePath)) {\n    console.log(`Copying hive ...`);\n    fs.copyFileSync(itemHivePath, path.join(contractsV1Dir, 'hive.contract.json'));\n} else {\n    console.log(`hive not found`);\n}\nif(fs.existsSync(itemTransactionPath)) {\n    console.log(`Copying transaction ...`);\n    fs.copyFileSync(itemTransactionPath, path.join(contractsV1Dir, 'transaction.contract.json'));\n} else {\n    console.log(`transaction not found`);\n}\nif(fs.existsSync(itemBlockPath)) {\n    console.log(`Copying block ...`);\n    fs.copyFileSync(itemBlockPath, path.join(contractsV1Dir, 'block.contract.json'));\n} else {\n    console.log(`block not found`);\n}\nif(fs.existsSync(itemBlockchainPath)) {\n    console.log(`Copying blockchain ...`);\n    fs.copyFileSync(itemBlockchainPath, path.join(contractsV1Dir, 'blockchain.contract.json'));\n} else {\n    console.log(`blockchain not found`);\n}\nif(fs.existsSync(itemPolkadotPath)) {\n    console.log(`Copying polkadot ...`);\n    fs.copyFileSync(itemPolkadotPath, path.join(contractsV1Dir, 'polkadot.contract.json'));\n} else {\n    console.log(`polkadot not found`);\n}\nif(fs.existsSync(itemPeerReviewPath)) {\n    console.log(`Copying peer-review ...`);\n    fs.copyFileSync(itemPeerReviewPath, path.join(contractsV1Dir, 'peer-review.contract.json'));\n} else {\n    console.log(`peer-review not found`);\n}\nif(fs.existsSync(itemCardanoPath)) {\n    console.log(`Copying cardano ...`);\n    fs.copyFileSync(itemCardanoPath, path.join(contractsV1Dir, 'cardano.contract.json'));\n} else {\n    console.log(`cardano not found`);\n}\nif(fs.existsSync(itemBearPath)) {\n    console.log(`Copying bear ...`);\n    fs.copyFileSync(itemBearPath, path.join(contractsV1Dir, 'bear.contract.json'));\n} else {\n    console.log(`bear not found`);\n}\nif(fs.existsSync(itemBeerPath)) {\n    console.log(`Copying beer ...`);\n    fs.copyFileSync(itemBeerPath, path.join(contractsV1Dir, 'beer.contract.json'));\n} else {\n    console.log(`beer not found`);\n}\nif(fs.existsSync(itemLockPath)) {\n    console.log(`Copying lock ...`);\n    fs.copyFileSync(itemLockPath, path.join(contractsV1Dir, 'lock.contract.json'));\n} else {\n    console.log(`lock not found`);\n}\nif(fs.existsSync(itemMarmaladePath)) {\n    console.log(`Copying marmalade ...`);\n    fs.copyFileSync(itemMarmaladePath, path.join(contractsV1Dir, 'marmalade.contract.json'));\n} else {\n    console.log(`marmalade not found`);\n}\nif(fs.existsSync(itemSuperMarmaladePath)) {\n    console.log(`Copying super-marmalade ...`);\n    fs.copyFileSync(itemSuperMarmaladePath, path.join(contractsV1Dir, 'super-marmalade.contract.json'));\n} else {\n    console.log(`super-marmalade not found`);\n}\nif(fs.existsSync(itemHyperMarmaladePath)) {\n    console.log(`Copying hyper-marmalade ...`);\n    fs.copyFileSync(itemHyperMarmaladePath, path.join(contractsV1Dir, 'hyper-marmalade.contract.json'));\n} else {\n    console.log(`hyper-marmalade not found`);\n}\n\nif(fs.existsSync(gameUnifiersPath)) {\n    console.log(`Copying unifiers ...`);\n    fs.copyFileSync(gameUnifiersPath, path.join(contractsV1Dir, 'unifiers.contract.json'));\n} else {\n    console.log(`unifiers not found`);\n}\n",
      "contentHash": "9c929037efc290892845dca1f3943537c0ec21af4c7ba0e135c549f1a9aca4c6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/deployer/src/unifiers.game.ts",
      "content": "import UNIFIERS_CONTRACT from \"../../../contracts.v1/artifacts/unifiers.contract.json\";\nimport ELEMENT_MONKEY_CONTRACT from \"../../../contracts.v1/artifacts/monkey.contract.json\";\nimport ELEMENT_GIRAFFE_CONTRACT from \"../../../contracts.v1/artifacts/giraffe.contract.json\";\nimport ELEMENT_BEE_CONTRACT from \"../../../contracts.v1/artifacts/bee.contract.json\";\nimport ELEMENT_COIN_CONTRACT from \"../../../contracts.v1/artifacts/coin.contract.json\";\nimport ELEMENT_SWARM_CONTRACT from \"../../../contracts.v1/artifacts/swarm.contract.json\";\nimport ELEMENT_HYDRA_CONTRACT from \"../../../contracts.v1/artifacts/hydra.contract.json\";\nimport ELEMENT_MONKEY_BRANCH_CONTRACT from \"../../../contracts.v1/artifacts/monkey-branch.contract.json\";\nimport ELEMENT_BRIDGE_CONTRACT from \"../../../contracts.v1/artifacts/bridge.contract.json\";\nimport ELEMENT_GOLDEN_GATE_CONTRACT from \"../../../contracts.v1/artifacts/golden-gate.contract.json\";\nimport ELEMENT_GOLD_CONTRACT from \"../../../contracts.v1/artifacts/gold.contract.json\";\nimport ELEMENT_SILVER_CONTRACT from \"../../../contracts.v1/artifacts/silver.contract.json\";\nimport ELEMENT_RHODIUM_CONTRACT from \"../../../contracts.v1/artifacts/rhodium.contract.json\";\nimport ELEMENT_HIVE_CONTRACT from \"../../../contracts.v1/artifacts/hive.contract.json\";\nimport ELEMENT_TRANSACTION_CONTRACT from \"../../../contracts.v1/artifacts/transaction.contract.json\";\nimport ELEMENT_BLOCK_CONTRACT from \"../../../contracts.v1/artifacts/block.contract.json\";\nimport ELEMENT_BLOCKCHAIN_CONTRACT from \"../../../contracts.v1/artifacts/blockchain.contract.json\";\nimport ELEMENT_POLKADOT_CONTRACT from \"../../../contracts.v1/artifacts/polkadot.contract.json\";\nimport ELEMENT_PEER_REVIEW_CONTRACT from \"../../../contracts.v1/artifacts/peer-review.contract.json\";\nimport ELEMENT_CARDANO_CONTRACT from \"../../../contracts.v1/artifacts/cardano.contract.json\";\nimport ELEMENT_BEAR_CONTRACT from \"../../../contracts.v1/artifacts/bear.contract.json\";\nimport ELEMENT_BEER_CONTRACT from \"../../../contracts.v1/artifacts/beer.contract.json\";\nimport ELEMENT_LOCK_CONTRACT from \"../../../contracts.v1/artifacts/lock.contract.json\";\nimport ELEMENT_MARMALADE_CONTRACT from \"../../../contracts.v1/artifacts/marmalade.contract.json\";\nimport ELEMENT_SUPER_MARMALADE_CONTRACT from \"../../../contracts.v1/artifacts/super-marmalade.contract.json\";\nimport ELEMENT_HYPER_MARMALADE_CONTRACT from \"../../../contracts.v1/artifacts/hyper-marmalade.contract.json\";\nimport { IDeployableGame } from \"./IDeployableGame\";\n\nconst UNIFIERS_ELEMENT_CONTRACTS: Record<number, any> = {\n    [0]: ELEMENT_MONKEY_CONTRACT,\n    [1]: ELEMENT_GIRAFFE_CONTRACT,\n    [2]: ELEMENT_BEE_CONTRACT,\n    [3]: ELEMENT_COIN_CONTRACT,\n    [4]: ELEMENT_SWARM_CONTRACT,\n    [5]: ELEMENT_HYDRA_CONTRACT,\n    [6]: ELEMENT_MONKEY_BRANCH_CONTRACT,\n    [7]: ELEMENT_BRIDGE_CONTRACT,\n    [8]: ELEMENT_GOLDEN_GATE_CONTRACT,\n    [9]: ELEMENT_GOLD_CONTRACT,\n    [10]: ELEMENT_SILVER_CONTRACT,\n    [11]: ELEMENT_RHODIUM_CONTRACT,\n    [12]: ELEMENT_HIVE_CONTRACT,\n    [13]: ELEMENT_TRANSACTION_CONTRACT,\n    [14]: ELEMENT_BLOCK_CONTRACT,\n    [15]: ELEMENT_BLOCKCHAIN_CONTRACT,\n    [16]: ELEMENT_POLKADOT_CONTRACT,\n    [17]: ELEMENT_PEER_REVIEW_CONTRACT,\n    [18]: ELEMENT_CARDANO_CONTRACT,\n    [19]: ELEMENT_BEAR_CONTRACT,\n    [20]: ELEMENT_BEER_CONTRACT,\n    [21]: ELEMENT_LOCK_CONTRACT,\n    [22]: ELEMENT_MARMALADE_CONTRACT,\n    [23]: ELEMENT_SUPER_MARMALADE_CONTRACT,\n    [24]: ELEMENT_HYPER_MARMALADE_CONTRACT,\n};\n\nexport const DEPLOYABLE_UNIFIERS: IDeployableGame = {\n    name: \"Unifiers\",\n    description: \"A game created with the help of the Unifiers group\",\n    gameContract: UNIFIERS_CONTRACT,\n    elementContracts: UNIFIERS_ELEMENT_CONTRACTS,\n};",
      "contentHash": "5b7166b571273cd3a9f9fe907fec28246d41cf568b4cea6c80de7727559a6f5a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/model/src/items.ts",
      "content": "import { IItem } from './IItem';\nimport { IRecipe } from './IRecipe';\nimport { IGameContent } from './IGameContent';\n\nexport const ITEM_MONKEY: IItem = {\n    id: 0,\n    name: 'Monkey',\n    description: 'We need a description here',\n    tier: 1,\n};\nexport const ITEM_GIRAFFE: IItem = {\n    id: 1,\n    name: 'Giraffe',\n    description: 'We need a description here',\n    tier: 1,\n};\nexport const ITEM_BEE: IItem = {\n    id: 2,\n    name: 'Bee',\n    description: 'We need a description here',\n    tier: 1,\n};\nexport const ITEM_COIN: IItem = {\n    id: 3,\n    name: 'Coin',\n    description: 'We need a description here',\n    tier: 1,\n};\nexport const ITEM_SWARM: IItem = {\n    id: 4,\n    name: 'Swarm',\n    description: 'We need a description here',\n    tier: 2,\n};\nexport const ITEM_HYDRA: IItem = {\n    id: 5,\n    name: 'Hydra',\n    description: 'We need a description here',\n    tier: 2,\n};\nexport const ITEM_MONKEY_BRANCH: IItem = {\n    id: 6,\n    name: 'Monkey Branch',\n    description: 'We need a description here',\n    tier: 2,\n};\nexport const ITEM_BRIDGE: IItem = {\n    id: 7,\n    name: 'Bridge',\n    description: 'We need a description here',\n    tier: 2,\n};\nexport const ITEM_GOLDEN_GATE: IItem = {\n    id: 8,\n    name: 'Golden Gate',\n    description: 'We need a description here',\n    tier: 2,\n};\nexport const ITEM_GOLD: IItem = {\n    id: 9,\n    name: 'Gold',\n    description: 'We need a description here',\n    tier: 1,\n};\nexport const ITEM_SILVER: IItem = {\n    id: 10,\n    name: 'Silver',\n    description: 'We need a description here',\n    tier: 1,\n};\nexport const ITEM_RHODIUM: IItem = {\n    id: 11,\n    name: 'Rhodium',\n    description: 'We need a description here',\n    tier: 1,\n};\nexport const ITEM_HIVE: IItem = {\n    id: 12,\n    name: 'Hive',\n    description: 'We need a description here',\n    tier: 1,\n};\nexport const ITEM_TRANSACTION: IItem = {\n    id: 13,\n    name: 'Transaction',\n    description: 'We need a description here',\n    tier: 1,\n};\nexport const ITEM_BLOCK: IItem = {\n    id: 14,\n    name: 'Block',\n    description: 'We need a description here',\n    tier: 1,\n};\nexport const ITEM_BLOCKCHAIN: IItem = {\n    id: 15,\n    name: 'Blockchain',\n    description: 'We need a description here',\n    tier: 1,\n};\nexport const ITEM_POLKADOT: IItem = {\n    id: 16,\n    name: 'Polkadot',\n    description: 'We need a description here',\n    tier: 1,\n};\nexport const ITEM_PEER_REVIEW: IItem = {\n    id: 17,\n    name: 'Peer Review',\n    description: 'We need a description here',\n    tier: 1,\n};\nexport const ITEM_CARDANO: IItem = {\n    id: 18,\n    name: 'Cardano',\n    description: 'We need a description here',\n    tier: 2,\n};\nexport const ITEM_BEAR: IItem = {\n    id: 19,\n    name: 'Bear',\n    description: 'We need a description here',\n    tier: 1,\n};\nexport const ITEM_BEER: IItem = {\n    id: 20,\n    name: 'Beer',\n    description: 'We need a description here',\n    tier: 2,\n};\nexport const ITEM_LOCK: IItem = {\n    id: 21,\n    name: 'Lock',\n    description: 'We need a description here',\n    tier: 2,\n};\nexport const ITEM_MARMALADE: IItem = {\n    id: 22,\n    name: 'Marmalade',\n    description: 'We need a description here',\n    tier: 1,\n};\nexport const ITEM_SUPER_MARMALADE: IItem = {\n    id: 23,\n    name: 'Super Marmalade',\n    description: 'We need a description here',\n    tier: 2,\n};\nexport const ITEM_HYPER_MARMALADE: IItem = {\n    id: 24,\n    name: 'Hyper Marmalade',\n    description: 'We need a description here',\n    tier: 2,\n};\n\nexport const ALL_ITEMS: IItem[] = [\n    ITEM_MONKEY,\n    ITEM_GIRAFFE,\n    ITEM_BEE,\n    ITEM_COIN,\n    ITEM_SWARM,\n    ITEM_HYDRA,\n    ITEM_MONKEY_BRANCH,\n    ITEM_BRIDGE,\n    ITEM_GOLDEN_GATE,\n    ITEM_GOLD,\n    ITEM_SILVER,\n    ITEM_RHODIUM,\n    ITEM_HIVE,\n    ITEM_TRANSACTION,\n    ITEM_BLOCK,\n    ITEM_BLOCKCHAIN,\n    ITEM_POLKADOT,\n    ITEM_PEER_REVIEW,\n    ITEM_CARDANO,\n    ITEM_BEAR,\n    ITEM_BEER,\n    ITEM_LOCK,\n    ITEM_MARMALADE,\n    ITEM_SUPER_MARMALADE,\n    ITEM_HYPER_MARMALADE,\n];\n\nexport const RECIPE_MAKE_SWARM: IRecipe = {\n    id: 0,\n    a: ITEM_BEE,\n    b: ITEM_BEE,\n    result: ITEM_SWARM,\n};\nexport const RECIPE_MAKE_HYDRA: IRecipe = {\n    id: 1,\n    a: ITEM_GIRAFFE,\n    b: ITEM_GIRAFFE,\n    result: ITEM_HYDRA,\n};\nexport const RECIPE_MAKE_MONKEYBRANCH: IRecipe = {\n    id: 2,\n    a: ITEM_MONKEY,\n    b: ITEM_HYDRA,\n    result: ITEM_MONKEY_BRANCH,\n};\nexport const RECIPE_MAKE_BRIDGE: IRecipe = {\n    id: 3,\n    a: ITEM_MONKEY_BRANCH,\n    b: ITEM_MONKEY_BRANCH,\n    result: ITEM_BRIDGE,\n};\nexport const RECIPE_MAKE_GOLDENGATE: IRecipe = {\n    id: 4,\n    a: ITEM_COIN,\n    b: ITEM_BRIDGE,\n    result: ITEM_GOLDEN_GATE,\n};\nexport const RECIPE_MAKE_CARDANO: IRecipe = {\n    id: 5,\n    a: ITEM_BLOCKCHAIN,\n    b: ITEM_PEER_REVIEW,\n    result: ITEM_CARDANO,\n};\nexport const RECIPE_MAKE_BEER: IRecipe = {\n    id: 6,\n    a: ITEM_BEE,\n    b: ITEM_BEAR,\n    result: ITEM_BEER,\n};\nexport const RECIPE_MAKE_LOCK: IRecipe = {\n    id: 7,\n    a: ITEM_SILVER,\n    b: ITEM_SILVER,\n    result: ITEM_LOCK,\n};\nexport const RECIPE_MAKE_SUPERMARMALADE: IRecipe = {\n    id: 8,\n    a: ITEM_MARMALADE,\n    b: ITEM_MARMALADE,\n    result: ITEM_SUPER_MARMALADE,\n};\nexport const RECIPE_MAKE_HYPERMARMALADE: IRecipe = {\n    id: 9,\n    a: ITEM_SUPER_MARMALADE,\n    b: ITEM_SUPER_MARMALADE,\n    result: ITEM_HYPER_MARMALADE,\n};\n\nexport const ALL_RECIPES: IRecipe[] = [\n    RECIPE_MAKE_SWARM,\n    RECIPE_MAKE_HYDRA,\n    RECIPE_MAKE_MONKEYBRANCH,\n    RECIPE_MAKE_BRIDGE,\n    RECIPE_MAKE_GOLDENGATE,\n    RECIPE_MAKE_CARDANO,\n    RECIPE_MAKE_BEER,\n    RECIPE_MAKE_LOCK,\n    RECIPE_MAKE_SUPERMARMALADE,\n    RECIPE_MAKE_HYPERMARMALADE,\n];\n\nexport const GAME_UNIFIERS_ITEMS: Array<IItem> = [\n    ITEM_MONKEY,\n    ITEM_GIRAFFE,\n    ITEM_BEE,\n    ITEM_COIN,\n    ITEM_SWARM,\n    ITEM_HYDRA,\n    ITEM_MONKEY_BRANCH,\n    ITEM_BRIDGE,\n    ITEM_GOLDEN_GATE,\n    ITEM_GOLD,\n    ITEM_SILVER,\n    ITEM_RHODIUM,\n    ITEM_HIVE,\n    ITEM_TRANSACTION,\n    ITEM_BLOCK,\n    ITEM_BLOCKCHAIN,\n    ITEM_POLKADOT,\n    ITEM_PEER_REVIEW,\n    ITEM_CARDANO,\n    ITEM_BEAR,\n    ITEM_BEER,\n    ITEM_LOCK,\n    ITEM_MARMALADE,\n    ITEM_SUPER_MARMALADE,\n    ITEM_HYPER_MARMALADE,\n];\nexport const GAME_UNIFIERS_RECIPES: Array<IRecipe> = [\n    RECIPE_MAKE_SWARM,\n    RECIPE_MAKE_HYDRA,\n    RECIPE_MAKE_MONKEYBRANCH,\n    RECIPE_MAKE_BRIDGE,\n    RECIPE_MAKE_GOLDENGATE,\n    RECIPE_MAKE_CARDANO,\n    RECIPE_MAKE_BEER,\n    RECIPE_MAKE_LOCK,\n    RECIPE_MAKE_SUPERMARMALADE,\n    RECIPE_MAKE_HYPERMARMALADE,\n];\nexport const GAME_UNIFIERS: IGameContent = {\n    name: \"Unifiers\",\n    description: \"A game created with the help of the Unifiers group\",\n    items: GAME_UNIFIERS_ITEMS,\n    recipes: GAME_UNIFIERS_RECIPES,\n};\nexport const ALL_GAMES: Array<IGameContent> = [\n    GAME_UNIFIERS,\n];",
      "contentHash": "7071c702826d068dd61f978e22f055a706399b60d85dde5fc1ac06c656a1084d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBearContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Bear' */\nexport interface IBearContract extends IElementContract {\n}",
      "contentHash": "dbc7dce70d8590a162d8f1b061e33b71f7c3da8ee38e2d9be07d32bb87aff29b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBeeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Bee' */\nexport interface IBeeContract extends IElementContract {\n}",
      "contentHash": "e599bf6fbde7ef15a9e9e60771f8088870672b688a2944ee801634b35c40e814",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBeerContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Beer' */\nexport interface IBeerContract extends IElementContract {\n}",
      "contentHash": "c82126140d3e69e303de5acc77108515296d835e4c250b36e709c2977b8a725f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBlockchainContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Blockchain' */\nexport interface IBlockchainContract extends IElementContract {\n}",
      "contentHash": "04b54c84c1d47da99b9987c6c473c1134e694863bdfb49c27b3be53965730a15",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBlockContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Block' */\nexport interface IBlockContract extends IElementContract {\n}",
      "contentHash": "ed053882f8170fc6132db1e82e19bb6970896f8c09384ed9d87f81c7f814b8dd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBridgeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Bridge' */\nexport interface IBridgeContract extends IElementContract {\n}",
      "contentHash": "1933ae9c360f56d6ed47adad7d6fcfac7ba9de44cddf546d1458e412b201df1f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ICardanoContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Cardano' */\nexport interface ICardanoContract extends IElementContract {\n}",
      "contentHash": "23176866b2c544cd25b2bb81a57a2b568027aece572378d50f1921fb48b24673",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ICoinContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Coin' */\nexport interface ICoinContract extends IElementContract {\n}",
      "contentHash": "40857b349a34d90f452862672364e20be00e652d3fcaa81c4912d027bee3106f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IGiraffeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Giraffe' */\nexport interface IGiraffeContract extends IElementContract {\n}",
      "contentHash": "b0f132f7ec57e8b1a27e253388da29a87729a955b200b3c83729ee2b3f5f1c97",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IGoldContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Gold' */\nexport interface IGoldContract extends IElementContract {\n}",
      "contentHash": "0a6a7d8b7d8cb1c99cf77533d3d8d3aa4c2df967a9b1ecd398c8bc0a8cc7211e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IGoldenGateContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'GoldenGate' */\nexport interface IGoldenGateContract extends IElementContract {\n}",
      "contentHash": "4a8b2b8ebda9af7326a8060db985e25a7e7c70618a5f0e9c5cd9896a634d3cb0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IHiveContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Hive' */\nexport interface IHiveContract extends IElementContract {\n}",
      "contentHash": "08012832365dfcce94d28349d84b262d7c6defcee4e8794c955954fdf3f9f995",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IHydraContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Hydra' */\nexport interface IHydraContract extends IElementContract {\n}",
      "contentHash": "f85c3b6aee34bd315923d09ba262c6f3f257c271b416d6ba2677eccd50266175",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IHyperMarmaladeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'HyperMarmalade' */\nexport interface IHyperMarmaladeContract extends IElementContract {\n}",
      "contentHash": "c5f7a11fb98aa73dc04dbb7e0fbf3fbde0f22051db780788ffe59bf23ccf3a97",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ILockContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Lock' */\nexport interface ILockContract extends IElementContract {\n}",
      "contentHash": "5abbfe49063e89c4a18b0dee309fa6df2195942bc44aa293118326a2635e6be9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IMarmaladeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Marmalade' */\nexport interface IMarmaladeContract extends IElementContract {\n}",
      "contentHash": "b2a62c8f54e74767f5e19b10f3c62427d6e817f3fb9514b5fe775329eec3fc9a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IMonkeyBranchContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'MonkeyBranch' */\nexport interface IMonkeyBranchContract extends IElementContract {\n}",
      "contentHash": "3e89ed2ce9c367c8a78ed90b65baca703207d8f60495a354d6d7910af2562cef",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IMonkeyContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Monkey' */\nexport interface IMonkeyContract extends IElementContract {\n}",
      "contentHash": "baaa2ad1dfc9777ef7d05b76d2e17ab4f547235452a982b095d295df3e471574",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/index.ts",
      "content": "export * from './IGameContract';\nexport * from './IMonkeyContract';\nexport * from './IGiraffeContract';\nexport * from './IBeeContract';\nexport * from './ICoinContract';\nexport * from './ISwarmContract';\nexport * from './IHydraContract';\nexport * from './IMonkeyBranchContract';\nexport * from './IBridgeContract';\nexport * from './IGoldenGateContract';\nexport * from './IGoldContract';\nexport * from './ISilverContract';\nexport * from './IRhodiumContract';\nexport * from './IHiveContract';\nexport * from './ITransactionContract';\nexport * from './IBlockContract';\nexport * from './IBlockchainContract';\nexport * from './IPolkadotContract';\nexport * from './IPeerReviewContract';\nexport * from './ICardanoContract';\nexport * from './IBearContract';\nexport * from './IBeerContract';\nexport * from './ILockContract';\nexport * from './IMarmaladeContract';\nexport * from './ISuperMarmaladeContract';\nexport * from './IHyperMarmaladeContract';\n",
      "contentHash": "07918f19b280b2ca513d4c898cd19c62e158b3d33a4d4068cfd7ba574a042030",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IPeerReviewContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'PeerReview' */\nexport interface IPeerReviewContract extends IElementContract {\n}",
      "contentHash": "d0b75c0d4acf3414796ac9f63c83ad19390310ba518b18ca4623e4a2d023f611",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IPolkadotContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Polkadot' */\nexport interface IPolkadotContract extends IElementContract {\n}",
      "contentHash": "d59f6fab4c68fbe345e172ab165d1e662ff49bc067f14cb8af4e612aea946881",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IRhodiumContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Rhodium' */\nexport interface IRhodiumContract extends IElementContract {\n}",
      "contentHash": "8e688b8436c36043bde57972c959199126d54b5ce53065e51d59b1ddce69d833",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISilverContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Silver' */\nexport interface ISilverContract extends IElementContract {\n}",
      "contentHash": "d62ce35a00728f18e5a0693b180acfc5f86490d01c5a394bf15d677be51780b4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISuperMarmaladeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'SuperMarmalade' */\nexport interface ISuperMarmaladeContract extends IElementContract {\n}",
      "contentHash": "66a3b3529321223ab59de2801d7a39350680af4d45938486105887b390c5f77c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISwarmContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'SWARM' */\nexport interface ISwarmContract extends IElementContract {\n}",
      "contentHash": "9d2fa8eb888255c648fd9f8a409e3ceff1530082a2a17ae267af954f286dbfee",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ITransactionContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Transaction' */\nexport interface ITransactionContract extends IElementContract {\n}",
      "contentHash": "89f93a898dc4d37458bfe21b94c5748b59b8a68700fc9ca61f94818700429afe",
      "noWriteIfExists": false
    }
  ]
}