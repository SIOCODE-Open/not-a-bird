{
  "generatedSource": [
    {
      "filename": "Cargo.toml",
      "content": "[workspace]\n\nresolver = \"2\"\nmembers = [\n  \"packages/contract-monkey/src\",\n  \"packages/contract-giraffe/src\",\n  \"packages/contract-bee/src\",\n  \"packages/contract-coin/src\",\n  \"packages/contract-swarm/src\",\n  \"packages/contract-hydra/src\",\n  \"packages/contract-monkey-branch/src\",\n  \"packages/contract-bridge/src\",\n  \"packages/contract-golden-gate/src\",\n  \"packages/contract-gold/src\",\n  \"packages/contract-silver/src\",\n  \"packages/contract-rhodium/src\",\n  \"packages/contract-hive/src\",\n  \"packages/contract-transaction/src\",\n  \"packages/contract-block/src\",\n  \"packages/contract-blockchain/src\",\n  \"packages/contract-polkadot/src\",\n  \"packages/contract-peer-review/src\",\n  \"packages/contract-cardano/src\",\n  \"packages/contract-bear/src\",\n  \"packages/contract-beer/src\",\n  \"packages/contract-lock/src\",\n  \"packages/contract-marmalade/src\",\n  \"packages/contract-super-marmalade/src\",\n  \"packages/contract-hyper-marmalade/src\",\n  \"packages/contract-water/src\",\n  \"packages/contract-fire/src\",\n  \"packages/contract-steam/src\",\n  \"packages/contract-earth/src\",\n  \"packages/contract-mud/src\",\n  \"packages/contract-lava/src\",\n  \"packages/contract-wind/src\",\n  \"packages/contract-dust/src\",\n  \"packages/contract-rain/src\",\n  \"packages/contract-smoke/src\",\n  \"packages/contract-geyser/src\",\n  \"packages/contract-clay/src\",\n  \"packages/contract-sand/src\",\n  \"packages/contract-plant/src\",\n  \"packages/contract-rainbow/src\",\n  \"packages/contract-storm/src\",\n  \"packages/contract-obsidian/src\",\n  \"packages/contract-ash/src\",\n  \"packages/contract-volcano/src\",\n  \"packages/contract-sandstorm/src\",\n  \"packages/contract-cloud/src\",\n  \"packages/contract-fog/src\",\n  \"packages/contract-tree/src\",\n  \"packages/contract-forest/src\",\n  \"packages/contract-seeds/src\",\n  \"packages/contract-pottery/src\",\n  \"packages/contract-brick/src\",\n  \"packages/contract-quicksand/src\",\n  \"packages/contract-glass/src\",\n  \"packages/contract-dune/src\",\n  \"packages/contract-charcoal/src\",\n  \"packages/contract-leaves/src\",\n  \"packages/contract-wildfire/src\",\n  \"packages/contract-jungle/src\",\n  \"packages/contract-frosted-glass/src\",\n  \"packages/contract-crystal/src\",\n  \"packages/contract-magma/src\",\n  \"packages/contract-rock/src\",\n  \"packages/contract-shard/src\",\n  \"packages/contract-pebble/src\",\n  \"packages/contract-mountain/src\",\n  \"packages/contract-fertilizer/src\",\n  \"packages/contract-soot/src\",\n  \"packages/contract-lightning/src\",\n  \"packages/contract-mist/src\",\n  \"packages/contract-haze/src\",\n  \"packages/contract-flood/src\",\n  \"packages/contract-landslide/src\",\n  \"packages/contract-thunder/src\",\n  \"packages/contract-tornado/src\",\n  \"packages/contract-garden/src\",\n  \"packages/contract-ember/src\",\n  \"packages/contract-kiln/src\",\n  \"packages/contract-pollination/src\",\n  \"packages/contract-sinkhole/src\",\n  \"packages/contract-beach/src\",\n  \"packages/contract-wetstone/src\",\n  \"packages/contract-erosion/src\",\n  \"packages/contract-basalt/src\",\n  \"packages/contract-magma-chamber/src\",\n  \"packages/contract-breeze/src\",\n  \"packages/contract-warm-breeze/src\",\n  \"packages/contract-soil/src\",\n  \"packages/contract-canyon/src\",\n  \"packages/contract-windmill/src\",\n  \"packages/contract-adobe/src\",\n  \"packages/contract-wall/src\",\n  \"packages/contract-pumice/src\",\n  \"packages/contract-barbecue/src\",\n  \"packages/contract-farm/src\",\n  \"packages/contract-shards/src\",\n  \"packages/contract-molten-glass/src\",\n  \"packages/contract-prism/src\",\n  \"packages/contract-sparkle/src\",\n  \"packages/contract-desert/src\",\n  \"packages/contract-oasis/src\",\n  \"packages/contract-mirage/src\",\n  \"packages/contract-sand-dune/src\",\n  \"packages/contract-dam/src\",\n  \"packages/contract-firewall/src\",\n  \"packages/contract-barricade/src\",\n  \"packages/contract-plateau/src\",\n  \"packages/contract-pond/src\",\n  \"packages/contract-aromas/src\",\n  \"packages/contract-flower/src\",\n  \"packages/contract-spore/src\",\n  \"packages/contract-spread/src\",\n  \"packages/contract-fertile-land/src\",\n  \"packages/contract-wetland/src\",\n  \"packages/contract-peat/src\",\n  \"packages/contract-reeds/src\",\n  \"packages/contract-valley/src\",\n  \"packages/contract-river/src\",\n  \"packages/contract-scorched-earth/src\",\n  \"packages/contract-delta/src\",\n  \"packages/contract-estuary/src\",\n  \"packages/contract-fire-swamp/src\",\n  \"packages/contract-riverbank/src\",\n  \"packages/contract-ravine/src\",\n  \"packages/contract-gorge/src\",\n  \"packages/contract-charred-ravine/src\",\n  \"packages/contract-echo/src\",\n  \"packages/contract-cave/src\",\n  \"packages/contract-underground-lake/src\",\n  \"packages/contract-lava-cave/src\",\n  \"packages/contract-whispering-cave/src\",\n  \"packages/contract-subterranean-pool/src\",\n  \"packages/contract-spring/src\",\n  \"packages/contract-hot-spring/src\",\n  \"packages/contract-grotto/src\",\n  \"packages/contract-fountain/src\",\n  \"packages/contract-steam-vent/src\",\n  \"packages/contract-cool-breeze/src\",\n  \"packages/contract-monument/src\",\n  \"packages/contract-waterfall/src\",\n  \"packages/contract-eternal-flame/src\",\n  \"packages/contract-pillar-of-wind/src\",\n  \"packages/contract-stream/src\",\n  \"packages/contract-zephyr/src\",\n  \"packages/contract-creek/src\",\n  \"packages/contract-brook/src\",\n  \"packages/contract-whisper/src\",\n  \"packages/contract-rivulet/src\",\n  \"packages/contract-tributary/src\",\n  \"packages/contract-murmur/src\",\n  \"packages/contract-watershed/src\",\n  \"packages/contract-aquifer/src\",\n  \"packages/contract-parched-earth/src\",\n  \"packages/contract-fresh-breeze/src\",\n  \"packages/contract-groundwater/src\",\n  \"packages/contract-reservoir/src\",\n  \"packages/contract-geothermal-spring/src\",\n  \"packages/contract-artesian-well/src\",\n  \"packages/contract-basin/src\",\n  \"packages/contract-lake/src\",\n  \"packages/contract-dry-basin/src\",\n  \"packages/contract-depression/src\",\n  \"packages/contract-island/src\",\n  \"packages/contract-lagoon/src\",\n  \"packages/contract-wave/src\",\n  \"packages/contract-reef/src\",\n  \"packages/contract-coral/src\",\n  \"packages/contract-whirl/src\",\n  \"packages/contract-limestone/src\",\n  \"packages/contract-karst/src\",\n  \"packages/contract-quicklime/src\",\n  \"packages/contract-blowhole/src\",\n  \"packages/contract-game/src\",\n  \"packages/contract-unifiers/src\",\n  \"packages/contract-elementy/src\",\n]\nexclude = [\n  \".cargo\",\n  \"target\"\n]\n\n[workspace.dependencies]\nink = { version = \"5.0.0\", default-features = false }",
      "contentHash": "0396237114be94aa7703f5b424fc18e183d3cee105d5bc137a2ce4dd67af61a5",
      "noWriteIfExists": false
    },
    {
      "filename": "ITEMS.md",
      "content": "# Items\n\nIn this document we list all **items** (or _elements_) and **recipes** that can be found in the game. We also provide some explanation of the most important game mechanics revolving around items and recipes.\n\n## Buying\n\n**Buying an item**: Players may at any time call the game contract, transfer some value in the call, and receive items equal to the value transferred. The price of an item is calculated as follows:\n\nFor starters, each **item** has a **tier**. The item tier is a **positive integer number**. The game always has a **buy offer**, which is a tuple of (**native token price**, **received tier points**). When the player **buys**, they indirectly buy tier points, and may receive `floor(received_tier_points / tier)` items. The game only considers `floor(transfered_value / native_token_price)` amount of money transfered in, and the remainder is lost (or donated to the contract, however you want to see it).\n\n## Items\n\n* **Monkey** (`1`): We need a description here\n* **Giraffe** (`1`): We need a description here\n* **Bee** (`1`): We need a description here\n* **Coin** (`1`): We need a description here\n* **Swarm** (`2`): We need a description here\n* **Hydra** (`2`): We need a description here\n* **Monkey Branch** (`2`): We need a description here\n* **Bridge** (`2`): We need a description here\n* **Golden Gate** (`2`): We need a description here\n* **Gold** (`1`): We need a description here\n* **Silver** (`1`): We need a description here\n* **Rhodium** (`1`): We need a description here\n* **Hive** (`1`): We need a description here\n* **Transaction** (`1`): We need a description here\n* **Block** (`1`): We need a description here\n* **Blockchain** (`1`): We need a description here\n* **Polkadot** (`1`): We need a description here\n* **Peer Review** (`1`): We need a description here\n* **Cardano** (`2`): We need a description here\n* **Bear** (`1`): We need a description here\n* **Beer** (`2`): We need a description here\n* **Lock** (`2`): We need a description here\n* **Marmalade** (`1`): We need a description here\n* **Super Marmalade** (`2`): We need a description here\n* **Hyper Marmalade** (`2`): We need a description here\n* **Water** (`1`): We need a description here\n* **Fire** (`1`): We need a description here\n* **Steam** (`1`): We need a description here\n* **Earth** (`1`): We need a description here\n* **Mud** (`1`): We need a description here\n* **Lava** (`1`): We need a description here\n* **Wind** (`1`): We need a description here\n* **Dust** (`1`): We need a description here\n* **Rain** (`1`): We need a description here\n* **Smoke** (`1`): We need a description here\n* **Geyser** (`1`): We need a description here\n* **Clay** (`1`): We need a description here\n* **Sand** (`1`): We need a description here\n* **Plant** (`1`): We need a description here\n* **Rainbow** (`1`): We need a description here\n* **Storm** (`1`): We need a description here\n* **Obsidian** (`1`): We need a description here\n* **Ash** (`1`): We need a description here\n* **Volcano** (`1`): We need a description here\n* **Sandstorm** (`1`): We need a description here\n* **Cloud** (`1`): We need a description here\n* **Fog** (`1`): We need a description here\n* **Tree** (`1`): We need a description here\n* **Forest** (`1`): We need a description here\n* **Seeds** (`1`): We need a description here\n* **Pottery** (`1`): We need a description here\n* **Brick** (`1`): We need a description here\n* **Quicksand** (`1`): We need a description here\n* **Glass** (`1`): We need a description here\n* **Dune** (`1`): We need a description here\n* **Charcoal** (`1`): We need a description here\n* **Leaves** (`1`): We need a description here\n* **Wildfire** (`1`): We need a description here\n* **Jungle** (`1`): We need a description here\n* **Frosted Glass** (`1`): We need a description here\n* **Crystal** (`1`): We need a description here\n* **Magma** (`1`): We need a description here\n* **Rock** (`1`): We need a description here\n* **Shard** (`1`): We need a description here\n* **Pebble** (`1`): We need a description here\n* **Mountain** (`1`): We need a description here\n* **Fertilizer** (`1`): We need a description here\n* **Soot** (`1`): We need a description here\n* **Lightning** (`1`): We need a description here\n* **Mist** (`1`): We need a description here\n* **Haze** (`1`): We need a description here\n* **Flood** (`1`): We need a description here\n* **Landslide** (`1`): We need a description here\n* **Thunder** (`1`): We need a description here\n* **Tornado** (`1`): We need a description here\n* **Garden** (`1`): We need a description here\n* **Ember** (`1`): We need a description here\n* **Kiln** (`1`): We need a description here\n* **Pollination** (`1`): We need a description here\n* **Sinkhole** (`1`): We need a description here\n* **Beach** (`1`): We need a description here\n* **Wetstone** (`1`): We need a description here\n* **Erosion** (`1`): We need a description here\n* **Basalt** (`1`): We need a description here\n* **Magma Chamber** (`1`): We need a description here\n* **Breeze** (`1`): We need a description here\n* **Warm Breeze** (`1`): We need a description here\n* **Soil** (`1`): We need a description here\n* **Canyon** (`1`): We need a description here\n* **Windmill** (`1`): We need a description here\n* **Adobe** (`1`): We need a description here\n* **Wall** (`1`): We need a description here\n* **Pumice** (`1`): We need a description here\n* **Barbecue** (`1`): We need a description here\n* **Farm** (`1`): We need a description here\n* **Shards** (`1`): We need a description here\n* **Molten Glass** (`1`): We need a description here\n* **Prism** (`1`): We need a description here\n* **Sparkle** (`1`): We need a description here\n* **Desert** (`1`): We need a description here\n* **Oasis** (`1`): We need a description here\n* **Mirage** (`1`): We need a description here\n* **Sand Dune** (`1`): We need a description here\n* **Dam** (`1`): We need a description here\n* **Firewall** (`1`): We need a description here\n* **Barricade** (`1`): We need a description here\n* **Plateau** (`1`): We need a description here\n* **Pond** (`1`): We need a description here\n* **Aromas** (`1`): We need a description here\n* **Flower** (`1`): We need a description here\n* **Spore** (`1`): We need a description here\n* **Spread** (`1`): We need a description here\n* **Fertile Land** (`1`): We need a description here\n* **Wetland** (`1`): We need a description here\n* **Peat** (`1`): We need a description here\n* **Reeds** (`1`): We need a description here\n* **Valley** (`1`): We need a description here\n* **River** (`1`): We need a description here\n* **Scorched Earth** (`1`): We need a description here\n* **Delta** (`1`): We need a description here\n* **Estuary** (`1`): We need a description here\n* **Fire Swamp** (`1`): We need a description here\n* **Riverbank** (`1`): We need a description here\n* **Ravine** (`1`): We need a description here\n* **Gorge** (`1`): We need a description here\n* **Charred Ravine** (`1`): We need a description here\n* **Echo** (`1`): We need a description here\n* **Cave** (`1`): We need a description here\n* **Underground Lake** (`1`): We need a description here\n* **Lava Cave** (`1`): We need a description here\n* **Whispering Cave** (`1`): We need a description here\n* **Subterranean Pool** (`1`): We need a description here\n* **Spring** (`1`): We need a description here\n* **Hot Spring** (`1`): We need a description here\n* **Grotto** (`1`): We need a description here\n* **Fountain** (`1`): We need a description here\n* **Steam Vent** (`1`): We need a description here\n* **Cool Breeze** (`1`): We need a description here\n* **Monument** (`1`): We need a description here\n* **Waterfall** (`1`): We need a description here\n* **Eternal Flame** (`1`): We need a description here\n* **Pillar Of Wind** (`1`): We need a description here\n* **Stream** (`1`): We need a description here\n* **Zephyr** (`1`): We need a description here\n* **Creek** (`1`): We need a description here\n* **Brook** (`1`): We need a description here\n* **Whisper** (`1`): We need a description here\n* **Rivulet** (`1`): We need a description here\n* **Tributary** (`1`): We need a description here\n* **Murmur** (`1`): We need a description here\n* **Watershed** (`1`): We need a description here\n* **Aquifer** (`1`): We need a description here\n* **Parched Earth** (`1`): We need a description here\n* **Fresh Breeze** (`1`): We need a description here\n* **Groundwater** (`1`): We need a description here\n* **Reservoir** (`1`): We need a description here\n* **Geothermal Spring** (`1`): We need a description here\n* **Artesian Well** (`1`): We need a description here\n* **Basin** (`1`): We need a description here\n* **Lake** (`1`): We need a description here\n* **Dry Basin** (`1`): We need a description here\n* **Depression** (`1`): We need a description here\n* **Island** (`1`): We need a description here\n* **Lagoon** (`1`): We need a description here\n* **Wave** (`1`): We need a description here\n* **Reef** (`1`): We need a description here\n* **Coral** (`1`): We need a description here\n* **Whirl** (`1`): We need a description here\n* **Limestone** (`1`): We need a description here\n* **Karst** (`1`): We need a description here\n* **Quicklime** (`1`): We need a description here\n* **Blowhole** (`1`): We need a description here\n\n## Recipes\n\n* **Make Swarm** (`1 + 1 -> 2`) - **Bee** + **Bee** -> **Swarm**: \n* **Make Hydra** (`1 + 1 -> 2`) - **Giraffe** + **Giraffe** -> **Hydra**: \n* **Make Monkeybranch** (`1 + 2 -> 2`) - **Monkey** + **Hydra** -> **Monkey Branch**: \n* **Make Bridge** (`2 + 2 -> 2`) - **Monkey Branch** + **Monkey Branch** -> **Bridge**: \n* **Make Goldengate** (`1 + 2 -> 2`) - **Coin** + **Bridge** -> **Golden Gate**: \n* **Make Cardano** (`1 + 1 -> 2`) - **Blockchain** + **Peer Review** -> **Cardano**: \n* **Make Beer** (`1 + 1 -> 2`) - **Bee** + **Bear** -> **Beer**: \n* **Make Lock** (`1 + 1 -> 2`) - **Silver** + **Silver** -> **Lock**: \n* **Make Supermarmalade** (`1 + 1 -> 2`) - **Marmalade** + **Marmalade** -> **Super Marmalade**: \n* **Make Hypermarmalade** (`2 + 2 -> 2`) - **Super Marmalade** + **Super Marmalade** -> **Hyper Marmalade**: \n* **Make Steam** (`1 + 1 -> 1`) - **Water** + **Fire** -> **Steam**: We need a description here\n* **Make Mud** (`1 + 1 -> 1`) - **Water** + **Earth** -> **Mud**: We need a description here\n* **Make Lava** (`1 + 1 -> 1`) - **Fire** + **Earth** -> **Lava**: We need a description here\n* **Make Dust** (`1 + 1 -> 1`) - **Wind** + **Earth** -> **Dust**: We need a description here\n* **Make Rain** (`1 + 1 -> 1`) - **Water** + **Wind** -> **Rain**: We need a description here\n* **Make Smoke** (`1 + 1 -> 1`) - **Fire** + **Wind** -> **Smoke**: We need a description here\n* **Make Geyser** (`1 + 1 -> 1`) - **Steam** + **Earth** -> **Geyser**: We need a description here\n* **Make Clay** (`1 + 1 -> 1`) - **Mud** + **Fire** -> **Clay**: We need a description here\n* **Make Sand** (`1 + 1 -> 1`) - **Mud** + **Wind** -> **Sand**: We need a description here\n* **Make Plant** (`1 + 1 -> 1`) - **Rain** + **Earth** -> **Plant**: We need a description here\n* **Make Rainbow** (`1 + 1 -> 1`) - **Rain** + **Fire** -> **Rainbow**: We need a description here\n* **Make Storm** (`1 + 1 -> 1`) - **Rain** + **Wind** -> **Storm**: We need a description here\n* **Make Obsidian** (`1 + 1 -> 1`) - **Lava** + **Water** -> **Obsidian**: We need a description here\n* **Make Ash** (`1 + 1 -> 1`) - **Lava** + **Wind** -> **Ash**: We need a description here\n* **Make Volcano** (`1 + 1 -> 1`) - **Lava** + **Earth** -> **Volcano**: We need a description here\n* **Make Sandstorm** (`1 + 1 -> 1`) - **Dust** + **Wind** -> **Sandstorm**: We need a description here\n* **Make Cloud** (`1 + 1 -> 1`) - **Smoke** + **Water** -> **Cloud**: We need a description here\n* **Make Fog** (`1 + 1 -> 1`) - **Smoke** + **Wind** -> **Fog**: We need a description here\n* **Make Tree** (`1 + 1 -> 1`) - **Plant** + **Water** -> **Tree**: We need a description here\n* **Make Forest** (`1 + 1 -> 1`) - **Plant** + **Earth** -> **Forest**: We need a description here\n* **Make Seeds** (`1 + 1 -> 1`) - **Plant** + **Wind** -> **Seeds**: We need a description here\n* **Make Pottery** (`1 + 1 -> 1`) - **Clay** + **Fire** -> **Pottery**: We need a description here\n* **Make Brick** (`1 + 1 -> 1`) - **Clay** + **Earth** -> **Brick**: We need a description here\n* **Make Quicksand** (`1 + 1 -> 1`) - **Sand** + **Water** -> **Quicksand**: We need a description here\n* **Make Glass** (`1 + 1 -> 1`) - **Sand** + **Fire** -> **Glass**: We need a description here\n* **Make Dune** (`1 + 1 -> 1`) - **Sand** + **Wind** -> **Dune**: We need a description here\n* **Make Charcoal** (`1 + 1 -> 1`) - **Tree** + **Fire** -> **Charcoal**: We need a description here\n* **Make Leaves** (`1 + 1 -> 1`) - **Tree** + **Wind** -> **Leaves**: We need a description here\n* **Make Wildfire** (`1 + 1 -> 1`) - **Forest** + **Fire** -> **Wildfire**: We need a description here\n* **Make Jungle** (`1 + 1 -> 1`) - **Forest** + **Earth** -> **Jungle**: We need a description here\n* **Make Frosted Glass** (`1 + 1 -> 1`) - **Glass** + **Water** -> **Frosted Glass**: We need a description here\n* **Make Crystal** (`1 + 1 -> 1`) - **Glass** + **Earth** -> **Crystal**: We need a description here\n* **Make Magma** (`1 + 1 -> 1`) - **Obsidian** + **Fire** -> **Magma**: We need a description here\n* **Make Rock** (`1 + 1 -> 1`) - **Obsidian** + **Earth** -> **Rock**: We need a description here\n* **Make Shard** (`1 + 1 -> 1`) - **Obsidian** + **Wind** -> **Shard**: We need a description here\n* **Make Pebble** (`1 + 1 -> 1`) - **Rock** + **Water** -> **Pebble**: We need a description here\n* **Make Mountain** (`1 + 1 -> 1`) - **Rock** + **Earth** -> **Mountain**: We need a description here\n* **Make Fertilizer** (`1 + 1 -> 1`) - **Ash** + **Earth** -> **Fertilizer**: We need a description here\n* **Make Soot** (`1 + 1 -> 1`) - **Ash** + **Wind** -> **Soot**: We need a description here\n* **Make Lightning** (`1 + 1 -> 1`) - **Cloud** + **Fire** -> **Lightning**: We need a description here\n* **Make Mist** (`1 + 1 -> 1`) - **Fog** + **Earth** -> **Mist**: We need a description here\n* **Make Haze** (`1 + 1 -> 1`) - **Fog** + **Wind** -> **Haze**: We need a description here\n* **Make Flood** (`1 + 1 -> 1`) - **Storm** + **Water** -> **Flood**: We need a description here\n* **Make Landslide** (`1 + 1 -> 1`) - **Storm** + **Earth** -> **Landslide**: We need a description here\n* **Make Thunder** (`1 + 1 -> 1`) - **Storm** + **Fire** -> **Thunder**: We need a description here\n* **Make Tornado** (`1 + 1 -> 1`) - **Storm** + **Wind** -> **Tornado**: We need a description here\n* **Make Garden** (`1 + 1 -> 1`) - **Earth** + **Plant** -> **Garden**: We need a description here\n* **Make Ember** (`1 + 1 -> 1`) - **Fire** + **Ash** -> **Ember**: We need a description here\n* **Make Kiln** (`1 + 1 -> 1`) - **Fire** + **Pottery** -> **Kiln**: We need a description here\n* **Make Pollination** (`1 + 1 -> 1`) - **Wind** + **Plant** -> **Pollination**: We need a description here\n* **Make Sinkhole** (`1 + 1 -> 1`) - **Earth** + **Quicksand** -> **Sinkhole**: We need a description here\n* **Make Beach** (`1 + 1 -> 1`) - **Water** + **Sand** -> **Beach**: We need a description here\n* **Make Wetstone** (`1 + 1 -> 1`) - **Water** + **Obsidian** -> **Wetstone**: We need a description here\n* **Make Erosion** (`1 + 1 -> 1`) - **Wind** + **Rock** -> **Erosion**: We need a description here\n* **Make Basalt** (`1 + 1 -> 1`) - **Water** + **Lava** -> **Basalt**: We need a description here\n* **Make Magma Chamber** (`1 + 1 -> 1`) - **Earth** + **Lava** -> **Magma Chamber**: We need a description here\n* **Make Breeze** (`1 + 1 -> 1`) - **Wind** + **Dust** -> **Breeze**: We need a description here\n* **Make Warm Breeze** (`1 + 1 -> 1`) - **Fire** + **Breeze** -> **Warm Breeze**: We need a description here\n* **Make Soil** (`1 + 1 -> 1`) - **Earth** + **Plant** -> **Soil**: We need a description here\n* **Make Canyon** (`1 + 1 -> 1`) - **Water** + **Erosion** -> **Canyon**: We need a description here\n* **Make Windmill** (`1 + 1 -> 1`) - **Wind** + **Plant** -> **Windmill**: We need a description here\n* **Make Adobe** (`1 + 1 -> 1`) - **Earth** + **Clay** -> **Adobe**: We need a description here\n* **Make Wall** (`1 + 1 -> 1`) - **Earth** + **Brick** -> **Wall**: We need a description here\n* **Make Pumice** (`1 + 1 -> 1`) - **Water** + **Ash** -> **Pumice**: We need a description here\n* **Make Barbecue** (`1 + 1 -> 1`) - **Fire** + **Charcoal** -> **Barbecue**: We need a description here\n* **Make Farm** (`1 + 1 -> 1`) - **Earth** + **Seeds** -> **Farm**: We need a description here\n* **Make Shards** (`1 + 1 -> 1`) - **Wind** + **Obsidian** -> **Shards**: We need a description here\n* **Make Molten Glass** (`1 + 1 -> 1`) - **Fire** + **Crystal** -> **Molten Glass**: We need a description here\n* **Make Prism** (`1 + 1 -> 1`) - **Water** + **Crystal** -> **Prism**: We need a description here\n* **Make Sparkle** (`1 + 1 -> 1`) - **Wind** + **Crystal** -> **Sparkle**: We need a description here\n* **Make Desert** (`1 + 1 -> 1`) - **Earth** + **Beach** -> **Desert**: We need a description here\n* **Make Oasis** (`1 + 1 -> 1`) - **Water** + **Desert** -> **Oasis**: We need a description here\n* **Make Mirage** (`1 + 1 -> 1`) - **Fire** + **Desert** -> **Mirage**: We need a description here\n* **Make Sand Dune** (`1 + 1 -> 1`) - **Wind** + **Desert** -> **Sand Dune**: We need a description here\n* **Make Dam** (`1 + 1 -> 1`) - **Water** + **Wall** -> **Dam**: We need a description here\n* **Make Firewall** (`1 + 1 -> 1`) - **Fire** + **Wall** -> **Firewall**: We need a description here\n* **Make Barricade** (`1 + 1 -> 1`) - **Wind** + **Wall** -> **Barricade**: We need a description here\n* **Make Plateau** (`1 + 1 -> 1`) - **Earth** + **Canyon** -> **Plateau**: We need a description here\n* **Make Pond** (`1 + 1 -> 1`) - **Water** + **Garden** -> **Pond**: We need a description here\n* **Make Aromas** (`1 + 1 -> 1`) - **Wind** + **Garden** -> **Aromas**: We need a description here\n* **Make Flower** (`1 + 1 -> 1`) - **Water** + **Pollination** -> **Flower**: We need a description here\n* **Make Spore** (`1 + 1 -> 1`) - **Fire** + **Pollination** -> **Spore**: We need a description here\n* **Make Spread** (`1 + 1 -> 1`) - **Wind** + **Pollination** -> **Spread**: We need a description here\n* **Make Fertile Land** (`1 + 1 -> 1`) - **Earth** + **Soil** -> **Fertile Land**: We need a description here\n* **Make Wetland** (`1 + 1 -> 1`) - **Water** + **Fertile Land** -> **Wetland**: We need a description here\n* **Make Peat** (`1 + 1 -> 1`) - **Fire** + **Wetland** -> **Peat**: We need a description here\n* **Make Reeds** (`1 + 1 -> 1`) - **Wind** + **Wetland** -> **Reeds**: We need a description here\n* **Make Valley** (`1 + 1 -> 1`) - **Earth** + **Canyon** -> **Valley**: We need a description here\n* **Make River** (`1 + 1 -> 1`) - **Water** + **Valley** -> **River**: We need a description here\n* **Make Scorched Earth** (`1 + 1 -> 1`) - **Fire** + **Valley** -> **Scorched Earth**: We need a description here\n* **Make Delta** (`1 + 1 -> 1`) - **Earth** + **River** -> **Delta**: We need a description here\n* **Make Estuary** (`1 + 1 -> 1`) - **Water** + **Delta** -> **Estuary**: We need a description here\n* **Make Fire Swamp** (`1 + 1 -> 1`) - **Fire** + **Delta** -> **Fire Swamp**: We need a description here\n* **Make Riverbank** (`1 + 1 -> 1`) - **Wind** + **Delta** -> **Riverbank**: We need a description here\n* **Make Ravine** (`1 + 1 -> 1`) - **Earth** + **Erosion** -> **Ravine**: We need a description here\n* **Make Gorge** (`1 + 1 -> 1`) - **Water** + **Ravine** -> **Gorge**: We need a description here\n* **Make Charred Ravine** (`1 + 1 -> 1`) - **Fire** + **Ravine** -> **Charred Ravine**: We need a description here\n* **Make Echo** (`1 + 1 -> 1`) - **Wind** + **Ravine** -> **Echo**: We need a description here\n* **Make Cave** (`1 + 1 -> 1`) - **Earth** + **Echo** -> **Cave**: We need a description here\n* **Make Underground Lake** (`1 + 1 -> 1`) - **Water** + **Cave** -> **Underground Lake**: We need a description here\n* **Make Lava Cave** (`1 + 1 -> 1`) - **Fire** + **Cave** -> **Lava Cave**: We need a description here\n* **Make Whispering Cave** (`1 + 1 -> 1`) - **Wind** + **Cave** -> **Whispering Cave**: We need a description here\n* **Make Subterranean Pool** (`1 + 1 -> 1`) - **Earth** + **Underground Lake** -> **Subterranean Pool**: We need a description here\n* **Make Spring** (`1 + 1 -> 1`) - **Water** + **Subterranean Pool** -> **Spring**: We need a description here\n* **Make Hot Spring** (`1 + 1 -> 1`) - **Fire** + **Subterranean Pool** -> **Hot Spring**: We need a description here\n* **Make Grotto** (`1 + 1 -> 1`) - **Wind** + **Subterranean Pool** -> **Grotto**: We need a description here\n* **Make Fountain** (`1 + 1 -> 1`) - **Water** + **Spring** -> **Fountain**: We need a description here\n* **Make Steam Vent** (`1 + 1 -> 1`) - **Fire** + **Spring** -> **Steam Vent**: We need a description here\n* **Make Cool Breeze** (`1 + 1 -> 1`) - **Wind** + **Spring** -> **Cool Breeze**: We need a description here\n* **Make Monument** (`1 + 1 -> 1`) - **Earth** + **Fountain** -> **Monument**: We need a description here\n* **Make Waterfall** (`1 + 1 -> 1`) - **Water** + **Monument** -> **Waterfall**: We need a description here\n* **Make Eternal Flame** (`1 + 1 -> 1`) - **Fire** + **Monument** -> **Eternal Flame**: We need a description here\n* **Make Pillar Of Wind** (`1 + 1 -> 1`) - **Wind** + **Monument** -> **Pillar Of Wind**: We need a description here\n* **Make Stream** (`1 + 1 -> 1`) - **Water** + **River** -> **Stream**: We need a description here\n* **Make Zephyr** (`1 + 1 -> 1`) - **Wind** + **River** -> **Zephyr**: We need a description here\n* **Make Creek** (`1 + 1 -> 1`) - **Earth** + **Stream** -> **Creek**: We need a description here\n* **Make Brook** (`1 + 1 -> 1`) - **Water** + **Creek** -> **Brook**: We need a description here\n* **Make Whisper** (`1 + 1 -> 1`) - **Wind** + **Creek** -> **Whisper**: We need a description here\n* **Make Rivulet** (`1 + 1 -> 1`) - **Earth** + **Brook** -> **Rivulet**: We need a description here\n* **Make Tributary** (`1 + 1 -> 1`) - **Water** + **Rivulet** -> **Tributary**: We need a description here\n* **Make Murmur** (`1 + 1 -> 1`) - **Wind** + **Rivulet** -> **Murmur**: We need a description here\n* **Make Watershed** (`1 + 1 -> 1`) - **Earth** + **Tributary** -> **Watershed**: We need a description here\n* **Make Aquifer** (`1 + 1 -> 1`) - **Water** + **Watershed** -> **Aquifer**: We need a description here\n* **Make Parched Earth** (`1 + 1 -> 1`) - **Fire** + **Watershed** -> **Parched Earth**: We need a description here\n* **Make Fresh Breeze** (`1 + 1 -> 1`) - **Wind** + **Watershed** -> **Fresh Breeze**: We need a description here\n* **Make Groundwater** (`1 + 1 -> 1`) - **Earth** + **Aquifer** -> **Groundwater**: We need a description here\n* **Make Reservoir** (`1 + 1 -> 1`) - **Water** + **Groundwater** -> **Reservoir**: We need a description here\n* **Make Geothermal Spring** (`1 + 1 -> 1`) - **Fire** + **Groundwater** -> **Geothermal Spring**: We need a description here\n* **Make Artesian Well** (`1 + 1 -> 1`) - **Wind** + **Groundwater** -> **Artesian Well**: We need a description here\n* **Make Basin** (`1 + 1 -> 1`) - **Earth** + **Reservoir** -> **Basin**: We need a description here\n* **Make Lake** (`1 + 1 -> 1`) - **Water** + **Basin** -> **Lake**: We need a description here\n* **Make Dry Basin** (`1 + 1 -> 1`) - **Fire** + **Basin** -> **Dry Basin**: We need a description here\n* **Make Depression** (`1 + 1 -> 1`) - **Wind** + **Basin** -> **Depression**: We need a description here\n* **Make Island** (`1 + 1 -> 1`) - **Earth** + **Lake** -> **Island**: We need a description here\n* **Make Lagoon** (`1 + 1 -> 1`) - **Water** + **Lake** -> **Lagoon**: We need a description here\n* **Make Wave** (`1 + 1 -> 1`) - **Wind** + **Lake** -> **Wave**: We need a description here\n* **Make Reef** (`1 + 1 -> 1`) - **Earth** + **Lagoon** -> **Reef**: We need a description here\n* **Make Coral** (`1 + 1 -> 1`) - **Water** + **Reef** -> **Coral**: We need a description here\n* **Make Whirl** (`1 + 1 -> 1`) - **Wind** + **Reef** -> **Whirl**: We need a description here\n* **Make Limestone** (`1 + 1 -> 1`) - **Earth** + **Coral** -> **Limestone**: We need a description here\n* **Make Karst** (`1 + 1 -> 1`) - **Water** + **Limestone** -> **Karst**: We need a description here\n* **Make Quicklime** (`1 + 1 -> 1`) - **Fire** + **Limestone** -> **Quicklime**: We need a description here\n* **Make Blowhole** (`1 + 1 -> 1`) - **Wind** + **Karst** -> **Blowhole**: We need a description here\n",
      "contentHash": "b0cd9b409d9002f6d59dc8812ca973b82932f200ce628897d37da3745e3a0423",
      "noWriteIfExists": false
    },
    {
      "filename": "package.json",
      "content": "{\n  \"name\": \"@siocode/not-a-bird\",\n  \"version\": \"0.0.1\",\n  \"private\": true,\n  \"workspaces\": [\n    \"packages/*\"\n  ],\n  \"dependencies\": {\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\",\n    \"rxjs\": \"7.8.1\",\n    \"@polkadot/api\": \"11.0.2\",\n    \"@polkadot/api-contract\": \"11.0.2\",\n    \"leva\": \"0.9.35\",\n    \"@unique-nft/accounts\": \"^0.3.7\",\n    \"@unique-nft/sdk\": \"^0.7.4\",\n    \"bulma\": \"1.0.0\",\n    \"listr2\": \"8.2.1\",\n    \"markdown-it-task-lists\": \"^2.1.1\",\n    \"markdown-it-textual-uml\": \"^0.17.1\",\n    \"yaml\": \"^2.4.2\",\n    \"commander\": \"12.1.0\",\n    \"express\": \"4.19.2\"\n  },\n  \"devDependencies\": {\n    \"@types/react\": \"18.2.79\",\n    \"@types/react-dom\": \"18.2.25\",\n    \"chalk\": \"4\",\n    \"chokidar\": \"3.6.0\",\n    \"concurrently\": \"8.2.2\",\n    \"esbuild\": \"0.20.2\",\n    \"fs-extra\": \"11.2.0\",\n    \"sass\": \"1.75.0\",\n    \"typescript\": \"5.4.5\",\n    \"prettier\": \"^3.2.5\",\n    \"vitepress\": \"1.2.2\",\n    \"@types/node\": \"20.12.12\"\n  },\n  \"scripts\": {\n    \"c:monkey\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-monkey/src/Cargo.toml\",\n    \"c:giraffe\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-giraffe/src/Cargo.toml\",\n    \"c:bee\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-bee/src/Cargo.toml\",\n    \"c:coin\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-coin/src/Cargo.toml\",\n    \"c:swarm\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-swarm/src/Cargo.toml\",\n    \"c:hydra\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-hydra/src/Cargo.toml\",\n    \"c:monkey-branch\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-monkey-branch/src/Cargo.toml\",\n    \"c:bridge\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-bridge/src/Cargo.toml\",\n    \"c:golden-gate\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-golden-gate/src/Cargo.toml\",\n    \"c:gold\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-gold/src/Cargo.toml\",\n    \"c:silver\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-silver/src/Cargo.toml\",\n    \"c:rhodium\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-rhodium/src/Cargo.toml\",\n    \"c:hive\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-hive/src/Cargo.toml\",\n    \"c:transaction\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-transaction/src/Cargo.toml\",\n    \"c:block\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-block/src/Cargo.toml\",\n    \"c:blockchain\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-blockchain/src/Cargo.toml\",\n    \"c:polkadot\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-polkadot/src/Cargo.toml\",\n    \"c:peer-review\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-peer-review/src/Cargo.toml\",\n    \"c:cardano\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-cardano/src/Cargo.toml\",\n    \"c:bear\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-bear/src/Cargo.toml\",\n    \"c:beer\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-beer/src/Cargo.toml\",\n    \"c:lock\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-lock/src/Cargo.toml\",\n    \"c:marmalade\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-marmalade/src/Cargo.toml\",\n    \"c:super-marmalade\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-super-marmalade/src/Cargo.toml\",\n    \"c:hyper-marmalade\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-hyper-marmalade/src/Cargo.toml\",\n    \"c:water\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-water/src/Cargo.toml\",\n    \"c:fire\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-fire/src/Cargo.toml\",\n    \"c:steam\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-steam/src/Cargo.toml\",\n    \"c:earth\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-earth/src/Cargo.toml\",\n    \"c:mud\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-mud/src/Cargo.toml\",\n    \"c:lava\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-lava/src/Cargo.toml\",\n    \"c:wind\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-wind/src/Cargo.toml\",\n    \"c:dust\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-dust/src/Cargo.toml\",\n    \"c:rain\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-rain/src/Cargo.toml\",\n    \"c:smoke\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-smoke/src/Cargo.toml\",\n    \"c:geyser\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-geyser/src/Cargo.toml\",\n    \"c:clay\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-clay/src/Cargo.toml\",\n    \"c:sand\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-sand/src/Cargo.toml\",\n    \"c:plant\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-plant/src/Cargo.toml\",\n    \"c:rainbow\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-rainbow/src/Cargo.toml\",\n    \"c:storm\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-storm/src/Cargo.toml\",\n    \"c:obsidian\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-obsidian/src/Cargo.toml\",\n    \"c:ash\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-ash/src/Cargo.toml\",\n    \"c:volcano\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-volcano/src/Cargo.toml\",\n    \"c:sandstorm\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-sandstorm/src/Cargo.toml\",\n    \"c:cloud\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-cloud/src/Cargo.toml\",\n    \"c:fog\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-fog/src/Cargo.toml\",\n    \"c:tree\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-tree/src/Cargo.toml\",\n    \"c:forest\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-forest/src/Cargo.toml\",\n    \"c:seeds\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-seeds/src/Cargo.toml\",\n    \"c:pottery\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-pottery/src/Cargo.toml\",\n    \"c:brick\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-brick/src/Cargo.toml\",\n    \"c:quicksand\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-quicksand/src/Cargo.toml\",\n    \"c:glass\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-glass/src/Cargo.toml\",\n    \"c:dune\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-dune/src/Cargo.toml\",\n    \"c:charcoal\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-charcoal/src/Cargo.toml\",\n    \"c:leaves\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-leaves/src/Cargo.toml\",\n    \"c:wildfire\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-wildfire/src/Cargo.toml\",\n    \"c:jungle\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-jungle/src/Cargo.toml\",\n    \"c:frosted-glass\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-frosted-glass/src/Cargo.toml\",\n    \"c:crystal\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-crystal/src/Cargo.toml\",\n    \"c:magma\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-magma/src/Cargo.toml\",\n    \"c:rock\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-rock/src/Cargo.toml\",\n    \"c:shard\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-shard/src/Cargo.toml\",\n    \"c:pebble\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-pebble/src/Cargo.toml\",\n    \"c:mountain\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-mountain/src/Cargo.toml\",\n    \"c:fertilizer\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-fertilizer/src/Cargo.toml\",\n    \"c:soot\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-soot/src/Cargo.toml\",\n    \"c:lightning\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-lightning/src/Cargo.toml\",\n    \"c:mist\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-mist/src/Cargo.toml\",\n    \"c:haze\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-haze/src/Cargo.toml\",\n    \"c:flood\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-flood/src/Cargo.toml\",\n    \"c:landslide\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-landslide/src/Cargo.toml\",\n    \"c:thunder\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-thunder/src/Cargo.toml\",\n    \"c:tornado\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-tornado/src/Cargo.toml\",\n    \"c:garden\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-garden/src/Cargo.toml\",\n    \"c:ember\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-ember/src/Cargo.toml\",\n    \"c:kiln\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-kiln/src/Cargo.toml\",\n    \"c:pollination\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-pollination/src/Cargo.toml\",\n    \"c:sinkhole\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-sinkhole/src/Cargo.toml\",\n    \"c:beach\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-beach/src/Cargo.toml\",\n    \"c:wetstone\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-wetstone/src/Cargo.toml\",\n    \"c:erosion\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-erosion/src/Cargo.toml\",\n    \"c:basalt\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-basalt/src/Cargo.toml\",\n    \"c:magma-chamber\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-magma-chamber/src/Cargo.toml\",\n    \"c:breeze\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-breeze/src/Cargo.toml\",\n    \"c:warm-breeze\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-warm-breeze/src/Cargo.toml\",\n    \"c:soil\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-soil/src/Cargo.toml\",\n    \"c:canyon\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-canyon/src/Cargo.toml\",\n    \"c:windmill\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-windmill/src/Cargo.toml\",\n    \"c:adobe\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-adobe/src/Cargo.toml\",\n    \"c:wall\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-wall/src/Cargo.toml\",\n    \"c:pumice\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-pumice/src/Cargo.toml\",\n    \"c:barbecue\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-barbecue/src/Cargo.toml\",\n    \"c:farm\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-farm/src/Cargo.toml\",\n    \"c:shards\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-shards/src/Cargo.toml\",\n    \"c:molten-glass\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-molten-glass/src/Cargo.toml\",\n    \"c:prism\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-prism/src/Cargo.toml\",\n    \"c:sparkle\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-sparkle/src/Cargo.toml\",\n    \"c:desert\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-desert/src/Cargo.toml\",\n    \"c:oasis\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-oasis/src/Cargo.toml\",\n    \"c:mirage\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-mirage/src/Cargo.toml\",\n    \"c:sand-dune\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-sand-dune/src/Cargo.toml\",\n    \"c:dam\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-dam/src/Cargo.toml\",\n    \"c:firewall\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-firewall/src/Cargo.toml\",\n    \"c:barricade\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-barricade/src/Cargo.toml\",\n    \"c:plateau\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-plateau/src/Cargo.toml\",\n    \"c:pond\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-pond/src/Cargo.toml\",\n    \"c:aromas\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-aromas/src/Cargo.toml\",\n    \"c:flower\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-flower/src/Cargo.toml\",\n    \"c:spore\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-spore/src/Cargo.toml\",\n    \"c:spread\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-spread/src/Cargo.toml\",\n    \"c:fertile-land\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-fertile-land/src/Cargo.toml\",\n    \"c:wetland\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-wetland/src/Cargo.toml\",\n    \"c:peat\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-peat/src/Cargo.toml\",\n    \"c:reeds\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-reeds/src/Cargo.toml\",\n    \"c:valley\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-valley/src/Cargo.toml\",\n    \"c:river\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-river/src/Cargo.toml\",\n    \"c:scorched-earth\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-scorched-earth/src/Cargo.toml\",\n    \"c:delta\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-delta/src/Cargo.toml\",\n    \"c:estuary\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-estuary/src/Cargo.toml\",\n    \"c:fire-swamp\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-fire-swamp/src/Cargo.toml\",\n    \"c:riverbank\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-riverbank/src/Cargo.toml\",\n    \"c:ravine\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-ravine/src/Cargo.toml\",\n    \"c:gorge\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-gorge/src/Cargo.toml\",\n    \"c:charred-ravine\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-charred-ravine/src/Cargo.toml\",\n    \"c:echo\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-echo/src/Cargo.toml\",\n    \"c:cave\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-cave/src/Cargo.toml\",\n    \"c:underground-lake\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-underground-lake/src/Cargo.toml\",\n    \"c:lava-cave\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-lava-cave/src/Cargo.toml\",\n    \"c:whispering-cave\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-whispering-cave/src/Cargo.toml\",\n    \"c:subterranean-pool\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-subterranean-pool/src/Cargo.toml\",\n    \"c:spring\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-spring/src/Cargo.toml\",\n    \"c:hot-spring\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-hot-spring/src/Cargo.toml\",\n    \"c:grotto\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-grotto/src/Cargo.toml\",\n    \"c:fountain\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-fountain/src/Cargo.toml\",\n    \"c:steam-vent\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-steam-vent/src/Cargo.toml\",\n    \"c:cool-breeze\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-cool-breeze/src/Cargo.toml\",\n    \"c:monument\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-monument/src/Cargo.toml\",\n    \"c:waterfall\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-waterfall/src/Cargo.toml\",\n    \"c:eternal-flame\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-eternal-flame/src/Cargo.toml\",\n    \"c:pillar-of-wind\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-pillar-of-wind/src/Cargo.toml\",\n    \"c:stream\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-stream/src/Cargo.toml\",\n    \"c:zephyr\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-zephyr/src/Cargo.toml\",\n    \"c:creek\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-creek/src/Cargo.toml\",\n    \"c:brook\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-brook/src/Cargo.toml\",\n    \"c:whisper\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-whisper/src/Cargo.toml\",\n    \"c:rivulet\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-rivulet/src/Cargo.toml\",\n    \"c:tributary\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-tributary/src/Cargo.toml\",\n    \"c:murmur\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-murmur/src/Cargo.toml\",\n    \"c:watershed\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-watershed/src/Cargo.toml\",\n    \"c:aquifer\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-aquifer/src/Cargo.toml\",\n    \"c:parched-earth\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-parched-earth/src/Cargo.toml\",\n    \"c:fresh-breeze\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-fresh-breeze/src/Cargo.toml\",\n    \"c:groundwater\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-groundwater/src/Cargo.toml\",\n    \"c:reservoir\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-reservoir/src/Cargo.toml\",\n    \"c:geothermal-spring\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-geothermal-spring/src/Cargo.toml\",\n    \"c:artesian-well\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-artesian-well/src/Cargo.toml\",\n    \"c:basin\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-basin/src/Cargo.toml\",\n    \"c:lake\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-lake/src/Cargo.toml\",\n    \"c:dry-basin\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-dry-basin/src/Cargo.toml\",\n    \"c:depression\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-depression/src/Cargo.toml\",\n    \"c:island\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-island/src/Cargo.toml\",\n    \"c:lagoon\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-lagoon/src/Cargo.toml\",\n    \"c:wave\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-wave/src/Cargo.toml\",\n    \"c:reef\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-reef/src/Cargo.toml\",\n    \"c:coral\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-coral/src/Cargo.toml\",\n    \"c:whirl\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-whirl/src/Cargo.toml\",\n    \"c:limestone\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-limestone/src/Cargo.toml\",\n    \"c:karst\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-karst/src/Cargo.toml\",\n    \"c:quicklime\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-quicklime/src/Cargo.toml\",\n    \"c:blowhole\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-blowhole/src/Cargo.toml\",\n    \"c:unifiers\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-unifiers/src/Cargo.toml\",\n    \"c:elementy\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-elementy/src/Cargo.toml\",\n    \"c:game\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-game/src/Cargo.toml\",\n    \"build:contracts\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-game/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-monkey/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-giraffe/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-bee/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-coin/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-swarm/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-hydra/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-monkey-branch/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-bridge/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-golden-gate/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-gold/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-silver/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-rhodium/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-hive/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-transaction/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-block/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-blockchain/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-polkadot/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-peer-review/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-cardano/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-bear/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-beer/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-lock/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-marmalade/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-super-marmalade/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-hyper-marmalade/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-water/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-fire/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-steam/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-earth/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-mud/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-lava/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-wind/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-dust/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-rain/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-smoke/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-geyser/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-clay/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-sand/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-plant/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-rainbow/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-storm/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-obsidian/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-ash/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-volcano/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-sandstorm/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-cloud/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-fog/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-tree/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-forest/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-seeds/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-pottery/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-brick/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-quicksand/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-glass/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-dune/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-charcoal/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-leaves/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-wildfire/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-jungle/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-frosted-glass/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-crystal/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-magma/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-rock/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-shard/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-pebble/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-mountain/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-fertilizer/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-soot/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-lightning/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-mist/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-haze/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-flood/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-landslide/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-thunder/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-tornado/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-garden/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-ember/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-kiln/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-pollination/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-sinkhole/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-beach/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-wetstone/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-erosion/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-basalt/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-magma-chamber/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-breeze/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-warm-breeze/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-soil/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-canyon/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-windmill/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-adobe/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-wall/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-pumice/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-barbecue/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-farm/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-shards/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-molten-glass/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-prism/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-sparkle/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-desert/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-oasis/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-mirage/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-sand-dune/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-dam/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-firewall/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-barricade/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-plateau/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-pond/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-aromas/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-flower/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-spore/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-spread/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-fertile-land/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-wetland/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-peat/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-reeds/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-valley/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-river/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-scorched-earth/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-delta/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-estuary/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-fire-swamp/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-riverbank/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-ravine/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-gorge/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-charred-ravine/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-echo/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-cave/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-underground-lake/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-lava-cave/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-whispering-cave/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-subterranean-pool/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-spring/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-hot-spring/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-grotto/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-fountain/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-steam-vent/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-cool-breeze/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-monument/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-waterfall/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-eternal-flame/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-pillar-of-wind/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-stream/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-zephyr/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-creek/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-brook/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-whisper/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-rivulet/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-tributary/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-murmur/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-watershed/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-aquifer/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-parched-earth/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-fresh-breeze/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-groundwater/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-reservoir/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-geothermal-spring/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-artesian-well/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-basin/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-lake/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-dry-basin/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-depression/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-island/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-lagoon/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-wave/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-reef/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-coral/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-whirl/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-limestone/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-karst/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-quicklime/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-blowhole/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-unifiers/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-elementy/src/Cargo.toml\",\n    \"build\": \"npm run -w @not-a-bird/app-game build\",\n    \"serve:game\": \"npm run -w @not-a-bird/app-game serve\",\n    \"serve:faucet\": \"npm run -w @not-a-bird/dev-faucet start\",\n    \"serve\": \"concurrently \\\"npm run serve:game\\\" \\\"npm run serve:faucet\\\" -n \\\"GAME,FAUCET\\\"\",\n    \"docs:build\": \"npm run -w @not-a-bird/docs build\",\n    \"docs:preview\": \"npm run -w @not-a-bird/docs preview\",\n    \"docs:dev\": \"npm run -w @not-a-bird/docs dev\",\n    \"deploy:contracts\": \"npm run -w @not-a-bird/deployer start\",\n    \"deploy:copy\": \"npm run -w @not-a-bird/deployer copy\",\n    \"deploy:extract\": \"npm run -w @not-a-bird/deployer extract\",\n    \"deploy:build\": \"npm run -w @not-a-bird/deployer build\",\n    \"deploy:start\": \"npm run -w @not-a-bird/deployer start\",\n    \"deploy:dev\": \"npm run -w @not-a-bird/deployer start -- --dev\",\n    \"deploy:sionet\": \"npm run -w @not-a-bird/deployer start -- --sionet\",\n    \"faucet:build\": \"npm run -w @not-a-bird/dev-faucet build\",\n    \"faucet:start\": \"npm run -w @not-a-bird/dev-faucet start\"\n  }\n}",
      "contentHash": "f587507b90f5085689130981f9182f61c1c6c4a78c7e14f1676d9678c9311737",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-adobe/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-adobe/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-adobe\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Adobe'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "30725befc3e678beea4edac7150b20f983c39ad8b3399cd201d7d66b6c316851",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-adobe/README.md",
      "content": "# Adobe - Contract\n\nThis is a Adobe contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "c190047757461967dc6b3c28a92600342af7ff728a84df7a91902d9fa68db8d2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-adobe/src/Cargo.toml",
      "content": "[package]\nname = \"adobe\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "25fe74e8d5332dd6fd24933586e26e4b72ee3f9802443f6ad57fcc7e0fe5944d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-adobe/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod adobe {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Adobe' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct AdobeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for AdobeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl AdobeContract {\n        /// Creates a new PSP-22 compatible Adobe Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Adobe\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MADOBE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "96a8eb76fe9966f831f1fc738be9c46afa537412a4bb31f4a300eeaa2f8a3eaf",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-aquifer/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-aquifer/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-aquifer\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Aquifer'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "bc3f65e3d273b6425ddf82da1de4946757390df430c27dec54d76a39bd5345b5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-aquifer/README.md",
      "content": "# Aquifer - Contract\n\nThis is a Aquifer contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "9af3b5d28ef4db993d957021060edc544b554ad5fc87f25a4f457fa42f39ac6a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-aquifer/src/Cargo.toml",
      "content": "[package]\nname = \"aquifer\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "a03566ad1baa152d003596a8ffa746fe289cf7adbb89e8db4c734d0fa16e7abf",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-aquifer/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod aquifer {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Aquifer' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct AquiferContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for AquiferContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl AquiferContract {\n        /// Creates a new PSP-22 compatible Aquifer Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Aquifer\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MAQUIFER\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "e35870e2e6c80526c8bc9362b2895fd5cefe26783c4369e9e5d5dbf67709d1d8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-aromas/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-aromas/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-aromas\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Aromas'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "1020e7f22addf056cc969e23666278ea5d70754c12857868df06ed1951fd99e9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-aromas/README.md",
      "content": "# Aromas - Contract\n\nThis is a Aromas contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "210110bc18e2293c706362035d221e8bea05c02292bade6e895b12b9f62aea12",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-aromas/src/Cargo.toml",
      "content": "[package]\nname = \"aromas\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "5e080a40189a377b51b848c6f1e163e5d03ea95086586a23c639f68ba44ee626",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-aromas/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod aromas {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Aromas' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct AromasContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for AromasContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl AromasContract {\n        /// Creates a new PSP-22 compatible Aromas Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Aromas\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MAROMAS\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "8b6d21de39c425370c3d8667681936958704172f4b87e1716de7097612a7fe2b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-artesian-well/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-artesian-well/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-artesian-well\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'ArtesianWell'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "5e13e22bbcf013eb29b2dedd10602094f98d50a1ef0dbd5bb737e21147fd318b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-artesian-well/README.md",
      "content": "# Artesian Well - Contract\n\nThis is a Artesian Well contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "2e5f43d945db8130f75eb486539e6016913d145d325f00cde9338a2380572680",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-artesian-well/src/Cargo.toml",
      "content": "[package]\nname = \"artesian_well\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "3ae0f8015d09ad52e8ad43616af178aeea0873540e7abbc87c4667bed9ff8e5b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-artesian-well/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod artesian_well {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Artesian Well' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct ArtesianWellContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for ArtesianWellContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl ArtesianWellContract {\n        /// Creates a new PSP-22 compatible Artesian Well Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Artesian Well\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MARTESIAN_WELL\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "6310b0bb6888b298bae391b5f220e0ec0746219afcfc894e02d0fae6b0580f62",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-ash/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-ash/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-ash\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Ash'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "5051ee28933d5a46bc3817ab0c5c49df67e3ee73c027c034f5834c685bc7bd50",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-ash/README.md",
      "content": "# Ash - Contract\n\nThis is a Ash contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "33383cdd07e0e9b2bf237d4c3ec26c42af494f044804b44c059ba95594a62d47",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-ash/src/Cargo.toml",
      "content": "[package]\nname = \"ash\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "45f0412ba935f72ffee67aa5b8b7af7b1b34169aa86939ae02e3a7da6b5e3f0b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-ash/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod ash {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Ash' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct AshContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for AshContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl AshContract {\n        /// Creates a new PSP-22 compatible Ash Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Ash\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MASH\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "de73cf3a398ce1fdc1e595ff07601706498e4786ab24aeaa42717bae3acef4e7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-barbecue/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-barbecue/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-barbecue\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Barbecue'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "881b78add288a78b22e7426a17f88ea86954470e1ccbf4f5a6150e3d6afb140a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-barbecue/README.md",
      "content": "# Barbecue - Contract\n\nThis is a Barbecue contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "216e372615ce4cebeba1b3a3a1424a5b1af3a666ed1ec8f65cfc784ee1a0f4bf",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-barbecue/src/Cargo.toml",
      "content": "[package]\nname = \"barbecue\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "d2c65fa9d94ab2ffe255cffb7a68f3e54264596ad3f35fe8b57d1730d345f649",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-barbecue/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod barbecue {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Barbecue' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BarbecueContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BarbecueContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BarbecueContract {\n        /// Creates a new PSP-22 compatible Barbecue Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Barbecue\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBARBECUE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "f29a1a69285685da42bc2abf973d87c6970663f478223c9cc8cc48f3a9739121",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-barricade/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-barricade/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-barricade\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Barricade'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "e062f2156f067c4257158c48729a305bad5aae8a5febc9af08bef73a97c4f3c9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-barricade/README.md",
      "content": "# Barricade - Contract\n\nThis is a Barricade contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "c43affd85dea314387bc6e24d8091328ed417a35595ef87db03d9f2ce071f386",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-barricade/src/Cargo.toml",
      "content": "[package]\nname = \"barricade\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "d2dc7d6a96ceb162888598283e0a595059e47b2245f4f006ad395a1e0494e883",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-barricade/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod barricade {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Barricade' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BarricadeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BarricadeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BarricadeContract {\n        /// Creates a new PSP-22 compatible Barricade Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Barricade\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBARRICADE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "748ad3f1272e52edb00d0f42aee9a2265d347282ca7b6b7bccdcd955cca582e9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-basalt/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-basalt/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-basalt\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Basalt'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "8140dad69803b6a219571ab23fcab2ff480e914d39c84a372f620f5a5dd9a2f0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-basalt/README.md",
      "content": "# Basalt - Contract\n\nThis is a Basalt contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "380583d29e8ed70c25d02168ffeeb0c6744f8676fc652d81d306e0c38a25ae19",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-basalt/src/Cargo.toml",
      "content": "[package]\nname = \"basalt\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "95d13370e7f3f930fbf86eca23c5eb31a2add60f425ebaeca59c8dda12eadaa1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-basalt/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod basalt {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Basalt' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BasaltContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BasaltContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BasaltContract {\n        /// Creates a new PSP-22 compatible Basalt Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Basalt\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBASALT\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "015b3768404dff4f336e161dddbd46651d18eb0ecec385de72db0da36c625b0f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-basin/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-basin/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-basin\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Basin'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "bbf75fc44e10751361f8832fe59c20738fd415f3b30404a9be30c486e9c44b4a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-basin/README.md",
      "content": "# Basin - Contract\n\nThis is a Basin contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "478efccafe4a20a9d7f602b73f8dfe9155752d87ef6f1e30e937fe9e045c5eeb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-basin/src/Cargo.toml",
      "content": "[package]\nname = \"basin\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "62fb640f117854073858a21ff0fc8b9128c3107b7352c9894906feffd59abe96",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-basin/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod basin {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Basin' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BasinContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BasinContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BasinContract {\n        /// Creates a new PSP-22 compatible Basin Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Basin\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBASIN\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "07e40b886f85f798a25d00987316d5a48d2ccd58db6b18ce006a08e5bebd5654",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-beach/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-beach/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-beach\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Beach'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "307f7d384bcac46ccf560c6d7f145dc12973da17d068c77fabfc5a7521540f17",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-beach/README.md",
      "content": "# Beach - Contract\n\nThis is a Beach contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "42eaa54fa2cac18b0399dd276e9db23b1cb6898038a7112ce9c45cf2df5a5e37",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-beach/src/Cargo.toml",
      "content": "[package]\nname = \"beach\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "8cdaa7afcf20fdd6520758d21c1575e84ad38600be3af115be0628331404b5f4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-beach/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod beach {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Beach' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BeachContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BeachContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BeachContract {\n        /// Creates a new PSP-22 compatible Beach Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Beach\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBEACH\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "b079202e986c7311df81bf4d437d2f2db5c478abfb793cdebc53f4e8721aee74",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bear/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bear/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-bear\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Bear'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "c5e820e944f8315655113d3a7309f6e7465579ed7c6357322e52050973c595aa",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bear/README.md",
      "content": "# Bear - Contract\n\nThis is a Bear contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "2e39386436559c232cef064aa2d58095f11999f380fd440efa3b2d39d87cf757",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bear/src/Cargo.toml",
      "content": "[package]\nname = \"bear\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "60704033e05fab4c47ecb60980d99ac3d6e1c490d027c3edccb837a47a885d8e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bear/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod bear {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Bear' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BearContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BearContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BearContract {\n        /// Creates a new PSP-22 compatible Bear Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Bear\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBEAR\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "ba8baed7d9751f9e5b4991eed8f7eab8a28db0a9e8b92213b9e2b4d694fa80c4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bee/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bee/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-bee\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Bee'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "df64f208eb3b5902955f976d625a85877511581920afa69e625468e37ae766f7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bee/README.md",
      "content": "# Bee - Contract\n\nThis is a Bee contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "42ba68de5e5347dd40443ff01fbc82bff826ab61e61a2d8b482bfb9fcbd772cd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bee/src/Cargo.toml",
      "content": "[package]\nname = \"bee\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "0e85afa1508d8f9529c480efd872ee6597794bf4bf28e4ec631ee91e5e2b8b4f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bee/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod bee {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Bee' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BeeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BeeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BeeContract {\n        /// Creates a new PSP-22 compatible Bee Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Bee\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBEE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "e6b381ec395d4a73d7050366847ebafbdba846a0e928311c565777102fb9a63d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-beer/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-beer/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-beer\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Beer'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "005d88ee68ee7a19518883da7c4b28740ed8cc718f5b528a8d7d4ecc38e555b3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-beer/README.md",
      "content": "# Beer - Contract\n\nThis is a Beer contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "6556596f4bcae348b32f702943fa832f42ecd2004c10804c33cde99e376c20bf",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-beer/src/Cargo.toml",
      "content": "[package]\nname = \"beer\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "4a35c94ae27cf7cc8f4d0f876e2d61353fe0b6b9493a06041c0a725fdce40be5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-beer/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod beer {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Beer' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BeerContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BeerContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BeerContract {\n        /// Creates a new PSP-22 compatible Beer Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Beer\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBEER\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "03ed0a6783e40fddd1cfc547f4feff517236da1093a0937861f1a1ddf2219ce7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-block/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-block/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-block\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Block'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "334d2d40813210cc72b266c9c2ad222b3e1ad182859785be9182f074baca289c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-block/README.md",
      "content": "# Block - Contract\n\nThis is a Block contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "13895fe29965cbd074b5c51b99dd9cf6b75a3cc4525ed46d83d51d37069f596e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-block/src/Cargo.toml",
      "content": "[package]\nname = \"block\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "f0e3a9150f2b7779226738fbaa6c128b225e9d1328025468eb34c029a8bb6c5f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-block/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod block {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Block' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BlockContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BlockContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BlockContract {\n        /// Creates a new PSP-22 compatible Block Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Block\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBLOCK\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "ee63644084ebc5d51b9b7a588f6911248a9186ed5634c784c1ec04c58779505b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-blockchain/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-blockchain/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-blockchain\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Blockchain'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "16670b267ea062759434a9ab7b70ad03b8a6b2d4a50d6ff9820a9c73aec6c2fd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-blockchain/README.md",
      "content": "# Blockchain - Contract\n\nThis is a Blockchain contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "89fd1eb1fc51bb576e9928b8589b28db9f874a64ba7ea17c7110262b532e8d29",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-blockchain/src/Cargo.toml",
      "content": "[package]\nname = \"blockchain\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "069aabba9bacef8822abdac9bf53a26022ceafdf37f3c8e153a8e155917112c7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-blockchain/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod blockchain {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Blockchain' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BlockchainContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BlockchainContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BlockchainContract {\n        /// Creates a new PSP-22 compatible Blockchain Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Blockchain\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBLOCKCHAIN\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "e10b499f0e6887309e713178a1d92558b718bcc9c298f4b1d7a0a32af1b14695",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-blowhole/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-blowhole/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-blowhole\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Blowhole'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "1060fa7195192853e38e4afe838e9eb4d947ae11dca75ce944a8f558a70e13b2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-blowhole/README.md",
      "content": "# Blowhole - Contract\n\nThis is a Blowhole contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "108de3c75e15ec39f80fa44210c1077ed91ced2d83956006a8d177130b8f3876",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-blowhole/src/Cargo.toml",
      "content": "[package]\nname = \"blowhole\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "27b0d5f122a9bcfd57c3316dbb6db6407e9da99db42b61e03f4b8f78563c69ea",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-blowhole/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod blowhole {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Blowhole' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BlowholeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BlowholeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BlowholeContract {\n        /// Creates a new PSP-22 compatible Blowhole Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Blowhole\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBLOWHOLE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "aaacf20891b54662a3261c54f7d682df64f33711ab3ebcdfaaa7783f8058474f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-breeze/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-breeze/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-breeze\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Breeze'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "87b928b1f1227e963386b1e5c9a2606f2bf113277aa579de6e271271da7d9205",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-breeze/README.md",
      "content": "# Breeze - Contract\n\nThis is a Breeze contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "9abf76ccff0c519deaa4b1d3bc41df273a89e040e99e123f10ef6265a7975cc4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-breeze/src/Cargo.toml",
      "content": "[package]\nname = \"breeze\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "e62a08ba6fe1c7428631bd31d2ee133aaee5221b235734750d0b8a6511b21ae5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-breeze/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod breeze {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Breeze' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BreezeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BreezeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BreezeContract {\n        /// Creates a new PSP-22 compatible Breeze Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Breeze\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBREEZE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "877da887a57694e6b91a405029bda6f99bd07a6715be5d3df31d57eb8c0fa55a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-brick/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-brick/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-brick\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Brick'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "76319fe8bf559ba2e9f0f949fb84589e025cf510a9bc5b1dd62575b508721481",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-brick/README.md",
      "content": "# Brick - Contract\n\nThis is a Brick contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "2a36a621d299616d964ab0646b326120f80a02af8d508117999b83f4c5bd4a30",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-brick/src/Cargo.toml",
      "content": "[package]\nname = \"brick\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "d0819371ccca2e44998df8c9c9fb1ff5c1f4d4825489333f6afde9db88363dee",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-brick/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod brick {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Brick' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BrickContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BrickContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BrickContract {\n        /// Creates a new PSP-22 compatible Brick Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Brick\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBRICK\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "cf96a14f365f1d457066b236f5efa0286b8186735c68f7e36e61c93526c7f0fb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bridge/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bridge/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-bridge\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Bridge'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "71e57b82fb51c0038e7815d651f794f959d29392f62e22fe9bd87602c88fbcc6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bridge/README.md",
      "content": "# Bridge - Contract\n\nThis is a Bridge contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "48c4e7c5c8fc03815d109d8ac28bfffb8c64584ab278c92c7038d07d8208d2f2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bridge/src/Cargo.toml",
      "content": "[package]\nname = \"bridge\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "822034f54388ed73573ab7cb52ac11802c17abc0060991b0055a86da5f10fcc7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bridge/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod bridge {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Bridge' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BridgeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BridgeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BridgeContract {\n        /// Creates a new PSP-22 compatible Bridge Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Bridge\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBRIDGE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "a6216ae4fa6ca4dbfab290d7f1d6580fe363373f9c626b2efdfc28713394c49f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-brook/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-brook/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-brook\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Brook'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "cbae85d4824d8f9108e29c9950686fd6049798e24b19499557430559b91b8686",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-brook/README.md",
      "content": "# Brook - Contract\n\nThis is a Brook contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "df4f24e3cca3e088c2efef6a64d91779dcd1c62949a08e3208308cb5150b2acd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-brook/src/Cargo.toml",
      "content": "[package]\nname = \"brook\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "e8ae3ed1f08458f8b7a90bac7612ded7e87ad50143d4958b002729bdbc96b141",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-brook/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod brook {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Brook' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BrookContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BrookContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BrookContract {\n        /// Creates a new PSP-22 compatible Brook Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Brook\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBROOK\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "8309a49ee0a1f8969df238a6f1a4cb722afa5b28d1d99d584f4dd1d54f42e1f0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-canyon/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-canyon/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-canyon\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Canyon'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "419d058ae4998771e6f01b8b00d46142c240f012c16a5823b92802a1d2581eb5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-canyon/README.md",
      "content": "# Canyon - Contract\n\nThis is a Canyon contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "c3dbac9abbc4f404abbc2763a6ad4a715e5acbce2e92e2aba8f066ee2f949620",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-canyon/src/Cargo.toml",
      "content": "[package]\nname = \"canyon\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "cefab5afdcdfe39aa89735fa1a22744393829f1fb5bb067ae9cb0279e8c86126",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-canyon/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod canyon {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Canyon' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct CanyonContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for CanyonContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl CanyonContract {\n        /// Creates a new PSP-22 compatible Canyon Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Canyon\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MCANYON\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "25b502083a11fdc23e0a9457801e3018f7d79fc3558abcffb32ac58b5c7613ec",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cardano/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cardano/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-cardano\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Cardano'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "6cd90711295a05aba86bdc6cbd519d49351c793cfc191565d6b7623dd622c51d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cardano/README.md",
      "content": "# Cardano - Contract\n\nThis is a Cardano contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "e50327f0e5f343e9bad8e9c4531ef3b6173917ffc7473062bc1d24260f1cfcb9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cardano/src/Cargo.toml",
      "content": "[package]\nname = \"cardano\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "a70bc88fa4d69eec39df5bca97c6e17c7f332659e98bdb548c8336c9901027c0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cardano/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod cardano {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Cardano' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct CardanoContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for CardanoContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl CardanoContract {\n        /// Creates a new PSP-22 compatible Cardano Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Cardano\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MCARDANO\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "6289ff33bfd827f122a875fa42a3ac292a47726f123ab7a1503faf188945e79c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cave/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cave/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-cave\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Cave'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "dbe227fa226fe1abd40cb3b98f12d5101da4de26113c1866145853b472dc227e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cave/README.md",
      "content": "# Cave - Contract\n\nThis is a Cave contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "854d106e72f0107b9e5e44a3febc27a22e86c5ee8bf021f414134aa9e1a215fc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cave/src/Cargo.toml",
      "content": "[package]\nname = \"cave\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "1e0fb6293cb182abcb04ffe60695d2b111fc34a54f1d93d16915e59c092bc372",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cave/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod cave {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Cave' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct CaveContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for CaveContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl CaveContract {\n        /// Creates a new PSP-22 compatible Cave Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Cave\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MCAVE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "b45eb325e684547f5244db3752b4039a25418d070111a2ee52df799dec4b4b5f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-charcoal/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-charcoal/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-charcoal\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Charcoal'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "d54e101f28752311df6bd790533bc7dacb92c02cbdee18d47801d65847ff5184",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-charcoal/README.md",
      "content": "# Charcoal - Contract\n\nThis is a Charcoal contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "e29b5211e62d68326c7d5d0d19220566717fca26c51c321c398db629ff7eb7ec",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-charcoal/src/Cargo.toml",
      "content": "[package]\nname = \"charcoal\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "7fa36eb89d0c0ac64cd9dac32ebad4fca7e4a974c46d15b995b4de723d5f11f1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-charcoal/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod charcoal {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Charcoal' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct CharcoalContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for CharcoalContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl CharcoalContract {\n        /// Creates a new PSP-22 compatible Charcoal Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Charcoal\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MCHARCOAL\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "50843ebbd796ee2b769dddb8211c1566ec70e0162d350a9af80f18e266e81ceb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-charred-ravine/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-charred-ravine/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-charred-ravine\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'CharredRavine'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "496dce7df5108f86c2ecf3f5fb4bbc16f381c84d4c4caa8228bb616364741c4f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-charred-ravine/README.md",
      "content": "# Charred Ravine - Contract\n\nThis is a Charred Ravine contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "499159656f852cb368e354672062aa51914b4493b1e7a0ae7887240a543cb253",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-charred-ravine/src/Cargo.toml",
      "content": "[package]\nname = \"charred_ravine\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "4d3304754934c4ef82232dc169daea6c7b121677203060ce840b46fbd44dec4b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-charred-ravine/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod charred_ravine {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Charred Ravine' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct CharredRavineContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for CharredRavineContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl CharredRavineContract {\n        /// Creates a new PSP-22 compatible Charred Ravine Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Charred Ravine\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MCHARRED_RAVINE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "c63113d34f5839092a0dd05fd4c653cdad91fbd91c5a51b27db43c671e58967d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-clay/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-clay/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-clay\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Clay'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "fbc044fe7075ac07fb833e80c2835deecce2f9be43b5d9222b8781a3c29e36b4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-clay/README.md",
      "content": "# Clay - Contract\n\nThis is a Clay contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "d60cb85c8d427888ebcbcb124afbb080aeaafb7a970fa113f69b147e8c1be82e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-clay/src/Cargo.toml",
      "content": "[package]\nname = \"clay\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "8749bd6167dd651e91edd1accc6a937f88c34e8da860e2b3e003a2884355360d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-clay/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod clay {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Clay' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct ClayContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for ClayContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl ClayContract {\n        /// Creates a new PSP-22 compatible Clay Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Clay\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MCLAY\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "0072873937185d00e3c5fd787341113929eaf6e4e5c1eac4dc99f6acbe3398d3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cloud/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cloud/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-cloud\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Cloud'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "05500dcfe1e77420b2b3d09b08d3ebe0c2dd5b6d1774931d6c09b157f3398670",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cloud/README.md",
      "content": "# Cloud - Contract\n\nThis is a Cloud contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "89791c84bdfd2215c32cf80bd90c1db9b5ef44c2f30c1996955adcf070987fbd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cloud/src/Cargo.toml",
      "content": "[package]\nname = \"cloud\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "65e3093c1e1ea7fea926b876645ad3815434758afe07161de13037ef86e0ecbf",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cloud/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod cloud {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Cloud' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct CloudContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for CloudContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl CloudContract {\n        /// Creates a new PSP-22 compatible Cloud Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Cloud\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MCLOUD\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "810505610bb154a349224225d764f642019654ff2b0ae01fd536b3c88893ad84",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-coin/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-coin/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-coin\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Coin'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "c01f7f0195c293e8b2637c9ddfa32450c159c21145e74c16d991e6dd3d9d54aa",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-coin/README.md",
      "content": "# Coin - Contract\n\nThis is a Coin contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "bf8289471baa5931743abce48670040b5cdc475561d9e9fe8c51e3ee88953a6d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-coin/src/Cargo.toml",
      "content": "[package]\nname = \"coin\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "8f30cc841cfd8df72c67fc0ab25254dfc3ff5936b80bd983bb7cf83699e52cc6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-coin/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod coin {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Coin' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct CoinContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for CoinContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl CoinContract {\n        /// Creates a new PSP-22 compatible Coin Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Coin\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MCOIN\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "f9ae3f6a1e24162d0676552b60bcee822aea852b2ff6a213a23c27e8a68e2a37",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cool-breeze/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cool-breeze/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-cool-breeze\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'CoolBreeze'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "b0fe83b7f48f4b020c24f50e31be14be20c93fc961efa78793e61b07028b33a2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cool-breeze/README.md",
      "content": "# Cool Breeze - Contract\n\nThis is a Cool Breeze contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "a0a44adb2e900455b6513b810b2a836ddc175d187693835d3aaa87afb3db90d3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cool-breeze/src/Cargo.toml",
      "content": "[package]\nname = \"cool_breeze\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "5eb02545e9dd7eade669bda6a750fa649b2baed0456dbde14825d3a359d38718",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cool-breeze/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod cool_breeze {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Cool Breeze' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct CoolBreezeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for CoolBreezeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl CoolBreezeContract {\n        /// Creates a new PSP-22 compatible Cool Breeze Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Cool Breeze\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MCOOL_BREEZE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "55182b1ebf0da27333709ae53ed44208aa4f7cb1704bbee09fcfd6faec94708e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-coral/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-coral/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-coral\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Coral'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "c7333b90a96ff9bdbe5dd67ad5d731e6138fdfadc3f4199f1fe31a9ffb4310fb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-coral/README.md",
      "content": "# Coral - Contract\n\nThis is a Coral contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "7fdbe83aaeececc4dbf57b2452dca99c0bcac8d0717966d2e231acac07d00300",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-coral/src/Cargo.toml",
      "content": "[package]\nname = \"coral\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "676bc33b5a3bae91acf7eb478c5d0db2c572b886a6a14577b3bcee8d1d42ad31",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-coral/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod coral {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Coral' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct CoralContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for CoralContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl CoralContract {\n        /// Creates a new PSP-22 compatible Coral Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Coral\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MCORAL\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "813d91e7140b870d28df2585c6fb90ca63405841c89106c3c88f6215394f31f0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-creek/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-creek/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-creek\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Creek'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "b255befcaec9b1b4e472e40e44a2ad56ad1f499d788c24691ceba6ce6b8b357d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-creek/README.md",
      "content": "# Creek - Contract\n\nThis is a Creek contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "27062c9288920642e118663f56931731101ac59e149659d47d2772e1db9db6d0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-creek/src/Cargo.toml",
      "content": "[package]\nname = \"creek\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "ca212f716a59412313ede300a75081485428c1bca5fbd62952db02f0b16de6b7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-creek/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod creek {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Creek' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct CreekContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for CreekContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl CreekContract {\n        /// Creates a new PSP-22 compatible Creek Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Creek\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MCREEK\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "6ca94f51a5be6f8a574f14b2eea74715085e7801c6a577e99090b89d585ca0a3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-crystal/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-crystal/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-crystal\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Crystal'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "8c74d24c31a6bb43e621f235ad1d310bff560747a49448e9d9017d61259429d7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-crystal/README.md",
      "content": "# Crystal - Contract\n\nThis is a Crystal contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "578c72210e2c636083a38e22c927ae21baab1794767b9d3d0755f8fcebf5e66d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-crystal/src/Cargo.toml",
      "content": "[package]\nname = \"crystal\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "fa89ccd9ff70d4caf805e4a790f438028deac989e1992807ab75593e65e5329e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-crystal/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod crystal {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Crystal' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct CrystalContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for CrystalContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl CrystalContract {\n        /// Creates a new PSP-22 compatible Crystal Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Crystal\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MCRYSTAL\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "fb3b7550c1249cc416df5630a4ecebcfef2e2830bc3fd133eafa5572c7491b47",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dam/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dam/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-dam\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Dam'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "7bbf643586e2d342ad1f7be537e79259825882b3dc6239e626957bf64fafacd3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dam/README.md",
      "content": "# Dam - Contract\n\nThis is a Dam contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "e3ceedabff0046fcb27485676aefd077200e89983cadb08e74b4c127fa2684db",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dam/src/Cargo.toml",
      "content": "[package]\nname = \"dam\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "76f225dc4c254e64e0ffbfae5d34b84a90d6076700f9100d9b2a9b0967491730",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dam/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod dam {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Dam' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct DamContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for DamContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl DamContract {\n        /// Creates a new PSP-22 compatible Dam Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Dam\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MDAM\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "27630fe1958306cccf5d1ad5ca6daca80d7d67c774e4a2fcc831638300e791a7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-delta/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-delta/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-delta\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Delta'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "7782b85f0cdb4b15d4df8944b5db7523cd20e434b40ac1771812b8a6b2e7c17f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-delta/README.md",
      "content": "# Delta - Contract\n\nThis is a Delta contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "3ddadb4ff604910336b0a96a291cd26d4ee6c5ed53df7acac25f18f8b6cbd089",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-delta/src/Cargo.toml",
      "content": "[package]\nname = \"delta\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "a510890e93d6b16cceaa2764b5d2325c06cc8341578613ce1a4c8e6cf1210a52",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-delta/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod delta {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Delta' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct DeltaContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for DeltaContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl DeltaContract {\n        /// Creates a new PSP-22 compatible Delta Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Delta\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MDELTA\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "bfba24874e374fafb188a53ea3cb4e930ca11e2ec2863d15666c214e88fe8655",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-depression/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-depression/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-depression\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Depression'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "90db89dbf043856be8adf1a83d093706dfea2248e1297a4d3f45719d8d900841",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-depression/README.md",
      "content": "# Depression - Contract\n\nThis is a Depression contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "ee8b1971b5ce9cd1680cc3c431db62686030ce214c2d055a00f7b8234c04aa62",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-depression/src/Cargo.toml",
      "content": "[package]\nname = \"depression\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "08f4f0e19ceb81405b3c8a04294a4464697ddae778e2ef6a8ceb45467f264396",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-depression/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod depression {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Depression' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct DepressionContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for DepressionContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl DepressionContract {\n        /// Creates a new PSP-22 compatible Depression Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Depression\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MDEPRESSION\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "1e392b327d1ee7db65aca32de1ab13f3288b8da7ce6a3cb8d8899d11d043f9fe",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-desert/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-desert/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-desert\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Desert'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "e316ebaa37a732ce839a0ac730f97d54c583c1e847807f0dc30aaa6d6e9272ba",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-desert/README.md",
      "content": "# Desert - Contract\n\nThis is a Desert contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "5cb4f927542bfa20438173f2ac43fdebe8cc8a23777b9e01e565c59e09ecf9bd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-desert/src/Cargo.toml",
      "content": "[package]\nname = \"desert\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "30962f9d16752c7a20d6126fedc62d4624987ff74fce54f1053dfd98d4f18d7c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-desert/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod desert {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Desert' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct DesertContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for DesertContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl DesertContract {\n        /// Creates a new PSP-22 compatible Desert Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Desert\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MDESERT\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "d2019e012b45f5a1353612c47d1fffb50cfb82604254bd1aaa6f75dc54ba4a63",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dry-basin/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dry-basin/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-dry-basin\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'DryBasin'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "8f1ad8b6ced2ef3ff12c541b6afcf472acc48995c752d7547e81e3832617d057",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dry-basin/README.md",
      "content": "# Dry Basin - Contract\n\nThis is a Dry Basin contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "6bfe0e6fbd8a76524c7e8bb142d083a0a5e06e74d19dcb086ee387e04702d314",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dry-basin/src/Cargo.toml",
      "content": "[package]\nname = \"dry_basin\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "be3160d9cd775ad6acf12e2538b89b6dec8ce62c749084351888e070f9902abb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dry-basin/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod dry_basin {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Dry Basin' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct DryBasinContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for DryBasinContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl DryBasinContract {\n        /// Creates a new PSP-22 compatible Dry Basin Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Dry Basin\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MDRY_BASIN\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "e8ac34c2c501cd6025461cefd4d2d9fb134874052851d38ce733a9d051e3002b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dune/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dune/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-dune\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Dune'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "37d50bbe1a6962bc88b67ff9a0f1444fc6c11dbd07063b903ce8a4d9ffefb2ad",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dune/README.md",
      "content": "# Dune - Contract\n\nThis is a Dune contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "b2ed3f44b00afe77babeb7be77cbd2db317f04d271c1a2ba405248341e1a277d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dune/src/Cargo.toml",
      "content": "[package]\nname = \"dune\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "ca6e34c3de848c81a4581e9e6737a8708b6876743cfe4c2d47ffa46e435f3ff6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dune/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod dune {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Dune' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct DuneContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for DuneContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl DuneContract {\n        /// Creates a new PSP-22 compatible Dune Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Dune\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MDUNE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "5c49c5a80ae0b35593bc33b1c69153bb282fcb738017fce08f1d3448a6f72fdd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dust/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dust/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-dust\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Dust'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "da280c441b1bc8654d31686804fcc7f5b436e5a5f17caaa2159a58a9d0514b70",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dust/README.md",
      "content": "# Dust - Contract\n\nThis is a Dust contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "4f9e7e86864bdd2c739c15164ced30fd8ba9e3266f2c2c4c6cdcd4cc9fd1e87a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dust/src/Cargo.toml",
      "content": "[package]\nname = \"dust\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "2c5da92afd2ab4c1a46805903cb929d325417b42418c57d6c30ba6aef07fbee3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dust/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod dust {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Dust' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct DustContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for DustContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl DustContract {\n        /// Creates a new PSP-22 compatible Dust Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Dust\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MDUST\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "4c89880e342998e8802dafae29bd3855bcfa30173aa34074ca234161929f016d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-earth/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-earth/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-earth\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Earth'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "b69ad1a6835071fe2fffb3a5227703f6484c4bee5b117761f2c69a3871a0ba7c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-earth/README.md",
      "content": "# Earth - Contract\n\nThis is a Earth contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "17641144f3956bf4a92afc6e6fada89f684c207df1261fe9f8f1c211b7f1d55e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-earth/src/Cargo.toml",
      "content": "[package]\nname = \"earth\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "ca9d5007293a66afc8cdb1b691f90b51d9e8f2aa9ba074c730fa25ab1e456ca2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-earth/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod earth {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Earth' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct EarthContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for EarthContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl EarthContract {\n        /// Creates a new PSP-22 compatible Earth Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Earth\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MEARTH\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "33e5bb9a6ef51103f35fe4268e6f19f9e24952b6638840001bad6299bdea09e3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-echo/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-echo/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-echo\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Echo'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "f428d06c9ab1e5734e9f921aa7bde713e3d09b5c99c559f72bb9c28b4ab7da43",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-echo/README.md",
      "content": "# Echo - Contract\n\nThis is a Echo contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "244fb65c7dbb166d2ad909109bf7a1e65ebea03e6ec1819fb63af1a7581d0b0a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-echo/src/Cargo.toml",
      "content": "[package]\nname = \"echo\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "7d1074c77c6b8856e363f9af423eeab19d0e7bc4a99d97271f6a4c7971dce9a2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-echo/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod echo {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Echo' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct EchoContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for EchoContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl EchoContract {\n        /// Creates a new PSP-22 compatible Echo Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Echo\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MECHO\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "87e8bc3d3c0bb1576a64d113fc90c3cac23b5fb8377f41c9904b5b6633899cb0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-elementy/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-elementy/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-elementy\",\n    \"description\": \"The Game Contract of the game Elementy\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "b31a278236b1dba5e7677f9a60c04e50f59e1963d7a8ff0a7085567ae7cccd03",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-elementy/README.md",
      "content": "# Elementy - Game Contract\n\nThis is the **main outer contract** that the **game logic** interacts with.",
      "contentHash": "97024f647ad2f2fdbe84dffc8f6e27ab8235d4193f7437b8b7470a9a8fa97947",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-elementy/src/Cargo.toml",
      "content": "[package]\nname = \"elementy\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "7e06127946f4122e5d7d306d9b30969de91fae3f2d0ea4ca2cc9b65e2b51b8de",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-elementy/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n/// A game in which you combine elements to create new ones.\n#[ink::contract]\npub mod elementy {\n    pub use ink::prelude::string::String;\n    pub use ink::prelude::format;\n    pub use ink::storage::Mapping;\n    use ink::{\n        env::{\n            call::{build_call, ExecutionInput, Selector},\n            CallFlags, DefaultEnvironment,\n        },\n    };\n\n    /** Error type for the game contract for Elementy */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        Custom(String),\n        ElementContractError(String),\n        InkError(ink::primitives::LangError),\n        FatalError(String),\n        ElementContractIsNotLocked,\n        ElementContractAlreadyLocked,\n        NotTheOwner,\n        OwnerAlreadySet,\n        BuyOfferIsNotSet,\n        InsufficientBuyTransferredValue,\n        InvalidRecipe,\n        NotEnoughElements,\n        InvalidElement,\n    }\n\n    #[ink(storage)]\n    pub struct GameContract {\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        element_contract_ids: Mapping<u32, AccountId>,\n        buy_offer_price_native_tokens: u128,\n        buy_offer_reward_tier_points: u128,\n        buy_offer_is_set: bool,\n        pool_round: u128,\n        pool_target: u128,\n        pool_value: u128,\n    }\n\n    struct Element {\n        id: u32,\n        name: &'static str,\n        description: &'static str,\n        tier: u32,\n    }\n\n    struct Recipe {\n        id: u32,\n        a: u32,\n        b: u32,\n        c: u32,\n    }\n\n    const ELEMENT_WATER: Element = Element {\n        id: 25,\n        name: \"Water\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_FIRE: Element = Element {\n        id: 26,\n        name: \"Fire\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_STEAM: Element = Element {\n        id: 27,\n        name: \"Steam\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_EARTH: Element = Element {\n        id: 28,\n        name: \"Earth\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_MUD: Element = Element {\n        id: 29,\n        name: \"Mud\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_LAVA: Element = Element {\n        id: 30,\n        name: \"Lava\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_WIND: Element = Element {\n        id: 31,\n        name: \"Wind\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_DUST: Element = Element {\n        id: 32,\n        name: \"Dust\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_RAIN: Element = Element {\n        id: 33,\n        name: \"Rain\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_SMOKE: Element = Element {\n        id: 34,\n        name: \"Smoke\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_GEYSER: Element = Element {\n        id: 35,\n        name: \"Geyser\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_CLAY: Element = Element {\n        id: 36,\n        name: \"Clay\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_SAND: Element = Element {\n        id: 37,\n        name: \"Sand\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_PLANT: Element = Element {\n        id: 38,\n        name: \"Plant\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_RAINBOW: Element = Element {\n        id: 39,\n        name: \"Rainbow\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_STORM: Element = Element {\n        id: 40,\n        name: \"Storm\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_OBSIDIAN: Element = Element {\n        id: 41,\n        name: \"Obsidian\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_ASH: Element = Element {\n        id: 42,\n        name: \"Ash\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_VOLCANO: Element = Element {\n        id: 43,\n        name: \"Volcano\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_SANDSTORM: Element = Element {\n        id: 44,\n        name: \"Sandstorm\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_CLOUD: Element = Element {\n        id: 45,\n        name: \"Cloud\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_FOG: Element = Element {\n        id: 46,\n        name: \"Fog\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_TREE: Element = Element {\n        id: 47,\n        name: \"Tree\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_FOREST: Element = Element {\n        id: 48,\n        name: \"Forest\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_SEEDS: Element = Element {\n        id: 49,\n        name: \"Seeds\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_POTTERY: Element = Element {\n        id: 50,\n        name: \"Pottery\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_BRICK: Element = Element {\n        id: 51,\n        name: \"Brick\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_QUICKSAND: Element = Element {\n        id: 52,\n        name: \"Quicksand\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_GLASS: Element = Element {\n        id: 53,\n        name: \"Glass\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_DUNE: Element = Element {\n        id: 54,\n        name: \"Dune\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_CHARCOAL: Element = Element {\n        id: 55,\n        name: \"Charcoal\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_LEAVES: Element = Element {\n        id: 56,\n        name: \"Leaves\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_WILDFIRE: Element = Element {\n        id: 57,\n        name: \"Wildfire\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_JUNGLE: Element = Element {\n        id: 58,\n        name: \"Jungle\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_FROSTED_GLASS: Element = Element {\n        id: 59,\n        name: \"FrostedGlass\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_CRYSTAL: Element = Element {\n        id: 60,\n        name: \"Crystal\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_MAGMA: Element = Element {\n        id: 61,\n        name: \"Magma\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_ROCK: Element = Element {\n        id: 62,\n        name: \"Rock\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_SHARD: Element = Element {\n        id: 63,\n        name: \"Shard\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_PEBBLE: Element = Element {\n        id: 64,\n        name: \"Pebble\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_MOUNTAIN: Element = Element {\n        id: 65,\n        name: \"Mountain\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_FERTILIZER: Element = Element {\n        id: 66,\n        name: \"Fertilizer\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_SOOT: Element = Element {\n        id: 67,\n        name: \"Soot\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_LIGHTNING: Element = Element {\n        id: 68,\n        name: \"Lightning\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_MIST: Element = Element {\n        id: 69,\n        name: \"Mist\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_HAZE: Element = Element {\n        id: 70,\n        name: \"Haze\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_FLOOD: Element = Element {\n        id: 71,\n        name: \"Flood\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_LANDSLIDE: Element = Element {\n        id: 72,\n        name: \"Landslide\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_THUNDER: Element = Element {\n        id: 73,\n        name: \"Thunder\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_TORNADO: Element = Element {\n        id: 74,\n        name: \"Tornado\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_GARDEN: Element = Element {\n        id: 75,\n        name: \"Garden\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_EMBER: Element = Element {\n        id: 76,\n        name: \"Ember\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_KILN: Element = Element {\n        id: 77,\n        name: \"Kiln\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_POLLINATION: Element = Element {\n        id: 78,\n        name: \"Pollination\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_SINKHOLE: Element = Element {\n        id: 79,\n        name: \"Sinkhole\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_BEACH: Element = Element {\n        id: 80,\n        name: \"Beach\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_WETSTONE: Element = Element {\n        id: 81,\n        name: \"Wetstone\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_EROSION: Element = Element {\n        id: 82,\n        name: \"Erosion\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_BASALT: Element = Element {\n        id: 83,\n        name: \"Basalt\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_MAGMA_CHAMBER: Element = Element {\n        id: 84,\n        name: \"MagmaChamber\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_BREEZE: Element = Element {\n        id: 85,\n        name: \"Breeze\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_WARM_BREEZE: Element = Element {\n        id: 86,\n        name: \"WarmBreeze\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_SOIL: Element = Element {\n        id: 87,\n        name: \"Soil\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_CANYON: Element = Element {\n        id: 88,\n        name: \"Canyon\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_WINDMILL: Element = Element {\n        id: 89,\n        name: \"Windmill\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_ADOBE: Element = Element {\n        id: 90,\n        name: \"Adobe\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_WALL: Element = Element {\n        id: 91,\n        name: \"Wall\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_PUMICE: Element = Element {\n        id: 92,\n        name: \"Pumice\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_BARBECUE: Element = Element {\n        id: 93,\n        name: \"Barbecue\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_FARM: Element = Element {\n        id: 94,\n        name: \"Farm\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_SHARDS: Element = Element {\n        id: 95,\n        name: \"Shards\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_MOLTEN_GLASS: Element = Element {\n        id: 96,\n        name: \"MoltenGlass\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_PRISM: Element = Element {\n        id: 97,\n        name: \"Prism\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_SPARKLE: Element = Element {\n        id: 98,\n        name: \"Sparkle\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_DESERT: Element = Element {\n        id: 99,\n        name: \"Desert\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_OASIS: Element = Element {\n        id: 100,\n        name: \"Oasis\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_MIRAGE: Element = Element {\n        id: 101,\n        name: \"Mirage\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_SAND_DUNE: Element = Element {\n        id: 102,\n        name: \"SandDune\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_DAM: Element = Element {\n        id: 103,\n        name: \"Dam\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_FIREWALL: Element = Element {\n        id: 104,\n        name: \"Firewall\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_BARRICADE: Element = Element {\n        id: 105,\n        name: \"Barricade\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_PLATEAU: Element = Element {\n        id: 106,\n        name: \"Plateau\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_POND: Element = Element {\n        id: 107,\n        name: \"Pond\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_AROMAS: Element = Element {\n        id: 108,\n        name: \"Aromas\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_FLOWER: Element = Element {\n        id: 109,\n        name: \"Flower\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_SPORE: Element = Element {\n        id: 110,\n        name: \"Spore\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_SPREAD: Element = Element {\n        id: 111,\n        name: \"Spread\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_FERTILE_LAND: Element = Element {\n        id: 112,\n        name: \"FertileLand\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_WETLAND: Element = Element {\n        id: 113,\n        name: \"Wetland\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_PEAT: Element = Element {\n        id: 114,\n        name: \"Peat\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_REEDS: Element = Element {\n        id: 115,\n        name: \"Reeds\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_VALLEY: Element = Element {\n        id: 116,\n        name: \"Valley\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_RIVER: Element = Element {\n        id: 117,\n        name: \"River\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_SCORCHED_EARTH: Element = Element {\n        id: 118,\n        name: \"ScorchedEarth\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_DELTA: Element = Element {\n        id: 119,\n        name: \"Delta\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_ESTUARY: Element = Element {\n        id: 120,\n        name: \"Estuary\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_FIRE_SWAMP: Element = Element {\n        id: 121,\n        name: \"FireSwamp\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_RIVERBANK: Element = Element {\n        id: 122,\n        name: \"Riverbank\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_RAVINE: Element = Element {\n        id: 123,\n        name: \"Ravine\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_GORGE: Element = Element {\n        id: 124,\n        name: \"Gorge\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_CHARRED_RAVINE: Element = Element {\n        id: 125,\n        name: \"CharredRavine\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_ECHO: Element = Element {\n        id: 126,\n        name: \"Echo\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_CAVE: Element = Element {\n        id: 127,\n        name: \"Cave\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_UNDERGROUND_LAKE: Element = Element {\n        id: 128,\n        name: \"UndergroundLake\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_LAVA_CAVE: Element = Element {\n        id: 129,\n        name: \"LavaCave\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_WHISPERING_CAVE: Element = Element {\n        id: 130,\n        name: \"WhisperingCave\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_SUBTERRANEAN_POOL: Element = Element {\n        id: 131,\n        name: \"SubterraneanPool\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_SPRING: Element = Element {\n        id: 132,\n        name: \"Spring\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_HOT_SPRING: Element = Element {\n        id: 133,\n        name: \"HotSpring\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_GROTTO: Element = Element {\n        id: 134,\n        name: \"Grotto\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_FOUNTAIN: Element = Element {\n        id: 135,\n        name: \"Fountain\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_STEAM_VENT: Element = Element {\n        id: 136,\n        name: \"SteamVent\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_COOL_BREEZE: Element = Element {\n        id: 137,\n        name: \"CoolBreeze\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_MONUMENT: Element = Element {\n        id: 138,\n        name: \"Monument\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_WATERFALL: Element = Element {\n        id: 139,\n        name: \"Waterfall\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_ETERNAL_FLAME: Element = Element {\n        id: 140,\n        name: \"EternalFlame\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_PILLAR_OF_WIND: Element = Element {\n        id: 141,\n        name: \"PillarOfWind\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_STREAM: Element = Element {\n        id: 142,\n        name: \"Stream\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_ZEPHYR: Element = Element {\n        id: 143,\n        name: \"Zephyr\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_CREEK: Element = Element {\n        id: 144,\n        name: \"Creek\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_BROOK: Element = Element {\n        id: 145,\n        name: \"Brook\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_WHISPER: Element = Element {\n        id: 146,\n        name: \"Whisper\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_RIVULET: Element = Element {\n        id: 147,\n        name: \"Rivulet\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_TRIBUTARY: Element = Element {\n        id: 148,\n        name: \"Tributary\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_MURMUR: Element = Element {\n        id: 149,\n        name: \"Murmur\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_WATERSHED: Element = Element {\n        id: 150,\n        name: \"Watershed\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_AQUIFER: Element = Element {\n        id: 151,\n        name: \"Aquifer\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_PARCHED_EARTH: Element = Element {\n        id: 152,\n        name: \"ParchedEarth\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_FRESH_BREEZE: Element = Element {\n        id: 153,\n        name: \"FreshBreeze\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_GROUNDWATER: Element = Element {\n        id: 154,\n        name: \"Groundwater\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_RESERVOIR: Element = Element {\n        id: 155,\n        name: \"Reservoir\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_GEOTHERMAL_SPRING: Element = Element {\n        id: 156,\n        name: \"GeothermalSpring\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_ARTESIAN_WELL: Element = Element {\n        id: 157,\n        name: \"ArtesianWell\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_BASIN: Element = Element {\n        id: 158,\n        name: \"Basin\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_LAKE: Element = Element {\n        id: 159,\n        name: \"Lake\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_DRY_BASIN: Element = Element {\n        id: 160,\n        name: \"DryBasin\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_DEPRESSION: Element = Element {\n        id: 161,\n        name: \"Depression\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_ISLAND: Element = Element {\n        id: 162,\n        name: \"Island\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_LAGOON: Element = Element {\n        id: 163,\n        name: \"Lagoon\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_WAVE: Element = Element {\n        id: 164,\n        name: \"Wave\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_REEF: Element = Element {\n        id: 165,\n        name: \"Reef\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_CORAL: Element = Element {\n        id: 166,\n        name: \"Coral\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_WHIRL: Element = Element {\n        id: 167,\n        name: \"Whirl\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_LIMESTONE: Element = Element {\n        id: 168,\n        name: \"Limestone\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_KARST: Element = Element {\n        id: 169,\n        name: \"Karst\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_QUICKLIME: Element = Element {\n        id: 170,\n        name: \"Quicklime\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_BLOWHOLE: Element = Element {\n        id: 171,\n        name: \"Blowhole\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const RECIPE_MAKE_STEAM: Recipe = Recipe {\n        id: 10,\n        a: 25,\n        b: 26,\n        c: 27,\n    };\n    const RECIPE_MAKE_MUD: Recipe = Recipe {\n        id: 11,\n        a: 25,\n        b: 28,\n        c: 29,\n    };\n    const RECIPE_MAKE_LAVA: Recipe = Recipe {\n        id: 12,\n        a: 26,\n        b: 28,\n        c: 30,\n    };\n    const RECIPE_MAKE_DUST: Recipe = Recipe {\n        id: 13,\n        a: 31,\n        b: 28,\n        c: 32,\n    };\n    const RECIPE_MAKE_RAIN: Recipe = Recipe {\n        id: 14,\n        a: 25,\n        b: 31,\n        c: 33,\n    };\n    const RECIPE_MAKE_SMOKE: Recipe = Recipe {\n        id: 15,\n        a: 26,\n        b: 31,\n        c: 34,\n    };\n    const RECIPE_MAKE_GEYSER: Recipe = Recipe {\n        id: 16,\n        a: 27,\n        b: 28,\n        c: 35,\n    };\n    const RECIPE_MAKE_CLAY: Recipe = Recipe {\n        id: 17,\n        a: 29,\n        b: 26,\n        c: 36,\n    };\n    const RECIPE_MAKE_SAND: Recipe = Recipe {\n        id: 18,\n        a: 29,\n        b: 31,\n        c: 37,\n    };\n    const RECIPE_MAKE_PLANT: Recipe = Recipe {\n        id: 19,\n        a: 33,\n        b: 28,\n        c: 38,\n    };\n    const RECIPE_MAKE_RAINBOW: Recipe = Recipe {\n        id: 20,\n        a: 33,\n        b: 26,\n        c: 39,\n    };\n    const RECIPE_MAKE_STORM: Recipe = Recipe {\n        id: 21,\n        a: 33,\n        b: 31,\n        c: 40,\n    };\n    const RECIPE_MAKE_OBSIDIAN: Recipe = Recipe {\n        id: 22,\n        a: 30,\n        b: 25,\n        c: 41,\n    };\n    const RECIPE_MAKE_ASH: Recipe = Recipe {\n        id: 23,\n        a: 30,\n        b: 31,\n        c: 42,\n    };\n    const RECIPE_MAKE_VOLCANO: Recipe = Recipe {\n        id: 24,\n        a: 30,\n        b: 28,\n        c: 43,\n    };\n    const RECIPE_MAKE_SANDSTORM: Recipe = Recipe {\n        id: 25,\n        a: 32,\n        b: 31,\n        c: 44,\n    };\n    const RECIPE_MAKE_CLOUD: Recipe = Recipe {\n        id: 26,\n        a: 34,\n        b: 25,\n        c: 45,\n    };\n    const RECIPE_MAKE_FOG: Recipe = Recipe {\n        id: 27,\n        a: 34,\n        b: 31,\n        c: 46,\n    };\n    const RECIPE_MAKE_TREE: Recipe = Recipe {\n        id: 28,\n        a: 38,\n        b: 25,\n        c: 47,\n    };\n    const RECIPE_MAKE_FOREST: Recipe = Recipe {\n        id: 29,\n        a: 38,\n        b: 28,\n        c: 48,\n    };\n    const RECIPE_MAKE_SEEDS: Recipe = Recipe {\n        id: 30,\n        a: 38,\n        b: 31,\n        c: 49,\n    };\n    const RECIPE_MAKE_POTTERY: Recipe = Recipe {\n        id: 31,\n        a: 36,\n        b: 26,\n        c: 50,\n    };\n    const RECIPE_MAKE_BRICK: Recipe = Recipe {\n        id: 32,\n        a: 36,\n        b: 28,\n        c: 51,\n    };\n    const RECIPE_MAKE_QUICKSAND: Recipe = Recipe {\n        id: 33,\n        a: 37,\n        b: 25,\n        c: 52,\n    };\n    const RECIPE_MAKE_GLASS: Recipe = Recipe {\n        id: 34,\n        a: 37,\n        b: 26,\n        c: 53,\n    };\n    const RECIPE_MAKE_DUNE: Recipe = Recipe {\n        id: 35,\n        a: 37,\n        b: 31,\n        c: 54,\n    };\n    const RECIPE_MAKE_CHARCOAL: Recipe = Recipe {\n        id: 36,\n        a: 47,\n        b: 26,\n        c: 55,\n    };\n    const RECIPE_MAKE_LEAVES: Recipe = Recipe {\n        id: 37,\n        a: 47,\n        b: 31,\n        c: 56,\n    };\n    const RECIPE_MAKE_WILDFIRE: Recipe = Recipe {\n        id: 38,\n        a: 48,\n        b: 26,\n        c: 57,\n    };\n    const RECIPE_MAKE_JUNGLE: Recipe = Recipe {\n        id: 39,\n        a: 48,\n        b: 28,\n        c: 58,\n    };\n    const RECIPE_MAKE_FROSTED_GLASS: Recipe = Recipe {\n        id: 40,\n        a: 53,\n        b: 25,\n        c: 59,\n    };\n    const RECIPE_MAKE_CRYSTAL: Recipe = Recipe {\n        id: 41,\n        a: 53,\n        b: 28,\n        c: 60,\n    };\n    const RECIPE_MAKE_MAGMA: Recipe = Recipe {\n        id: 42,\n        a: 41,\n        b: 26,\n        c: 61,\n    };\n    const RECIPE_MAKE_ROCK: Recipe = Recipe {\n        id: 43,\n        a: 41,\n        b: 28,\n        c: 62,\n    };\n    const RECIPE_MAKE_SHARD: Recipe = Recipe {\n        id: 44,\n        a: 41,\n        b: 31,\n        c: 63,\n    };\n    const RECIPE_MAKE_PEBBLE: Recipe = Recipe {\n        id: 45,\n        a: 62,\n        b: 25,\n        c: 64,\n    };\n    const RECIPE_MAKE_MOUNTAIN: Recipe = Recipe {\n        id: 46,\n        a: 62,\n        b: 28,\n        c: 65,\n    };\n    const RECIPE_MAKE_FERTILIZER: Recipe = Recipe {\n        id: 47,\n        a: 42,\n        b: 28,\n        c: 66,\n    };\n    const RECIPE_MAKE_SOOT: Recipe = Recipe {\n        id: 48,\n        a: 42,\n        b: 31,\n        c: 67,\n    };\n    const RECIPE_MAKE_LIGHTNING: Recipe = Recipe {\n        id: 49,\n        a: 45,\n        b: 26,\n        c: 68,\n    };\n    const RECIPE_MAKE_MIST: Recipe = Recipe {\n        id: 50,\n        a: 46,\n        b: 28,\n        c: 69,\n    };\n    const RECIPE_MAKE_HAZE: Recipe = Recipe {\n        id: 51,\n        a: 46,\n        b: 31,\n        c: 70,\n    };\n    const RECIPE_MAKE_FLOOD: Recipe = Recipe {\n        id: 52,\n        a: 40,\n        b: 25,\n        c: 71,\n    };\n    const RECIPE_MAKE_LANDSLIDE: Recipe = Recipe {\n        id: 53,\n        a: 40,\n        b: 28,\n        c: 72,\n    };\n    const RECIPE_MAKE_THUNDER: Recipe = Recipe {\n        id: 54,\n        a: 40,\n        b: 26,\n        c: 73,\n    };\n    const RECIPE_MAKE_TORNADO: Recipe = Recipe {\n        id: 55,\n        a: 40,\n        b: 31,\n        c: 74,\n    };\n    const RECIPE_MAKE_GARDEN: Recipe = Recipe {\n        id: 56,\n        a: 28,\n        b: 38,\n        c: 75,\n    };\n    const RECIPE_MAKE_EMBER: Recipe = Recipe {\n        id: 57,\n        a: 26,\n        b: 42,\n        c: 76,\n    };\n    const RECIPE_MAKE_KILN: Recipe = Recipe {\n        id: 58,\n        a: 26,\n        b: 50,\n        c: 77,\n    };\n    const RECIPE_MAKE_POLLINATION: Recipe = Recipe {\n        id: 59,\n        a: 31,\n        b: 38,\n        c: 78,\n    };\n    const RECIPE_MAKE_SINKHOLE: Recipe = Recipe {\n        id: 60,\n        a: 28,\n        b: 52,\n        c: 79,\n    };\n    const RECIPE_MAKE_BEACH: Recipe = Recipe {\n        id: 61,\n        a: 25,\n        b: 37,\n        c: 80,\n    };\n    const RECIPE_MAKE_WETSTONE: Recipe = Recipe {\n        id: 62,\n        a: 25,\n        b: 41,\n        c: 81,\n    };\n    const RECIPE_MAKE_EROSION: Recipe = Recipe {\n        id: 63,\n        a: 31,\n        b: 62,\n        c: 82,\n    };\n    const RECIPE_MAKE_BASALT: Recipe = Recipe {\n        id: 64,\n        a: 25,\n        b: 30,\n        c: 83,\n    };\n    const RECIPE_MAKE_MAGMA_CHAMBER: Recipe = Recipe {\n        id: 65,\n        a: 28,\n        b: 30,\n        c: 84,\n    };\n    const RECIPE_MAKE_BREEZE: Recipe = Recipe {\n        id: 66,\n        a: 31,\n        b: 32,\n        c: 85,\n    };\n    const RECIPE_MAKE_WARM_BREEZE: Recipe = Recipe {\n        id: 67,\n        a: 26,\n        b: 85,\n        c: 86,\n    };\n    const RECIPE_MAKE_SOIL: Recipe = Recipe {\n        id: 68,\n        a: 28,\n        b: 38,\n        c: 87,\n    };\n    const RECIPE_MAKE_CANYON: Recipe = Recipe {\n        id: 69,\n        a: 25,\n        b: 82,\n        c: 88,\n    };\n    const RECIPE_MAKE_WINDMILL: Recipe = Recipe {\n        id: 70,\n        a: 31,\n        b: 38,\n        c: 89,\n    };\n    const RECIPE_MAKE_ADOBE: Recipe = Recipe {\n        id: 71,\n        a: 28,\n        b: 36,\n        c: 90,\n    };\n    const RECIPE_MAKE_WALL: Recipe = Recipe {\n        id: 72,\n        a: 28,\n        b: 51,\n        c: 91,\n    };\n    const RECIPE_MAKE_PUMICE: Recipe = Recipe {\n        id: 73,\n        a: 25,\n        b: 42,\n        c: 92,\n    };\n    const RECIPE_MAKE_BARBECUE: Recipe = Recipe {\n        id: 74,\n        a: 26,\n        b: 55,\n        c: 93,\n    };\n    const RECIPE_MAKE_FARM: Recipe = Recipe {\n        id: 75,\n        a: 28,\n        b: 49,\n        c: 94,\n    };\n    const RECIPE_MAKE_SHARDS: Recipe = Recipe {\n        id: 76,\n        a: 31,\n        b: 41,\n        c: 95,\n    };\n    const RECIPE_MAKE_MOLTEN_GLASS: Recipe = Recipe {\n        id: 77,\n        a: 26,\n        b: 60,\n        c: 96,\n    };\n    const RECIPE_MAKE_PRISM: Recipe = Recipe {\n        id: 78,\n        a: 25,\n        b: 60,\n        c: 97,\n    };\n    const RECIPE_MAKE_SPARKLE: Recipe = Recipe {\n        id: 79,\n        a: 31,\n        b: 60,\n        c: 98,\n    };\n    const RECIPE_MAKE_DESERT: Recipe = Recipe {\n        id: 80,\n        a: 28,\n        b: 80,\n        c: 99,\n    };\n    const RECIPE_MAKE_OASIS: Recipe = Recipe {\n        id: 81,\n        a: 25,\n        b: 99,\n        c: 100,\n    };\n    const RECIPE_MAKE_MIRAGE: Recipe = Recipe {\n        id: 82,\n        a: 26,\n        b: 99,\n        c: 101,\n    };\n    const RECIPE_MAKE_SAND_DUNE: Recipe = Recipe {\n        id: 83,\n        a: 31,\n        b: 99,\n        c: 102,\n    };\n    const RECIPE_MAKE_DAM: Recipe = Recipe {\n        id: 84,\n        a: 25,\n        b: 91,\n        c: 103,\n    };\n    const RECIPE_MAKE_FIREWALL: Recipe = Recipe {\n        id: 85,\n        a: 26,\n        b: 91,\n        c: 104,\n    };\n    const RECIPE_MAKE_BARRICADE: Recipe = Recipe {\n        id: 86,\n        a: 31,\n        b: 91,\n        c: 105,\n    };\n    const RECIPE_MAKE_PLATEAU: Recipe = Recipe {\n        id: 87,\n        a: 28,\n        b: 88,\n        c: 106,\n    };\n    const RECIPE_MAKE_POND: Recipe = Recipe {\n        id: 88,\n        a: 25,\n        b: 75,\n        c: 107,\n    };\n    const RECIPE_MAKE_AROMAS: Recipe = Recipe {\n        id: 89,\n        a: 31,\n        b: 75,\n        c: 108,\n    };\n    const RECIPE_MAKE_FLOWER: Recipe = Recipe {\n        id: 90,\n        a: 25,\n        b: 78,\n        c: 109,\n    };\n    const RECIPE_MAKE_SPORE: Recipe = Recipe {\n        id: 91,\n        a: 26,\n        b: 78,\n        c: 110,\n    };\n    const RECIPE_MAKE_SPREAD: Recipe = Recipe {\n        id: 92,\n        a: 31,\n        b: 78,\n        c: 111,\n    };\n    const RECIPE_MAKE_FERTILE_LAND: Recipe = Recipe {\n        id: 93,\n        a: 28,\n        b: 87,\n        c: 112,\n    };\n    const RECIPE_MAKE_WETLAND: Recipe = Recipe {\n        id: 94,\n        a: 25,\n        b: 112,\n        c: 113,\n    };\n    const RECIPE_MAKE_PEAT: Recipe = Recipe {\n        id: 95,\n        a: 26,\n        b: 113,\n        c: 114,\n    };\n    const RECIPE_MAKE_REEDS: Recipe = Recipe {\n        id: 96,\n        a: 31,\n        b: 113,\n        c: 115,\n    };\n    const RECIPE_MAKE_VALLEY: Recipe = Recipe {\n        id: 97,\n        a: 28,\n        b: 88,\n        c: 116,\n    };\n    const RECIPE_MAKE_RIVER: Recipe = Recipe {\n        id: 98,\n        a: 25,\n        b: 116,\n        c: 117,\n    };\n    const RECIPE_MAKE_SCORCHED_EARTH: Recipe = Recipe {\n        id: 99,\n        a: 26,\n        b: 116,\n        c: 118,\n    };\n    const RECIPE_MAKE_DELTA: Recipe = Recipe {\n        id: 100,\n        a: 28,\n        b: 117,\n        c: 119,\n    };\n    const RECIPE_MAKE_ESTUARY: Recipe = Recipe {\n        id: 101,\n        a: 25,\n        b: 119,\n        c: 120,\n    };\n    const RECIPE_MAKE_FIRE_SWAMP: Recipe = Recipe {\n        id: 102,\n        a: 26,\n        b: 119,\n        c: 121,\n    };\n    const RECIPE_MAKE_RIVERBANK: Recipe = Recipe {\n        id: 103,\n        a: 31,\n        b: 119,\n        c: 122,\n    };\n    const RECIPE_MAKE_RAVINE: Recipe = Recipe {\n        id: 104,\n        a: 28,\n        b: 82,\n        c: 123,\n    };\n    const RECIPE_MAKE_GORGE: Recipe = Recipe {\n        id: 105,\n        a: 25,\n        b: 123,\n        c: 124,\n    };\n    const RECIPE_MAKE_CHARRED_RAVINE: Recipe = Recipe {\n        id: 106,\n        a: 26,\n        b: 123,\n        c: 125,\n    };\n    const RECIPE_MAKE_ECHO: Recipe = Recipe {\n        id: 107,\n        a: 31,\n        b: 123,\n        c: 126,\n    };\n    const RECIPE_MAKE_CAVE: Recipe = Recipe {\n        id: 108,\n        a: 28,\n        b: 126,\n        c: 127,\n    };\n    const RECIPE_MAKE_UNDERGROUND_LAKE: Recipe = Recipe {\n        id: 109,\n        a: 25,\n        b: 127,\n        c: 128,\n    };\n    const RECIPE_MAKE_LAVA_CAVE: Recipe = Recipe {\n        id: 110,\n        a: 26,\n        b: 127,\n        c: 129,\n    };\n    const RECIPE_MAKE_WHISPERING_CAVE: Recipe = Recipe {\n        id: 111,\n        a: 31,\n        b: 127,\n        c: 130,\n    };\n    const RECIPE_MAKE_SUBTERRANEAN_POOL: Recipe = Recipe {\n        id: 112,\n        a: 28,\n        b: 128,\n        c: 131,\n    };\n    const RECIPE_MAKE_SPRING: Recipe = Recipe {\n        id: 113,\n        a: 25,\n        b: 131,\n        c: 132,\n    };\n    const RECIPE_MAKE_HOT_SPRING: Recipe = Recipe {\n        id: 114,\n        a: 26,\n        b: 131,\n        c: 133,\n    };\n    const RECIPE_MAKE_GROTTO: Recipe = Recipe {\n        id: 115,\n        a: 31,\n        b: 131,\n        c: 134,\n    };\n    const RECIPE_MAKE_FOUNTAIN: Recipe = Recipe {\n        id: 116,\n        a: 25,\n        b: 132,\n        c: 135,\n    };\n    const RECIPE_MAKE_STEAM_VENT: Recipe = Recipe {\n        id: 117,\n        a: 26,\n        b: 132,\n        c: 136,\n    };\n    const RECIPE_MAKE_COOL_BREEZE: Recipe = Recipe {\n        id: 118,\n        a: 31,\n        b: 132,\n        c: 137,\n    };\n    const RECIPE_MAKE_MONUMENT: Recipe = Recipe {\n        id: 119,\n        a: 28,\n        b: 135,\n        c: 138,\n    };\n    const RECIPE_MAKE_WATERFALL: Recipe = Recipe {\n        id: 120,\n        a: 25,\n        b: 138,\n        c: 139,\n    };\n    const RECIPE_MAKE_ETERNAL_FLAME: Recipe = Recipe {\n        id: 121,\n        a: 26,\n        b: 138,\n        c: 140,\n    };\n    const RECIPE_MAKE_PILLAR_OF_WIND: Recipe = Recipe {\n        id: 122,\n        a: 31,\n        b: 138,\n        c: 141,\n    };\n    const RECIPE_MAKE_STREAM: Recipe = Recipe {\n        id: 123,\n        a: 25,\n        b: 117,\n        c: 142,\n    };\n    const RECIPE_MAKE_ZEPHYR: Recipe = Recipe {\n        id: 124,\n        a: 31,\n        b: 117,\n        c: 143,\n    };\n    const RECIPE_MAKE_CREEK: Recipe = Recipe {\n        id: 125,\n        a: 28,\n        b: 142,\n        c: 144,\n    };\n    const RECIPE_MAKE_BROOK: Recipe = Recipe {\n        id: 126,\n        a: 25,\n        b: 144,\n        c: 145,\n    };\n    const RECIPE_MAKE_WHISPER: Recipe = Recipe {\n        id: 127,\n        a: 31,\n        b: 144,\n        c: 146,\n    };\n    const RECIPE_MAKE_RIVULET: Recipe = Recipe {\n        id: 128,\n        a: 28,\n        b: 145,\n        c: 147,\n    };\n    const RECIPE_MAKE_TRIBUTARY: Recipe = Recipe {\n        id: 129,\n        a: 25,\n        b: 147,\n        c: 148,\n    };\n    const RECIPE_MAKE_MURMUR: Recipe = Recipe {\n        id: 130,\n        a: 31,\n        b: 147,\n        c: 149,\n    };\n    const RECIPE_MAKE_WATERSHED: Recipe = Recipe {\n        id: 131,\n        a: 28,\n        b: 148,\n        c: 150,\n    };\n    const RECIPE_MAKE_AQUIFER: Recipe = Recipe {\n        id: 132,\n        a: 25,\n        b: 150,\n        c: 151,\n    };\n    const RECIPE_MAKE_PARCHED_EARTH: Recipe = Recipe {\n        id: 133,\n        a: 26,\n        b: 150,\n        c: 152,\n    };\n    const RECIPE_MAKE_FRESH_BREEZE: Recipe = Recipe {\n        id: 134,\n        a: 31,\n        b: 150,\n        c: 153,\n    };\n    const RECIPE_MAKE_GROUNDWATER: Recipe = Recipe {\n        id: 135,\n        a: 28,\n        b: 151,\n        c: 154,\n    };\n    const RECIPE_MAKE_RESERVOIR: Recipe = Recipe {\n        id: 136,\n        a: 25,\n        b: 154,\n        c: 155,\n    };\n    const RECIPE_MAKE_GEOTHERMAL_SPRING: Recipe = Recipe {\n        id: 137,\n        a: 26,\n        b: 154,\n        c: 156,\n    };\n    const RECIPE_MAKE_ARTESIAN_WELL: Recipe = Recipe {\n        id: 138,\n        a: 31,\n        b: 154,\n        c: 157,\n    };\n    const RECIPE_MAKE_BASIN: Recipe = Recipe {\n        id: 139,\n        a: 28,\n        b: 155,\n        c: 158,\n    };\n    const RECIPE_MAKE_LAKE: Recipe = Recipe {\n        id: 140,\n        a: 25,\n        b: 158,\n        c: 159,\n    };\n    const RECIPE_MAKE_DRY_BASIN: Recipe = Recipe {\n        id: 141,\n        a: 26,\n        b: 158,\n        c: 160,\n    };\n    const RECIPE_MAKE_DEPRESSION: Recipe = Recipe {\n        id: 142,\n        a: 31,\n        b: 158,\n        c: 161,\n    };\n    const RECIPE_MAKE_ISLAND: Recipe = Recipe {\n        id: 143,\n        a: 28,\n        b: 159,\n        c: 162,\n    };\n    const RECIPE_MAKE_LAGOON: Recipe = Recipe {\n        id: 144,\n        a: 25,\n        b: 159,\n        c: 163,\n    };\n    const RECIPE_MAKE_WAVE: Recipe = Recipe {\n        id: 145,\n        a: 31,\n        b: 159,\n        c: 164,\n    };\n    const RECIPE_MAKE_REEF: Recipe = Recipe {\n        id: 146,\n        a: 28,\n        b: 163,\n        c: 165,\n    };\n    const RECIPE_MAKE_CORAL: Recipe = Recipe {\n        id: 147,\n        a: 25,\n        b: 165,\n        c: 166,\n    };\n    const RECIPE_MAKE_WHIRL: Recipe = Recipe {\n        id: 148,\n        a: 31,\n        b: 165,\n        c: 167,\n    };\n    const RECIPE_MAKE_LIMESTONE: Recipe = Recipe {\n        id: 149,\n        a: 28,\n        b: 166,\n        c: 168,\n    };\n    const RECIPE_MAKE_KARST: Recipe = Recipe {\n        id: 150,\n        a: 25,\n        b: 168,\n        c: 169,\n    };\n    const RECIPE_MAKE_QUICKLIME: Recipe = Recipe {\n        id: 151,\n        a: 26,\n        b: 168,\n        c: 170,\n    };\n    const RECIPE_MAKE_BLOWHOLE: Recipe = Recipe {\n        id: 152,\n        a: 31,\n        b: 169,\n        c: 171,\n    };\n\n    fn find_item(index: u32) -> Option<Element> {\n        if index == 25 {\n            return Some(ELEMENT_WATER);\n        }\n        if index == 26 {\n            return Some(ELEMENT_FIRE);\n        }\n        if index == 27 {\n            return Some(ELEMENT_STEAM);\n        }\n        if index == 28 {\n            return Some(ELEMENT_EARTH);\n        }\n        if index == 29 {\n            return Some(ELEMENT_MUD);\n        }\n        if index == 30 {\n            return Some(ELEMENT_LAVA);\n        }\n        if index == 31 {\n            return Some(ELEMENT_WIND);\n        }\n        if index == 32 {\n            return Some(ELEMENT_DUST);\n        }\n        if index == 33 {\n            return Some(ELEMENT_RAIN);\n        }\n        if index == 34 {\n            return Some(ELEMENT_SMOKE);\n        }\n        if index == 35 {\n            return Some(ELEMENT_GEYSER);\n        }\n        if index == 36 {\n            return Some(ELEMENT_CLAY);\n        }\n        if index == 37 {\n            return Some(ELEMENT_SAND);\n        }\n        if index == 38 {\n            return Some(ELEMENT_PLANT);\n        }\n        if index == 39 {\n            return Some(ELEMENT_RAINBOW);\n        }\n        if index == 40 {\n            return Some(ELEMENT_STORM);\n        }\n        if index == 41 {\n            return Some(ELEMENT_OBSIDIAN);\n        }\n        if index == 42 {\n            return Some(ELEMENT_ASH);\n        }\n        if index == 43 {\n            return Some(ELEMENT_VOLCANO);\n        }\n        if index == 44 {\n            return Some(ELEMENT_SANDSTORM);\n        }\n        if index == 45 {\n            return Some(ELEMENT_CLOUD);\n        }\n        if index == 46 {\n            return Some(ELEMENT_FOG);\n        }\n        if index == 47 {\n            return Some(ELEMENT_TREE);\n        }\n        if index == 48 {\n            return Some(ELEMENT_FOREST);\n        }\n        if index == 49 {\n            return Some(ELEMENT_SEEDS);\n        }\n        if index == 50 {\n            return Some(ELEMENT_POTTERY);\n        }\n        if index == 51 {\n            return Some(ELEMENT_BRICK);\n        }\n        if index == 52 {\n            return Some(ELEMENT_QUICKSAND);\n        }\n        if index == 53 {\n            return Some(ELEMENT_GLASS);\n        }\n        if index == 54 {\n            return Some(ELEMENT_DUNE);\n        }\n        if index == 55 {\n            return Some(ELEMENT_CHARCOAL);\n        }\n        if index == 56 {\n            return Some(ELEMENT_LEAVES);\n        }\n        if index == 57 {\n            return Some(ELEMENT_WILDFIRE);\n        }\n        if index == 58 {\n            return Some(ELEMENT_JUNGLE);\n        }\n        if index == 59 {\n            return Some(ELEMENT_FROSTED_GLASS);\n        }\n        if index == 60 {\n            return Some(ELEMENT_CRYSTAL);\n        }\n        if index == 61 {\n            return Some(ELEMENT_MAGMA);\n        }\n        if index == 62 {\n            return Some(ELEMENT_ROCK);\n        }\n        if index == 63 {\n            return Some(ELEMENT_SHARD);\n        }\n        if index == 64 {\n            return Some(ELEMENT_PEBBLE);\n        }\n        if index == 65 {\n            return Some(ELEMENT_MOUNTAIN);\n        }\n        if index == 66 {\n            return Some(ELEMENT_FERTILIZER);\n        }\n        if index == 67 {\n            return Some(ELEMENT_SOOT);\n        }\n        if index == 68 {\n            return Some(ELEMENT_LIGHTNING);\n        }\n        if index == 69 {\n            return Some(ELEMENT_MIST);\n        }\n        if index == 70 {\n            return Some(ELEMENT_HAZE);\n        }\n        if index == 71 {\n            return Some(ELEMENT_FLOOD);\n        }\n        if index == 72 {\n            return Some(ELEMENT_LANDSLIDE);\n        }\n        if index == 73 {\n            return Some(ELEMENT_THUNDER);\n        }\n        if index == 74 {\n            return Some(ELEMENT_TORNADO);\n        }\n        if index == 75 {\n            return Some(ELEMENT_GARDEN);\n        }\n        if index == 76 {\n            return Some(ELEMENT_EMBER);\n        }\n        if index == 77 {\n            return Some(ELEMENT_KILN);\n        }\n        if index == 78 {\n            return Some(ELEMENT_POLLINATION);\n        }\n        if index == 79 {\n            return Some(ELEMENT_SINKHOLE);\n        }\n        if index == 80 {\n            return Some(ELEMENT_BEACH);\n        }\n        if index == 81 {\n            return Some(ELEMENT_WETSTONE);\n        }\n        if index == 82 {\n            return Some(ELEMENT_EROSION);\n        }\n        if index == 83 {\n            return Some(ELEMENT_BASALT);\n        }\n        if index == 84 {\n            return Some(ELEMENT_MAGMA_CHAMBER);\n        }\n        if index == 85 {\n            return Some(ELEMENT_BREEZE);\n        }\n        if index == 86 {\n            return Some(ELEMENT_WARM_BREEZE);\n        }\n        if index == 87 {\n            return Some(ELEMENT_SOIL);\n        }\n        if index == 88 {\n            return Some(ELEMENT_CANYON);\n        }\n        if index == 89 {\n            return Some(ELEMENT_WINDMILL);\n        }\n        if index == 90 {\n            return Some(ELEMENT_ADOBE);\n        }\n        if index == 91 {\n            return Some(ELEMENT_WALL);\n        }\n        if index == 92 {\n            return Some(ELEMENT_PUMICE);\n        }\n        if index == 93 {\n            return Some(ELEMENT_BARBECUE);\n        }\n        if index == 94 {\n            return Some(ELEMENT_FARM);\n        }\n        if index == 95 {\n            return Some(ELEMENT_SHARDS);\n        }\n        if index == 96 {\n            return Some(ELEMENT_MOLTEN_GLASS);\n        }\n        if index == 97 {\n            return Some(ELEMENT_PRISM);\n        }\n        if index == 98 {\n            return Some(ELEMENT_SPARKLE);\n        }\n        if index == 99 {\n            return Some(ELEMENT_DESERT);\n        }\n        if index == 100 {\n            return Some(ELEMENT_OASIS);\n        }\n        if index == 101 {\n            return Some(ELEMENT_MIRAGE);\n        }\n        if index == 102 {\n            return Some(ELEMENT_SAND_DUNE);\n        }\n        if index == 103 {\n            return Some(ELEMENT_DAM);\n        }\n        if index == 104 {\n            return Some(ELEMENT_FIREWALL);\n        }\n        if index == 105 {\n            return Some(ELEMENT_BARRICADE);\n        }\n        if index == 106 {\n            return Some(ELEMENT_PLATEAU);\n        }\n        if index == 107 {\n            return Some(ELEMENT_POND);\n        }\n        if index == 108 {\n            return Some(ELEMENT_AROMAS);\n        }\n        if index == 109 {\n            return Some(ELEMENT_FLOWER);\n        }\n        if index == 110 {\n            return Some(ELEMENT_SPORE);\n        }\n        if index == 111 {\n            return Some(ELEMENT_SPREAD);\n        }\n        if index == 112 {\n            return Some(ELEMENT_FERTILE_LAND);\n        }\n        if index == 113 {\n            return Some(ELEMENT_WETLAND);\n        }\n        if index == 114 {\n            return Some(ELEMENT_PEAT);\n        }\n        if index == 115 {\n            return Some(ELEMENT_REEDS);\n        }\n        if index == 116 {\n            return Some(ELEMENT_VALLEY);\n        }\n        if index == 117 {\n            return Some(ELEMENT_RIVER);\n        }\n        if index == 118 {\n            return Some(ELEMENT_SCORCHED_EARTH);\n        }\n        if index == 119 {\n            return Some(ELEMENT_DELTA);\n        }\n        if index == 120 {\n            return Some(ELEMENT_ESTUARY);\n        }\n        if index == 121 {\n            return Some(ELEMENT_FIRE_SWAMP);\n        }\n        if index == 122 {\n            return Some(ELEMENT_RIVERBANK);\n        }\n        if index == 123 {\n            return Some(ELEMENT_RAVINE);\n        }\n        if index == 124 {\n            return Some(ELEMENT_GORGE);\n        }\n        if index == 125 {\n            return Some(ELEMENT_CHARRED_RAVINE);\n        }\n        if index == 126 {\n            return Some(ELEMENT_ECHO);\n        }\n        if index == 127 {\n            return Some(ELEMENT_CAVE);\n        }\n        if index == 128 {\n            return Some(ELEMENT_UNDERGROUND_LAKE);\n        }\n        if index == 129 {\n            return Some(ELEMENT_LAVA_CAVE);\n        }\n        if index == 130 {\n            return Some(ELEMENT_WHISPERING_CAVE);\n        }\n        if index == 131 {\n            return Some(ELEMENT_SUBTERRANEAN_POOL);\n        }\n        if index == 132 {\n            return Some(ELEMENT_SPRING);\n        }\n        if index == 133 {\n            return Some(ELEMENT_HOT_SPRING);\n        }\n        if index == 134 {\n            return Some(ELEMENT_GROTTO);\n        }\n        if index == 135 {\n            return Some(ELEMENT_FOUNTAIN);\n        }\n        if index == 136 {\n            return Some(ELEMENT_STEAM_VENT);\n        }\n        if index == 137 {\n            return Some(ELEMENT_COOL_BREEZE);\n        }\n        if index == 138 {\n            return Some(ELEMENT_MONUMENT);\n        }\n        if index == 139 {\n            return Some(ELEMENT_WATERFALL);\n        }\n        if index == 140 {\n            return Some(ELEMENT_ETERNAL_FLAME);\n        }\n        if index == 141 {\n            return Some(ELEMENT_PILLAR_OF_WIND);\n        }\n        if index == 142 {\n            return Some(ELEMENT_STREAM);\n        }\n        if index == 143 {\n            return Some(ELEMENT_ZEPHYR);\n        }\n        if index == 144 {\n            return Some(ELEMENT_CREEK);\n        }\n        if index == 145 {\n            return Some(ELEMENT_BROOK);\n        }\n        if index == 146 {\n            return Some(ELEMENT_WHISPER);\n        }\n        if index == 147 {\n            return Some(ELEMENT_RIVULET);\n        }\n        if index == 148 {\n            return Some(ELEMENT_TRIBUTARY);\n        }\n        if index == 149 {\n            return Some(ELEMENT_MURMUR);\n        }\n        if index == 150 {\n            return Some(ELEMENT_WATERSHED);\n        }\n        if index == 151 {\n            return Some(ELEMENT_AQUIFER);\n        }\n        if index == 152 {\n            return Some(ELEMENT_PARCHED_EARTH);\n        }\n        if index == 153 {\n            return Some(ELEMENT_FRESH_BREEZE);\n        }\n        if index == 154 {\n            return Some(ELEMENT_GROUNDWATER);\n        }\n        if index == 155 {\n            return Some(ELEMENT_RESERVOIR);\n        }\n        if index == 156 {\n            return Some(ELEMENT_GEOTHERMAL_SPRING);\n        }\n        if index == 157 {\n            return Some(ELEMENT_ARTESIAN_WELL);\n        }\n        if index == 158 {\n            return Some(ELEMENT_BASIN);\n        }\n        if index == 159 {\n            return Some(ELEMENT_LAKE);\n        }\n        if index == 160 {\n            return Some(ELEMENT_DRY_BASIN);\n        }\n        if index == 161 {\n            return Some(ELEMENT_DEPRESSION);\n        }\n        if index == 162 {\n            return Some(ELEMENT_ISLAND);\n        }\n        if index == 163 {\n            return Some(ELEMENT_LAGOON);\n        }\n        if index == 164 {\n            return Some(ELEMENT_WAVE);\n        }\n        if index == 165 {\n            return Some(ELEMENT_REEF);\n        }\n        if index == 166 {\n            return Some(ELEMENT_CORAL);\n        }\n        if index == 167 {\n            return Some(ELEMENT_WHIRL);\n        }\n        if index == 168 {\n            return Some(ELEMENT_LIMESTONE);\n        }\n        if index == 169 {\n            return Some(ELEMENT_KARST);\n        }\n        if index == 170 {\n            return Some(ELEMENT_QUICKLIME);\n        }\n        if index == 171 {\n            return Some(ELEMENT_BLOWHOLE);\n        }\n        None\n    }\n\n    fn find_recipe(index: u32) -> Option<Recipe> {\n        if index == 10 {\n            return Some(RECIPE_MAKE_STEAM);\n        }\n        if index == 11 {\n            return Some(RECIPE_MAKE_MUD);\n        }\n        if index == 12 {\n            return Some(RECIPE_MAKE_LAVA);\n        }\n        if index == 13 {\n            return Some(RECIPE_MAKE_DUST);\n        }\n        if index == 14 {\n            return Some(RECIPE_MAKE_RAIN);\n        }\n        if index == 15 {\n            return Some(RECIPE_MAKE_SMOKE);\n        }\n        if index == 16 {\n            return Some(RECIPE_MAKE_GEYSER);\n        }\n        if index == 17 {\n            return Some(RECIPE_MAKE_CLAY);\n        }\n        if index == 18 {\n            return Some(RECIPE_MAKE_SAND);\n        }\n        if index == 19 {\n            return Some(RECIPE_MAKE_PLANT);\n        }\n        if index == 20 {\n            return Some(RECIPE_MAKE_RAINBOW);\n        }\n        if index == 21 {\n            return Some(RECIPE_MAKE_STORM);\n        }\n        if index == 22 {\n            return Some(RECIPE_MAKE_OBSIDIAN);\n        }\n        if index == 23 {\n            return Some(RECIPE_MAKE_ASH);\n        }\n        if index == 24 {\n            return Some(RECIPE_MAKE_VOLCANO);\n        }\n        if index == 25 {\n            return Some(RECIPE_MAKE_SANDSTORM);\n        }\n        if index == 26 {\n            return Some(RECIPE_MAKE_CLOUD);\n        }\n        if index == 27 {\n            return Some(RECIPE_MAKE_FOG);\n        }\n        if index == 28 {\n            return Some(RECIPE_MAKE_TREE);\n        }\n        if index == 29 {\n            return Some(RECIPE_MAKE_FOREST);\n        }\n        if index == 30 {\n            return Some(RECIPE_MAKE_SEEDS);\n        }\n        if index == 31 {\n            return Some(RECIPE_MAKE_POTTERY);\n        }\n        if index == 32 {\n            return Some(RECIPE_MAKE_BRICK);\n        }\n        if index == 33 {\n            return Some(RECIPE_MAKE_QUICKSAND);\n        }\n        if index == 34 {\n            return Some(RECIPE_MAKE_GLASS);\n        }\n        if index == 35 {\n            return Some(RECIPE_MAKE_DUNE);\n        }\n        if index == 36 {\n            return Some(RECIPE_MAKE_CHARCOAL);\n        }\n        if index == 37 {\n            return Some(RECIPE_MAKE_LEAVES);\n        }\n        if index == 38 {\n            return Some(RECIPE_MAKE_WILDFIRE);\n        }\n        if index == 39 {\n            return Some(RECIPE_MAKE_JUNGLE);\n        }\n        if index == 40 {\n            return Some(RECIPE_MAKE_FROSTED_GLASS);\n        }\n        if index == 41 {\n            return Some(RECIPE_MAKE_CRYSTAL);\n        }\n        if index == 42 {\n            return Some(RECIPE_MAKE_MAGMA);\n        }\n        if index == 43 {\n            return Some(RECIPE_MAKE_ROCK);\n        }\n        if index == 44 {\n            return Some(RECIPE_MAKE_SHARD);\n        }\n        if index == 45 {\n            return Some(RECIPE_MAKE_PEBBLE);\n        }\n        if index == 46 {\n            return Some(RECIPE_MAKE_MOUNTAIN);\n        }\n        if index == 47 {\n            return Some(RECIPE_MAKE_FERTILIZER);\n        }\n        if index == 48 {\n            return Some(RECIPE_MAKE_SOOT);\n        }\n        if index == 49 {\n            return Some(RECIPE_MAKE_LIGHTNING);\n        }\n        if index == 50 {\n            return Some(RECIPE_MAKE_MIST);\n        }\n        if index == 51 {\n            return Some(RECIPE_MAKE_HAZE);\n        }\n        if index == 52 {\n            return Some(RECIPE_MAKE_FLOOD);\n        }\n        if index == 53 {\n            return Some(RECIPE_MAKE_LANDSLIDE);\n        }\n        if index == 54 {\n            return Some(RECIPE_MAKE_THUNDER);\n        }\n        if index == 55 {\n            return Some(RECIPE_MAKE_TORNADO);\n        }\n        if index == 56 {\n            return Some(RECIPE_MAKE_GARDEN);\n        }\n        if index == 57 {\n            return Some(RECIPE_MAKE_EMBER);\n        }\n        if index == 58 {\n            return Some(RECIPE_MAKE_KILN);\n        }\n        if index == 59 {\n            return Some(RECIPE_MAKE_POLLINATION);\n        }\n        if index == 60 {\n            return Some(RECIPE_MAKE_SINKHOLE);\n        }\n        if index == 61 {\n            return Some(RECIPE_MAKE_BEACH);\n        }\n        if index == 62 {\n            return Some(RECIPE_MAKE_WETSTONE);\n        }\n        if index == 63 {\n            return Some(RECIPE_MAKE_EROSION);\n        }\n        if index == 64 {\n            return Some(RECIPE_MAKE_BASALT);\n        }\n        if index == 65 {\n            return Some(RECIPE_MAKE_MAGMA_CHAMBER);\n        }\n        if index == 66 {\n            return Some(RECIPE_MAKE_BREEZE);\n        }\n        if index == 67 {\n            return Some(RECIPE_MAKE_WARM_BREEZE);\n        }\n        if index == 68 {\n            return Some(RECIPE_MAKE_SOIL);\n        }\n        if index == 69 {\n            return Some(RECIPE_MAKE_CANYON);\n        }\n        if index == 70 {\n            return Some(RECIPE_MAKE_WINDMILL);\n        }\n        if index == 71 {\n            return Some(RECIPE_MAKE_ADOBE);\n        }\n        if index == 72 {\n            return Some(RECIPE_MAKE_WALL);\n        }\n        if index == 73 {\n            return Some(RECIPE_MAKE_PUMICE);\n        }\n        if index == 74 {\n            return Some(RECIPE_MAKE_BARBECUE);\n        }\n        if index == 75 {\n            return Some(RECIPE_MAKE_FARM);\n        }\n        if index == 76 {\n            return Some(RECIPE_MAKE_SHARDS);\n        }\n        if index == 77 {\n            return Some(RECIPE_MAKE_MOLTEN_GLASS);\n        }\n        if index == 78 {\n            return Some(RECIPE_MAKE_PRISM);\n        }\n        if index == 79 {\n            return Some(RECIPE_MAKE_SPARKLE);\n        }\n        if index == 80 {\n            return Some(RECIPE_MAKE_DESERT);\n        }\n        if index == 81 {\n            return Some(RECIPE_MAKE_OASIS);\n        }\n        if index == 82 {\n            return Some(RECIPE_MAKE_MIRAGE);\n        }\n        if index == 83 {\n            return Some(RECIPE_MAKE_SAND_DUNE);\n        }\n        if index == 84 {\n            return Some(RECIPE_MAKE_DAM);\n        }\n        if index == 85 {\n            return Some(RECIPE_MAKE_FIREWALL);\n        }\n        if index == 86 {\n            return Some(RECIPE_MAKE_BARRICADE);\n        }\n        if index == 87 {\n            return Some(RECIPE_MAKE_PLATEAU);\n        }\n        if index == 88 {\n            return Some(RECIPE_MAKE_POND);\n        }\n        if index == 89 {\n            return Some(RECIPE_MAKE_AROMAS);\n        }\n        if index == 90 {\n            return Some(RECIPE_MAKE_FLOWER);\n        }\n        if index == 91 {\n            return Some(RECIPE_MAKE_SPORE);\n        }\n        if index == 92 {\n            return Some(RECIPE_MAKE_SPREAD);\n        }\n        if index == 93 {\n            return Some(RECIPE_MAKE_FERTILE_LAND);\n        }\n        if index == 94 {\n            return Some(RECIPE_MAKE_WETLAND);\n        }\n        if index == 95 {\n            return Some(RECIPE_MAKE_PEAT);\n        }\n        if index == 96 {\n            return Some(RECIPE_MAKE_REEDS);\n        }\n        if index == 97 {\n            return Some(RECIPE_MAKE_VALLEY);\n        }\n        if index == 98 {\n            return Some(RECIPE_MAKE_RIVER);\n        }\n        if index == 99 {\n            return Some(RECIPE_MAKE_SCORCHED_EARTH);\n        }\n        if index == 100 {\n            return Some(RECIPE_MAKE_DELTA);\n        }\n        if index == 101 {\n            return Some(RECIPE_MAKE_ESTUARY);\n        }\n        if index == 102 {\n            return Some(RECIPE_MAKE_FIRE_SWAMP);\n        }\n        if index == 103 {\n            return Some(RECIPE_MAKE_RIVERBANK);\n        }\n        if index == 104 {\n            return Some(RECIPE_MAKE_RAVINE);\n        }\n        if index == 105 {\n            return Some(RECIPE_MAKE_GORGE);\n        }\n        if index == 106 {\n            return Some(RECIPE_MAKE_CHARRED_RAVINE);\n        }\n        if index == 107 {\n            return Some(RECIPE_MAKE_ECHO);\n        }\n        if index == 108 {\n            return Some(RECIPE_MAKE_CAVE);\n        }\n        if index == 109 {\n            return Some(RECIPE_MAKE_UNDERGROUND_LAKE);\n        }\n        if index == 110 {\n            return Some(RECIPE_MAKE_LAVA_CAVE);\n        }\n        if index == 111 {\n            return Some(RECIPE_MAKE_WHISPERING_CAVE);\n        }\n        if index == 112 {\n            return Some(RECIPE_MAKE_SUBTERRANEAN_POOL);\n        }\n        if index == 113 {\n            return Some(RECIPE_MAKE_SPRING);\n        }\n        if index == 114 {\n            return Some(RECIPE_MAKE_HOT_SPRING);\n        }\n        if index == 115 {\n            return Some(RECIPE_MAKE_GROTTO);\n        }\n        if index == 116 {\n            return Some(RECIPE_MAKE_FOUNTAIN);\n        }\n        if index == 117 {\n            return Some(RECIPE_MAKE_STEAM_VENT);\n        }\n        if index == 118 {\n            return Some(RECIPE_MAKE_COOL_BREEZE);\n        }\n        if index == 119 {\n            return Some(RECIPE_MAKE_MONUMENT);\n        }\n        if index == 120 {\n            return Some(RECIPE_MAKE_WATERFALL);\n        }\n        if index == 121 {\n            return Some(RECIPE_MAKE_ETERNAL_FLAME);\n        }\n        if index == 122 {\n            return Some(RECIPE_MAKE_PILLAR_OF_WIND);\n        }\n        if index == 123 {\n            return Some(RECIPE_MAKE_STREAM);\n        }\n        if index == 124 {\n            return Some(RECIPE_MAKE_ZEPHYR);\n        }\n        if index == 125 {\n            return Some(RECIPE_MAKE_CREEK);\n        }\n        if index == 126 {\n            return Some(RECIPE_MAKE_BROOK);\n        }\n        if index == 127 {\n            return Some(RECIPE_MAKE_WHISPER);\n        }\n        if index == 128 {\n            return Some(RECIPE_MAKE_RIVULET);\n        }\n        if index == 129 {\n            return Some(RECIPE_MAKE_TRIBUTARY);\n        }\n        if index == 130 {\n            return Some(RECIPE_MAKE_MURMUR);\n        }\n        if index == 131 {\n            return Some(RECIPE_MAKE_WATERSHED);\n        }\n        if index == 132 {\n            return Some(RECIPE_MAKE_AQUIFER);\n        }\n        if index == 133 {\n            return Some(RECIPE_MAKE_PARCHED_EARTH);\n        }\n        if index == 134 {\n            return Some(RECIPE_MAKE_FRESH_BREEZE);\n        }\n        if index == 135 {\n            return Some(RECIPE_MAKE_GROUNDWATER);\n        }\n        if index == 136 {\n            return Some(RECIPE_MAKE_RESERVOIR);\n        }\n        if index == 137 {\n            return Some(RECIPE_MAKE_GEOTHERMAL_SPRING);\n        }\n        if index == 138 {\n            return Some(RECIPE_MAKE_ARTESIAN_WELL);\n        }\n        if index == 139 {\n            return Some(RECIPE_MAKE_BASIN);\n        }\n        if index == 140 {\n            return Some(RECIPE_MAKE_LAKE);\n        }\n        if index == 141 {\n            return Some(RECIPE_MAKE_DRY_BASIN);\n        }\n        if index == 142 {\n            return Some(RECIPE_MAKE_DEPRESSION);\n        }\n        if index == 143 {\n            return Some(RECIPE_MAKE_ISLAND);\n        }\n        if index == 144 {\n            return Some(RECIPE_MAKE_LAGOON);\n        }\n        if index == 145 {\n            return Some(RECIPE_MAKE_WAVE);\n        }\n        if index == 146 {\n            return Some(RECIPE_MAKE_REEF);\n        }\n        if index == 147 {\n            return Some(RECIPE_MAKE_CORAL);\n        }\n        if index == 148 {\n            return Some(RECIPE_MAKE_WHIRL);\n        }\n        if index == 149 {\n            return Some(RECIPE_MAKE_LIMESTONE);\n        }\n        if index == 150 {\n            return Some(RECIPE_MAKE_KARST);\n        }\n        if index == 151 {\n            return Some(RECIPE_MAKE_QUICKLIME);\n        }\n        if index == 152 {\n            return Some(RECIPE_MAKE_BLOWHOLE);\n        }\n        None\n    }\n\n\n    impl Default for GameContract {\n        fn default() -> Self {\n            let element_contract_ids = Mapping::new();\n            Self {\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                element_contract_ids,\n                buy_offer_price_native_tokens: 0,\n                buy_offer_reward_tier_points: 0,\n                buy_offer_is_set: false,\n                pool_round: 1,\n                pool_target: 10,\n                pool_value: 0,\n            }\n        }\n    }\n\n    impl GameContract {\n        /// Creates a new PSP-22 compatible Lava Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        /// Sets the owner of the contract\n        #[ink(message)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::OwnerAlreadySet);\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        /// Locks the contract id of an element\n        #[ink(message)]\n        pub fn lock_element_contract(&mut self, element_id: u32, element_contract_id: AccountId) -> Result<(), Error> {\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::NotTheOwner);\n            }\n            if self.element_contract_ids.contains(element_id) {\n                return Err(Error::ElementContractAlreadyLocked);\n            }\n            self.element_contract_ids.insert(element_id, &element_contract_id);\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn balance_of_element(&self, element_id: u32) -> Result<u128, Error> {\n            let element_contract_id = self.element_contract_ids.get(element_id).unwrap_or(AccountId::from([0xFF; 32]));\n            if element_contract_id == AccountId::from([0xFF; 32]) {\n                return Err(Error::ElementContractIsNotLocked);\n            }\n            let call_result = build_call::<DefaultEnvironment>()\n                .call(element_contract_id)\n                .exec_input(\n                    ExecutionInput::new(Selector::new(\n                            // Selector of PSP22::balance_of -> 0x6568382f\n                            [0x65, 0x68, 0x38, 0x2f]\n                        ))\n                        .push_arg(&self.env().caller()) // owner: AccountId parameter\n                )\n                .returns::<u128>()\n                .try_invoke();\n            match call_result {\n                Ok(okresult) => match okresult {\n                    Ok(result) => Ok(result),\n                    Err(reserr) => Err(Error::InkError(reserr))\n                },\n                Err(_) => Err(Error::FatalError(String::from(\"Error invoking PSP22::balance_of\")))\n            }\n        }\n\n        #[ink(message)]\n        pub fn set_buy_offer(&mut self, price: u128, reward_tier_points: u128) -> Result<(), Error> {\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::NotTheOwner);\n            }\n            self.buy_offer_price_native_tokens = price;\n            self.buy_offer_reward_tier_points = reward_tier_points;\n            self.buy_offer_is_set = true;\n            Ok(())\n        }\n        \n        #[ink(message)]\n        pub fn buy_offer(&self) -> Result<(u128, u128), Error> {\n            Ok((self.buy_offer_price_native_tokens, self.buy_offer_reward_tier_points))\n        }\n\n        #[ink(message)]\n        pub fn pool(&self) -> Result<(u128, u128, u128), Error> {\n            Ok((self.pool_round, self.pool_target, self.pool_value))\n        }\n\n        #[ink(message)]\n        pub fn sacrifice(&mut self, element_id: u32) -> Result<(), Error> {\n            let found_item = find_item(element_id);\n\n            if found_item.is_none() {\n                return Err(Error::InvalidElement);\n            }\n\n            let balance_of = self.balance_of_element(element_id).unwrap_or(0);\n            if balance_of == 0 {\n                return Err(Error::NotEnoughElements);\n            }\n\n            let element_contract_id = self.element_contract_ids.get(element_id).unwrap_or(AccountId::from([0xFF; 32]));\n\n            if element_contract_id == AccountId::from([0xFF; 32]) {\n                return Err(Error::ElementContractIsNotLocked);\n            }\n\n            let call_result = build_call::<DefaultEnvironment>()\n                .call(element_contract_id)\n                .call_flags(CallFlags::ALLOW_REENTRY)\n                .exec_input(\n                    ExecutionInput::new(Selector::new(\n                            // Selector of ElementContract::burn -> 0x100fa9ca\n                            [0x10, 0x0f, 0xa9, 0xca]\n                        ))\n                        .push_arg::<AccountId>(self.env().caller()) // owner: AccountId parameter\n                        .push_arg::<u128>(1) // value: u128 parameter\n                )\n                .returns::<Result<(), Error>>()\n                .try_invoke();\n            \n            match call_result {\n                Ok(okresult) => match okresult {\n                    Ok(_) => {\n                        self.pool_value = self.pool_value.checked_add(found_item.unwrap().tier.into()).unwrap_or(0);\n                        if self.pool_value >= self.pool_target {\n                            self.pool_round = self.pool_round.checked_add(1).unwrap_or(0);\n                            self.pool_value = 0;\n                            // Transfer contract value to caller\n                            self.env().transfer(self.env().caller(), self.env().balance());\n                            // Next target is last target + 10 * round\n                            self.pool_target = self.pool_target.checked_add(self.pool_round.checked_mul(10).unwrap_or(0)).unwrap_or(0);\n                        }\n                        Ok(())\n                    },\n                    Err(reserr) => Err(Error::InkError(reserr))\n                },\n                Err(fatalerr) => Err(Error::FatalError(format!(\"Error invoking ElementContract::burn: {:?}\", fatalerr)))\n            }\n        }\n\n        #[ink(message)]\n        pub fn prize(&self) -> Result<u128, Error> {\n            Ok(self.env().balance())\n        }\n\n        #[ink(message, payable)]\n        pub fn buy(&mut self, element_id: u32) -> Result<(), Error> {\n            if !self.buy_offer_is_set {\n                return Err(Error::BuyOfferIsNotSet);\n            }\n\n            let val = self.env().transferred_value();\n\n            if val < self.buy_offer_price_native_tokens {\n                return Err(Error::InsufficientBuyTransferredValue);\n            }\n\n            let buy_count = val.checked_div(self.buy_offer_price_native_tokens).unwrap_or(0);\n\n            if buy_count == 0 {\n                return Err(Error::InsufficientBuyTransferredValue);\n            }\n\n            // TODO: Add element tiers and calculate number of received items based on that\n            let reward_tier_points = self.buy_offer_reward_tier_points.checked_mul(buy_count).unwrap_or(0);\n\n            if reward_tier_points == 0 {\n                return Err(Error::FatalError(String::from(\"Error calculating reward tier points, possible overflow\")));\n            }\n\n            let element_contract_id = self.element_contract_ids.get(element_id).unwrap_or(AccountId::from([0xFF; 32]));\n\n            if element_contract_id == AccountId::from([0xFF; 32]) {\n                return Err(Error::ElementContractIsNotLocked);\n            }\n\n            let element = find_item(element_id);\n\n            if element.is_none() {\n                return Err(Error::InvalidElement);\n            }\n\n            let el = element.unwrap();\n\n            let reward_items: u128 = reward_tier_points.checked_div(el.tier.into()).unwrap_or(0);\n\n            if reward_items == 0 {\n                return Err(Error::InsufficientBuyTransferredValue);\n            }\n\n            let call_result = build_call::<DefaultEnvironment>()\n                .call(element_contract_id)\n                .call_flags(CallFlags::TAIL_CALL)\n                .exec_input(\n                    ExecutionInput::new(Selector::new(\n                            // Selector of ElementContract::mint -> 0x21615d0f\n                            [0x21, 0x61, 0x5d, 0x0f]\n                        ))\n                        .push_arg::<AccountId>(self.env().caller()) // owner: AccountId parameter\n                        .push_arg::<u128>(reward_items) // value: u128 parameter\n                )\n                .returns::<()>()\n                .try_invoke();\n            match call_result {\n                Ok(okresult) => match okresult {\n                    Ok(_) => Ok(()),\n                    Err(reserr) => Err(Error::InkError(reserr))\n                },\n                Err(fatalerr) => Err(Error::FatalError(format!(\"Error invoking ElementContract::mint: {:?}\", fatalerr)))\n            }\n        }\n\n        #[ink(message)]\n        pub fn craft(&mut self, recipe_id: u32) -> Result<(), Error> {\n            let recipe = find_recipe(recipe_id);\n\n            if recipe.is_none() {\n                return Err(Error::InvalidRecipe);\n            }\n\n            let rec = recipe.unwrap();\n\n            let element_a_index = rec.a;\n            let element_b_index = rec.b;\n            let element_c_index = rec.c;\n\n            let element_a_contract_id = self.element_contract_ids.get(element_a_index).unwrap_or(AccountId::from([0xFF; 32]));\n            let element_b_contract_id = self.element_contract_ids.get(element_b_index).unwrap_or(AccountId::from([0xFF; 32]));\n            let element_c_contract_id = self.element_contract_ids.get(element_c_index).unwrap_or(AccountId::from([0xFF; 32]));\n\n            let element_a_balance = self.balance_of_element(element_a_index).unwrap_or(0);\n            let element_b_balance = self.balance_of_element(element_b_index).unwrap_or(0);\n\n            if element_a_contract_id == AccountId::from([0xFF; 32]) || element_b_contract_id == AccountId::from([0xFF; 32]) || element_c_contract_id == AccountId::from([0xFF; 32]) {\n                return Err(Error::ElementContractIsNotLocked);\n            }\n\n            if element_a_balance == 0 || element_b_balance == 0 {\n                return Err(Error::NotEnoughElements);\n            }\n\n            // Burn calls to element contracts\n            let call_result_a = build_call::<DefaultEnvironment>()\n                .call(element_a_contract_id)\n                .call_flags(CallFlags::ALLOW_REENTRY)\n                .exec_input(\n                    ExecutionInput::new(Selector::new(\n                            // Selector of ElementContract::burn -> 0x100fa9ca\n                            [0x10, 0x0f, 0xa9, 0xca]\n                        ))\n                        .push_arg::<AccountId>(self.env().caller()) // owner: AccountId parameter\n                        .push_arg::<u128>(1) // value: u128 parameter\n                )\n                .returns::<Result<(), Error>>()\n                .try_invoke();\n            \n            let call_result_b = build_call::<DefaultEnvironment>()\n                .call(element_b_contract_id)\n                .call_flags(CallFlags::ALLOW_REENTRY)\n                .exec_input(\n                    ExecutionInput::new(Selector::new(\n                            // Selector of ElementContract::burn -> 0x100fa9ca\n                            [0x10, 0x0f, 0xa9, 0xca]\n                        ))\n                        .push_arg::<AccountId>(self.env().caller()) // owner: AccountId parameter\n                        .push_arg::<u128>(1) // value: u128 parameter\n                )\n                .returns::<Result<(), Error>>()\n                .try_invoke();\n            \n            match call_result_a {\n                Ok(okresult1) => match okresult1 {\n                    Ok(_) => (),\n                    Err(reserr1) => return Err(Error::InkError(reserr1))\n                },\n                Err(fatalerr1) => return Err(Error::FatalError(format!(\"Error invoking ElementContract::burn (1 / 3): {:?}\", fatalerr1)))\n            }\n\n            match call_result_b {\n                Ok(okresult2) => match okresult2 {\n                    Ok(_) => (),\n                    Err(reserr2) => return Err(Error::InkError(reserr2))\n                },\n                Err(fatalerr2) => return Err(Error::FatalError(format!(\"Error invoking ElementContract::burn (2 / 3): {:?}\", fatalerr2)))\n            }\n            \n            // Mint call to element contract\n            let call_result_c = build_call::<DefaultEnvironment>()\n                .call(element_c_contract_id)\n                .call_flags(CallFlags::TAIL_CALL)\n                .exec_input(\n                    ExecutionInput::new(Selector::new(\n                            // Selector of ElementContract::mint -> 0x21615d0f\n                            [0x21, 0x61, 0x5d, 0x0f]\n                        ))\n                        .push_arg::<AccountId>(self.env().caller()) // owner: AccountId parameter\n                        .push_arg::<u128>(1) // value: u128 parameter\n                )\n                .returns::<Result<(), Error>>()\n                .try_invoke();\n    \n            match call_result_c {\n                Ok(okresult3) => match okresult3 {\n                    Ok(_) => Ok(()),\n                    Err(reserr3) => Err(Error::InkError(reserr3))\n                },\n                Err(fatalerr3) => Err(Error::FatalError(format!(\"Error invoking ElementContract::mint (3 / 3): {:?}\", fatalerr3)))\n            }\n            \n        }\n    }\n\n}",
      "contentHash": "df5c118407031f29172f4fd91fc59d8a43fa7b241f9e695cc04f3bbafcef7ac5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-ember/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-ember/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-ember\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Ember'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "2703a7ad435cfe7e9cc9846f3f22bce88b1e4a6f6cda38615cc3613bfb5c3647",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-ember/README.md",
      "content": "# Ember - Contract\n\nThis is a Ember contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "34b9b87b147a04f3c245702554936ea5294e3112e799f0e0b8aefcc131415fbe",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-ember/src/Cargo.toml",
      "content": "[package]\nname = \"ember\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "9e951fd4ff7590797631373116916c4c032be5c9bdd36ab124cf6cddaca13c3d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-ember/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod ember {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Ember' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct EmberContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for EmberContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl EmberContract {\n        /// Creates a new PSP-22 compatible Ember Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Ember\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MEMBER\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "43f34e995d6fd2619b4258ab27c695915ce95e81880ecd651dae79a4d5c73019",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-erosion/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-erosion/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-erosion\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Erosion'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "09f4eed16ec69b52bdbed70893abea337e0058a944b1fd5fa34b04d2866a7a07",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-erosion/README.md",
      "content": "# Erosion - Contract\n\nThis is a Erosion contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "a71ef5d17e79ab27a44eea7c233106ac8ad231e124727c61bf847933d2aef6d0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-erosion/src/Cargo.toml",
      "content": "[package]\nname = \"erosion\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "e5f4956e00e57397d2ec09d8566d2e1de1c7834797ff4aeb245110108939c5e5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-erosion/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod erosion {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Erosion' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct ErosionContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for ErosionContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl ErosionContract {\n        /// Creates a new PSP-22 compatible Erosion Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Erosion\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MEROSION\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "53ebdf0c3e22e208fe21c3dbfef81f99322859d99a393ef2b0eabb1f7086b989",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-estuary/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-estuary/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-estuary\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Estuary'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "ea08c9fb8c2b1c760834fa154c5f7574b91b5495fa05bdce478cac98a20e4cb6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-estuary/README.md",
      "content": "# Estuary - Contract\n\nThis is a Estuary contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "e228cc5940db3bec1b8bd6b17fe724655c77a940603034eedfde1137ab9f35f7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-estuary/src/Cargo.toml",
      "content": "[package]\nname = \"estuary\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "4dd8e5b080b1e1f17ae293e2864159cf1c575da05bf25e2a553abacf5408b858",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-estuary/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod estuary {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Estuary' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct EstuaryContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for EstuaryContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl EstuaryContract {\n        /// Creates a new PSP-22 compatible Estuary Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Estuary\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MESTUARY\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "33f1d6a0a3b3006cd3d020e800e1c027f41081aaf9c0e1a8c6fbf2b42fc15957",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-eternal-flame/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-eternal-flame/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-eternal-flame\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'EternalFlame'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "4510498bd912f1af62bd0b2d84585201c9eb1cdcb9ae92fc3847e9638078da16",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-eternal-flame/README.md",
      "content": "# Eternal Flame - Contract\n\nThis is a Eternal Flame contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "72a1e3366e821b57a9584fff99641f52158e1e86b4814df63a5db9b9436ac730",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-eternal-flame/src/Cargo.toml",
      "content": "[package]\nname = \"eternal_flame\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "c61e98f409ca02a7f6de002c58ac3ba3382879a684b8351311e7f1ce9f2a75d2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-eternal-flame/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod eternal_flame {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Eternal Flame' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct EternalFlameContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for EternalFlameContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl EternalFlameContract {\n        /// Creates a new PSP-22 compatible Eternal Flame Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Eternal Flame\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"METERNAL_FLAME\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "b074e82c2b2c27525e4a14a84a2c24a93fbabbca9bf74b03436abb5325617539",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-farm/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-farm/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-farm\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Farm'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "c4a196b4408ae1d8d08b2245e482f572ea7e4b22a95cea860aab972b5b8ac4b1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-farm/README.md",
      "content": "# Farm - Contract\n\nThis is a Farm contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "3842cc5029918d7defeb489091e56159db8fa7fe98d4f1c9c6e4e0967b6360dc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-farm/src/Cargo.toml",
      "content": "[package]\nname = \"farm\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "0f730192837250cb2fde15ae1564baa767dc464ce3a7b09eccbd52b393dd4009",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-farm/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod farm {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Farm' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct FarmContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for FarmContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl FarmContract {\n        /// Creates a new PSP-22 compatible Farm Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Farm\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MFARM\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "52bf044004900ba61a969b2bbc906df444ee28bac682ffab15e1a87971d2b4ce",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fertile-land/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fertile-land/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-fertile-land\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'FertileLand'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "f95379fbb60ad6174b7ab15cbc630586ab502cc361c104fa7da51eac4a58dc7b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fertile-land/README.md",
      "content": "# Fertile Land - Contract\n\nThis is a Fertile Land contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "a2f29246a0a6079f9860a236ff5934572edab7e877fb33fb7e78032dbfc98e0e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fertile-land/src/Cargo.toml",
      "content": "[package]\nname = \"fertile_land\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "8f8855e22cfceaa37325f55a95120ba9d22bd53f5a50bbf0c8330831bd79f5ce",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fertile-land/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod fertile_land {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Fertile Land' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct FertileLandContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for FertileLandContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl FertileLandContract {\n        /// Creates a new PSP-22 compatible Fertile Land Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Fertile Land\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MFERTILE_LAND\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "0539c51e2198581236a6a8f81e5e586f911497d28a94e7b35a7ce0c0fc778b8a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fertilizer/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fertilizer/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-fertilizer\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Fertilizer'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "1b6c0a3d7a3034aa866c3afd9f2143ab0b80b17d81a42c47ef3372b4b0354c16",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fertilizer/README.md",
      "content": "# Fertilizer - Contract\n\nThis is a Fertilizer contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "0fec6f331033bd81d58d7e0a23a26dc2c91f294dae3d1dcc7eef81f39f31f5d5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fertilizer/src/Cargo.toml",
      "content": "[package]\nname = \"fertilizer\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "f72ccea02d963fa93fe2f40c10d5ed2f654dcb8ccd541d4680ce7326e8d30aad",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fertilizer/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod fertilizer {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Fertilizer' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct FertilizerContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for FertilizerContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl FertilizerContract {\n        /// Creates a new PSP-22 compatible Fertilizer Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Fertilizer\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MFERTILIZER\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "9af3e0e595db13c055edf54dc36ce981ace4916cafb6b521f9d5374cf477bc05",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fire-swamp/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fire-swamp/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-fire-swamp\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'FireSwamp'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "a5046f2d5df286c0a9c07617395f3fb2749cf08a0d13dcc31dd38105fa647f77",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fire-swamp/README.md",
      "content": "# Fire Swamp - Contract\n\nThis is a Fire Swamp contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "99f15cdcc88679768ad8d47c1008b469f4bf03671ca3770d399fd6b7e30be19b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fire-swamp/src/Cargo.toml",
      "content": "[package]\nname = \"fire_swamp\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "b7a3272605ffe8154a4d94f3ec72d82aa247aee50a465b5360098204449d2ef7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fire-swamp/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod fire_swamp {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Fire Swamp' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct FireSwampContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for FireSwampContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl FireSwampContract {\n        /// Creates a new PSP-22 compatible Fire Swamp Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Fire Swamp\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MFIRE_SWAMP\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "a0d74f5d286a17277f52c8d4e0e937eb4edcbf037a10251b96dedc9659c39faf",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fire/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fire/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-fire\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Fire'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "e8c665d7ea2ade4e5ac672b7b286a119d49816e3b6a973ff45dddd69e89ef47d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fire/README.md",
      "content": "# Fire - Contract\n\nThis is a Fire contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "fb244d7c22082eab97129bac506b811223a18ebf2978aa827f2b85ce67a57723",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fire/src/Cargo.toml",
      "content": "[package]\nname = \"fire\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "9520e61b9f13f56d2ba329c527b622fda115a62c838d3a98a45336964f2f38e2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fire/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod fire {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Fire' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct FireContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for FireContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl FireContract {\n        /// Creates a new PSP-22 compatible Fire Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Fire\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MFIRE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "d5a0870423c235a6bfd5374ee6f9124c76773dc839e8cf91a9bd1e60dcc1ff20",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-firewall/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-firewall/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-firewall\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Firewall'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "6c4c993202e42aa1e163a6058b08638aa4b50b3b9e62d3bffde91c0399b2c5c8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-firewall/README.md",
      "content": "# Firewall - Contract\n\nThis is a Firewall contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "12f841420b26c69093ed64a1e215368d62fad11bb50fd27e7b7ba42b3ee1ce78",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-firewall/src/Cargo.toml",
      "content": "[package]\nname = \"firewall\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "39d57f04b40db4e18ad025d10c3416ab7348585201b2453da1108f0e4a640325",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-firewall/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod firewall {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Firewall' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct FirewallContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for FirewallContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl FirewallContract {\n        /// Creates a new PSP-22 compatible Firewall Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Firewall\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MFIREWALL\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "72416225e84e48aa4b79094e85b92d2c52f55f47ff75ee6b19dd96422cbb6dde",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-flood/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-flood/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-flood\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Flood'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "967dd9f18be705fdd59105cd9efa15311f713a2a597b5619736c055fb0df425a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-flood/README.md",
      "content": "# Flood - Contract\n\nThis is a Flood contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "49d85dd491127862da4da376a39753ee3a1a6ff950cba197cb1af39ab537a302",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-flood/src/Cargo.toml",
      "content": "[package]\nname = \"flood\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "d9f51eb11eb2fc04cd739d8ce88845be65f6c31ac0ca4d495cf9e583c4422028",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-flood/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod flood {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Flood' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct FloodContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for FloodContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl FloodContract {\n        /// Creates a new PSP-22 compatible Flood Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Flood\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MFLOOD\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "ee8c799603e0a6b37950c96c522c7363f91447638fd2731689bfbbbc0a2f39bc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-flower/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-flower/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-flower\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Flower'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "8c18d2e96a72661eff63a5c0f8b12644eaf968bae1fa977d871ae733a8c163bf",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-flower/README.md",
      "content": "# Flower - Contract\n\nThis is a Flower contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "001b9a3bbc69dec3272b0a536ecb57e1fef3463fad0c6ec1947cb9d1355c64a1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-flower/src/Cargo.toml",
      "content": "[package]\nname = \"flower\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "2a8b7b36daac405e24a93d97665111a1cc987cc8a9df6f8bba9639c53ba5f000",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-flower/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod flower {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Flower' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct FlowerContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for FlowerContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl FlowerContract {\n        /// Creates a new PSP-22 compatible Flower Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Flower\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MFLOWER\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "f8849719c1fe3a423c2748a0564fab75fe629584d330a8879d31d1fad907f0e1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fog/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fog/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-fog\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Fog'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "37ee64e82e9a23d0088e9c093d769f596a09ccf2d08e464bb9c12a54cc8c68af",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fog/README.md",
      "content": "# Fog - Contract\n\nThis is a Fog contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "79ee2f43469cc1d6ed489603d4ef0bce49facd71cc9c0255f3f83733d9ac4a36",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fog/src/Cargo.toml",
      "content": "[package]\nname = \"fog\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "49f73c96f1cd2986e92a641b8751c86e8d5b01534598a65f64ec2f78dd21692f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fog/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod fog {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Fog' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct FogContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for FogContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl FogContract {\n        /// Creates a new PSP-22 compatible Fog Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Fog\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MFOG\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "0cf1145e29335847ef15bda4d67ab714f1afa1334aac8594ba762c8af9fb2003",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-forest/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-forest/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-forest\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Forest'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "eb8c3af05e020dfebbac2628a7561ac8620e3d341922d0a407bc45cb7cabf54b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-forest/README.md",
      "content": "# Forest - Contract\n\nThis is a Forest contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "203a7de20d1839ea37126d554ca905ed3ab9beca549a960ccb44e855b97e7fcd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-forest/src/Cargo.toml",
      "content": "[package]\nname = \"forest\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "3f039f079e9a74b3ea083138edcb65a3b430b889ea847719132a01aee6a8b387",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-forest/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod forest {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Forest' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct ForestContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for ForestContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl ForestContract {\n        /// Creates a new PSP-22 compatible Forest Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Forest\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MFOREST\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "baceaca29a2a804801c546155d9bd289ebbb935d98e3e9206c43061f858b41c4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fountain/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fountain/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-fountain\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Fountain'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "cca4b58f6dfe9e1e70708731690522bdc4c4e1c522ee8266b6964289f27c8a90",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fountain/README.md",
      "content": "# Fountain - Contract\n\nThis is a Fountain contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "47f5c5f5eabec4acb0011b847f701cb8df56b71da31046909af2dbffb40d34d2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fountain/src/Cargo.toml",
      "content": "[package]\nname = \"fountain\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "1d67ab0e68f257746f0b340b043d7b6b666c2067da88ed20d8134106c5a7af29",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fountain/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod fountain {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Fountain' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct FountainContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for FountainContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl FountainContract {\n        /// Creates a new PSP-22 compatible Fountain Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Fountain\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MFOUNTAIN\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "04faec224d9c28c9436bd7de0e04528292a0ce46f707b103d087b15a657f93c4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fresh-breeze/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fresh-breeze/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-fresh-breeze\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'FreshBreeze'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "59c59c607f1f3674e033405c4f7f68c964a30f071ab14b33bf8696f5b650cc61",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fresh-breeze/README.md",
      "content": "# Fresh Breeze - Contract\n\nThis is a Fresh Breeze contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "e1615ff69ba5bf8da08f2f959cbb4c10f004ccf8c30837095c4cebc75f210580",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fresh-breeze/src/Cargo.toml",
      "content": "[package]\nname = \"fresh_breeze\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "791bdc86e90ba7fab239900fbdba0ee1fb534acbce47e19040ccaab71044626f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fresh-breeze/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod fresh_breeze {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Fresh Breeze' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct FreshBreezeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for FreshBreezeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl FreshBreezeContract {\n        /// Creates a new PSP-22 compatible Fresh Breeze Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Fresh Breeze\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MFRESH_BREEZE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "a48ba073d54e852670bf06822ccdd4356584c6365f783e61df12519c427b32c6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-frosted-glass/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-frosted-glass/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-frosted-glass\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'FrostedGlass'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "ac05c173828063ebae9be1ff54b4c886593fa1dea0e11eab3f52e6975154eb31",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-frosted-glass/README.md",
      "content": "# Frosted Glass - Contract\n\nThis is a Frosted Glass contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "aa330228971631be238ac2754645a96c6d71a43569893ffaf7441a51e74ef3c4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-frosted-glass/src/Cargo.toml",
      "content": "[package]\nname = \"frosted_glass\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "96c9136ac0d774c5d4348176c15bdaaf74b4f0d0b63635171f4cf71cc51e9394",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-frosted-glass/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod frosted_glass {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Frosted Glass' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct FrostedGlassContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for FrostedGlassContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl FrostedGlassContract {\n        /// Creates a new PSP-22 compatible Frosted Glass Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Frosted Glass\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MFROSTED_GLASS\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "4244137d952fbdfa4e60d1350d4fd9b67cbf14c48e58f64c907bc538c4bff769",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-garden/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-garden/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-garden\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Garden'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "1729c35bac31818252c800e0938045a85552c706750835cf58c67cbdfa2acb58",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-garden/README.md",
      "content": "# Garden - Contract\n\nThis is a Garden contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "54eb34def0fa686ff0d16590add5cfa4efa10c57d8545f7f78e0b5af77e10412",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-garden/src/Cargo.toml",
      "content": "[package]\nname = \"garden\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "04c3a6f1a2b2ca65c0f83f24307dbd265d7d6db56267ac08065aa77b3cf70301",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-garden/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod garden {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Garden' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct GardenContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for GardenContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl GardenContract {\n        /// Creates a new PSP-22 compatible Garden Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Garden\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MGARDEN\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "e35cefe15b177c03e38c1116d89f968f8cc4d8cc8b7c93675ed727b0eee59125",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-geothermal-spring/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-geothermal-spring/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-geothermal-spring\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'GeothermalSpring'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "5ed64ecfd11d927e6cadd1e7b68a3e9bb5dbbd5ee428c5c8df010d4ca8e97381",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-geothermal-spring/README.md",
      "content": "# Geothermal Spring - Contract\n\nThis is a Geothermal Spring contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "222c5b42603d168d7c3afbfa27ee46ab178011b14d870d95fe129268091231f2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-geothermal-spring/src/Cargo.toml",
      "content": "[package]\nname = \"geothermal_spring\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "a5a1d03b15e37b700b4f620193f49bcb4945982eeeeb22b0a12f7e31819683ae",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-geothermal-spring/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod geothermal_spring {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Geothermal Spring' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct GeothermalSpringContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for GeothermalSpringContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl GeothermalSpringContract {\n        /// Creates a new PSP-22 compatible Geothermal Spring Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Geothermal Spring\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MGEOTHERMAL_SPRING\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "7f9151d14fada84e6006057f8d8f0ba716d6f714c13c871e195621fbe836fea6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-geyser/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-geyser/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-geyser\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Geyser'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "0883e775f2e586b424d40fce379bd0c91d44f94ce596584ddc5d619576043107",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-geyser/README.md",
      "content": "# Geyser - Contract\n\nThis is a Geyser contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "e41613cb6a08235833d7b4e3d5ae1ff028487ca87d220d01f42c934882b27f21",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-geyser/src/Cargo.toml",
      "content": "[package]\nname = \"geyser\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "223d610baf5dc1480cc01069b1fa57e2ff2d7efb461140cc46d4978290a255e9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-geyser/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod geyser {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Geyser' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct GeyserContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for GeyserContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl GeyserContract {\n        /// Creates a new PSP-22 compatible Geyser Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Geyser\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MGEYSER\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "0960c7a560560a2e27e9def99e59fec1f6634134bc37bf248f9df819f3d0990f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-giraffe/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-giraffe/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-giraffe\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Giraffe'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "9ab37aa292aea97759eb079afc0a1ed13cbbe07c2146a9c1c9a66437b8a0647c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-giraffe/README.md",
      "content": "# Giraffe - Contract\n\nThis is a Giraffe contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "ccfc0ee2c15d5195774e45cd40e7ff8df5eca00da502cc996a2b5c26757ea7a8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-giraffe/src/Cargo.toml",
      "content": "[package]\nname = \"giraffe\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "dd2c9f669ee88d2a3c3fa2d9bcd351cff275320990a81c87a55b38d68c80ff10",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-giraffe/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod giraffe {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Giraffe' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct GiraffeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for GiraffeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl GiraffeContract {\n        /// Creates a new PSP-22 compatible Giraffe Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Giraffe\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MGIRAFFE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "97471cd37cff0add32955f7bb977a44a2d706dcc2ffb827144ef20d75b0a5c7e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-glass/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-glass/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-glass\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Glass'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "45c1eccfa1e43f6165685b9f28ad81e28bda3939fce18974019ca71c59fec0f2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-glass/README.md",
      "content": "# Glass - Contract\n\nThis is a Glass contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "d5de2dc723ca3a54e1d29b2d8433a2e24d610a07cc823625651ccc3f9b2d3cc2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-glass/src/Cargo.toml",
      "content": "[package]\nname = \"glass\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "7ef2070cd4cd939d35c5b8af549b652ddbc6d2fc52bd55731ad1d7d988d28263",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-glass/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod glass {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Glass' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct GlassContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for GlassContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl GlassContract {\n        /// Creates a new PSP-22 compatible Glass Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Glass\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MGLASS\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "c10725e48a4d62481d828a9ae11d32c39b111a7e02d996c5e7d9053907909595",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-gold/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-gold/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-gold\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Gold'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "f11aa5053c746bfe2fdacafa76749ec8151de17909ceda192f5037ca4a35789b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-gold/README.md",
      "content": "# Gold - Contract\n\nThis is a Gold contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "bd6c32971670789fc6782a9cfe64761d704716d704be3802ef74930e5f6c5038",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-gold/src/Cargo.toml",
      "content": "[package]\nname = \"gold\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "4744d485a69314636ce0e6d4696b8cf4ef151005920d947d59d4f9f8419e0bb2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-gold/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod gold {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Gold' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct GoldContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for GoldContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl GoldContract {\n        /// Creates a new PSP-22 compatible Gold Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Gold\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MGOLD\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "1bf31f1ecfc78be555541f6e8ef6c1c49bb7f6baad45650add82608c72cff88d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-golden-gate/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-golden-gate/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-golden-gate\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'GoldenGate'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "b95c1f9f8e48798c34791591167ab62fb6d5395b13c049c90ea8a8d24db4cedb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-golden-gate/README.md",
      "content": "# Golden Gate - Contract\n\nThis is a Golden Gate contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "2436b3d78ddb405503a92f275f5f64eb733ac9dd7eff43259f7a830c4424f382",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-golden-gate/src/Cargo.toml",
      "content": "[package]\nname = \"golden_gate\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "45e0b56582c45d117111235d4157c37653da5ead7f7bdd653adcca73648bdaf6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-golden-gate/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod golden_gate {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Golden Gate' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct GoldenGateContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for GoldenGateContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl GoldenGateContract {\n        /// Creates a new PSP-22 compatible Golden Gate Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Golden Gate\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MGOLDEN_GATE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "9897ef5a7fc3b7a294d5e1284d75a20b28f3f249bf7d4e7cd26f929fb7811397",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-gorge/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-gorge/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-gorge\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Gorge'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "c6de8937532e770ff293334115cc316b5628dcd9e76cce493ce4b0172c27ba91",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-gorge/README.md",
      "content": "# Gorge - Contract\n\nThis is a Gorge contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "a12477c8a9cb818b5de23fb675ad7b94ec2fda0c6b1f826803665a2f003cda64",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-gorge/src/Cargo.toml",
      "content": "[package]\nname = \"gorge\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "233f8f7c0a3666bce3a372506e731b3937fa7f0a5d6fa1bdbaffe1ce97b13d84",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-gorge/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod gorge {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Gorge' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct GorgeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for GorgeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl GorgeContract {\n        /// Creates a new PSP-22 compatible Gorge Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Gorge\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MGORGE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "c0f3912919dd8d96b83129b710fbc184b1db905a33da1a786d0443583704df18",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-grotto/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-grotto/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-grotto\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Grotto'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "1bbf0af374d6c94e118ebc98365da8c87da98994ea725a0412f66a19b932953b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-grotto/README.md",
      "content": "# Grotto - Contract\n\nThis is a Grotto contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "069589a7b219c29989353f16b5f848c5ac72d4600aaf556a88cd826a08b37c1e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-grotto/src/Cargo.toml",
      "content": "[package]\nname = \"grotto\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "d3e22923d43be74172cc9af66d09c28b98028dcaa1341e86709dc867693e51c1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-grotto/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod grotto {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Grotto' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct GrottoContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for GrottoContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl GrottoContract {\n        /// Creates a new PSP-22 compatible Grotto Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Grotto\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MGROTTO\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "753671004e4ccedaa6e75df4cdd8a419c13dee4435d10358b3662bf4d60f2afd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-groundwater/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-groundwater/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-groundwater\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Groundwater'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "1f12c852166eb24dff7f0f015e3571235b2dc28bec573f0954f8c54354a91795",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-groundwater/README.md",
      "content": "# Groundwater - Contract\n\nThis is a Groundwater contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "b08d0d193cdb00701625ea988cf8279d2a7f25671ea476dd7952e7a439cc7b4f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-groundwater/src/Cargo.toml",
      "content": "[package]\nname = \"groundwater\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "07996e0bc4dba9adbc5dc79789612b6f3e04831dfbbd4628b409332c03fed0d0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-groundwater/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod groundwater {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Groundwater' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct GroundwaterContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for GroundwaterContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl GroundwaterContract {\n        /// Creates a new PSP-22 compatible Groundwater Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Groundwater\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MGROUNDWATER\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "24e856e7e66caeee7704aad592c3e234222ce4bca3cca9cf4b9ef6edb582af25",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-haze/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-haze/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-haze\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Haze'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "8d777f7fe3d005a4b599448042bb6fb6f6e97e8169ffc36d2170c4fe133c7ba2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-haze/README.md",
      "content": "# Haze - Contract\n\nThis is a Haze contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "6334f8f94193034de12c17773d31271ca2f1dbb37299ed04101dd6532ef415a9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-haze/src/Cargo.toml",
      "content": "[package]\nname = \"haze\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "594742b5316b6f82a2c1a64a56ef27fcb8b76709b6422408b092b087a020de4c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-haze/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod haze {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Haze' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct HazeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for HazeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl HazeContract {\n        /// Creates a new PSP-22 compatible Haze Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Haze\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MHAZE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "fdd0191d032e07dc2b0af9588ecc7fbad8af1cc665e5f580d8317a2c62e8bbe4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hive/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hive/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-hive\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Hive'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "cde7ec20c8f10435404d021925ec77007917a7799215340fb137b4df5d399a4c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hive/README.md",
      "content": "# Hive - Contract\n\nThis is a Hive contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "5d576fb4fe865a41e413953672d12eeaa28ccfee5e18ab4147e746a45ebb1838",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hive/src/Cargo.toml",
      "content": "[package]\nname = \"hive\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "d2605dfba42a28e60498eec922d6552b3969807793e9ca93959a86ae9416ff07",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hive/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod hive {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Hive' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct HiveContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for HiveContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl HiveContract {\n        /// Creates a new PSP-22 compatible Hive Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Hive\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MHIVE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "75a37fd20ceeef476e2a4d0211bca5cb91ce270bfccd24f0423de052e67582f3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hot-spring/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hot-spring/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-hot-spring\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'HotSpring'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "14f5fa1c200ad05032f79fc413080bedce6dc5c747f9d103290da678ddde40e3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hot-spring/README.md",
      "content": "# Hot Spring - Contract\n\nThis is a Hot Spring contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "22fe285ea5c4fce66377d5991c4f17a463c287073dc75553763ba4b0449ba42b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hot-spring/src/Cargo.toml",
      "content": "[package]\nname = \"hot_spring\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "d46cd78328389bc5a5849a64f6701cdb259bdadbb9134310e42070eb56bc7a6f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hot-spring/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod hot_spring {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Hot Spring' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct HotSpringContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for HotSpringContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl HotSpringContract {\n        /// Creates a new PSP-22 compatible Hot Spring Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Hot Spring\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MHOT_SPRING\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "24174684cdd14f20034e029cd5e088024ee2687673128d2956fb8caed72d93c3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hydra/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hydra/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-hydra\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Hydra'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "d5c05fa62915939b813e1f02a41a0e99aec48e5975679a2b4743c975b61ee065",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hydra/README.md",
      "content": "# Hydra - Contract\n\nThis is a Hydra contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "fc131ebe193171c5b792e3af19b11f593e30fdcd7855e412b6c271bff00890e3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hydra/src/Cargo.toml",
      "content": "[package]\nname = \"hydra\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "0caaa876a93b04705396fb01474a007f16eb92f9e0848e7db129845bbfcb646f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hydra/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod hydra {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Hydra' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct HydraContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for HydraContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl HydraContract {\n        /// Creates a new PSP-22 compatible Hydra Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Hydra\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MHYDRA\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "554fd625c7aad4eb6923da13783e140e5266b806e7ca2ef8a0ed536cbae5f8c4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hyper-marmalade/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hyper-marmalade/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-hyper-marmalade\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'HyperMarmalade'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "8feef154feadcea3438aa5d5f49d5fab1de4c7c1fec641a2b776f9f2a4b4d52a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hyper-marmalade/README.md",
      "content": "# Hyper Marmalade - Contract\n\nThis is a Hyper Marmalade contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "9d06bbac58e86b35bc35d412b23ca687f9b06a58bbd7e9e41d52034816ec2d18",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hyper-marmalade/src/Cargo.toml",
      "content": "[package]\nname = \"hyper_marmalade\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "6d473bef655c2a15d2c817b95b09af4d9182e61d3672757513c0ecc762ae2cec",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hyper-marmalade/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod hyper_marmalade {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Hyper Marmalade' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct HyperMarmaladeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for HyperMarmaladeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl HyperMarmaladeContract {\n        /// Creates a new PSP-22 compatible Hyper Marmalade Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Hyper Marmalade\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MHYPER_MARMALADE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "632ce0e3cef50b80ce0e930e8bc72c4c3b2cee400a9e2929ddccec20736679b1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-island/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-island/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-island\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Island'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "a5c39f71ca7ffe47e057a5f6003b1ffde6dda7c4e261b5483da114722e86e6cf",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-island/README.md",
      "content": "# Island - Contract\n\nThis is a Island contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "4ff834328d416bf1b48eefddfff53e441a9b3501382508adfac68da5342b1346",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-island/src/Cargo.toml",
      "content": "[package]\nname = \"island\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "28761f231d714b09eaf58c097695c9d6a8103a538070492faed94128a9de5f87",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-island/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod island {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Island' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct IslandContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for IslandContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl IslandContract {\n        /// Creates a new PSP-22 compatible Island Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Island\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MISLAND\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "315a7172e6ad180f74cbf9d2027da2f4a4b1731a9c588977bab2ed3efbf427ae",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-jungle/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-jungle/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-jungle\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Jungle'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "836af793d262e05a4709f899f7a86c1b7628c391e09478492f5861be80faccff",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-jungle/README.md",
      "content": "# Jungle - Contract\n\nThis is a Jungle contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "658f3d071d0c07901f13bd51ba87a0f8fd4896e710223f16996b9c10db7817ab",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-jungle/src/Cargo.toml",
      "content": "[package]\nname = \"jungle\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "cfcfde4cb693b226fadd45779e9af35a77be7a16a9fbdee0effebda5002a6608",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-jungle/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod jungle {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Jungle' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct JungleContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for JungleContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl JungleContract {\n        /// Creates a new PSP-22 compatible Jungle Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Jungle\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MJUNGLE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "aaeb7eda2b82d5c914737f1a6e43dc69c7c36bbdbd9e363cf8fb78d998837302",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-karst/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-karst/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-karst\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Karst'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "0d29714324aa357adff658c0db09db771c2b030b5591f8ccd3a60c4db1ea2826",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-karst/README.md",
      "content": "# Karst - Contract\n\nThis is a Karst contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "d7546fc73c28f84f19078f729358d5bf3fb1d071af997bc1ea08594691652cdf",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-karst/src/Cargo.toml",
      "content": "[package]\nname = \"karst\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "f6f7eeb614d7c8cc7a3d92595b71e25be09e9df7f7e454bcafe02be9f72b7efc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-karst/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod karst {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Karst' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct KarstContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for KarstContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl KarstContract {\n        /// Creates a new PSP-22 compatible Karst Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Karst\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MKARST\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "848fd10932816fdcbbb185b44645457153bc3809b870f1fd193fe3b724f89be6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-kiln/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-kiln/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-kiln\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Kiln'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "81a197797505b332edef2305e6d0f195e9d1d7441caea692f4b37254d6378167",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-kiln/README.md",
      "content": "# Kiln - Contract\n\nThis is a Kiln contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "ec232e7bccc90420b2e4d3e033623c4a990ed03d61814757870f5e060ae2b29c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-kiln/src/Cargo.toml",
      "content": "[package]\nname = \"kiln\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "2c0c549d8c158d7a4512d8d1ca084458b8809e62469f2c0f3af4fdc02ea330d5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-kiln/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod kiln {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Kiln' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct KilnContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for KilnContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl KilnContract {\n        /// Creates a new PSP-22 compatible Kiln Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Kiln\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MKILN\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "80c109874b1832f78fd35bc5a4d5e28dcf49b257e6af8ad90b81440ba22dd28a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lagoon/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lagoon/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-lagoon\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Lagoon'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "7180b7cc7cef9b9ab8986079dae562a7293fd80234e8e97ff3e2fcd85b08dc4a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lagoon/README.md",
      "content": "# Lagoon - Contract\n\nThis is a Lagoon contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "c8569328fd795299fb928a79e8f1873783209058f3acd60e6d73b7461c50eb0e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lagoon/src/Cargo.toml",
      "content": "[package]\nname = \"lagoon\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "a436d7eb1116d764c9c4fc56c925c229dcaa79cbe25be3c0f5b25ef53fba5911",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lagoon/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod lagoon {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Lagoon' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct LagoonContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for LagoonContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl LagoonContract {\n        /// Creates a new PSP-22 compatible Lagoon Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Lagoon\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MLAGOON\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "72e5a43fb2069853f354989ffd0ac74bc5710736ad1025b1a8aa8f693c3e3523",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lake/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lake/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-lake\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Lake'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "123beb96842eb62ce09e5809f77555850a9c0f57cb8ce7c330134566a7eb6c7b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lake/README.md",
      "content": "# Lake - Contract\n\nThis is a Lake contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "6941cd795e530047e82ddd9e9e150e6419cc86d322165bd51953721a60d93faa",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lake/src/Cargo.toml",
      "content": "[package]\nname = \"lake\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "eec61c8d9d2ef33a0797ea55e494309afd72117d59d1c00935e62c20a3afff1e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lake/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod lake {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Lake' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct LakeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for LakeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl LakeContract {\n        /// Creates a new PSP-22 compatible Lake Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Lake\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MLAKE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "a5491b25aa9e5126fc02d187075dc473c27db7afb4b8448d9980c83860e7fc3f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-landslide/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-landslide/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-landslide\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Landslide'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "66a661ab746f273cc7f063a420748e6e156baa743fa5a5f91bd1289b51988688",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-landslide/README.md",
      "content": "# Landslide - Contract\n\nThis is a Landslide contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "2b1a0506c885f9e131a993e809d3e3b6f1aedb605cf42797596c421a7ec6ec74",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-landslide/src/Cargo.toml",
      "content": "[package]\nname = \"landslide\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "4b084e577ca2d85112ba44627016baf952cc787269ecf27e92af17652ee6d1bb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-landslide/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod landslide {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Landslide' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct LandslideContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for LandslideContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl LandslideContract {\n        /// Creates a new PSP-22 compatible Landslide Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Landslide\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MLANDSLIDE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "dbd40fc89bc4e0258d4889229af6c0882c9ac78b9e5e52533d8fe95ff23e96c7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lava-cave/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lava-cave/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-lava-cave\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'LavaCave'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "4c4f5aeaf156fbac044aed4e9fdb99e2b7f468a6dee0ab39de276a3eb3b9bae3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lava-cave/README.md",
      "content": "# Lava Cave - Contract\n\nThis is a Lava Cave contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "de539e688fcf9f6fcb4ecae55535683ed7aaa8ff35f48b3e6f5f1ec2dd26500e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lava-cave/src/Cargo.toml",
      "content": "[package]\nname = \"lava_cave\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "6d04b2d01c48b3a402504d4a2b4321f02c226086416ce83fc3d93b6d6379e0c5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lava-cave/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod lava_cave {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Lava Cave' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct LavaCaveContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for LavaCaveContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl LavaCaveContract {\n        /// Creates a new PSP-22 compatible Lava Cave Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Lava Cave\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MLAVA_CAVE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "fb02bd96e522e9a2eeb09732ae7cd6428cba01b3e5e36a35d3d104bb678661ae",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lava/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lava/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-lava\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Lava'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "e22ea3fe3e5226fddd95bbb6ab3ac26199365b1a7079beb9a17149034a5efe7f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lava/README.md",
      "content": "# Lava - Contract\n\nThis is a Lava contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "692aae091c4f83adbe2f763c0421a7b90597aeab349b35df84696a3b53e6683e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lava/src/Cargo.toml",
      "content": "[package]\nname = \"lava\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "cf4e4458d2d341a7314d99f5f2bb600b3ecfb6d3ec4a650d0f7dd203873364c7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lava/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod lava {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Lava' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct LavaContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for LavaContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl LavaContract {\n        /// Creates a new PSP-22 compatible Lava Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Lava\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MLAVA\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "924f50b020f00179abaf0f54b1f4689cb5a379a1eb012955808ddd5a26d76afa",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-leaves/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-leaves/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-leaves\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Leaves'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "a02d1783e7a8e7580d3686117661aad4c635948a4b3b3abf5410f31000268334",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-leaves/README.md",
      "content": "# Leaves - Contract\n\nThis is a Leaves contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "4060fed2253b0791883eb510600f8b3f82307d33409dc282d7ae397f95db4de1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-leaves/src/Cargo.toml",
      "content": "[package]\nname = \"leaves\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "2cbfb70a76f069b87f3b6545fa68daf71e1bcb4ec9973678370a8863120df941",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-leaves/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod leaves {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Leaves' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct LeavesContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for LeavesContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl LeavesContract {\n        /// Creates a new PSP-22 compatible Leaves Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Leaves\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MLEAVES\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "27963bb507caa432d17a00d6b0283b342837b5c64c3791c97420371d7b5d1593",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lightning/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lightning/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-lightning\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Lightning'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "0b4568b41383cf1f4b436fbcc6980b81f07205c5e3035151500a29bc6d7baaf8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lightning/README.md",
      "content": "# Lightning - Contract\n\nThis is a Lightning contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "cf6901976766cb931a8e00a10a04bdc6eda003f9519db768e5152f95fe483ff4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lightning/src/Cargo.toml",
      "content": "[package]\nname = \"lightning\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "6d6ee54c8c6e46b218231cda45c343a5b4ee4f59dba8d361713666af2cd35309",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lightning/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod lightning {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Lightning' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct LightningContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for LightningContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl LightningContract {\n        /// Creates a new PSP-22 compatible Lightning Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Lightning\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MLIGHTNING\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "a09e359beae3e7df7e018a54e1aaca325683757c6e7ab4e4737af07d1d1e7c97",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-limestone/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-limestone/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-limestone\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Limestone'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "02e30828f2cf74d8a5d7178fafaf00e38cd7f5672d3112b786a24440e5eae305",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-limestone/README.md",
      "content": "# Limestone - Contract\n\nThis is a Limestone contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "1381ffe88d8788e325868a0d933322be46701861fbe066fd93730876712bb22c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-limestone/src/Cargo.toml",
      "content": "[package]\nname = \"limestone\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "0c7c0668a23ff5da2e72b8626007c3d6053005f5af9825cdecc4e4783499a457",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-limestone/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod limestone {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Limestone' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct LimestoneContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for LimestoneContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl LimestoneContract {\n        /// Creates a new PSP-22 compatible Limestone Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Limestone\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MLIMESTONE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "586dbb0c7d0264db9690af360cc4c4017645a04e44d028a833a072e0a8be725f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lock/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lock/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-lock\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Lock'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "e71f4face98093d848aec0167212897a7201f7dbdb908474cab088641ca23116",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lock/README.md",
      "content": "# Lock - Contract\n\nThis is a Lock contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "97e2cdf1b9ddefa6f3f76a74ae5048a2bb5c30e507d9dc691db7a831272a1f04",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lock/src/Cargo.toml",
      "content": "[package]\nname = \"lock\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "c31f2a897a0978d62d065789d4f771b45818e06358e8118727c874b4434b12ef",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lock/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod lock {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Lock' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct LockContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for LockContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl LockContract {\n        /// Creates a new PSP-22 compatible Lock Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Lock\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MLOCK\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "762fcad080ea449dc8f5d8938548b3e69474e6392dcaf2f5a7ba19090244590a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-magma-chamber/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-magma-chamber/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-magma-chamber\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'MagmaChamber'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "2a85a7561f955ec7702cae0a1ab5c2a5db4faecf8ebb9b0729923211e301c771",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-magma-chamber/README.md",
      "content": "# Magma Chamber - Contract\n\nThis is a Magma Chamber contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "87c9e5155f8ba44b9a32ed3701833111cd205e77d4b2871b8877288120898fb9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-magma-chamber/src/Cargo.toml",
      "content": "[package]\nname = \"magma_chamber\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "05ceed7f7ea89f3d65d66b35363c8cf0fa8f954df7f7c1c339b07b591232122a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-magma-chamber/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod magma_chamber {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Magma Chamber' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct MagmaChamberContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for MagmaChamberContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl MagmaChamberContract {\n        /// Creates a new PSP-22 compatible Magma Chamber Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Magma Chamber\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MMAGMA_CHAMBER\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "49e9747d0a420aecb17fd19fa81ad143fe77613c65ecc2ecc0977bfe3db21ba0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-magma/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-magma/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-magma\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Magma'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "4e8f5b6f9979edfd3da725611a48db72c4afaa7eb635cb86e3ebdebfde609dca",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-magma/README.md",
      "content": "# Magma - Contract\n\nThis is a Magma contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "474679e6c51974264a034d56131b6713a0e0430b10ac86f15278d8812360e7d3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-magma/src/Cargo.toml",
      "content": "[package]\nname = \"magma\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "9d29f0307ddac5746a814043706209b27f5e2952a67fe95e98e84597a15b0e00",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-magma/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod magma {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Magma' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct MagmaContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for MagmaContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl MagmaContract {\n        /// Creates a new PSP-22 compatible Magma Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Magma\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MMAGMA\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "f5c8079e3b2e901daafa772e02b6157e098d65820b9d210c6f1418ef49e22a6e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-marmalade/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-marmalade/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-marmalade\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Marmalade'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "3327b1212b5a102bf1ccf62522ec1ca06606766d15cd1956d4fa359105f0bc89",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-marmalade/README.md",
      "content": "# Marmalade - Contract\n\nThis is a Marmalade contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "e2212a2d07aea142b29abfc5e594eb20b8d85fc2c413b556b7ab71b801a0bc86",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-marmalade/src/Cargo.toml",
      "content": "[package]\nname = \"marmalade\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "183944a233218611a90c6e110398a59bdf193992556d7331a39490d79c2ae9be",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-marmalade/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod marmalade {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Marmalade' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct MarmaladeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for MarmaladeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl MarmaladeContract {\n        /// Creates a new PSP-22 compatible Marmalade Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Marmalade\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MMARMALADE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "3b48dd0d6a151f3c6fcd8d3e397c4d90c174cd8384f4df59998e57f9d345cd04",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mirage/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mirage/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-mirage\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Mirage'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "a3a2da2efb69b52a7bf00904213da69359a2e92bf98a3ba8c1f91c689d8b21f9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mirage/README.md",
      "content": "# Mirage - Contract\n\nThis is a Mirage contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "bb28defbcdcb5f4ef84833bde0b34188f0d80f5d650c3e6673962a302afd2229",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mirage/src/Cargo.toml",
      "content": "[package]\nname = \"mirage\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "134c4d8d2267eb8ce3979f01364db894db6977f21e2d85bb89d94e7db9212d3f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mirage/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod mirage {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Mirage' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct MirageContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for MirageContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl MirageContract {\n        /// Creates a new PSP-22 compatible Mirage Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Mirage\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MMIRAGE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "3de971db6f452bc013eb736918518619e681f3e0ca657de5cd87171e9333fac4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mist/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mist/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-mist\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Mist'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "90e0ef922c7dce4044627ffcb4744e2bbf623c655bf3c53fbdee8836c4e0fced",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mist/README.md",
      "content": "# Mist - Contract\n\nThis is a Mist contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "3e0e203f3ee5c34431cb8385c126e8191f41b632c6a742ee0f9fca900d274d3d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mist/src/Cargo.toml",
      "content": "[package]\nname = \"mist\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "88e0470c34debdb973b148b34429f9826da0366923bb76ef29259f2765007ff3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mist/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod mist {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Mist' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct MistContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for MistContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl MistContract {\n        /// Creates a new PSP-22 compatible Mist Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Mist\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MMIST\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "53d3104a46c22e6c4c4115e47296891b338d02dbfbe795b8b0a24bb236527468",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-molten-glass/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-molten-glass/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-molten-glass\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'MoltenGlass'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "75526e9c7005ddf8ebf504a4d7f39e48355e8a969e6e6ca08c637a28da1af89a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-molten-glass/README.md",
      "content": "# Molten Glass - Contract\n\nThis is a Molten Glass contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "7d117878661bd538a92d6a8b4e289fc3d6b38d8ef5b5f1f1373e569c252cdf4e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-molten-glass/src/Cargo.toml",
      "content": "[package]\nname = \"molten_glass\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "8bc7b3d9d312d007f55ff1b16387b0a65db967ffc5d438218a8de32e9a55c8cb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-molten-glass/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod molten_glass {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Molten Glass' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct MoltenGlassContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for MoltenGlassContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl MoltenGlassContract {\n        /// Creates a new PSP-22 compatible Molten Glass Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Molten Glass\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MMOLTEN_GLASS\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "81f9183e779faaf41426876606e3377cd6b610c9423783c49c847e99c2e96163",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monkey-branch/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monkey-branch/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-monkey-branch\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'MonkeyBranch'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "eb787efb08b5fc8bc11996e01d17bec955550d8492f78250a384059252156cb0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monkey-branch/README.md",
      "content": "# Monkey Branch - Contract\n\nThis is a Monkey Branch contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "0c48d6df37349961880898b9663df972d4704f2160e026e951cca106dea30e6d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monkey-branch/src/Cargo.toml",
      "content": "[package]\nname = \"monkey_branch\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "7000c0a534a43b8262b003e2e77f00c504293d5a11328f12d1833dac4add41b3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monkey-branch/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod monkey_branch {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Monkey Branch' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct MonkeyBranchContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for MonkeyBranchContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl MonkeyBranchContract {\n        /// Creates a new PSP-22 compatible Monkey Branch Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Monkey Branch\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MMONKEY_BRANCH\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "c38a13246cfd3ee17b83b2487f142c784b7a6e652f17df1df0c01f440970f912",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monkey/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monkey/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-monkey\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Monkey'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "de14ebeaea51e73d0f1747dcee917bc533e3ea4a72ec5a723216ab77b5c8ff0d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monkey/README.md",
      "content": "# Monkey - Contract\n\nThis is a Monkey contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "0fe44480ded17f5789b1971f83f2f32ddc380bb8d46300682eb8afbae74c3462",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monkey/src/Cargo.toml",
      "content": "[package]\nname = \"monkey\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "7f6f7dabf709af47b4eb4a27d330ee0dfd4dabd8cfe0896733088724015c9c92",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monkey/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod monkey {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Monkey' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct MonkeyContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for MonkeyContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl MonkeyContract {\n        /// Creates a new PSP-22 compatible Monkey Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Monkey\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MMONKEY\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "c61a23b45a84087b3389cc01e039cd04a59ef2d3aec7bf670ee1ca6b366b7c6e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monument/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monument/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-monument\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Monument'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "66c1aac49506005745cb6c414cb560569ec631ebf7aafa129585906b85920989",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monument/README.md",
      "content": "# Monument - Contract\n\nThis is a Monument contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "438c37e9fec54264d9f3b7ab22373d1be7455a8797aebca04bf68d3b162364dd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monument/src/Cargo.toml",
      "content": "[package]\nname = \"monument\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "4b46787f6964624a51af35d6b6b41053eb9e90bbc101ec9154daa195b6d3b355",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monument/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod monument {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Monument' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct MonumentContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for MonumentContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl MonumentContract {\n        /// Creates a new PSP-22 compatible Monument Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Monument\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MMONUMENT\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "3ff985955cd88e182cd6670876c5e56ed3886f5482419cb85ddc7cf4a9046ea1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mountain/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mountain/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-mountain\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Mountain'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "5c837a7249f1fe8862ae72c9ebb0e22d8ce0c251c2a8c8112242ff831433daaf",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mountain/README.md",
      "content": "# Mountain - Contract\n\nThis is a Mountain contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "81e6d587b395f00cb6ffbe68fcd8298f2961af99bfc12e31dd8dd84633d1074b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mountain/src/Cargo.toml",
      "content": "[package]\nname = \"mountain\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "ba1dfb92e112a15dec343311bc6664dcdef79c24a109a7c4ea1e16926f980909",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mountain/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod mountain {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Mountain' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct MountainContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for MountainContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl MountainContract {\n        /// Creates a new PSP-22 compatible Mountain Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Mountain\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MMOUNTAIN\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "a1ffa3ef35daaf7281a78bd1975afff70c2cc54702a932f1d292fa145f68312f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mud/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mud/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-mud\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Mud'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "8649315c55e2cbca95b6f1d5efaa3e0b73a01271cac91bdacc3def3c574e1a92",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mud/README.md",
      "content": "# Mud - Contract\n\nThis is a Mud contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "fdcf7bc71bc649a720764584cc21f0988571d95ac631c9b6c2d203466a4f7673",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mud/src/Cargo.toml",
      "content": "[package]\nname = \"mud\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "3393acac1721fa1045c89a239378c7054be7c2198788e3589bc575aa4f4174ae",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mud/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod mud {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Mud' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct MudContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for MudContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl MudContract {\n        /// Creates a new PSP-22 compatible Mud Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Mud\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MMUD\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "c7ba72a2daf00ff560998b6e0f8f5b1c6845a66d2811adde55c82871da37c6f5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-murmur/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-murmur/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-murmur\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Murmur'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "caded0c52b8fe56dc272fe38f5c770171def41d89bf5f717c7680faf9333337f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-murmur/README.md",
      "content": "# Murmur - Contract\n\nThis is a Murmur contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "4b078686b61a85b99e5a215d3e17e8c9b7b5c5ad2bb8f5fe92371173fb4e6309",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-murmur/src/Cargo.toml",
      "content": "[package]\nname = \"murmur\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "798ac8618135583d092da0c7eee1e592848bf93f1f880adec1d475b6752c7f12",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-murmur/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod murmur {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Murmur' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct MurmurContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for MurmurContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl MurmurContract {\n        /// Creates a new PSP-22 compatible Murmur Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Murmur\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MMURMUR\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "ae4b60d888b82fe65fa077186779cea701e25e16fb950c28d09365ea75d5c9ef",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-oasis/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-oasis/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-oasis\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Oasis'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "3fd028e2987f766dbe75ad5468c3fca48591e9fd99d447b8e6b50892fb882682",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-oasis/README.md",
      "content": "# Oasis - Contract\n\nThis is a Oasis contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "dbebcf29f3ef3ebab9b4f26e7fbb49a0e90acb4c886250727ed148df04b1ccb6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-oasis/src/Cargo.toml",
      "content": "[package]\nname = \"oasis\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "de7726263abf74cef42bdd24d5881446092b9e0822ee6ae3e2c50194e8b282a5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-oasis/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod oasis {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Oasis' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct OasisContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for OasisContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl OasisContract {\n        /// Creates a new PSP-22 compatible Oasis Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Oasis\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MOASIS\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "db24ce35ced16bdd9c92545ec60189c37a0938abf2d6dcd81c3df95acb34f130",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-obsidian/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-obsidian/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-obsidian\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Obsidian'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "166128a2cad1988f2b9af0473340168439a2c2d8ef808adf766e949a24712c20",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-obsidian/README.md",
      "content": "# Obsidian - Contract\n\nThis is a Obsidian contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "48d53bc8ec4da135f944d67b60f4423d5fa86c60a41a694b0016a728189afc42",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-obsidian/src/Cargo.toml",
      "content": "[package]\nname = \"obsidian\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "7ad5bd97024acf415d02426602f8da03db61fad651b282961e1df1fdb39f8543",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-obsidian/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod obsidian {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Obsidian' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct ObsidianContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for ObsidianContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl ObsidianContract {\n        /// Creates a new PSP-22 compatible Obsidian Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Obsidian\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MOBSIDIAN\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "2211c619fc6a57108d187203a53b331edcb05efc97a7eb5861ddbc2072d92995",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-parched-earth/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-parched-earth/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-parched-earth\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'ParchedEarth'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "8192785187adadb2c03ddc14c98f9c9b17e9828cc96b1bc2ff884c71536a414e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-parched-earth/README.md",
      "content": "# Parched Earth - Contract\n\nThis is a Parched Earth contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "cf5cc0279b55d0ba30223ea9e930398e5c405fa6dc9450b9424ae08c23b05060",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-parched-earth/src/Cargo.toml",
      "content": "[package]\nname = \"parched_earth\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "fa07f997fbc2e5c13481ff1db57d2d58fef91444e28681f31a8d0cf2633d9f18",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-parched-earth/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod parched_earth {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Parched Earth' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct ParchedEarthContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for ParchedEarthContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl ParchedEarthContract {\n        /// Creates a new PSP-22 compatible Parched Earth Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Parched Earth\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MPARCHED_EARTH\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "018e3ba1c2354732c0df7ad10a8cda6712f8f00d22aae239a57899dfb837435e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-peat/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-peat/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-peat\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Peat'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "f28d3c6d259fee14a92ea9516ffa2cefcad615459e4cf8dc9177910bd131c3c5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-peat/README.md",
      "content": "# Peat - Contract\n\nThis is a Peat contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "1b7f21ac428c75d4977784877636b700a73d85510c94b3f6c3ae7170f6d9e659",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-peat/src/Cargo.toml",
      "content": "[package]\nname = \"peat\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "3829bad603bff40546e2a01c45e13372a925355637a886236d4d3c7b128463fa",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-peat/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod peat {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Peat' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct PeatContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for PeatContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl PeatContract {\n        /// Creates a new PSP-22 compatible Peat Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Peat\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MPEAT\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "285c92022507cdf6997654c2748cc92871004671c2d5eddb75dcfc6354e7b111",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pebble/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pebble/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-pebble\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Pebble'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "8006e8b6726ef3fac55dade6021ca8973fb33e9bb3b36955c95e20972f095734",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pebble/README.md",
      "content": "# Pebble - Contract\n\nThis is a Pebble contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "124039991c5ec919006bbc4fc7cb2999e799584d1a788dda78367f70da96888b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pebble/src/Cargo.toml",
      "content": "[package]\nname = \"pebble\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "4a91c1eed70cbaa330a1f11993392610fb86e540ecb52cc90a9e47d8d8b4db75",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pebble/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod pebble {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Pebble' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct PebbleContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for PebbleContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl PebbleContract {\n        /// Creates a new PSP-22 compatible Pebble Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Pebble\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MPEBBLE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "8aa65748e0f9ea1e36f194c9c08dd1fdd7f6a2756acd5ce040dfd4ae839f3071",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-peer-review/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-peer-review/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-peer-review\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'PeerReview'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "4f32783a421fe39c823946001632ce16944ee59eac0309737d5c084560c796b1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-peer-review/README.md",
      "content": "# Peer Review - Contract\n\nThis is a Peer Review contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "c19bcf2eabf99cb52ddd6e092dfbdad1930be55662fe246e82ea5c9036087f64",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-peer-review/src/Cargo.toml",
      "content": "[package]\nname = \"peer_review\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "d6979f10e0b8b3d93bcd4ad72a74ecb5f9679af23d008c1b81921ff749680dad",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-peer-review/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod peer_review {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Peer Review' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct PeerReviewContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for PeerReviewContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl PeerReviewContract {\n        /// Creates a new PSP-22 compatible Peer Review Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Peer Review\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MPEER_REVIEW\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "efdc3c3fbefa37b05f12d85f4567ca7be0c29a18b4bcf6900b6396bbbcc05880",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pillar-of-wind/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pillar-of-wind/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-pillar-of-wind\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'PillarOfWind'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "424968fe5f7d4d742a8237341ddc28a8916c0b6a4762eadd9928f97d827ebf66",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pillar-of-wind/README.md",
      "content": "# Pillar Of Wind - Contract\n\nThis is a Pillar Of Wind contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "54a6f147e52469ca2390bfa977f8c26e7768ba2effc7e1923322d769b19fc83e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pillar-of-wind/src/Cargo.toml",
      "content": "[package]\nname = \"pillar_of_wind\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "e69b476c39a721f2151eb67ed06921a8c526a9aad1cbc30901f253c3c7acd57d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pillar-of-wind/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod pillar_of_wind {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Pillar Of Wind' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct PillarOfWindContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for PillarOfWindContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl PillarOfWindContract {\n        /// Creates a new PSP-22 compatible Pillar Of Wind Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Pillar Of Wind\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MPILLAR_OF_WIND\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "105453826ccd4b1a16fd85a0399c86f0a11531ed2c81cbee1d1c73164811f6d3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-plant/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-plant/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-plant\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Plant'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "93ed7bec61543e84af1e505055a2c01227c05fc7f2e5461e05460e892e1aed41",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-plant/README.md",
      "content": "# Plant - Contract\n\nThis is a Plant contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "6db0f6cbdbcc919abad35c441e0d8cd1ecd105a13d3f7cd3374ff1406ab3cc35",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-plant/src/Cargo.toml",
      "content": "[package]\nname = \"plant\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "496b9d845acc9df18699bd4e2fb3dda6028eb8b409b5c0478196c263b55cd7fc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-plant/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod plant {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Plant' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct PlantContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for PlantContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl PlantContract {\n        /// Creates a new PSP-22 compatible Plant Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Plant\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MPLANT\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "86f7836940c5d750bcd8013fb12ea0debd513c311166e9c9fa107b9ef3a2c434",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-plateau/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-plateau/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-plateau\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Plateau'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "3437b02c35e78227c7de3a60d547930fc5d88a8cbd47d673b68a19d0000ca07f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-plateau/README.md",
      "content": "# Plateau - Contract\n\nThis is a Plateau contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "fadaedff4082a32e699ca70c42b53278d004385883c14dfd0617280d9198e831",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-plateau/src/Cargo.toml",
      "content": "[package]\nname = \"plateau\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "35beb48a18656795a5de3129cec25cc51a747f28db300818abdaa1f95666e8fe",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-plateau/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod plateau {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Plateau' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct PlateauContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for PlateauContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl PlateauContract {\n        /// Creates a new PSP-22 compatible Plateau Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Plateau\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MPLATEAU\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "9d54e65d493d7fa9accf429a9c1010348e2ebf0b819c1f051917fa9978d55927",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-polkadot/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-polkadot/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-polkadot\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Polkadot'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "cd9d8d09b5e590980bf26d85a3731eb15ff8f0bceefe5932c807b244c8f9d207",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-polkadot/README.md",
      "content": "# Polkadot - Contract\n\nThis is a Polkadot contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "9b0fa293dc49386b4cfa6be13f796490255812517a493d54d3df339e251f5fbf",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-polkadot/src/Cargo.toml",
      "content": "[package]\nname = \"polkadot\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "4a2d079862b27c896f4a4be1ef2577e4b00e21b7a5e03ba2d92ca853d495cf3a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-polkadot/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod polkadot {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Polkadot' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct PolkadotContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for PolkadotContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl PolkadotContract {\n        /// Creates a new PSP-22 compatible Polkadot Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Polkadot\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MPOLKADOT\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "417a9d721c82f963d8a402427273d2d39ed5850c01429d1866b15f1c4147a42b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pollination/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pollination/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-pollination\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Pollination'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "28d7e1c2382088aa5adb545c7683e90d52f0ff5fde5354c1f6e0765b7e86e853",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pollination/README.md",
      "content": "# Pollination - Contract\n\nThis is a Pollination contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "60993a23b384d3b18af98a44f4fb26a97deea53211dfbb8f2441f237624c5ba7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pollination/src/Cargo.toml",
      "content": "[package]\nname = \"pollination\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "a0d281b9d3e6be84a7b6a579b81d23b879d3a6263525ba16ee441398fb12b22d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pollination/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod pollination {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Pollination' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct PollinationContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for PollinationContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl PollinationContract {\n        /// Creates a new PSP-22 compatible Pollination Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Pollination\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MPOLLINATION\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "3a066316752d89c8bcc9603c69e38c053a93e1ac421216839868638b6576297b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pond/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pond/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-pond\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Pond'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "b1decedf4161362c538fc7fa087d35134546d14fa9b3cb9157e97df8f4ffb927",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pond/README.md",
      "content": "# Pond - Contract\n\nThis is a Pond contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "0801fe4beb8532a52252cbbf6e8c833615bca5c4c8327bb0b5dd332682181959",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pond/src/Cargo.toml",
      "content": "[package]\nname = \"pond\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "0003370bf4eb7beb33234f717f1b15645608ac92df7e12b13eaf8f0e1e41241b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pond/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod pond {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Pond' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct PondContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for PondContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl PondContract {\n        /// Creates a new PSP-22 compatible Pond Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Pond\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MPOND\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "1d0ca702d6dfedef412cae657f47d9e567ac83f928ffbe3860c4486e69d97db4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pottery/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pottery/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-pottery\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Pottery'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "8fa9702c7066aa76228fbed46378da174b49fdadf137c7acdd385eee1a02550a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pottery/README.md",
      "content": "# Pottery - Contract\n\nThis is a Pottery contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "7761a3e2e27ea5ca10b633384ef5b0ce8ea89cd13e50fc357d2d9c8ca19ab8a8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pottery/src/Cargo.toml",
      "content": "[package]\nname = \"pottery\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "e899502c5f7fb86cd9a00ec368b80a6774c0b20c8bca1c0430319f26d353e179",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pottery/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod pottery {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Pottery' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct PotteryContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for PotteryContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl PotteryContract {\n        /// Creates a new PSP-22 compatible Pottery Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Pottery\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MPOTTERY\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "020b68d596e1f6e02f7459761183552938d9bc78c2fc9af59b34f60787f110fc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-prism/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-prism/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-prism\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Prism'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "57b9ddf861e29bfde74c5dd853bdc30ffcdfd185efd12716ff6136edaecf8c0e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-prism/README.md",
      "content": "# Prism - Contract\n\nThis is a Prism contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "8c2b3b56e383ad85cf57d43480a2666b1b2f87014991817ccaa3bf517e8ce214",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-prism/src/Cargo.toml",
      "content": "[package]\nname = \"prism\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "cc8e9f969c197fb3bfdcd0d7124c55ce32df54837b016b8b46f4806968620337",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-prism/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod prism {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Prism' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct PrismContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for PrismContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl PrismContract {\n        /// Creates a new PSP-22 compatible Prism Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Prism\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MPRISM\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "6cfd8fc3e67de0d0bf25cb9621e7004f306449f1dbe769d0de135fdffe48d77e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pumice/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pumice/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-pumice\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Pumice'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "a414769fbe3997c73b617c4222ca251bb5c2cc92548958f467ce46665eb56b7b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pumice/README.md",
      "content": "# Pumice - Contract\n\nThis is a Pumice contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "42c6de0bfefbf1c9577bbbd44248bad0d0ade0a770baf9d5fde725040457db63",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pumice/src/Cargo.toml",
      "content": "[package]\nname = \"pumice\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "3fe60e6a480f1b2c9c25f65cb4176bf9ce802b9fd257f1b939c3cc3f53400544",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pumice/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod pumice {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Pumice' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct PumiceContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for PumiceContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl PumiceContract {\n        /// Creates a new PSP-22 compatible Pumice Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Pumice\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MPUMICE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "35e155370b7b888b2b9ef08eb84b5f1a2e3ad6aa61572fd217f9674598bef4c0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-quicklime/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-quicklime/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-quicklime\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Quicklime'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "867b990175da7156606e675b4516cdad45aaa3c90c9b4f3bf4dab0e18bdb38d9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-quicklime/README.md",
      "content": "# Quicklime - Contract\n\nThis is a Quicklime contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "c54d72679cdb18e873c628fa7c083a06b52250f55ca5c91faa8decdc8d7fcddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-quicklime/src/Cargo.toml",
      "content": "[package]\nname = \"quicklime\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "619a28f9e7e74d9a9aab3dad62a7cbd7ee3942d70ec43e1bb28960f832358f35",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-quicklime/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod quicklime {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Quicklime' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct QuicklimeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for QuicklimeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl QuicklimeContract {\n        /// Creates a new PSP-22 compatible Quicklime Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Quicklime\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MQUICKLIME\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "bc3390dcc7a9ef5a59110235b90abf2c7a029501817547f22f4b5211a4cbb957",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-quicksand/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-quicksand/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-quicksand\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Quicksand'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "466c31d4f034faf80754a7a441a7d6f5dcf5c889a24fb62484547894bcd9d67d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-quicksand/README.md",
      "content": "# Quicksand - Contract\n\nThis is a Quicksand contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "a9b1a462d50451b119517aacc1c7045364275546b111dd3baa9709a070e1e671",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-quicksand/src/Cargo.toml",
      "content": "[package]\nname = \"quicksand\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "e7534ee5aa3a149aa8c5ba94c4c8a38607b9988913f478181acf34ab8aca7499",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-quicksand/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod quicksand {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Quicksand' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct QuicksandContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for QuicksandContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl QuicksandContract {\n        /// Creates a new PSP-22 compatible Quicksand Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Quicksand\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MQUICKSAND\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "5ed24d0385e9dc0729577640a40ccdf942130d4330bd79506c5a39dd2fe00cc4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rain/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rain/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-rain\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Rain'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "363cf550441fc65a9ba3796cf2958d58166bf7bb832027d47c7eb4e95f9f0ae3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rain/README.md",
      "content": "# Rain - Contract\n\nThis is a Rain contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "c097c481b98d68650d65b7fc9c635e0d6de5e040df3fc9790acec5cde0f6ad99",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rain/src/Cargo.toml",
      "content": "[package]\nname = \"rain\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "e74497e05235cbf693bb091e20265d98cc8b107a0d8f1f0c113262fa258eb93a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rain/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod rain {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Rain' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct RainContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for RainContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl RainContract {\n        /// Creates a new PSP-22 compatible Rain Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Rain\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MRAIN\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "e3c998eedfbe270a65a95235a92a12d0bcd8afcdef5c4aec9fcb3ccd8e7d2058",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rainbow/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rainbow/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-rainbow\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Rainbow'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "23ebe835588c09b30ccab76e941584f1895eedf5356c02690dd1640060c08b05",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rainbow/README.md",
      "content": "# Rainbow - Contract\n\nThis is a Rainbow contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "7f66f56b0d6dedbd973edc173a85ac4f666f6d1cfa260e7f685e66abaf7d1d89",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rainbow/src/Cargo.toml",
      "content": "[package]\nname = \"rainbow\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "d4f5a8d8b99773525f6a9c669477435fe7415838f4cf057a1c61a00cc4532f1a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rainbow/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod rainbow {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Rainbow' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct RainbowContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for RainbowContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl RainbowContract {\n        /// Creates a new PSP-22 compatible Rainbow Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Rainbow\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MRAINBOW\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "7f246c29ebfd72d008d616488d55c48f2d413d1f5108a7ed394f279d68d36043",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-ravine/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-ravine/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-ravine\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Ravine'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "d2eef133b9a6ab94b3788f9c426c1e9e9436205637bb1267524aa3ac3b6abc46",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-ravine/README.md",
      "content": "# Ravine - Contract\n\nThis is a Ravine contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "6db45db698ce647cdc39bd50dc1ac7e7cc2ce5a9fd0e305d6100ad2f600a742c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-ravine/src/Cargo.toml",
      "content": "[package]\nname = \"ravine\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "03d3bff529fd6335320f90a3e7d13d9e7866b345f980de0a26bad66459566282",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-ravine/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod ravine {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Ravine' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct RavineContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for RavineContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl RavineContract {\n        /// Creates a new PSP-22 compatible Ravine Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Ravine\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MRAVINE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "865b78ddcc716451c5e2c039b36f030cce395200914b890c317a5aea057ffe31",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-reeds/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-reeds/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-reeds\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Reeds'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "e5e51656102750bf22b5bc3238a3a42b15139752efc7c26b007613df5e9eee51",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-reeds/README.md",
      "content": "# Reeds - Contract\n\nThis is a Reeds contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "7c45b20bbdde52c7132dc1a7aa1e8c7c5a98f62fd6d1d8bd98f8197f2f9492b8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-reeds/src/Cargo.toml",
      "content": "[package]\nname = \"reeds\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "ff3aea8e69a2fe0e190071d4cdb88eac84b507d486ccbcba973c91c54d73d021",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-reeds/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod reeds {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Reeds' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct ReedsContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for ReedsContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl ReedsContract {\n        /// Creates a new PSP-22 compatible Reeds Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Reeds\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MREEDS\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "a4e1900244120476e85fbe66ba48685c9cf02770ba678c35ce2276bf7f2e7da6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-reef/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-reef/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-reef\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Reef'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "1f8d077eabd626e423db0e1fc5b3b35070bd8972b3dd58414944f0d7a0ca3e7b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-reef/README.md",
      "content": "# Reef - Contract\n\nThis is a Reef contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "cd007cf5ff74c5c70e3647ec404196da7e28282d3a1bd87aaae5cc9f7d22519d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-reef/src/Cargo.toml",
      "content": "[package]\nname = \"reef\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "b9b1777286967db71015acafa732d10b6782f09eb7686fd19eb9ebdc00ddd26c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-reef/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod reef {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Reef' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct ReefContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for ReefContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl ReefContract {\n        /// Creates a new PSP-22 compatible Reef Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Reef\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MREEF\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "3ee3f9c72125adcb19235e78d123ab153250ecf00f9c8aa7dde3ec1e24eccc7c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-reservoir/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-reservoir/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-reservoir\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Reservoir'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "c66c0391d68afb25e1d8277279782421ab2d32d0dc11b7ec15e6e70476aefd6f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-reservoir/README.md",
      "content": "# Reservoir - Contract\n\nThis is a Reservoir contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "215152b75a95b4c2a869c2e4864da9f8b38b66b777093b8704dd675b347c9ac8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-reservoir/src/Cargo.toml",
      "content": "[package]\nname = \"reservoir\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "131ee7e313ef0262ffc2152c1d589f3235c38d9982140d68240bc302671d4b36",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-reservoir/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod reservoir {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Reservoir' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct ReservoirContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for ReservoirContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl ReservoirContract {\n        /// Creates a new PSP-22 compatible Reservoir Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Reservoir\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MRESERVOIR\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "bba78e1c1c229308c2d614e7125d19f78a6609a6ac96fb95b648dc88643c1e5d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rhodium/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rhodium/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-rhodium\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Rhodium'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "a57bffc26e2a9520d4d747f8e9fabc068aef6311f8903aef05e05df1e127bb3c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rhodium/README.md",
      "content": "# Rhodium - Contract\n\nThis is a Rhodium contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "d2a98c179a3e4fb60c62738edd955f8f680ed3b673d6f2682ff4d3f9653ad832",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rhodium/src/Cargo.toml",
      "content": "[package]\nname = \"rhodium\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "414c27a3b895c0eb8b7988bc34570a47f14b7ddeaa8dbaa568a0aa7aa6719880",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rhodium/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod rhodium {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Rhodium' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct RhodiumContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for RhodiumContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl RhodiumContract {\n        /// Creates a new PSP-22 compatible Rhodium Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Rhodium\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MRHODIUM\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "eea946d93632fa8112601b0879b9cd9f757cdc8093b7d694f8fe36bacb73369e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-river/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-river/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-river\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'River'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "0db6909803e88df190634d8be968ab4fb92cf95605c1135ab63a6de2cd0765dc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-river/README.md",
      "content": "# River - Contract\n\nThis is a River contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "ac887ec03659acc7adfa8794e382b0664329870f4564bed3cd2971babaeefd55",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-river/src/Cargo.toml",
      "content": "[package]\nname = \"river\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "89ffddc9b0b9a177d538830c5451a6d928addc8b2aa0c2b0d29ac7073d7a0bc8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-river/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod river {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'River' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct RiverContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for RiverContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl RiverContract {\n        /// Creates a new PSP-22 compatible River Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"River\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MRIVER\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "d65ed742c321852a061855f40066d7dfa13d65e1edefb01c11c46cb8ccb3ccc9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-riverbank/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-riverbank/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-riverbank\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Riverbank'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "c94adc6fef36335e1b0d5574fcf0152fdaf1df74bddac04a9f0f376a0b3fe7f0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-riverbank/README.md",
      "content": "# Riverbank - Contract\n\nThis is a Riverbank contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "216c84b51f5d310ffe7221c5dbc0818d9aa9c2a06d83de2930a95c208e269860",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-riverbank/src/Cargo.toml",
      "content": "[package]\nname = \"riverbank\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "0b7db53ebcef5711efd7beb4e1f47b828aaf522817826afcfcd124387a5ba10b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-riverbank/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod riverbank {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Riverbank' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct RiverbankContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for RiverbankContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl RiverbankContract {\n        /// Creates a new PSP-22 compatible Riverbank Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Riverbank\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MRIVERBANK\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "d13b4d9f56d0143e85b2100980b7ed5ffc05248bb8bb38d7d7b42e5b5523e1af",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rivulet/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rivulet/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-rivulet\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Rivulet'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "7f7d6cc92c61c0966f83a3a53a23579cdaa0adba6313c9d703f576d728a54f42",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rivulet/README.md",
      "content": "# Rivulet - Contract\n\nThis is a Rivulet contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "77debbc06d8d329412ac38952c8e315032bac45e1def7bef9479a333a3869e73",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rivulet/src/Cargo.toml",
      "content": "[package]\nname = \"rivulet\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "395eee590eeb89aa69c33051992597f4b03ec45c412c1d921d9e41f96ed3ba48",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rivulet/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod rivulet {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Rivulet' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct RivuletContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for RivuletContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl RivuletContract {\n        /// Creates a new PSP-22 compatible Rivulet Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Rivulet\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MRIVULET\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "b78007eafe4ff27709fb3b8f7e132b2127ce89c8292a0d21e9332c2ff1fc2ceb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rock/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rock/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-rock\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Rock'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "9ab5e2cd0b2016481be9fb903bbac70ab5c68b970ea155ccb2a7aaae1204fda4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rock/README.md",
      "content": "# Rock - Contract\n\nThis is a Rock contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "93dd228667a4e2f99e944fe5a927fa9530da5400b3a9c7f5a5ecd33767901d33",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rock/src/Cargo.toml",
      "content": "[package]\nname = \"rock\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "e7336f55fb90e57fb7673f000fc0f5b81c9bdbc241d44e85e60642aef027d889",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rock/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod rock {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Rock' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct RockContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for RockContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl RockContract {\n        /// Creates a new PSP-22 compatible Rock Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Rock\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MROCK\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "686c3ca7bd3c520977aef76d5e450a96f4d94632d487ebee7ca66987ea662005",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sand-dune/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sand-dune/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-sand-dune\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'SandDune'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "6327df9330c50d7d6c12154f31825ef964531162dbcd00cf483178483065729d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sand-dune/README.md",
      "content": "# Sand Dune - Contract\n\nThis is a Sand Dune contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "e0bb40bf34f0786fdd9595ce1f9805da4feb94ebc96517d6fe405da96b10b8ce",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sand-dune/src/Cargo.toml",
      "content": "[package]\nname = \"sand_dune\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "3c73e08b388a3b05f4c7ae9e398aa2fa8bcf7e68e7266a6e6d82addfa97051fc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sand-dune/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod sand_dune {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Sand Dune' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SandDuneContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SandDuneContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SandDuneContract {\n        /// Creates a new PSP-22 compatible Sand Dune Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Sand Dune\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSAND_DUNE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "6abc4436209ecd1dace6147dfc4bb6b7e77ffe8f244647cb9e843c11c6afba46",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sand/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sand/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-sand\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Sand'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "f12de0aeaa01bd320fc46631b1dc420227fdac50677022ca84a8b2403a412ece",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sand/README.md",
      "content": "# Sand - Contract\n\nThis is a Sand contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "3bfb9259f411860223cfb632b42f6ec907cc37ce8095bcd4ac6f14bf5bf05bbf",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sand/src/Cargo.toml",
      "content": "[package]\nname = \"sand\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "ef44ce780b292d99976fc89b51e70acff6e8efbc62ef2b63f522d61b7d8ed42a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sand/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod sand {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Sand' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SandContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SandContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SandContract {\n        /// Creates a new PSP-22 compatible Sand Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Sand\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSAND\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "f14356b65c7f601e50a7f8862d3dae68846632cab4ea4683702033d5139c2c14",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sandstorm/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sandstorm/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-sandstorm\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Sandstorm'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "4105554f6160e1f7f6018bd1191fa500eaeb01c183908b23cb0c0b89fdee70d2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sandstorm/README.md",
      "content": "# Sandstorm - Contract\n\nThis is a Sandstorm contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "6d9433e9724c47b546459a812a80da45945d0628d8790850e1b80e7960f1c1ab",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sandstorm/src/Cargo.toml",
      "content": "[package]\nname = \"sandstorm\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "2b788b2d48e6f5e4501d4e972ce42a391cfd9ae6b4b9ce738faaf8f22348d706",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sandstorm/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod sandstorm {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Sandstorm' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SandstormContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SandstormContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SandstormContract {\n        /// Creates a new PSP-22 compatible Sandstorm Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Sandstorm\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSANDSTORM\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "3f6a80f3b628c89e8c2e810322de25234c9fbbe023fccba9bba672e77da915b8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-scorched-earth/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-scorched-earth/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-scorched-earth\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'ScorchedEarth'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "175b24aa4d285825e436f6c1d4361692607d20ecb7a7b2420ea80031dce8b573",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-scorched-earth/README.md",
      "content": "# Scorched Earth - Contract\n\nThis is a Scorched Earth contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "bc13b3e6fcce5a462190972f50bffa47e6661d43bfac393140fd6c7fb9c08708",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-scorched-earth/src/Cargo.toml",
      "content": "[package]\nname = \"scorched_earth\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "4acde9f5cc434948b9806f79ed7694a2b0214b52e27ef764bcefdf38181c0fdc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-scorched-earth/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod scorched_earth {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Scorched Earth' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct ScorchedEarthContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for ScorchedEarthContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl ScorchedEarthContract {\n        /// Creates a new PSP-22 compatible Scorched Earth Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Scorched Earth\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSCORCHED_EARTH\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "2172ad10936c0ead8c0ca955c1173b0e34a14ecab368b9dfe54c95152056df38",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-seeds/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-seeds/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-seeds\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Seeds'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "1021f92e83fbabd1ce54cb0d9a3df5c437d06a02754e4357a12221a332c42732",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-seeds/README.md",
      "content": "# Seeds - Contract\n\nThis is a Seeds contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "42281317b303984ab177c311eb3da4937fca362587a701cb1f442e32885a1eec",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-seeds/src/Cargo.toml",
      "content": "[package]\nname = \"seeds\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "7702755fb3030a1c892b087ea9600e7aec71fa36e331eb86d065b0e39d745207",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-seeds/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod seeds {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Seeds' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SeedsContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SeedsContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SeedsContract {\n        /// Creates a new PSP-22 compatible Seeds Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Seeds\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSEEDS\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "d51878a268ec2f9ca3d6586509dacc9197906ca9278a3f1315a9953e40be489b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-shard/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-shard/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-shard\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Shard'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "b849a7da64ee26d99625d563be639f890323369a3d0fa7089e917b2d1a307373",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-shard/README.md",
      "content": "# Shard - Contract\n\nThis is a Shard contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "c22f9dd78fa669361e0b696012cf591323ec49cae280e1e68c24e854e1620524",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-shard/src/Cargo.toml",
      "content": "[package]\nname = \"shard\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "0dd98ad00a4e34d37c4d42eeac3ee09f8a18c63ca5e3dd6c0cc1c9a8c4f9aa23",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-shard/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod shard {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Shard' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct ShardContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for ShardContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl ShardContract {\n        /// Creates a new PSP-22 compatible Shard Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Shard\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSHARD\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "eb3e552f96c3eaea41c6d92db0ea41fc0e058edbd001f4e4e295a341f3a2acb9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-shards/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-shards/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-shards\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Shards'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "9dd9f34b85fa37fd2c9f6231d1def42b6482623c88ff6c6691d61d557910101e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-shards/README.md",
      "content": "# Shards - Contract\n\nThis is a Shards contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "5f544b9f81183fdd634d29f39e351931602470212f0c9d121adab5828ca4dd61",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-shards/src/Cargo.toml",
      "content": "[package]\nname = \"shards\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "352d289fe63dc4a9d4ebdb0e97a071efc08285b766fe20ada8cb22f3456a6f30",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-shards/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod shards {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Shards' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct ShardsContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for ShardsContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl ShardsContract {\n        /// Creates a new PSP-22 compatible Shards Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Shards\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSHARDS\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "25d05c6a22cbb87c9b68339f5e4a7508a8d8db3c3557fe05f124bf10cc2c1f0f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-silver/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-silver/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-silver\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Silver'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "6e2dc39f3f1b81b1564e86d365de304326de8538b07d469f1700076fad8c3dc2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-silver/README.md",
      "content": "# Silver - Contract\n\nThis is a Silver contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "36d6a2d5374bde49dff6544ba9e5153176d7e8057e81e4b4f2aa4ef0369fd04d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-silver/src/Cargo.toml",
      "content": "[package]\nname = \"silver\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "1ee2ed8aa6a8e3b8e0d946fcc2163cd36eb1f5e3fdb951f2a62f5a97f52ccf8d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-silver/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod silver {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Silver' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SilverContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SilverContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SilverContract {\n        /// Creates a new PSP-22 compatible Silver Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Silver\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSILVER\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "e9c3798061df660990fdb101970902e4351570120a3ab9758b94fd6ed9f077fe",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sinkhole/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sinkhole/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-sinkhole\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Sinkhole'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "1597ff7b0a11573c904d652666ae7b4c7231898b6b7e233c60b548f0f61bb06c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sinkhole/README.md",
      "content": "# Sinkhole - Contract\n\nThis is a Sinkhole contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "990e6d39a8b5515d592119fffe8e032e110064ce98ef28f5b55624c761737f77",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sinkhole/src/Cargo.toml",
      "content": "[package]\nname = \"sinkhole\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "3a411bb017c367c3296bddcb8b79d329e7eb5936f341b498ea53fe02351b0eaa",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sinkhole/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod sinkhole {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Sinkhole' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SinkholeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SinkholeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SinkholeContract {\n        /// Creates a new PSP-22 compatible Sinkhole Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Sinkhole\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSINKHOLE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "99a13628815bb2526e2e516bec7aee8472914dd77cf09f995525bf1dc493e0c0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-smoke/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-smoke/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-smoke\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Smoke'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "407a463dec69ed67f914e61ba93433b02fb50cc2cd40acd4fa1ccd2ae9958e53",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-smoke/README.md",
      "content": "# Smoke - Contract\n\nThis is a Smoke contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "2d9fb7ea586981d62f849c11a3ea968cefcf067833bcb69e37a1334d1289900b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-smoke/src/Cargo.toml",
      "content": "[package]\nname = \"smoke\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "ce2de53c0dbff85f9ea0cd5651cf0e5d0b0e07a9c62ac7f22b0d703f520bd898",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-smoke/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod smoke {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Smoke' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SmokeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SmokeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SmokeContract {\n        /// Creates a new PSP-22 compatible Smoke Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Smoke\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSMOKE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "0b0e0bbf98caabdaf3b551ab9fb760ac83c9e3712357f2097498746d506da28b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-soil/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-soil/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-soil\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Soil'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "de71165f8021bfe6ae0821aa9211e4dd09b89f3517d8ed350080b957f502b5eb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-soil/README.md",
      "content": "# Soil - Contract\n\nThis is a Soil contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "1a70f5fd2ebf6e806c8308d499ffeb2d01430331dcad51aea624fa62adb669db",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-soil/src/Cargo.toml",
      "content": "[package]\nname = \"soil\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "8fdcb1f086d09bd129d2872163980fcc463c9734d1e1ea8fe1ad5a9c49f38f8f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-soil/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod soil {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Soil' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SoilContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SoilContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SoilContract {\n        /// Creates a new PSP-22 compatible Soil Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Soil\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSOIL\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "13767f532bb37e0059a8ba3f760f9115fa6f10cac6f9be72758e202d852facbd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-soot/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-soot/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-soot\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Soot'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "7261ab6ba1522afad9d864f4ed1855f709276c3fd8c7d71e6b8601ca468c78fc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-soot/README.md",
      "content": "# Soot - Contract\n\nThis is a Soot contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "9bcaef2f92f4ff6b5d6a0691c8aa49521855455c35258584eb65b3949c3a024e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-soot/src/Cargo.toml",
      "content": "[package]\nname = \"soot\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "47d7306b94c41185f34d7789a543c4509ac0372ca44f5e188bb61eda897a2a31",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-soot/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod soot {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Soot' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SootContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SootContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SootContract {\n        /// Creates a new PSP-22 compatible Soot Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Soot\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSOOT\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "77666ad963d62113ce42c01c5feba12bbeb8f93301990e01038c9e88f56207fe",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sparkle/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sparkle/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-sparkle\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Sparkle'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "9c054992687383d437f72d9c2c9a2a694c5c3c953bb3a0b63738210f8abe5d02",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sparkle/README.md",
      "content": "# Sparkle - Contract\n\nThis is a Sparkle contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "b0da838f45070581c44dd5c144c37b77e2f55330fa737a5aac57cbdee6ee720f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sparkle/src/Cargo.toml",
      "content": "[package]\nname = \"sparkle\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "34a800669a8d1b87342bd04726597985942a0cd610d028f8ddc02fc62ee24f7e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sparkle/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod sparkle {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Sparkle' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SparkleContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SparkleContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SparkleContract {\n        /// Creates a new PSP-22 compatible Sparkle Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Sparkle\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSPARKLE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "2680a659ba01c48885dc83e61c6864867382681302511ec4f5d1e740bc499777",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-spore/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-spore/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-spore\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Spore'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "04ac9dfb34975b16c82b0a16c12e0d9525db5a32ca89143c320f2c4384b2052d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-spore/README.md",
      "content": "# Spore - Contract\n\nThis is a Spore contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "ba9c39ff2eceafece7e77333962555e09217b720b151b1084159f1d33ddf56a4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-spore/src/Cargo.toml",
      "content": "[package]\nname = \"spore\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "e332555c0da9150d2363ad318c38d4c74ee1c9c138a0ad4bb7282bf0ac9a13e7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-spore/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod spore {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Spore' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SporeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SporeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SporeContract {\n        /// Creates a new PSP-22 compatible Spore Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Spore\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSPORE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "4ae1cd7b0e27bb608db2d5f96ec7527c4abce9b726baa9e147341b05f0dac031",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-spread/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-spread/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-spread\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Spread'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "f0cc42c2a5154cdbaf19a8713fdaca0a55cfa7728b87c898898622a8c7a715eb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-spread/README.md",
      "content": "# Spread - Contract\n\nThis is a Spread contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "a626241dc02c56468f1c44488c03393a08eef69c416bba8469378b00b7caaec0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-spread/src/Cargo.toml",
      "content": "[package]\nname = \"spread\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "a385b86e02c6a87dc54114f338c3ae4086823115b24ebd6084b1289386b0976d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-spread/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod spread {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Spread' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SpreadContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SpreadContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SpreadContract {\n        /// Creates a new PSP-22 compatible Spread Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Spread\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSPREAD\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "0d789cad6085a88aa21b065f65b4d947a59f1c812bc4c32b616f39beee382a82",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-spring/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-spring/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-spring\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Spring'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "16e55ba503a4eab74e43ed9b8cd2e381be542be0f2a548ddc9938817dbfa03df",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-spring/README.md",
      "content": "# Spring - Contract\n\nThis is a Spring contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "c46129dd165a76212fa67072d63c2cb22020134e48de05dbc30e70349da77df3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-spring/src/Cargo.toml",
      "content": "[package]\nname = \"spring\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "61b7d96c8665dc82cf22782ec4515065da854a153dabb1a57523286e816b98c8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-spring/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod spring {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Spring' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SpringContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SpringContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SpringContract {\n        /// Creates a new PSP-22 compatible Spring Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Spring\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSPRING\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "543191e811945e136d58af565b5d3e63f1d14ebc1a30d12856de74e97d4d98e7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-steam-vent/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-steam-vent/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-steam-vent\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'SteamVent'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "d44ff4cdc069d8a75b126cee5dafdb469a7e4abd9aef2deba5a7f00fd658e404",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-steam-vent/README.md",
      "content": "# Steam Vent - Contract\n\nThis is a Steam Vent contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "439fb3a2f2cfd6b5a795c9072533c7f504679bf6e26fb4143b4345109b423b09",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-steam-vent/src/Cargo.toml",
      "content": "[package]\nname = \"steam_vent\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "819dda8574f53b76756ce412adeec6f3750b0d38ec5ae26c4548b100e67ccf30",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-steam-vent/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod steam_vent {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Steam Vent' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SteamVentContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SteamVentContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SteamVentContract {\n        /// Creates a new PSP-22 compatible Steam Vent Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Steam Vent\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSTEAM_VENT\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "aa5d1c64a001841b7ada8e14b0d5aff312c3bc2bf30dc6d7f2f8e3d0f64d4011",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-steam/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-steam/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-steam\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Steam'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "9a4476a31fe4573b138639d8854d76d5b8a36693eecb04a1c0bd86db71369d6e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-steam/README.md",
      "content": "# Steam - Contract\n\nThis is a Steam contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "b71377a76edcfe04c75c31bee81a77cd189a8430b0ce527f8789e98ce3caea54",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-steam/src/Cargo.toml",
      "content": "[package]\nname = \"steam\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "2d3f08718a123afbdc37359cedcf6ef1d0508a8b2724d284dbfc2824fa6a95b9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-steam/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod steam {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Steam' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SteamContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SteamContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SteamContract {\n        /// Creates a new PSP-22 compatible Steam Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Steam\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSTEAM\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "9a7bb6c77d50910fcd313ce8eb72703cce500070159dbde8f9b140d5efef3bbc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-storm/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-storm/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-storm\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Storm'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "92b27b79d6e772a98aaa1dba431d2687333d173360027f9e6d0ebb0e5bad7e33",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-storm/README.md",
      "content": "# Storm - Contract\n\nThis is a Storm contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "ef485507b6ad7a7f07ca817459b33fe78b1cc1b9984bc9f15139ad28fd6007cb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-storm/src/Cargo.toml",
      "content": "[package]\nname = \"storm\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "794a7db66b103941766ef0d938aa55f27ed2cc2dd9d489717550562b30779ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-storm/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod storm {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Storm' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct StormContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for StormContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl StormContract {\n        /// Creates a new PSP-22 compatible Storm Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Storm\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSTORM\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "792e1799c65552ce166e1a45a231f3b72a69f88737bf72a96b71c8d07c66bb21",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-stream/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-stream/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-stream\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Stream'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "48c5572851f48308251989289fd495b0b4e0c4624440363a8aa5687bd4aab98a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-stream/README.md",
      "content": "# Stream - Contract\n\nThis is a Stream contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "f8c50e818a5edb5afad984f4f92dcb42c01aa3a29e302a7b6a9eedb3e045abdf",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-stream/src/Cargo.toml",
      "content": "[package]\nname = \"stream\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "305254b1e8673be8ac3f79afae484594e149af30f3e7bb1e75ff03bffcb7b4dd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-stream/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod stream {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Stream' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct StreamContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for StreamContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl StreamContract {\n        /// Creates a new PSP-22 compatible Stream Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Stream\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSTREAM\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "69908a1c438b4c04ce0828baaf5f95819639797e55eaba3c49ace5c1a0cf3beb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-subterranean-pool/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-subterranean-pool/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-subterranean-pool\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'SubterraneanPool'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "29ea3f1fcf4bbe4e9c377e283db198f6bcb4fa791049408361243776b4fa34bf",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-subterranean-pool/README.md",
      "content": "# Subterranean Pool - Contract\n\nThis is a Subterranean Pool contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "08825abaad2e4565604fd59d674fd6b7e57c8533a3cee9a3370664d07a0cbbe0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-subterranean-pool/src/Cargo.toml",
      "content": "[package]\nname = \"subterranean_pool\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "8ea52517c25f42e1d13ed85da58571fa15f08d594127380e7e6e81411752151c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-subterranean-pool/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod subterranean_pool {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Subterranean Pool' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SubterraneanPoolContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SubterraneanPoolContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SubterraneanPoolContract {\n        /// Creates a new PSP-22 compatible Subterranean Pool Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Subterranean Pool\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSUBTERRANEAN_POOL\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "788c293ee5839e8ebd54351ae062ece642d7f6512715987ed5fcc55d0697f01a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-super-marmalade/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-super-marmalade/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-super-marmalade\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'SuperMarmalade'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "7b75ec668e54bab3a27e0e970cae537d6f14844eec2035ab1e6ca8dbb946c60b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-super-marmalade/README.md",
      "content": "# Super Marmalade - Contract\n\nThis is a Super Marmalade contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "21b3bf3936d988d866577311510d2175f6b8c431a1faede43fb56ea5b52bf454",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-super-marmalade/src/Cargo.toml",
      "content": "[package]\nname = \"super_marmalade\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "ebd07d2637898d5e1f8db47c9210ab93a6c0505087d298601a578558540b0e8c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-super-marmalade/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod super_marmalade {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Super Marmalade' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SuperMarmaladeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SuperMarmaladeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SuperMarmaladeContract {\n        /// Creates a new PSP-22 compatible Super Marmalade Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Super Marmalade\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSUPER_MARMALADE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "0dbf028512831b87c700e6c5a9572f1ab61db153700dd7d941e0cbbd17860b30",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-swarm/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-swarm/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-swarm\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'SWARM'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "a3d7be01a635940b781898b92e55bbdcb051e116932166f58a17e1067adf3ab0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-swarm/README.md",
      "content": "# Swarm - Contract\n\nThis is a Swarm contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "abbf73f569c67515051a4e0aa593da7d80fc95b01f28f28dab860b87be74eab3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-swarm/src/Cargo.toml",
      "content": "[package]\nname = \"swarm\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "df2924d132cabcce9275dec8e7982775dd93f4fd566ce6daf782cc501a78be94",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-swarm/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod swarm {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Swarm' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SwarmContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SwarmContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SwarmContract {\n        /// Creates a new PSP-22 compatible Swarm Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Swarm\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSWARM\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "35a4bf4f9a2bf0b23139d2466eb437a626d5fb69a83a98f5e043a91866a7d668",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-thunder/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-thunder/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-thunder\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Thunder'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "cb5af0f3605c89ab0972598986fdc77fdb688512993a22b87f1400c30b152d75",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-thunder/README.md",
      "content": "# Thunder - Contract\n\nThis is a Thunder contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "43f9e9c7880b8c7820b1ec0ac5deb3f21907b52623e1ed7fcdd6c169d5e1450b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-thunder/src/Cargo.toml",
      "content": "[package]\nname = \"thunder\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "c4c5e971c7fa4010d1f846c3e751615089106858729d3ee4c0aa280f1f89dcca",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-thunder/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod thunder {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Thunder' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct ThunderContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for ThunderContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl ThunderContract {\n        /// Creates a new PSP-22 compatible Thunder Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Thunder\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MTHUNDER\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "863bee3ff5eca5530aa90351698e6e7869ff8284d09489b1e20fd517da7b426f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-tornado/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-tornado/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-tornado\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Tornado'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "c4fad6628ee786c8474f217bc64adc3465e579268b9ab0637a36794a2b34673a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-tornado/README.md",
      "content": "# Tornado - Contract\n\nThis is a Tornado contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "ad5bed14a8e2698eaf594acf9856597b209250a5b53f1a59d89603e15fa9f98a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-tornado/src/Cargo.toml",
      "content": "[package]\nname = \"tornado\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "4435160fb91bac02bbc3ad0e8bc88dae63cacda9fc1ce26355542bd141a651b6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-tornado/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod tornado {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Tornado' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct TornadoContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for TornadoContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl TornadoContract {\n        /// Creates a new PSP-22 compatible Tornado Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Tornado\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MTORNADO\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "e95126ce3368e26c207692535a4d3390510df8d61d95c03f6a14c58449506b6f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-transaction/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-transaction/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-transaction\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Transaction'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "bfc0a12319e481e9d6795e19d4ef48234ba06899e12abbfa1452960817e1a491",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-transaction/README.md",
      "content": "# Transaction - Contract\n\nThis is a Transaction contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "23d86b5a34010d8861080333bf0f25821954fd175aac4e20d068dbc3decc3571",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-transaction/src/Cargo.toml",
      "content": "[package]\nname = \"transaction\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "976dc687c50ea89a82fc48fbc36c7e1f6a9c81686cb73d40ca810f771f7a4635",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-transaction/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod transaction {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Transaction' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct TransactionContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for TransactionContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl TransactionContract {\n        /// Creates a new PSP-22 compatible Transaction Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Transaction\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MTRANSACTION\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "ddddd002a817db1b6730b448836b9ee1d6e35d4f335acf1ec975fce7c78a9534",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-tree/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-tree/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-tree\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Tree'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "3cc87b3de3835b1e5ac54817537a43b0aea0aea377caaf5bc37c08ada2c358fd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-tree/README.md",
      "content": "# Tree - Contract\n\nThis is a Tree contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "e6c18344d628f5a1ab5ce9aa2ca1369819d083a01e18cb02cefb1fdd1ac50781",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-tree/src/Cargo.toml",
      "content": "[package]\nname = \"tree\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "79e86d0f3bca4b5be1f539a405afd6955fbde76c774cb44cacb2351af7a9f5c5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-tree/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod tree {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Tree' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct TreeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for TreeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl TreeContract {\n        /// Creates a new PSP-22 compatible Tree Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Tree\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MTREE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "4ae50394b3946ac0da7b21e31424e995ee43685b523a4799950fc9df963ecfb0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-tributary/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-tributary/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-tributary\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Tributary'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "fa335b9126c2de7072b612916205354c7934212d6075bf90de56309a549c7d37",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-tributary/README.md",
      "content": "# Tributary - Contract\n\nThis is a Tributary contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "bf463a7f09d2e91099f11c6930df52ed0d0217700d405fdc5cffb8c702a182ca",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-tributary/src/Cargo.toml",
      "content": "[package]\nname = \"tributary\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "6ff0c58800d8edb355ab1a69fc9705faf8680d6d232dd18afabce150b914021b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-tributary/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod tributary {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Tributary' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct TributaryContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for TributaryContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl TributaryContract {\n        /// Creates a new PSP-22 compatible Tributary Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Tributary\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MTRIBUTARY\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "773c72f2ec5e311651cd05e548cbe67771f2f78e32bc0897d11f032b34ad086d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-underground-lake/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-underground-lake/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-underground-lake\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'UndergroundLake'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "f43ed3f3a522dda2b0393f7654e90fe22d0040a4002b809a2612461301dde46e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-underground-lake/README.md",
      "content": "# Underground Lake - Contract\n\nThis is a Underground Lake contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "8af51e94f8b80e52218ee23252715eea118bedffecac3b0361813f87b34b9b82",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-underground-lake/src/Cargo.toml",
      "content": "[package]\nname = \"underground_lake\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "e798cc81ad0af1d121a29ef0057f050612ebe6cdf34122eed9194e3c0607c5f1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-underground-lake/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod underground_lake {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Underground Lake' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct UndergroundLakeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for UndergroundLakeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl UndergroundLakeContract {\n        /// Creates a new PSP-22 compatible Underground Lake Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Underground Lake\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MUNDERGROUND_LAKE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "ff3aae2661a9f2ebbfbc651521c16e178b26ccbab8fe2e66ccc01e21112b3655",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-unifiers/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-unifiers/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-unifiers\",\n    \"description\": \"The Game Contract of the game Unifiers\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "394aadf17341df2cbcfceda609096b5d5f15fa7e8b12c0b53323f402fd797d4f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-unifiers/README.md",
      "content": "# Unifiers - Game Contract\n\nThis is the **main outer contract** that the **game logic** interacts with.",
      "contentHash": "5ed8906052112c082200b96d9d322863a5b38d18c40e6f8c0c138e678d0822e0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-unifiers/src/Cargo.toml",
      "content": "[package]\nname = \"unifiers\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "8d18f99d5d06f990db4eef7f7ba554e6754e650209a0fa2522d7b10ce220a726",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-unifiers/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n/// A game created with the help of the Unifiers group\n#[ink::contract]\npub mod unifiers {\n    pub use ink::prelude::string::String;\n    pub use ink::prelude::format;\n    pub use ink::storage::Mapping;\n    use ink::{\n        env::{\n            call::{build_call, ExecutionInput, Selector},\n            CallFlags, DefaultEnvironment,\n        },\n    };\n\n    /** Error type for the game contract for Unifiers */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        Custom(String),\n        ElementContractError(String),\n        InkError(ink::primitives::LangError),\n        FatalError(String),\n        ElementContractIsNotLocked,\n        ElementContractAlreadyLocked,\n        NotTheOwner,\n        OwnerAlreadySet,\n        BuyOfferIsNotSet,\n        InsufficientBuyTransferredValue,\n        InvalidRecipe,\n        NotEnoughElements,\n        InvalidElement,\n    }\n\n    #[ink(storage)]\n    pub struct GameContract {\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        element_contract_ids: Mapping<u32, AccountId>,\n        buy_offer_price_native_tokens: u128,\n        buy_offer_reward_tier_points: u128,\n        buy_offer_is_set: bool,\n        pool_round: u128,\n        pool_target: u128,\n        pool_value: u128,\n    }\n\n    struct Element {\n        id: u32,\n        name: &'static str,\n        description: &'static str,\n        tier: u32,\n    }\n\n    struct Recipe {\n        id: u32,\n        a: u32,\n        b: u32,\n        c: u32,\n    }\n\n    const ELEMENT_MONKEY: Element = Element {\n        id: 0,\n        name: \"Monkey\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_GIRAFFE: Element = Element {\n        id: 1,\n        name: \"Giraffe\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_BEE: Element = Element {\n        id: 2,\n        name: \"Bee\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_COIN: Element = Element {\n        id: 3,\n        name: \"Coin\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_SWARM: Element = Element {\n        id: 4,\n        name: \"SWARM\",\n        description: \"We need a description here\",\n        tier: 2,\n    };\n    const ELEMENT_HYDRA: Element = Element {\n        id: 5,\n        name: \"Hydra\",\n        description: \"We need a description here\",\n        tier: 2,\n    };\n    const ELEMENT_MONKEY_BRANCH: Element = Element {\n        id: 6,\n        name: \"MonkeyBranch\",\n        description: \"We need a description here\",\n        tier: 2,\n    };\n    const ELEMENT_BRIDGE: Element = Element {\n        id: 7,\n        name: \"Bridge\",\n        description: \"We need a description here\",\n        tier: 2,\n    };\n    const ELEMENT_GOLDEN_GATE: Element = Element {\n        id: 8,\n        name: \"GoldenGate\",\n        description: \"We need a description here\",\n        tier: 2,\n    };\n    const ELEMENT_GOLD: Element = Element {\n        id: 9,\n        name: \"Gold\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_SILVER: Element = Element {\n        id: 10,\n        name: \"Silver\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_RHODIUM: Element = Element {\n        id: 11,\n        name: \"Rhodium\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_HIVE: Element = Element {\n        id: 12,\n        name: \"Hive\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_TRANSACTION: Element = Element {\n        id: 13,\n        name: \"Transaction\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_BLOCK: Element = Element {\n        id: 14,\n        name: \"Block\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_BLOCKCHAIN: Element = Element {\n        id: 15,\n        name: \"Blockchain\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_POLKADOT: Element = Element {\n        id: 16,\n        name: \"Polkadot\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_PEER_REVIEW: Element = Element {\n        id: 17,\n        name: \"PeerReview\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_CARDANO: Element = Element {\n        id: 18,\n        name: \"Cardano\",\n        description: \"We need a description here\",\n        tier: 2,\n    };\n    const ELEMENT_BEAR: Element = Element {\n        id: 19,\n        name: \"Bear\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_BEER: Element = Element {\n        id: 20,\n        name: \"Beer\",\n        description: \"We need a description here\",\n        tier: 2,\n    };\n    const ELEMENT_LOCK: Element = Element {\n        id: 21,\n        name: \"Lock\",\n        description: \"We need a description here\",\n        tier: 2,\n    };\n    const ELEMENT_MARMALADE: Element = Element {\n        id: 22,\n        name: \"Marmalade\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_SUPER_MARMALADE: Element = Element {\n        id: 23,\n        name: \"SuperMarmalade\",\n        description: \"We need a description here\",\n        tier: 2,\n    };\n    const ELEMENT_HYPER_MARMALADE: Element = Element {\n        id: 24,\n        name: \"HyperMarmalade\",\n        description: \"We need a description here\",\n        tier: 2,\n    };\n    const RECIPE_MAKE_SWARM: Recipe = Recipe {\n        id: 0,\n        a: 2,\n        b: 2,\n        c: 4,\n    };\n    const RECIPE_MAKE_HYDRA: Recipe = Recipe {\n        id: 1,\n        a: 1,\n        b: 1,\n        c: 5,\n    };\n    const RECIPE_MAKE_MONKEYBRANCH: Recipe = Recipe {\n        id: 2,\n        a: 0,\n        b: 5,\n        c: 6,\n    };\n    const RECIPE_MAKE_BRIDGE: Recipe = Recipe {\n        id: 3,\n        a: 6,\n        b: 6,\n        c: 7,\n    };\n    const RECIPE_MAKE_GOLDENGATE: Recipe = Recipe {\n        id: 4,\n        a: 3,\n        b: 7,\n        c: 8,\n    };\n    const RECIPE_MAKE_CARDANO: Recipe = Recipe {\n        id: 5,\n        a: 15,\n        b: 17,\n        c: 18,\n    };\n    const RECIPE_MAKE_BEER: Recipe = Recipe {\n        id: 6,\n        a: 2,\n        b: 19,\n        c: 20,\n    };\n    const RECIPE_MAKE_LOCK: Recipe = Recipe {\n        id: 7,\n        a: 10,\n        b: 10,\n        c: 21,\n    };\n    const RECIPE_MAKE_SUPERMARMALADE: Recipe = Recipe {\n        id: 8,\n        a: 22,\n        b: 22,\n        c: 23,\n    };\n    const RECIPE_MAKE_HYPERMARMALADE: Recipe = Recipe {\n        id: 9,\n        a: 23,\n        b: 23,\n        c: 24,\n    };\n\n    fn find_item(index: u32) -> Option<Element> {\n        if index == 0 {\n            return Some(ELEMENT_MONKEY);\n        }\n        if index == 1 {\n            return Some(ELEMENT_GIRAFFE);\n        }\n        if index == 2 {\n            return Some(ELEMENT_BEE);\n        }\n        if index == 3 {\n            return Some(ELEMENT_COIN);\n        }\n        if index == 4 {\n            return Some(ELEMENT_SWARM);\n        }\n        if index == 5 {\n            return Some(ELEMENT_HYDRA);\n        }\n        if index == 6 {\n            return Some(ELEMENT_MONKEY_BRANCH);\n        }\n        if index == 7 {\n            return Some(ELEMENT_BRIDGE);\n        }\n        if index == 8 {\n            return Some(ELEMENT_GOLDEN_GATE);\n        }\n        if index == 9 {\n            return Some(ELEMENT_GOLD);\n        }\n        if index == 10 {\n            return Some(ELEMENT_SILVER);\n        }\n        if index == 11 {\n            return Some(ELEMENT_RHODIUM);\n        }\n        if index == 12 {\n            return Some(ELEMENT_HIVE);\n        }\n        if index == 13 {\n            return Some(ELEMENT_TRANSACTION);\n        }\n        if index == 14 {\n            return Some(ELEMENT_BLOCK);\n        }\n        if index == 15 {\n            return Some(ELEMENT_BLOCKCHAIN);\n        }\n        if index == 16 {\n            return Some(ELEMENT_POLKADOT);\n        }\n        if index == 17 {\n            return Some(ELEMENT_PEER_REVIEW);\n        }\n        if index == 18 {\n            return Some(ELEMENT_CARDANO);\n        }\n        if index == 19 {\n            return Some(ELEMENT_BEAR);\n        }\n        if index == 20 {\n            return Some(ELEMENT_BEER);\n        }\n        if index == 21 {\n            return Some(ELEMENT_LOCK);\n        }\n        if index == 22 {\n            return Some(ELEMENT_MARMALADE);\n        }\n        if index == 23 {\n            return Some(ELEMENT_SUPER_MARMALADE);\n        }\n        if index == 24 {\n            return Some(ELEMENT_HYPER_MARMALADE);\n        }\n        None\n    }\n\n    fn find_recipe(index: u32) -> Option<Recipe> {\n        if index == 0 {\n            return Some(RECIPE_MAKE_SWARM);\n        }\n        if index == 1 {\n            return Some(RECIPE_MAKE_HYDRA);\n        }\n        if index == 2 {\n            return Some(RECIPE_MAKE_MONKEYBRANCH);\n        }\n        if index == 3 {\n            return Some(RECIPE_MAKE_BRIDGE);\n        }\n        if index == 4 {\n            return Some(RECIPE_MAKE_GOLDENGATE);\n        }\n        if index == 5 {\n            return Some(RECIPE_MAKE_CARDANO);\n        }\n        if index == 6 {\n            return Some(RECIPE_MAKE_BEER);\n        }\n        if index == 7 {\n            return Some(RECIPE_MAKE_LOCK);\n        }\n        if index == 8 {\n            return Some(RECIPE_MAKE_SUPERMARMALADE);\n        }\n        if index == 9 {\n            return Some(RECIPE_MAKE_HYPERMARMALADE);\n        }\n        None\n    }\n\n\n    impl Default for GameContract {\n        fn default() -> Self {\n            let element_contract_ids = Mapping::new();\n            Self {\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                element_contract_ids,\n                buy_offer_price_native_tokens: 0,\n                buy_offer_reward_tier_points: 0,\n                buy_offer_is_set: false,\n                pool_round: 1,\n                pool_target: 10,\n                pool_value: 0,\n            }\n        }\n    }\n\n    impl GameContract {\n        /// Creates a new PSP-22 compatible Lava Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        /// Sets the owner of the contract\n        #[ink(message)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::OwnerAlreadySet);\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        /// Locks the contract id of an element\n        #[ink(message)]\n        pub fn lock_element_contract(&mut self, element_id: u32, element_contract_id: AccountId) -> Result<(), Error> {\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::NotTheOwner);\n            }\n            if self.element_contract_ids.contains(element_id) {\n                return Err(Error::ElementContractAlreadyLocked);\n            }\n            self.element_contract_ids.insert(element_id, &element_contract_id);\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn balance_of_element(&self, element_id: u32) -> Result<u128, Error> {\n            let element_contract_id = self.element_contract_ids.get(element_id).unwrap_or(AccountId::from([0xFF; 32]));\n            if element_contract_id == AccountId::from([0xFF; 32]) {\n                return Err(Error::ElementContractIsNotLocked);\n            }\n            let call_result = build_call::<DefaultEnvironment>()\n                .call(element_contract_id)\n                .exec_input(\n                    ExecutionInput::new(Selector::new(\n                            // Selector of PSP22::balance_of -> 0x6568382f\n                            [0x65, 0x68, 0x38, 0x2f]\n                        ))\n                        .push_arg(&self.env().caller()) // owner: AccountId parameter\n                )\n                .returns::<u128>()\n                .try_invoke();\n            match call_result {\n                Ok(okresult) => match okresult {\n                    Ok(result) => Ok(result),\n                    Err(reserr) => Err(Error::InkError(reserr))\n                },\n                Err(_) => Err(Error::FatalError(String::from(\"Error invoking PSP22::balance_of\")))\n            }\n        }\n\n        #[ink(message)]\n        pub fn set_buy_offer(&mut self, price: u128, reward_tier_points: u128) -> Result<(), Error> {\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::NotTheOwner);\n            }\n            self.buy_offer_price_native_tokens = price;\n            self.buy_offer_reward_tier_points = reward_tier_points;\n            self.buy_offer_is_set = true;\n            Ok(())\n        }\n        \n        #[ink(message)]\n        pub fn buy_offer(&self) -> Result<(u128, u128), Error> {\n            Ok((self.buy_offer_price_native_tokens, self.buy_offer_reward_tier_points))\n        }\n\n        #[ink(message)]\n        pub fn pool(&self) -> Result<(u128, u128, u128), Error> {\n            Ok((self.pool_round, self.pool_target, self.pool_value))\n        }\n\n        #[ink(message)]\n        pub fn sacrifice(&mut self, element_id: u32) -> Result<(), Error> {\n            let found_item = find_item(element_id);\n\n            if found_item.is_none() {\n                return Err(Error::InvalidElement);\n            }\n\n            let balance_of = self.balance_of_element(element_id).unwrap_or(0);\n            if balance_of == 0 {\n                return Err(Error::NotEnoughElements);\n            }\n\n            let element_contract_id = self.element_contract_ids.get(element_id).unwrap_or(AccountId::from([0xFF; 32]));\n\n            if element_contract_id == AccountId::from([0xFF; 32]) {\n                return Err(Error::ElementContractIsNotLocked);\n            }\n\n            let call_result = build_call::<DefaultEnvironment>()\n                .call(element_contract_id)\n                .call_flags(CallFlags::ALLOW_REENTRY)\n                .exec_input(\n                    ExecutionInput::new(Selector::new(\n                            // Selector of ElementContract::burn -> 0x100fa9ca\n                            [0x10, 0x0f, 0xa9, 0xca]\n                        ))\n                        .push_arg::<AccountId>(self.env().caller()) // owner: AccountId parameter\n                        .push_arg::<u128>(1) // value: u128 parameter\n                )\n                .returns::<Result<(), Error>>()\n                .try_invoke();\n            \n            match call_result {\n                Ok(okresult) => match okresult {\n                    Ok(_) => {\n                        self.pool_value = self.pool_value.checked_add(found_item.unwrap().tier.into()).unwrap_or(0);\n                        if self.pool_value >= self.pool_target {\n                            self.pool_round = self.pool_round.checked_add(1).unwrap_or(0);\n                            self.pool_value = 0;\n                            // Transfer contract value to caller\n                            self.env().transfer(self.env().caller(), self.env().balance());\n                            // Next target is last target + 10 * round\n                            self.pool_target = self.pool_target.checked_add(self.pool_round.checked_mul(10).unwrap_or(0)).unwrap_or(0);\n                        }\n                        Ok(())\n                    },\n                    Err(reserr) => Err(Error::InkError(reserr))\n                },\n                Err(fatalerr) => Err(Error::FatalError(format!(\"Error invoking ElementContract::burn: {:?}\", fatalerr)))\n            }\n        }\n\n        #[ink(message)]\n        pub fn prize(&self) -> Result<u128, Error> {\n            Ok(self.env().balance())\n        }\n\n        #[ink(message, payable)]\n        pub fn buy(&mut self, element_id: u32) -> Result<(), Error> {\n            if !self.buy_offer_is_set {\n                return Err(Error::BuyOfferIsNotSet);\n            }\n\n            let val = self.env().transferred_value();\n\n            if val < self.buy_offer_price_native_tokens {\n                return Err(Error::InsufficientBuyTransferredValue);\n            }\n\n            let buy_count = val.checked_div(self.buy_offer_price_native_tokens).unwrap_or(0);\n\n            if buy_count == 0 {\n                return Err(Error::InsufficientBuyTransferredValue);\n            }\n\n            // TODO: Add element tiers and calculate number of received items based on that\n            let reward_tier_points = self.buy_offer_reward_tier_points.checked_mul(buy_count).unwrap_or(0);\n\n            if reward_tier_points == 0 {\n                return Err(Error::FatalError(String::from(\"Error calculating reward tier points, possible overflow\")));\n            }\n\n            let element_contract_id = self.element_contract_ids.get(element_id).unwrap_or(AccountId::from([0xFF; 32]));\n\n            if element_contract_id == AccountId::from([0xFF; 32]) {\n                return Err(Error::ElementContractIsNotLocked);\n            }\n\n            let element = find_item(element_id);\n\n            if element.is_none() {\n                return Err(Error::InvalidElement);\n            }\n\n            let el = element.unwrap();\n\n            let reward_items: u128 = reward_tier_points.checked_div(el.tier.into()).unwrap_or(0);\n\n            if reward_items == 0 {\n                return Err(Error::InsufficientBuyTransferredValue);\n            }\n\n            let call_result = build_call::<DefaultEnvironment>()\n                .call(element_contract_id)\n                .call_flags(CallFlags::TAIL_CALL)\n                .exec_input(\n                    ExecutionInput::new(Selector::new(\n                            // Selector of ElementContract::mint -> 0x21615d0f\n                            [0x21, 0x61, 0x5d, 0x0f]\n                        ))\n                        .push_arg::<AccountId>(self.env().caller()) // owner: AccountId parameter\n                        .push_arg::<u128>(reward_items) // value: u128 parameter\n                )\n                .returns::<()>()\n                .try_invoke();\n            match call_result {\n                Ok(okresult) => match okresult {\n                    Ok(_) => Ok(()),\n                    Err(reserr) => Err(Error::InkError(reserr))\n                },\n                Err(fatalerr) => Err(Error::FatalError(format!(\"Error invoking ElementContract::mint: {:?}\", fatalerr)))\n            }\n        }\n\n        #[ink(message)]\n        pub fn craft(&mut self, recipe_id: u32) -> Result<(), Error> {\n            let recipe = find_recipe(recipe_id);\n\n            if recipe.is_none() {\n                return Err(Error::InvalidRecipe);\n            }\n\n            let rec = recipe.unwrap();\n\n            let element_a_index = rec.a;\n            let element_b_index = rec.b;\n            let element_c_index = rec.c;\n\n            let element_a_contract_id = self.element_contract_ids.get(element_a_index).unwrap_or(AccountId::from([0xFF; 32]));\n            let element_b_contract_id = self.element_contract_ids.get(element_b_index).unwrap_or(AccountId::from([0xFF; 32]));\n            let element_c_contract_id = self.element_contract_ids.get(element_c_index).unwrap_or(AccountId::from([0xFF; 32]));\n\n            let element_a_balance = self.balance_of_element(element_a_index).unwrap_or(0);\n            let element_b_balance = self.balance_of_element(element_b_index).unwrap_or(0);\n\n            if element_a_contract_id == AccountId::from([0xFF; 32]) || element_b_contract_id == AccountId::from([0xFF; 32]) || element_c_contract_id == AccountId::from([0xFF; 32]) {\n                return Err(Error::ElementContractIsNotLocked);\n            }\n\n            if element_a_balance == 0 || element_b_balance == 0 {\n                return Err(Error::NotEnoughElements);\n            }\n\n            // Burn calls to element contracts\n            let call_result_a = build_call::<DefaultEnvironment>()\n                .call(element_a_contract_id)\n                .call_flags(CallFlags::ALLOW_REENTRY)\n                .exec_input(\n                    ExecutionInput::new(Selector::new(\n                            // Selector of ElementContract::burn -> 0x100fa9ca\n                            [0x10, 0x0f, 0xa9, 0xca]\n                        ))\n                        .push_arg::<AccountId>(self.env().caller()) // owner: AccountId parameter\n                        .push_arg::<u128>(1) // value: u128 parameter\n                )\n                .returns::<Result<(), Error>>()\n                .try_invoke();\n            \n            let call_result_b = build_call::<DefaultEnvironment>()\n                .call(element_b_contract_id)\n                .call_flags(CallFlags::ALLOW_REENTRY)\n                .exec_input(\n                    ExecutionInput::new(Selector::new(\n                            // Selector of ElementContract::burn -> 0x100fa9ca\n                            [0x10, 0x0f, 0xa9, 0xca]\n                        ))\n                        .push_arg::<AccountId>(self.env().caller()) // owner: AccountId parameter\n                        .push_arg::<u128>(1) // value: u128 parameter\n                )\n                .returns::<Result<(), Error>>()\n                .try_invoke();\n            \n            match call_result_a {\n                Ok(okresult1) => match okresult1 {\n                    Ok(_) => (),\n                    Err(reserr1) => return Err(Error::InkError(reserr1))\n                },\n                Err(fatalerr1) => return Err(Error::FatalError(format!(\"Error invoking ElementContract::burn (1 / 3): {:?}\", fatalerr1)))\n            }\n\n            match call_result_b {\n                Ok(okresult2) => match okresult2 {\n                    Ok(_) => (),\n                    Err(reserr2) => return Err(Error::InkError(reserr2))\n                },\n                Err(fatalerr2) => return Err(Error::FatalError(format!(\"Error invoking ElementContract::burn (2 / 3): {:?}\", fatalerr2)))\n            }\n            \n            // Mint call to element contract\n            let call_result_c = build_call::<DefaultEnvironment>()\n                .call(element_c_contract_id)\n                .call_flags(CallFlags::TAIL_CALL)\n                .exec_input(\n                    ExecutionInput::new(Selector::new(\n                            // Selector of ElementContract::mint -> 0x21615d0f\n                            [0x21, 0x61, 0x5d, 0x0f]\n                        ))\n                        .push_arg::<AccountId>(self.env().caller()) // owner: AccountId parameter\n                        .push_arg::<u128>(1) // value: u128 parameter\n                )\n                .returns::<Result<(), Error>>()\n                .try_invoke();\n    \n            match call_result_c {\n                Ok(okresult3) => match okresult3 {\n                    Ok(_) => Ok(()),\n                    Err(reserr3) => Err(Error::InkError(reserr3))\n                },\n                Err(fatalerr3) => Err(Error::FatalError(format!(\"Error invoking ElementContract::mint (3 / 3): {:?}\", fatalerr3)))\n            }\n            \n        }\n    }\n\n}",
      "contentHash": "02ef6f16984cc15fe4ffb3fd2bd97f61e6c3c68988757de6af5e6fb93c0ed00e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-valley/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-valley/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-valley\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Valley'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "abd92315df3c8f3b3e39287249181f0cc63f9b1d9ccd0fc41d4eed994dda112c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-valley/README.md",
      "content": "# Valley - Contract\n\nThis is a Valley contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "921835428c3361bc70b0740c201362cefc39389f59b9ff6804410a417b7703ca",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-valley/src/Cargo.toml",
      "content": "[package]\nname = \"valley\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "7857edf381598423251f5614dc1952d279fcbc2ee0003ccd827f9a7e60af3e89",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-valley/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod valley {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Valley' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct ValleyContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for ValleyContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl ValleyContract {\n        /// Creates a new PSP-22 compatible Valley Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Valley\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MVALLEY\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "ffc5095f1e43b4517c007c551d9b6e772f6f060df329a285645438a53e8ad585",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-volcano/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-volcano/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-volcano\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Volcano'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "366f1a9aaa13886d203dadbaaadae1a23eb6669792df31774945983056606986",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-volcano/README.md",
      "content": "# Volcano - Contract\n\nThis is a Volcano contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "c2e3f3acf8ea78fa029dea91fc4669a8d8c5e82dab62d4ed7df1ea67a012c570",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-volcano/src/Cargo.toml",
      "content": "[package]\nname = \"volcano\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "66cd3aa7e347ce9e3644a6791c6dc1060b704ba64163458214f46ba453956ea9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-volcano/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod volcano {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Volcano' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct VolcanoContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for VolcanoContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl VolcanoContract {\n        /// Creates a new PSP-22 compatible Volcano Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Volcano\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MVOLCANO\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "eaef7e479449a0e2fdcc87891e98d948265545a56b87e79fd81e10b156007602",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wall/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wall/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-wall\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Wall'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "74468e5d9b074d49b82aff0a73b83b21f7be364740ff19ab0e53dd24ce84b548",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wall/README.md",
      "content": "# Wall - Contract\n\nThis is a Wall contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "b98ed6f62fa22b3d61d01e65dc5fe499b0bc0bf17668c9a43763dd5d22d90172",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wall/src/Cargo.toml",
      "content": "[package]\nname = \"wall\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "7f90fa7e280bd2bf2a33cf0299f3a18799f65c07634984a62189367941690c4f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wall/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod wall {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Wall' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct WallContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for WallContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl WallContract {\n        /// Creates a new PSP-22 compatible Wall Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Wall\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MWALL\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "e04be09d102c56f3a1dd53082ec5d3aba9821f683e5bff42b8a0438603b34ed8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-warm-breeze/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-warm-breeze/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-warm-breeze\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'WarmBreeze'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "c7d1fc78a80d7d68a3a3e5a10c8d73a38f9d9f252009942fe89c94b5507fdc82",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-warm-breeze/README.md",
      "content": "# Warm Breeze - Contract\n\nThis is a Warm Breeze contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "ef9c3296d93b7f55261e7ba64ff11c88f539fdc602dc20242a42a880f1870a38",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-warm-breeze/src/Cargo.toml",
      "content": "[package]\nname = \"warm_breeze\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "bff19a24a6a8ff617d4ad306384a414371221904d1b709cb05a1b54ccf106844",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-warm-breeze/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod warm_breeze {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Warm Breeze' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct WarmBreezeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for WarmBreezeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl WarmBreezeContract {\n        /// Creates a new PSP-22 compatible Warm Breeze Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Warm Breeze\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MWARM_BREEZE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "e13b6f0d4ece81cbed4d84e1a770fe09d89f0b2d801447d71542db8c323aad5f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-water/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-water/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-water\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Water'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "cac610073d5c6afeb359903b063fcc0e813e2ecacef11556dbd0d48c820fa524",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-water/README.md",
      "content": "# Water - Contract\n\nThis is a Water contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "2ee24c587a6f6cceb45089d79a8516a392d29014d8f304d6a07b1c02c84e1fff",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-water/src/Cargo.toml",
      "content": "[package]\nname = \"water\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "abfd355630ccda731ba36c9d63cb728037ba4c3557041154e1e23ed0202a2032",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-water/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod water {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Water' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct WaterContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for WaterContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl WaterContract {\n        /// Creates a new PSP-22 compatible Water Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Water\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MWATER\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "d3193a3ab40afe663f596be9b274dd571d279290f243456447ce74484285e363",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-waterfall/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-waterfall/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-waterfall\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Waterfall'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "aac290306454e2eecd0571cb788e6c8814f5a982db26a153974aff69a4d821b5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-waterfall/README.md",
      "content": "# Waterfall - Contract\n\nThis is a Waterfall contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "8dcef6a4fe9c6b2a2d46430bae72425e6967cb350e276e5d42b68b4cc469c05f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-waterfall/src/Cargo.toml",
      "content": "[package]\nname = \"waterfall\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "1c3eb99ddf2277173a20e22119960b6d7f5eed833b1d3b632533b3186466b625",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-waterfall/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod waterfall {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Waterfall' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct WaterfallContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for WaterfallContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl WaterfallContract {\n        /// Creates a new PSP-22 compatible Waterfall Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Waterfall\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MWATERFALL\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "50ac20f7b7ba09d116490e7cf895c9fb4e77c47d0a75f04ba0934825ea9bf66d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-watershed/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-watershed/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-watershed\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Watershed'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "d5fd86513735d4aa9cdd7d4207d4188325793902171a75352597b61aa99e9975",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-watershed/README.md",
      "content": "# Watershed - Contract\n\nThis is a Watershed contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "8e6518063f6aa490aba0af837a9792e3361769a31173246ccb289429ae7213ef",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-watershed/src/Cargo.toml",
      "content": "[package]\nname = \"watershed\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "c231a081b5dd8ba353241718efcd54cc414eaac94b8a3af8cf0a85f9818dcf95",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-watershed/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod watershed {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Watershed' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct WatershedContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for WatershedContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl WatershedContract {\n        /// Creates a new PSP-22 compatible Watershed Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Watershed\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MWATERSHED\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "891956aaf83eb990a81fb22d3e277a2b05721ea895121c415aaf6fc100a4a504",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wave/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wave/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-wave\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Wave'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "affebf6b1a59a90ad7fbaf60aca24bbbdbc82de77a49fb6b36f20c94a4b8e457",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wave/README.md",
      "content": "# Wave - Contract\n\nThis is a Wave contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "b9020f318272290ea1ff606e93d1613c8908ef8433a7110d6f761ac4d30c30de",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wave/src/Cargo.toml",
      "content": "[package]\nname = \"wave\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "f2a5f5c478d3b1fc41017aa4d32279c35239d23c693876ce1c811a08f05c748f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wave/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod wave {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Wave' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct WaveContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for WaveContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl WaveContract {\n        /// Creates a new PSP-22 compatible Wave Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Wave\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MWAVE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "0941976fdf1f15b84fb817be4ad582c98deac356bc41669fd10cb1ed8233cac4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wetland/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wetland/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-wetland\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Wetland'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "404062119b051b295c0f93338b0f1a2f35507af1bbac10987ee5652ad4ba57e5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wetland/README.md",
      "content": "# Wetland - Contract\n\nThis is a Wetland contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "c62cb4195c400a5d9ccde595e2e5b7736c12ddcdf3336ac83b7082e80cf9973c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wetland/src/Cargo.toml",
      "content": "[package]\nname = \"wetland\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "f7d095aa9ec34e27169781b6256e9af62485d3522eed81e386836f8c135bb6bc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wetland/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod wetland {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Wetland' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct WetlandContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for WetlandContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl WetlandContract {\n        /// Creates a new PSP-22 compatible Wetland Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Wetland\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MWETLAND\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "626205b8fb6a4baff55d35525712234148518ed2ad3f6393996d020c668e2fd0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wetstone/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wetstone/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-wetstone\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Wetstone'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "7d717dd6c5a9b5af4a161ee9cd23195853b443ed9a61411b368ca4fac3d64ed5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wetstone/README.md",
      "content": "# Wetstone - Contract\n\nThis is a Wetstone contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "4aa1386c2e4a9e10ee3c1d2f55e5919c854ef625f82fb3f80eb780911830135c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wetstone/src/Cargo.toml",
      "content": "[package]\nname = \"wetstone\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "e5ac1a04602f62142d92897fd052b27ed6e867cd9f5ea9ed3268cccd3cd3b072",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wetstone/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod wetstone {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Wetstone' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct WetstoneContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for WetstoneContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl WetstoneContract {\n        /// Creates a new PSP-22 compatible Wetstone Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Wetstone\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MWETSTONE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "cfc1adf775971837f5755feacb00f6036ea744ab392077dca82976eee42a925f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-whirl/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-whirl/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-whirl\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Whirl'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "a4a1e34ccd77d369eae05c65a667cf6e7d8be41100ffc5ee5b428762622651a4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-whirl/README.md",
      "content": "# Whirl - Contract\n\nThis is a Whirl contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "c6f02f6f0f4eb166ecebfd6f718345cab33135cfabef637f4ec9db9144197491",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-whirl/src/Cargo.toml",
      "content": "[package]\nname = \"whirl\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "936ccac57bbf7cf9a1188c31bd2ce3ebe56e2e1d21c2a81fa71bdc84086bf5db",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-whirl/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod whirl {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Whirl' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct WhirlContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for WhirlContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl WhirlContract {\n        /// Creates a new PSP-22 compatible Whirl Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Whirl\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MWHIRL\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "e9b461539996ba0c45a0046a80f94f474d112cef290418f3e13f3bcef4fe8546",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-whisper/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-whisper/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-whisper\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Whisper'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "cfc0f9c0b96273ffd60e3c029d22c32e2958e52e09edeb13d6b955be287cfe1c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-whisper/README.md",
      "content": "# Whisper - Contract\n\nThis is a Whisper contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "816477648b39734e90ea71ce1438ee35c759cc2419f23ba54d059ea00cb95ed4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-whisper/src/Cargo.toml",
      "content": "[package]\nname = \"whisper\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "f362deea832da44a8f04ec8b50dd40364d90810defdee82f2f35905ddaffa401",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-whisper/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod whisper {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Whisper' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct WhisperContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for WhisperContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl WhisperContract {\n        /// Creates a new PSP-22 compatible Whisper Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Whisper\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MWHISPER\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "81d87cd26da437b59a0ab9ec223b76073dc278db78bbc3cc31a88c85ecc93e95",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-whispering-cave/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-whispering-cave/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-whispering-cave\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'WhisperingCave'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "98ee1345b6340b5547b400dd6a431f66f6ca3ba398a9b0a80ae34bef93250e45",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-whispering-cave/README.md",
      "content": "# Whispering Cave - Contract\n\nThis is a Whispering Cave contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "9b3bee8a2739950cadeee75a24d211e14d0581c7a026ca64bc6419b1462a8e36",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-whispering-cave/src/Cargo.toml",
      "content": "[package]\nname = \"whispering_cave\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "869d34ee3615d31f32bf38099c3ae1597a192eabaf6d3ea39e1c2cc088f4a02c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-whispering-cave/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod whispering_cave {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Whispering Cave' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct WhisperingCaveContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for WhisperingCaveContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl WhisperingCaveContract {\n        /// Creates a new PSP-22 compatible Whispering Cave Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Whispering Cave\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MWHISPERING_CAVE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "81a6d56d4fcb2b759a983da704306da0e63b7ed12f7a031b04899bce1b9f932c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wildfire/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wildfire/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-wildfire\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Wildfire'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "2454aec1cc10c16f39d2102b06492542a51f04067540acf7f3f0188b6e136570",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wildfire/README.md",
      "content": "# Wildfire - Contract\n\nThis is a Wildfire contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "bf76595bd36a015e8d3f667feee928e23be91fde7b57b6a16c6225ede27804d6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wildfire/src/Cargo.toml",
      "content": "[package]\nname = \"wildfire\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "3cc88ab592f52d6d5d65d3f42809a468dde4f8881b4e071191efb29f328b3f39",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wildfire/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod wildfire {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Wildfire' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct WildfireContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for WildfireContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl WildfireContract {\n        /// Creates a new PSP-22 compatible Wildfire Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Wildfire\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MWILDFIRE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "181d50741712261b6e1152ccf8567fe0e31d2f7a6c658757f0534dfc74265e94",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wind/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wind/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-wind\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Wind'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "e579eb4e55264beef5b24f3e218818847d450f39e0f742a066caee6bd664a9a1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wind/README.md",
      "content": "# Wind - Contract\n\nThis is a Wind contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "e36f2a7d3384067c56dcbd7a2c479663d2a02f6d75b61a6d94d63068f8d3c00d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wind/src/Cargo.toml",
      "content": "[package]\nname = \"wind\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "2e39508e830b660b682c7fd30dc3acb237c9d70e016c1e30536e419d8d55a956",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wind/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod wind {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Wind' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct WindContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for WindContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl WindContract {\n        /// Creates a new PSP-22 compatible Wind Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Wind\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MWIND\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "bf3251a0a55a95dfeef589bed8bf28fa644bdf7d2e722bc3f151f706664bb1fe",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-windmill/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-windmill/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-windmill\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Windmill'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "c4aa86247f43c89f6a8f15cdcaf850848bc771c49b165b708a3e6021c540e7d0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-windmill/README.md",
      "content": "# Windmill - Contract\n\nThis is a Windmill contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "9854f834aba0452969d75a65be8151934f82887333975d8c6766ad7f289d1445",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-windmill/src/Cargo.toml",
      "content": "[package]\nname = \"windmill\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "06c0e100e96a2460950ba3637ac18ce32fb4c8ff62399dd623b6fd14731d7b65",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-windmill/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod windmill {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Windmill' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct WindmillContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for WindmillContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl WindmillContract {\n        /// Creates a new PSP-22 compatible Windmill Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Windmill\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MWINDMILL\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "435515782bf8e889592d5c10da5b7e5c180ca7af2659e74428f15faf62d4bfe6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-zephyr/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-zephyr/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-zephyr\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Zephyr'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "0c3f927768c0db482fd08c21f665fa36d58e9c3ba3b69f29ed28be4d64f4cc2c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-zephyr/README.md",
      "content": "# Zephyr - Contract\n\nThis is a Zephyr contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "16e97c7f0d8115aaa98f4300ea814fd3c782ac04e8cd2c9559753645a5f492a9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-zephyr/src/Cargo.toml",
      "content": "[package]\nname = \"zephyr\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "0ca27123cf282b835de85af2be2e9af201b191e48edb8dab7f8132fd53a550b4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-zephyr/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod zephyr {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Zephyr' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct ZephyrContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for ZephyrContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl ZephyrContract {\n        /// Creates a new PSP-22 compatible Zephyr Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Zephyr\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MZEPHYR\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "120dc4315fa893c40c0f5fbc5a2d999a61eba07c3ac3d07aee08dec2c454b625",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/deployer/copy-contracts.js",
      "content": "const fs = require('fs');\nconst path = require('path');\n\nconst POSSIBLE_TARGET_INK_DIRS = [\n    \"../../target/ink\",\n    \"../../../target/ink\",\n    \"target/ink\",\n];\nconst POSSIBLE_CONTRACTS_V1_README_MD_FILES = [\n    \"../../contracts.v1/README.md\",\n    \"../../../contracts.v1/README.md\",\n    \"contracts.v1/README.md\",\n]\n\nconst realTargetInkIndex = POSSIBLE_TARGET_INK_DIRS.findIndex((dir) => fs.existsSync(dir));\nconst targetInkDir = POSSIBLE_TARGET_INK_DIRS[realTargetInkIndex];\n\nconsole.log(`Copying contracts from ${POSSIBLE_TARGET_INK_DIRS[realTargetInkIndex]} ...`);\n\nconst realContractsV1ReadmeMdIndex = POSSIBLE_CONTRACTS_V1_README_MD_FILES.findIndex((file) => fs.existsSync(file));\nconst contractsV1ReadmeMd = POSSIBLE_CONTRACTS_V1_README_MD_FILES[realContractsV1ReadmeMdIndex];\nconst contractsV1Dir = path.join(path.dirname(contractsV1ReadmeMd), \"artifacts\");\n\nconsole.log(`Copying contracts into ${contractsV1Dir} ...`);\n\nif(!fs.existsSync(contractsV1Dir)) {\n    fs.mkdirSync(contractsV1Dir, { recursive: true });\n}\n\nconst itemMonkeyPath = path.join(targetInkDir, 'monkey/monkey.contract');\nconst itemGiraffePath = path.join(targetInkDir, 'giraffe/giraffe.contract');\nconst itemBeePath = path.join(targetInkDir, 'bee/bee.contract');\nconst itemCoinPath = path.join(targetInkDir, 'coin/coin.contract');\nconst itemSwarmPath = path.join(targetInkDir, 'swarm/swarm.contract');\nconst itemHydraPath = path.join(targetInkDir, 'hydra/hydra.contract');\nconst itemMonkeyBranchPath = path.join(targetInkDir, 'monkey_branch/monkey_branch.contract');\nconst itemBridgePath = path.join(targetInkDir, 'bridge/bridge.contract');\nconst itemGoldenGatePath = path.join(targetInkDir, 'golden_gate/golden_gate.contract');\nconst itemGoldPath = path.join(targetInkDir, 'gold/gold.contract');\nconst itemSilverPath = path.join(targetInkDir, 'silver/silver.contract');\nconst itemRhodiumPath = path.join(targetInkDir, 'rhodium/rhodium.contract');\nconst itemHivePath = path.join(targetInkDir, 'hive/hive.contract');\nconst itemTransactionPath = path.join(targetInkDir, 'transaction/transaction.contract');\nconst itemBlockPath = path.join(targetInkDir, 'block/block.contract');\nconst itemBlockchainPath = path.join(targetInkDir, 'blockchain/blockchain.contract');\nconst itemPolkadotPath = path.join(targetInkDir, 'polkadot/polkadot.contract');\nconst itemPeerReviewPath = path.join(targetInkDir, 'peer_review/peer_review.contract');\nconst itemCardanoPath = path.join(targetInkDir, 'cardano/cardano.contract');\nconst itemBearPath = path.join(targetInkDir, 'bear/bear.contract');\nconst itemBeerPath = path.join(targetInkDir, 'beer/beer.contract');\nconst itemLockPath = path.join(targetInkDir, 'lock/lock.contract');\nconst itemMarmaladePath = path.join(targetInkDir, 'marmalade/marmalade.contract');\nconst itemSuperMarmaladePath = path.join(targetInkDir, 'super_marmalade/super_marmalade.contract');\nconst itemHyperMarmaladePath = path.join(targetInkDir, 'hyper_marmalade/hyper_marmalade.contract');\nconst itemWaterPath = path.join(targetInkDir, 'water/water.contract');\nconst itemFirePath = path.join(targetInkDir, 'fire/fire.contract');\nconst itemSteamPath = path.join(targetInkDir, 'steam/steam.contract');\nconst itemEarthPath = path.join(targetInkDir, 'earth/earth.contract');\nconst itemMudPath = path.join(targetInkDir, 'mud/mud.contract');\nconst itemLavaPath = path.join(targetInkDir, 'lava/lava.contract');\nconst itemWindPath = path.join(targetInkDir, 'wind/wind.contract');\nconst itemDustPath = path.join(targetInkDir, 'dust/dust.contract');\nconst itemRainPath = path.join(targetInkDir, 'rain/rain.contract');\nconst itemSmokePath = path.join(targetInkDir, 'smoke/smoke.contract');\nconst itemGeyserPath = path.join(targetInkDir, 'geyser/geyser.contract');\nconst itemClayPath = path.join(targetInkDir, 'clay/clay.contract');\nconst itemSandPath = path.join(targetInkDir, 'sand/sand.contract');\nconst itemPlantPath = path.join(targetInkDir, 'plant/plant.contract');\nconst itemRainbowPath = path.join(targetInkDir, 'rainbow/rainbow.contract');\nconst itemStormPath = path.join(targetInkDir, 'storm/storm.contract');\nconst itemObsidianPath = path.join(targetInkDir, 'obsidian/obsidian.contract');\nconst itemAshPath = path.join(targetInkDir, 'ash/ash.contract');\nconst itemVolcanoPath = path.join(targetInkDir, 'volcano/volcano.contract');\nconst itemSandstormPath = path.join(targetInkDir, 'sandstorm/sandstorm.contract');\nconst itemCloudPath = path.join(targetInkDir, 'cloud/cloud.contract');\nconst itemFogPath = path.join(targetInkDir, 'fog/fog.contract');\nconst itemTreePath = path.join(targetInkDir, 'tree/tree.contract');\nconst itemForestPath = path.join(targetInkDir, 'forest/forest.contract');\nconst itemSeedsPath = path.join(targetInkDir, 'seeds/seeds.contract');\nconst itemPotteryPath = path.join(targetInkDir, 'pottery/pottery.contract');\nconst itemBrickPath = path.join(targetInkDir, 'brick/brick.contract');\nconst itemQuicksandPath = path.join(targetInkDir, 'quicksand/quicksand.contract');\nconst itemGlassPath = path.join(targetInkDir, 'glass/glass.contract');\nconst itemDunePath = path.join(targetInkDir, 'dune/dune.contract');\nconst itemCharcoalPath = path.join(targetInkDir, 'charcoal/charcoal.contract');\nconst itemLeavesPath = path.join(targetInkDir, 'leaves/leaves.contract');\nconst itemWildfirePath = path.join(targetInkDir, 'wildfire/wildfire.contract');\nconst itemJunglePath = path.join(targetInkDir, 'jungle/jungle.contract');\nconst itemFrostedGlassPath = path.join(targetInkDir, 'frosted_glass/frosted_glass.contract');\nconst itemCrystalPath = path.join(targetInkDir, 'crystal/crystal.contract');\nconst itemMagmaPath = path.join(targetInkDir, 'magma/magma.contract');\nconst itemRockPath = path.join(targetInkDir, 'rock/rock.contract');\nconst itemShardPath = path.join(targetInkDir, 'shard/shard.contract');\nconst itemPebblePath = path.join(targetInkDir, 'pebble/pebble.contract');\nconst itemMountainPath = path.join(targetInkDir, 'mountain/mountain.contract');\nconst itemFertilizerPath = path.join(targetInkDir, 'fertilizer/fertilizer.contract');\nconst itemSootPath = path.join(targetInkDir, 'soot/soot.contract');\nconst itemLightningPath = path.join(targetInkDir, 'lightning/lightning.contract');\nconst itemMistPath = path.join(targetInkDir, 'mist/mist.contract');\nconst itemHazePath = path.join(targetInkDir, 'haze/haze.contract');\nconst itemFloodPath = path.join(targetInkDir, 'flood/flood.contract');\nconst itemLandslidePath = path.join(targetInkDir, 'landslide/landslide.contract');\nconst itemThunderPath = path.join(targetInkDir, 'thunder/thunder.contract');\nconst itemTornadoPath = path.join(targetInkDir, 'tornado/tornado.contract');\nconst itemGardenPath = path.join(targetInkDir, 'garden/garden.contract');\nconst itemEmberPath = path.join(targetInkDir, 'ember/ember.contract');\nconst itemKilnPath = path.join(targetInkDir, 'kiln/kiln.contract');\nconst itemPollinationPath = path.join(targetInkDir, 'pollination/pollination.contract');\nconst itemSinkholePath = path.join(targetInkDir, 'sinkhole/sinkhole.contract');\nconst itemBeachPath = path.join(targetInkDir, 'beach/beach.contract');\nconst itemWetstonePath = path.join(targetInkDir, 'wetstone/wetstone.contract');\nconst itemErosionPath = path.join(targetInkDir, 'erosion/erosion.contract');\nconst itemBasaltPath = path.join(targetInkDir, 'basalt/basalt.contract');\nconst itemMagmaChamberPath = path.join(targetInkDir, 'magma_chamber/magma_chamber.contract');\nconst itemBreezePath = path.join(targetInkDir, 'breeze/breeze.contract');\nconst itemWarmBreezePath = path.join(targetInkDir, 'warm_breeze/warm_breeze.contract');\nconst itemSoilPath = path.join(targetInkDir, 'soil/soil.contract');\nconst itemCanyonPath = path.join(targetInkDir, 'canyon/canyon.contract');\nconst itemWindmillPath = path.join(targetInkDir, 'windmill/windmill.contract');\nconst itemAdobePath = path.join(targetInkDir, 'adobe/adobe.contract');\nconst itemWallPath = path.join(targetInkDir, 'wall/wall.contract');\nconst itemPumicePath = path.join(targetInkDir, 'pumice/pumice.contract');\nconst itemBarbecuePath = path.join(targetInkDir, 'barbecue/barbecue.contract');\nconst itemFarmPath = path.join(targetInkDir, 'farm/farm.contract');\nconst itemShardsPath = path.join(targetInkDir, 'shards/shards.contract');\nconst itemMoltenGlassPath = path.join(targetInkDir, 'molten_glass/molten_glass.contract');\nconst itemPrismPath = path.join(targetInkDir, 'prism/prism.contract');\nconst itemSparklePath = path.join(targetInkDir, 'sparkle/sparkle.contract');\nconst itemDesertPath = path.join(targetInkDir, 'desert/desert.contract');\nconst itemOasisPath = path.join(targetInkDir, 'oasis/oasis.contract');\nconst itemMiragePath = path.join(targetInkDir, 'mirage/mirage.contract');\nconst itemSandDunePath = path.join(targetInkDir, 'sand_dune/sand_dune.contract');\nconst itemDamPath = path.join(targetInkDir, 'dam/dam.contract');\nconst itemFirewallPath = path.join(targetInkDir, 'firewall/firewall.contract');\nconst itemBarricadePath = path.join(targetInkDir, 'barricade/barricade.contract');\nconst itemPlateauPath = path.join(targetInkDir, 'plateau/plateau.contract');\nconst itemPondPath = path.join(targetInkDir, 'pond/pond.contract');\nconst itemAromasPath = path.join(targetInkDir, 'aromas/aromas.contract');\nconst itemFlowerPath = path.join(targetInkDir, 'flower/flower.contract');\nconst itemSporePath = path.join(targetInkDir, 'spore/spore.contract');\nconst itemSpreadPath = path.join(targetInkDir, 'spread/spread.contract');\nconst itemFertileLandPath = path.join(targetInkDir, 'fertile_land/fertile_land.contract');\nconst itemWetlandPath = path.join(targetInkDir, 'wetland/wetland.contract');\nconst itemPeatPath = path.join(targetInkDir, 'peat/peat.contract');\nconst itemReedsPath = path.join(targetInkDir, 'reeds/reeds.contract');\nconst itemValleyPath = path.join(targetInkDir, 'valley/valley.contract');\nconst itemRiverPath = path.join(targetInkDir, 'river/river.contract');\nconst itemScorchedEarthPath = path.join(targetInkDir, 'scorched_earth/scorched_earth.contract');\nconst itemDeltaPath = path.join(targetInkDir, 'delta/delta.contract');\nconst itemEstuaryPath = path.join(targetInkDir, 'estuary/estuary.contract');\nconst itemFireSwampPath = path.join(targetInkDir, 'fire_swamp/fire_swamp.contract');\nconst itemRiverbankPath = path.join(targetInkDir, 'riverbank/riverbank.contract');\nconst itemRavinePath = path.join(targetInkDir, 'ravine/ravine.contract');\nconst itemGorgePath = path.join(targetInkDir, 'gorge/gorge.contract');\nconst itemCharredRavinePath = path.join(targetInkDir, 'charred_ravine/charred_ravine.contract');\nconst itemEchoPath = path.join(targetInkDir, 'echo/echo.contract');\nconst itemCavePath = path.join(targetInkDir, 'cave/cave.contract');\nconst itemUndergroundLakePath = path.join(targetInkDir, 'underground_lake/underground_lake.contract');\nconst itemLavaCavePath = path.join(targetInkDir, 'lava_cave/lava_cave.contract');\nconst itemWhisperingCavePath = path.join(targetInkDir, 'whispering_cave/whispering_cave.contract');\nconst itemSubterraneanPoolPath = path.join(targetInkDir, 'subterranean_pool/subterranean_pool.contract');\nconst itemSpringPath = path.join(targetInkDir, 'spring/spring.contract');\nconst itemHotSpringPath = path.join(targetInkDir, 'hot_spring/hot_spring.contract');\nconst itemGrottoPath = path.join(targetInkDir, 'grotto/grotto.contract');\nconst itemFountainPath = path.join(targetInkDir, 'fountain/fountain.contract');\nconst itemSteamVentPath = path.join(targetInkDir, 'steam_vent/steam_vent.contract');\nconst itemCoolBreezePath = path.join(targetInkDir, 'cool_breeze/cool_breeze.contract');\nconst itemMonumentPath = path.join(targetInkDir, 'monument/monument.contract');\nconst itemWaterfallPath = path.join(targetInkDir, 'waterfall/waterfall.contract');\nconst itemEternalFlamePath = path.join(targetInkDir, 'eternal_flame/eternal_flame.contract');\nconst itemPillarOfWindPath = path.join(targetInkDir, 'pillar_of_wind/pillar_of_wind.contract');\nconst itemStreamPath = path.join(targetInkDir, 'stream/stream.contract');\nconst itemZephyrPath = path.join(targetInkDir, 'zephyr/zephyr.contract');\nconst itemCreekPath = path.join(targetInkDir, 'creek/creek.contract');\nconst itemBrookPath = path.join(targetInkDir, 'brook/brook.contract');\nconst itemWhisperPath = path.join(targetInkDir, 'whisper/whisper.contract');\nconst itemRivuletPath = path.join(targetInkDir, 'rivulet/rivulet.contract');\nconst itemTributaryPath = path.join(targetInkDir, 'tributary/tributary.contract');\nconst itemMurmurPath = path.join(targetInkDir, 'murmur/murmur.contract');\nconst itemWatershedPath = path.join(targetInkDir, 'watershed/watershed.contract');\nconst itemAquiferPath = path.join(targetInkDir, 'aquifer/aquifer.contract');\nconst itemParchedEarthPath = path.join(targetInkDir, 'parched_earth/parched_earth.contract');\nconst itemFreshBreezePath = path.join(targetInkDir, 'fresh_breeze/fresh_breeze.contract');\nconst itemGroundwaterPath = path.join(targetInkDir, 'groundwater/groundwater.contract');\nconst itemReservoirPath = path.join(targetInkDir, 'reservoir/reservoir.contract');\nconst itemGeothermalSpringPath = path.join(targetInkDir, 'geothermal_spring/geothermal_spring.contract');\nconst itemArtesianWellPath = path.join(targetInkDir, 'artesian_well/artesian_well.contract');\nconst itemBasinPath = path.join(targetInkDir, 'basin/basin.contract');\nconst itemLakePath = path.join(targetInkDir, 'lake/lake.contract');\nconst itemDryBasinPath = path.join(targetInkDir, 'dry_basin/dry_basin.contract');\nconst itemDepressionPath = path.join(targetInkDir, 'depression/depression.contract');\nconst itemIslandPath = path.join(targetInkDir, 'island/island.contract');\nconst itemLagoonPath = path.join(targetInkDir, 'lagoon/lagoon.contract');\nconst itemWavePath = path.join(targetInkDir, 'wave/wave.contract');\nconst itemReefPath = path.join(targetInkDir, 'reef/reef.contract');\nconst itemCoralPath = path.join(targetInkDir, 'coral/coral.contract');\nconst itemWhirlPath = path.join(targetInkDir, 'whirl/whirl.contract');\nconst itemLimestonePath = path.join(targetInkDir, 'limestone/limestone.contract');\nconst itemKarstPath = path.join(targetInkDir, 'karst/karst.contract');\nconst itemQuicklimePath = path.join(targetInkDir, 'quicklime/quicklime.contract');\nconst itemBlowholePath = path.join(targetInkDir, 'blowhole/blowhole.contract');\nconst gameUnifiersPath = path.join(targetInkDir, 'unifiers/unifiers.contract');\nconst gameElementyPath = path.join(targetInkDir, 'elementy/elementy.contract');\n\nif(fs.existsSync(itemMonkeyPath)) {\n    console.log(`Copying monkey ...`);\n    fs.copyFileSync(itemMonkeyPath, path.join(contractsV1Dir, 'monkey.contract.json'));\n} else {\n    console.log(`monkey not found`);\n}\nif(fs.existsSync(itemGiraffePath)) {\n    console.log(`Copying giraffe ...`);\n    fs.copyFileSync(itemGiraffePath, path.join(contractsV1Dir, 'giraffe.contract.json'));\n} else {\n    console.log(`giraffe not found`);\n}\nif(fs.existsSync(itemBeePath)) {\n    console.log(`Copying bee ...`);\n    fs.copyFileSync(itemBeePath, path.join(contractsV1Dir, 'bee.contract.json'));\n} else {\n    console.log(`bee not found`);\n}\nif(fs.existsSync(itemCoinPath)) {\n    console.log(`Copying coin ...`);\n    fs.copyFileSync(itemCoinPath, path.join(contractsV1Dir, 'coin.contract.json'));\n} else {\n    console.log(`coin not found`);\n}\nif(fs.existsSync(itemSwarmPath)) {\n    console.log(`Copying swarm ...`);\n    fs.copyFileSync(itemSwarmPath, path.join(contractsV1Dir, 'swarm.contract.json'));\n} else {\n    console.log(`swarm not found`);\n}\nif(fs.existsSync(itemHydraPath)) {\n    console.log(`Copying hydra ...`);\n    fs.copyFileSync(itemHydraPath, path.join(contractsV1Dir, 'hydra.contract.json'));\n} else {\n    console.log(`hydra not found`);\n}\nif(fs.existsSync(itemMonkeyBranchPath)) {\n    console.log(`Copying monkey_branch ...`);\n    fs.copyFileSync(itemMonkeyBranchPath, path.join(contractsV1Dir, 'monkey_branch.contract.json'));\n} else {\n    console.log(`monkey_branch not found`);\n}\nif(fs.existsSync(itemBridgePath)) {\n    console.log(`Copying bridge ...`);\n    fs.copyFileSync(itemBridgePath, path.join(contractsV1Dir, 'bridge.contract.json'));\n} else {\n    console.log(`bridge not found`);\n}\nif(fs.existsSync(itemGoldenGatePath)) {\n    console.log(`Copying golden_gate ...`);\n    fs.copyFileSync(itemGoldenGatePath, path.join(contractsV1Dir, 'golden_gate.contract.json'));\n} else {\n    console.log(`golden_gate not found`);\n}\nif(fs.existsSync(itemGoldPath)) {\n    console.log(`Copying gold ...`);\n    fs.copyFileSync(itemGoldPath, path.join(contractsV1Dir, 'gold.contract.json'));\n} else {\n    console.log(`gold not found`);\n}\nif(fs.existsSync(itemSilverPath)) {\n    console.log(`Copying silver ...`);\n    fs.copyFileSync(itemSilverPath, path.join(contractsV1Dir, 'silver.contract.json'));\n} else {\n    console.log(`silver not found`);\n}\nif(fs.existsSync(itemRhodiumPath)) {\n    console.log(`Copying rhodium ...`);\n    fs.copyFileSync(itemRhodiumPath, path.join(contractsV1Dir, 'rhodium.contract.json'));\n} else {\n    console.log(`rhodium not found`);\n}\nif(fs.existsSync(itemHivePath)) {\n    console.log(`Copying hive ...`);\n    fs.copyFileSync(itemHivePath, path.join(contractsV1Dir, 'hive.contract.json'));\n} else {\n    console.log(`hive not found`);\n}\nif(fs.existsSync(itemTransactionPath)) {\n    console.log(`Copying transaction ...`);\n    fs.copyFileSync(itemTransactionPath, path.join(contractsV1Dir, 'transaction.contract.json'));\n} else {\n    console.log(`transaction not found`);\n}\nif(fs.existsSync(itemBlockPath)) {\n    console.log(`Copying block ...`);\n    fs.copyFileSync(itemBlockPath, path.join(contractsV1Dir, 'block.contract.json'));\n} else {\n    console.log(`block not found`);\n}\nif(fs.existsSync(itemBlockchainPath)) {\n    console.log(`Copying blockchain ...`);\n    fs.copyFileSync(itemBlockchainPath, path.join(contractsV1Dir, 'blockchain.contract.json'));\n} else {\n    console.log(`blockchain not found`);\n}\nif(fs.existsSync(itemPolkadotPath)) {\n    console.log(`Copying polkadot ...`);\n    fs.copyFileSync(itemPolkadotPath, path.join(contractsV1Dir, 'polkadot.contract.json'));\n} else {\n    console.log(`polkadot not found`);\n}\nif(fs.existsSync(itemPeerReviewPath)) {\n    console.log(`Copying peer_review ...`);\n    fs.copyFileSync(itemPeerReviewPath, path.join(contractsV1Dir, 'peer_review.contract.json'));\n} else {\n    console.log(`peer_review not found`);\n}\nif(fs.existsSync(itemCardanoPath)) {\n    console.log(`Copying cardano ...`);\n    fs.copyFileSync(itemCardanoPath, path.join(contractsV1Dir, 'cardano.contract.json'));\n} else {\n    console.log(`cardano not found`);\n}\nif(fs.existsSync(itemBearPath)) {\n    console.log(`Copying bear ...`);\n    fs.copyFileSync(itemBearPath, path.join(contractsV1Dir, 'bear.contract.json'));\n} else {\n    console.log(`bear not found`);\n}\nif(fs.existsSync(itemBeerPath)) {\n    console.log(`Copying beer ...`);\n    fs.copyFileSync(itemBeerPath, path.join(contractsV1Dir, 'beer.contract.json'));\n} else {\n    console.log(`beer not found`);\n}\nif(fs.existsSync(itemLockPath)) {\n    console.log(`Copying lock ...`);\n    fs.copyFileSync(itemLockPath, path.join(contractsV1Dir, 'lock.contract.json'));\n} else {\n    console.log(`lock not found`);\n}\nif(fs.existsSync(itemMarmaladePath)) {\n    console.log(`Copying marmalade ...`);\n    fs.copyFileSync(itemMarmaladePath, path.join(contractsV1Dir, 'marmalade.contract.json'));\n} else {\n    console.log(`marmalade not found`);\n}\nif(fs.existsSync(itemSuperMarmaladePath)) {\n    console.log(`Copying super_marmalade ...`);\n    fs.copyFileSync(itemSuperMarmaladePath, path.join(contractsV1Dir, 'super_marmalade.contract.json'));\n} else {\n    console.log(`super_marmalade not found`);\n}\nif(fs.existsSync(itemHyperMarmaladePath)) {\n    console.log(`Copying hyper_marmalade ...`);\n    fs.copyFileSync(itemHyperMarmaladePath, path.join(contractsV1Dir, 'hyper_marmalade.contract.json'));\n} else {\n    console.log(`hyper_marmalade not found`);\n}\nif(fs.existsSync(itemWaterPath)) {\n    console.log(`Copying water ...`);\n    fs.copyFileSync(itemWaterPath, path.join(contractsV1Dir, 'water.contract.json'));\n} else {\n    console.log(`water not found`);\n}\nif(fs.existsSync(itemFirePath)) {\n    console.log(`Copying fire ...`);\n    fs.copyFileSync(itemFirePath, path.join(contractsV1Dir, 'fire.contract.json'));\n} else {\n    console.log(`fire not found`);\n}\nif(fs.existsSync(itemSteamPath)) {\n    console.log(`Copying steam ...`);\n    fs.copyFileSync(itemSteamPath, path.join(contractsV1Dir, 'steam.contract.json'));\n} else {\n    console.log(`steam not found`);\n}\nif(fs.existsSync(itemEarthPath)) {\n    console.log(`Copying earth ...`);\n    fs.copyFileSync(itemEarthPath, path.join(contractsV1Dir, 'earth.contract.json'));\n} else {\n    console.log(`earth not found`);\n}\nif(fs.existsSync(itemMudPath)) {\n    console.log(`Copying mud ...`);\n    fs.copyFileSync(itemMudPath, path.join(contractsV1Dir, 'mud.contract.json'));\n} else {\n    console.log(`mud not found`);\n}\nif(fs.existsSync(itemLavaPath)) {\n    console.log(`Copying lava ...`);\n    fs.copyFileSync(itemLavaPath, path.join(contractsV1Dir, 'lava.contract.json'));\n} else {\n    console.log(`lava not found`);\n}\nif(fs.existsSync(itemWindPath)) {\n    console.log(`Copying wind ...`);\n    fs.copyFileSync(itemWindPath, path.join(contractsV1Dir, 'wind.contract.json'));\n} else {\n    console.log(`wind not found`);\n}\nif(fs.existsSync(itemDustPath)) {\n    console.log(`Copying dust ...`);\n    fs.copyFileSync(itemDustPath, path.join(contractsV1Dir, 'dust.contract.json'));\n} else {\n    console.log(`dust not found`);\n}\nif(fs.existsSync(itemRainPath)) {\n    console.log(`Copying rain ...`);\n    fs.copyFileSync(itemRainPath, path.join(contractsV1Dir, 'rain.contract.json'));\n} else {\n    console.log(`rain not found`);\n}\nif(fs.existsSync(itemSmokePath)) {\n    console.log(`Copying smoke ...`);\n    fs.copyFileSync(itemSmokePath, path.join(contractsV1Dir, 'smoke.contract.json'));\n} else {\n    console.log(`smoke not found`);\n}\nif(fs.existsSync(itemGeyserPath)) {\n    console.log(`Copying geyser ...`);\n    fs.copyFileSync(itemGeyserPath, path.join(contractsV1Dir, 'geyser.contract.json'));\n} else {\n    console.log(`geyser not found`);\n}\nif(fs.existsSync(itemClayPath)) {\n    console.log(`Copying clay ...`);\n    fs.copyFileSync(itemClayPath, path.join(contractsV1Dir, 'clay.contract.json'));\n} else {\n    console.log(`clay not found`);\n}\nif(fs.existsSync(itemSandPath)) {\n    console.log(`Copying sand ...`);\n    fs.copyFileSync(itemSandPath, path.join(contractsV1Dir, 'sand.contract.json'));\n} else {\n    console.log(`sand not found`);\n}\nif(fs.existsSync(itemPlantPath)) {\n    console.log(`Copying plant ...`);\n    fs.copyFileSync(itemPlantPath, path.join(contractsV1Dir, 'plant.contract.json'));\n} else {\n    console.log(`plant not found`);\n}\nif(fs.existsSync(itemRainbowPath)) {\n    console.log(`Copying rainbow ...`);\n    fs.copyFileSync(itemRainbowPath, path.join(contractsV1Dir, 'rainbow.contract.json'));\n} else {\n    console.log(`rainbow not found`);\n}\nif(fs.existsSync(itemStormPath)) {\n    console.log(`Copying storm ...`);\n    fs.copyFileSync(itemStormPath, path.join(contractsV1Dir, 'storm.contract.json'));\n} else {\n    console.log(`storm not found`);\n}\nif(fs.existsSync(itemObsidianPath)) {\n    console.log(`Copying obsidian ...`);\n    fs.copyFileSync(itemObsidianPath, path.join(contractsV1Dir, 'obsidian.contract.json'));\n} else {\n    console.log(`obsidian not found`);\n}\nif(fs.existsSync(itemAshPath)) {\n    console.log(`Copying ash ...`);\n    fs.copyFileSync(itemAshPath, path.join(contractsV1Dir, 'ash.contract.json'));\n} else {\n    console.log(`ash not found`);\n}\nif(fs.existsSync(itemVolcanoPath)) {\n    console.log(`Copying volcano ...`);\n    fs.copyFileSync(itemVolcanoPath, path.join(contractsV1Dir, 'volcano.contract.json'));\n} else {\n    console.log(`volcano not found`);\n}\nif(fs.existsSync(itemSandstormPath)) {\n    console.log(`Copying sandstorm ...`);\n    fs.copyFileSync(itemSandstormPath, path.join(contractsV1Dir, 'sandstorm.contract.json'));\n} else {\n    console.log(`sandstorm not found`);\n}\nif(fs.existsSync(itemCloudPath)) {\n    console.log(`Copying cloud ...`);\n    fs.copyFileSync(itemCloudPath, path.join(contractsV1Dir, 'cloud.contract.json'));\n} else {\n    console.log(`cloud not found`);\n}\nif(fs.existsSync(itemFogPath)) {\n    console.log(`Copying fog ...`);\n    fs.copyFileSync(itemFogPath, path.join(contractsV1Dir, 'fog.contract.json'));\n} else {\n    console.log(`fog not found`);\n}\nif(fs.existsSync(itemTreePath)) {\n    console.log(`Copying tree ...`);\n    fs.copyFileSync(itemTreePath, path.join(contractsV1Dir, 'tree.contract.json'));\n} else {\n    console.log(`tree not found`);\n}\nif(fs.existsSync(itemForestPath)) {\n    console.log(`Copying forest ...`);\n    fs.copyFileSync(itemForestPath, path.join(contractsV1Dir, 'forest.contract.json'));\n} else {\n    console.log(`forest not found`);\n}\nif(fs.existsSync(itemSeedsPath)) {\n    console.log(`Copying seeds ...`);\n    fs.copyFileSync(itemSeedsPath, path.join(contractsV1Dir, 'seeds.contract.json'));\n} else {\n    console.log(`seeds not found`);\n}\nif(fs.existsSync(itemPotteryPath)) {\n    console.log(`Copying pottery ...`);\n    fs.copyFileSync(itemPotteryPath, path.join(contractsV1Dir, 'pottery.contract.json'));\n} else {\n    console.log(`pottery not found`);\n}\nif(fs.existsSync(itemBrickPath)) {\n    console.log(`Copying brick ...`);\n    fs.copyFileSync(itemBrickPath, path.join(contractsV1Dir, 'brick.contract.json'));\n} else {\n    console.log(`brick not found`);\n}\nif(fs.existsSync(itemQuicksandPath)) {\n    console.log(`Copying quicksand ...`);\n    fs.copyFileSync(itemQuicksandPath, path.join(contractsV1Dir, 'quicksand.contract.json'));\n} else {\n    console.log(`quicksand not found`);\n}\nif(fs.existsSync(itemGlassPath)) {\n    console.log(`Copying glass ...`);\n    fs.copyFileSync(itemGlassPath, path.join(contractsV1Dir, 'glass.contract.json'));\n} else {\n    console.log(`glass not found`);\n}\nif(fs.existsSync(itemDunePath)) {\n    console.log(`Copying dune ...`);\n    fs.copyFileSync(itemDunePath, path.join(contractsV1Dir, 'dune.contract.json'));\n} else {\n    console.log(`dune not found`);\n}\nif(fs.existsSync(itemCharcoalPath)) {\n    console.log(`Copying charcoal ...`);\n    fs.copyFileSync(itemCharcoalPath, path.join(contractsV1Dir, 'charcoal.contract.json'));\n} else {\n    console.log(`charcoal not found`);\n}\nif(fs.existsSync(itemLeavesPath)) {\n    console.log(`Copying leaves ...`);\n    fs.copyFileSync(itemLeavesPath, path.join(contractsV1Dir, 'leaves.contract.json'));\n} else {\n    console.log(`leaves not found`);\n}\nif(fs.existsSync(itemWildfirePath)) {\n    console.log(`Copying wildfire ...`);\n    fs.copyFileSync(itemWildfirePath, path.join(contractsV1Dir, 'wildfire.contract.json'));\n} else {\n    console.log(`wildfire not found`);\n}\nif(fs.existsSync(itemJunglePath)) {\n    console.log(`Copying jungle ...`);\n    fs.copyFileSync(itemJunglePath, path.join(contractsV1Dir, 'jungle.contract.json'));\n} else {\n    console.log(`jungle not found`);\n}\nif(fs.existsSync(itemFrostedGlassPath)) {\n    console.log(`Copying frosted_glass ...`);\n    fs.copyFileSync(itemFrostedGlassPath, path.join(contractsV1Dir, 'frosted_glass.contract.json'));\n} else {\n    console.log(`frosted_glass not found`);\n}\nif(fs.existsSync(itemCrystalPath)) {\n    console.log(`Copying crystal ...`);\n    fs.copyFileSync(itemCrystalPath, path.join(contractsV1Dir, 'crystal.contract.json'));\n} else {\n    console.log(`crystal not found`);\n}\nif(fs.existsSync(itemMagmaPath)) {\n    console.log(`Copying magma ...`);\n    fs.copyFileSync(itemMagmaPath, path.join(contractsV1Dir, 'magma.contract.json'));\n} else {\n    console.log(`magma not found`);\n}\nif(fs.existsSync(itemRockPath)) {\n    console.log(`Copying rock ...`);\n    fs.copyFileSync(itemRockPath, path.join(contractsV1Dir, 'rock.contract.json'));\n} else {\n    console.log(`rock not found`);\n}\nif(fs.existsSync(itemShardPath)) {\n    console.log(`Copying shard ...`);\n    fs.copyFileSync(itemShardPath, path.join(contractsV1Dir, 'shard.contract.json'));\n} else {\n    console.log(`shard not found`);\n}\nif(fs.existsSync(itemPebblePath)) {\n    console.log(`Copying pebble ...`);\n    fs.copyFileSync(itemPebblePath, path.join(contractsV1Dir, 'pebble.contract.json'));\n} else {\n    console.log(`pebble not found`);\n}\nif(fs.existsSync(itemMountainPath)) {\n    console.log(`Copying mountain ...`);\n    fs.copyFileSync(itemMountainPath, path.join(contractsV1Dir, 'mountain.contract.json'));\n} else {\n    console.log(`mountain not found`);\n}\nif(fs.existsSync(itemFertilizerPath)) {\n    console.log(`Copying fertilizer ...`);\n    fs.copyFileSync(itemFertilizerPath, path.join(contractsV1Dir, 'fertilizer.contract.json'));\n} else {\n    console.log(`fertilizer not found`);\n}\nif(fs.existsSync(itemSootPath)) {\n    console.log(`Copying soot ...`);\n    fs.copyFileSync(itemSootPath, path.join(contractsV1Dir, 'soot.contract.json'));\n} else {\n    console.log(`soot not found`);\n}\nif(fs.existsSync(itemLightningPath)) {\n    console.log(`Copying lightning ...`);\n    fs.copyFileSync(itemLightningPath, path.join(contractsV1Dir, 'lightning.contract.json'));\n} else {\n    console.log(`lightning not found`);\n}\nif(fs.existsSync(itemMistPath)) {\n    console.log(`Copying mist ...`);\n    fs.copyFileSync(itemMistPath, path.join(contractsV1Dir, 'mist.contract.json'));\n} else {\n    console.log(`mist not found`);\n}\nif(fs.existsSync(itemHazePath)) {\n    console.log(`Copying haze ...`);\n    fs.copyFileSync(itemHazePath, path.join(contractsV1Dir, 'haze.contract.json'));\n} else {\n    console.log(`haze not found`);\n}\nif(fs.existsSync(itemFloodPath)) {\n    console.log(`Copying flood ...`);\n    fs.copyFileSync(itemFloodPath, path.join(contractsV1Dir, 'flood.contract.json'));\n} else {\n    console.log(`flood not found`);\n}\nif(fs.existsSync(itemLandslidePath)) {\n    console.log(`Copying landslide ...`);\n    fs.copyFileSync(itemLandslidePath, path.join(contractsV1Dir, 'landslide.contract.json'));\n} else {\n    console.log(`landslide not found`);\n}\nif(fs.existsSync(itemThunderPath)) {\n    console.log(`Copying thunder ...`);\n    fs.copyFileSync(itemThunderPath, path.join(contractsV1Dir, 'thunder.contract.json'));\n} else {\n    console.log(`thunder not found`);\n}\nif(fs.existsSync(itemTornadoPath)) {\n    console.log(`Copying tornado ...`);\n    fs.copyFileSync(itemTornadoPath, path.join(contractsV1Dir, 'tornado.contract.json'));\n} else {\n    console.log(`tornado not found`);\n}\nif(fs.existsSync(itemGardenPath)) {\n    console.log(`Copying garden ...`);\n    fs.copyFileSync(itemGardenPath, path.join(contractsV1Dir, 'garden.contract.json'));\n} else {\n    console.log(`garden not found`);\n}\nif(fs.existsSync(itemEmberPath)) {\n    console.log(`Copying ember ...`);\n    fs.copyFileSync(itemEmberPath, path.join(contractsV1Dir, 'ember.contract.json'));\n} else {\n    console.log(`ember not found`);\n}\nif(fs.existsSync(itemKilnPath)) {\n    console.log(`Copying kiln ...`);\n    fs.copyFileSync(itemKilnPath, path.join(contractsV1Dir, 'kiln.contract.json'));\n} else {\n    console.log(`kiln not found`);\n}\nif(fs.existsSync(itemPollinationPath)) {\n    console.log(`Copying pollination ...`);\n    fs.copyFileSync(itemPollinationPath, path.join(contractsV1Dir, 'pollination.contract.json'));\n} else {\n    console.log(`pollination not found`);\n}\nif(fs.existsSync(itemSinkholePath)) {\n    console.log(`Copying sinkhole ...`);\n    fs.copyFileSync(itemSinkholePath, path.join(contractsV1Dir, 'sinkhole.contract.json'));\n} else {\n    console.log(`sinkhole not found`);\n}\nif(fs.existsSync(itemBeachPath)) {\n    console.log(`Copying beach ...`);\n    fs.copyFileSync(itemBeachPath, path.join(contractsV1Dir, 'beach.contract.json'));\n} else {\n    console.log(`beach not found`);\n}\nif(fs.existsSync(itemWetstonePath)) {\n    console.log(`Copying wetstone ...`);\n    fs.copyFileSync(itemWetstonePath, path.join(contractsV1Dir, 'wetstone.contract.json'));\n} else {\n    console.log(`wetstone not found`);\n}\nif(fs.existsSync(itemErosionPath)) {\n    console.log(`Copying erosion ...`);\n    fs.copyFileSync(itemErosionPath, path.join(contractsV1Dir, 'erosion.contract.json'));\n} else {\n    console.log(`erosion not found`);\n}\nif(fs.existsSync(itemBasaltPath)) {\n    console.log(`Copying basalt ...`);\n    fs.copyFileSync(itemBasaltPath, path.join(contractsV1Dir, 'basalt.contract.json'));\n} else {\n    console.log(`basalt not found`);\n}\nif(fs.existsSync(itemMagmaChamberPath)) {\n    console.log(`Copying magma_chamber ...`);\n    fs.copyFileSync(itemMagmaChamberPath, path.join(contractsV1Dir, 'magma_chamber.contract.json'));\n} else {\n    console.log(`magma_chamber not found`);\n}\nif(fs.existsSync(itemBreezePath)) {\n    console.log(`Copying breeze ...`);\n    fs.copyFileSync(itemBreezePath, path.join(contractsV1Dir, 'breeze.contract.json'));\n} else {\n    console.log(`breeze not found`);\n}\nif(fs.existsSync(itemWarmBreezePath)) {\n    console.log(`Copying warm_breeze ...`);\n    fs.copyFileSync(itemWarmBreezePath, path.join(contractsV1Dir, 'warm_breeze.contract.json'));\n} else {\n    console.log(`warm_breeze not found`);\n}\nif(fs.existsSync(itemSoilPath)) {\n    console.log(`Copying soil ...`);\n    fs.copyFileSync(itemSoilPath, path.join(contractsV1Dir, 'soil.contract.json'));\n} else {\n    console.log(`soil not found`);\n}\nif(fs.existsSync(itemCanyonPath)) {\n    console.log(`Copying canyon ...`);\n    fs.copyFileSync(itemCanyonPath, path.join(contractsV1Dir, 'canyon.contract.json'));\n} else {\n    console.log(`canyon not found`);\n}\nif(fs.existsSync(itemWindmillPath)) {\n    console.log(`Copying windmill ...`);\n    fs.copyFileSync(itemWindmillPath, path.join(contractsV1Dir, 'windmill.contract.json'));\n} else {\n    console.log(`windmill not found`);\n}\nif(fs.existsSync(itemAdobePath)) {\n    console.log(`Copying adobe ...`);\n    fs.copyFileSync(itemAdobePath, path.join(contractsV1Dir, 'adobe.contract.json'));\n} else {\n    console.log(`adobe not found`);\n}\nif(fs.existsSync(itemWallPath)) {\n    console.log(`Copying wall ...`);\n    fs.copyFileSync(itemWallPath, path.join(contractsV1Dir, 'wall.contract.json'));\n} else {\n    console.log(`wall not found`);\n}\nif(fs.existsSync(itemPumicePath)) {\n    console.log(`Copying pumice ...`);\n    fs.copyFileSync(itemPumicePath, path.join(contractsV1Dir, 'pumice.contract.json'));\n} else {\n    console.log(`pumice not found`);\n}\nif(fs.existsSync(itemBarbecuePath)) {\n    console.log(`Copying barbecue ...`);\n    fs.copyFileSync(itemBarbecuePath, path.join(contractsV1Dir, 'barbecue.contract.json'));\n} else {\n    console.log(`barbecue not found`);\n}\nif(fs.existsSync(itemFarmPath)) {\n    console.log(`Copying farm ...`);\n    fs.copyFileSync(itemFarmPath, path.join(contractsV1Dir, 'farm.contract.json'));\n} else {\n    console.log(`farm not found`);\n}\nif(fs.existsSync(itemShardsPath)) {\n    console.log(`Copying shards ...`);\n    fs.copyFileSync(itemShardsPath, path.join(contractsV1Dir, 'shards.contract.json'));\n} else {\n    console.log(`shards not found`);\n}\nif(fs.existsSync(itemMoltenGlassPath)) {\n    console.log(`Copying molten_glass ...`);\n    fs.copyFileSync(itemMoltenGlassPath, path.join(contractsV1Dir, 'molten_glass.contract.json'));\n} else {\n    console.log(`molten_glass not found`);\n}\nif(fs.existsSync(itemPrismPath)) {\n    console.log(`Copying prism ...`);\n    fs.copyFileSync(itemPrismPath, path.join(contractsV1Dir, 'prism.contract.json'));\n} else {\n    console.log(`prism not found`);\n}\nif(fs.existsSync(itemSparklePath)) {\n    console.log(`Copying sparkle ...`);\n    fs.copyFileSync(itemSparklePath, path.join(contractsV1Dir, 'sparkle.contract.json'));\n} else {\n    console.log(`sparkle not found`);\n}\nif(fs.existsSync(itemDesertPath)) {\n    console.log(`Copying desert ...`);\n    fs.copyFileSync(itemDesertPath, path.join(contractsV1Dir, 'desert.contract.json'));\n} else {\n    console.log(`desert not found`);\n}\nif(fs.existsSync(itemOasisPath)) {\n    console.log(`Copying oasis ...`);\n    fs.copyFileSync(itemOasisPath, path.join(contractsV1Dir, 'oasis.contract.json'));\n} else {\n    console.log(`oasis not found`);\n}\nif(fs.existsSync(itemMiragePath)) {\n    console.log(`Copying mirage ...`);\n    fs.copyFileSync(itemMiragePath, path.join(contractsV1Dir, 'mirage.contract.json'));\n} else {\n    console.log(`mirage not found`);\n}\nif(fs.existsSync(itemSandDunePath)) {\n    console.log(`Copying sand_dune ...`);\n    fs.copyFileSync(itemSandDunePath, path.join(contractsV1Dir, 'sand_dune.contract.json'));\n} else {\n    console.log(`sand_dune not found`);\n}\nif(fs.existsSync(itemDamPath)) {\n    console.log(`Copying dam ...`);\n    fs.copyFileSync(itemDamPath, path.join(contractsV1Dir, 'dam.contract.json'));\n} else {\n    console.log(`dam not found`);\n}\nif(fs.existsSync(itemFirewallPath)) {\n    console.log(`Copying firewall ...`);\n    fs.copyFileSync(itemFirewallPath, path.join(contractsV1Dir, 'firewall.contract.json'));\n} else {\n    console.log(`firewall not found`);\n}\nif(fs.existsSync(itemBarricadePath)) {\n    console.log(`Copying barricade ...`);\n    fs.copyFileSync(itemBarricadePath, path.join(contractsV1Dir, 'barricade.contract.json'));\n} else {\n    console.log(`barricade not found`);\n}\nif(fs.existsSync(itemPlateauPath)) {\n    console.log(`Copying plateau ...`);\n    fs.copyFileSync(itemPlateauPath, path.join(contractsV1Dir, 'plateau.contract.json'));\n} else {\n    console.log(`plateau not found`);\n}\nif(fs.existsSync(itemPondPath)) {\n    console.log(`Copying pond ...`);\n    fs.copyFileSync(itemPondPath, path.join(contractsV1Dir, 'pond.contract.json'));\n} else {\n    console.log(`pond not found`);\n}\nif(fs.existsSync(itemAromasPath)) {\n    console.log(`Copying aromas ...`);\n    fs.copyFileSync(itemAromasPath, path.join(contractsV1Dir, 'aromas.contract.json'));\n} else {\n    console.log(`aromas not found`);\n}\nif(fs.existsSync(itemFlowerPath)) {\n    console.log(`Copying flower ...`);\n    fs.copyFileSync(itemFlowerPath, path.join(contractsV1Dir, 'flower.contract.json'));\n} else {\n    console.log(`flower not found`);\n}\nif(fs.existsSync(itemSporePath)) {\n    console.log(`Copying spore ...`);\n    fs.copyFileSync(itemSporePath, path.join(contractsV1Dir, 'spore.contract.json'));\n} else {\n    console.log(`spore not found`);\n}\nif(fs.existsSync(itemSpreadPath)) {\n    console.log(`Copying spread ...`);\n    fs.copyFileSync(itemSpreadPath, path.join(contractsV1Dir, 'spread.contract.json'));\n} else {\n    console.log(`spread not found`);\n}\nif(fs.existsSync(itemFertileLandPath)) {\n    console.log(`Copying fertile_land ...`);\n    fs.copyFileSync(itemFertileLandPath, path.join(contractsV1Dir, 'fertile_land.contract.json'));\n} else {\n    console.log(`fertile_land not found`);\n}\nif(fs.existsSync(itemWetlandPath)) {\n    console.log(`Copying wetland ...`);\n    fs.copyFileSync(itemWetlandPath, path.join(contractsV1Dir, 'wetland.contract.json'));\n} else {\n    console.log(`wetland not found`);\n}\nif(fs.existsSync(itemPeatPath)) {\n    console.log(`Copying peat ...`);\n    fs.copyFileSync(itemPeatPath, path.join(contractsV1Dir, 'peat.contract.json'));\n} else {\n    console.log(`peat not found`);\n}\nif(fs.existsSync(itemReedsPath)) {\n    console.log(`Copying reeds ...`);\n    fs.copyFileSync(itemReedsPath, path.join(contractsV1Dir, 'reeds.contract.json'));\n} else {\n    console.log(`reeds not found`);\n}\nif(fs.existsSync(itemValleyPath)) {\n    console.log(`Copying valley ...`);\n    fs.copyFileSync(itemValleyPath, path.join(contractsV1Dir, 'valley.contract.json'));\n} else {\n    console.log(`valley not found`);\n}\nif(fs.existsSync(itemRiverPath)) {\n    console.log(`Copying river ...`);\n    fs.copyFileSync(itemRiverPath, path.join(contractsV1Dir, 'river.contract.json'));\n} else {\n    console.log(`river not found`);\n}\nif(fs.existsSync(itemScorchedEarthPath)) {\n    console.log(`Copying scorched_earth ...`);\n    fs.copyFileSync(itemScorchedEarthPath, path.join(contractsV1Dir, 'scorched_earth.contract.json'));\n} else {\n    console.log(`scorched_earth not found`);\n}\nif(fs.existsSync(itemDeltaPath)) {\n    console.log(`Copying delta ...`);\n    fs.copyFileSync(itemDeltaPath, path.join(contractsV1Dir, 'delta.contract.json'));\n} else {\n    console.log(`delta not found`);\n}\nif(fs.existsSync(itemEstuaryPath)) {\n    console.log(`Copying estuary ...`);\n    fs.copyFileSync(itemEstuaryPath, path.join(contractsV1Dir, 'estuary.contract.json'));\n} else {\n    console.log(`estuary not found`);\n}\nif(fs.existsSync(itemFireSwampPath)) {\n    console.log(`Copying fire_swamp ...`);\n    fs.copyFileSync(itemFireSwampPath, path.join(contractsV1Dir, 'fire_swamp.contract.json'));\n} else {\n    console.log(`fire_swamp not found`);\n}\nif(fs.existsSync(itemRiverbankPath)) {\n    console.log(`Copying riverbank ...`);\n    fs.copyFileSync(itemRiverbankPath, path.join(contractsV1Dir, 'riverbank.contract.json'));\n} else {\n    console.log(`riverbank not found`);\n}\nif(fs.existsSync(itemRavinePath)) {\n    console.log(`Copying ravine ...`);\n    fs.copyFileSync(itemRavinePath, path.join(contractsV1Dir, 'ravine.contract.json'));\n} else {\n    console.log(`ravine not found`);\n}\nif(fs.existsSync(itemGorgePath)) {\n    console.log(`Copying gorge ...`);\n    fs.copyFileSync(itemGorgePath, path.join(contractsV1Dir, 'gorge.contract.json'));\n} else {\n    console.log(`gorge not found`);\n}\nif(fs.existsSync(itemCharredRavinePath)) {\n    console.log(`Copying charred_ravine ...`);\n    fs.copyFileSync(itemCharredRavinePath, path.join(contractsV1Dir, 'charred_ravine.contract.json'));\n} else {\n    console.log(`charred_ravine not found`);\n}\nif(fs.existsSync(itemEchoPath)) {\n    console.log(`Copying echo ...`);\n    fs.copyFileSync(itemEchoPath, path.join(contractsV1Dir, 'echo.contract.json'));\n} else {\n    console.log(`echo not found`);\n}\nif(fs.existsSync(itemCavePath)) {\n    console.log(`Copying cave ...`);\n    fs.copyFileSync(itemCavePath, path.join(contractsV1Dir, 'cave.contract.json'));\n} else {\n    console.log(`cave not found`);\n}\nif(fs.existsSync(itemUndergroundLakePath)) {\n    console.log(`Copying underground_lake ...`);\n    fs.copyFileSync(itemUndergroundLakePath, path.join(contractsV1Dir, 'underground_lake.contract.json'));\n} else {\n    console.log(`underground_lake not found`);\n}\nif(fs.existsSync(itemLavaCavePath)) {\n    console.log(`Copying lava_cave ...`);\n    fs.copyFileSync(itemLavaCavePath, path.join(contractsV1Dir, 'lava_cave.contract.json'));\n} else {\n    console.log(`lava_cave not found`);\n}\nif(fs.existsSync(itemWhisperingCavePath)) {\n    console.log(`Copying whispering_cave ...`);\n    fs.copyFileSync(itemWhisperingCavePath, path.join(contractsV1Dir, 'whispering_cave.contract.json'));\n} else {\n    console.log(`whispering_cave not found`);\n}\nif(fs.existsSync(itemSubterraneanPoolPath)) {\n    console.log(`Copying subterranean_pool ...`);\n    fs.copyFileSync(itemSubterraneanPoolPath, path.join(contractsV1Dir, 'subterranean_pool.contract.json'));\n} else {\n    console.log(`subterranean_pool not found`);\n}\nif(fs.existsSync(itemSpringPath)) {\n    console.log(`Copying spring ...`);\n    fs.copyFileSync(itemSpringPath, path.join(contractsV1Dir, 'spring.contract.json'));\n} else {\n    console.log(`spring not found`);\n}\nif(fs.existsSync(itemHotSpringPath)) {\n    console.log(`Copying hot_spring ...`);\n    fs.copyFileSync(itemHotSpringPath, path.join(contractsV1Dir, 'hot_spring.contract.json'));\n} else {\n    console.log(`hot_spring not found`);\n}\nif(fs.existsSync(itemGrottoPath)) {\n    console.log(`Copying grotto ...`);\n    fs.copyFileSync(itemGrottoPath, path.join(contractsV1Dir, 'grotto.contract.json'));\n} else {\n    console.log(`grotto not found`);\n}\nif(fs.existsSync(itemFountainPath)) {\n    console.log(`Copying fountain ...`);\n    fs.copyFileSync(itemFountainPath, path.join(contractsV1Dir, 'fountain.contract.json'));\n} else {\n    console.log(`fountain not found`);\n}\nif(fs.existsSync(itemSteamVentPath)) {\n    console.log(`Copying steam_vent ...`);\n    fs.copyFileSync(itemSteamVentPath, path.join(contractsV1Dir, 'steam_vent.contract.json'));\n} else {\n    console.log(`steam_vent not found`);\n}\nif(fs.existsSync(itemCoolBreezePath)) {\n    console.log(`Copying cool_breeze ...`);\n    fs.copyFileSync(itemCoolBreezePath, path.join(contractsV1Dir, 'cool_breeze.contract.json'));\n} else {\n    console.log(`cool_breeze not found`);\n}\nif(fs.existsSync(itemMonumentPath)) {\n    console.log(`Copying monument ...`);\n    fs.copyFileSync(itemMonumentPath, path.join(contractsV1Dir, 'monument.contract.json'));\n} else {\n    console.log(`monument not found`);\n}\nif(fs.existsSync(itemWaterfallPath)) {\n    console.log(`Copying waterfall ...`);\n    fs.copyFileSync(itemWaterfallPath, path.join(contractsV1Dir, 'waterfall.contract.json'));\n} else {\n    console.log(`waterfall not found`);\n}\nif(fs.existsSync(itemEternalFlamePath)) {\n    console.log(`Copying eternal_flame ...`);\n    fs.copyFileSync(itemEternalFlamePath, path.join(contractsV1Dir, 'eternal_flame.contract.json'));\n} else {\n    console.log(`eternal_flame not found`);\n}\nif(fs.existsSync(itemPillarOfWindPath)) {\n    console.log(`Copying pillar_of_wind ...`);\n    fs.copyFileSync(itemPillarOfWindPath, path.join(contractsV1Dir, 'pillar_of_wind.contract.json'));\n} else {\n    console.log(`pillar_of_wind not found`);\n}\nif(fs.existsSync(itemStreamPath)) {\n    console.log(`Copying stream ...`);\n    fs.copyFileSync(itemStreamPath, path.join(contractsV1Dir, 'stream.contract.json'));\n} else {\n    console.log(`stream not found`);\n}\nif(fs.existsSync(itemZephyrPath)) {\n    console.log(`Copying zephyr ...`);\n    fs.copyFileSync(itemZephyrPath, path.join(contractsV1Dir, 'zephyr.contract.json'));\n} else {\n    console.log(`zephyr not found`);\n}\nif(fs.existsSync(itemCreekPath)) {\n    console.log(`Copying creek ...`);\n    fs.copyFileSync(itemCreekPath, path.join(contractsV1Dir, 'creek.contract.json'));\n} else {\n    console.log(`creek not found`);\n}\nif(fs.existsSync(itemBrookPath)) {\n    console.log(`Copying brook ...`);\n    fs.copyFileSync(itemBrookPath, path.join(contractsV1Dir, 'brook.contract.json'));\n} else {\n    console.log(`brook not found`);\n}\nif(fs.existsSync(itemWhisperPath)) {\n    console.log(`Copying whisper ...`);\n    fs.copyFileSync(itemWhisperPath, path.join(contractsV1Dir, 'whisper.contract.json'));\n} else {\n    console.log(`whisper not found`);\n}\nif(fs.existsSync(itemRivuletPath)) {\n    console.log(`Copying rivulet ...`);\n    fs.copyFileSync(itemRivuletPath, path.join(contractsV1Dir, 'rivulet.contract.json'));\n} else {\n    console.log(`rivulet not found`);\n}\nif(fs.existsSync(itemTributaryPath)) {\n    console.log(`Copying tributary ...`);\n    fs.copyFileSync(itemTributaryPath, path.join(contractsV1Dir, 'tributary.contract.json'));\n} else {\n    console.log(`tributary not found`);\n}\nif(fs.existsSync(itemMurmurPath)) {\n    console.log(`Copying murmur ...`);\n    fs.copyFileSync(itemMurmurPath, path.join(contractsV1Dir, 'murmur.contract.json'));\n} else {\n    console.log(`murmur not found`);\n}\nif(fs.existsSync(itemWatershedPath)) {\n    console.log(`Copying watershed ...`);\n    fs.copyFileSync(itemWatershedPath, path.join(contractsV1Dir, 'watershed.contract.json'));\n} else {\n    console.log(`watershed not found`);\n}\nif(fs.existsSync(itemAquiferPath)) {\n    console.log(`Copying aquifer ...`);\n    fs.copyFileSync(itemAquiferPath, path.join(contractsV1Dir, 'aquifer.contract.json'));\n} else {\n    console.log(`aquifer not found`);\n}\nif(fs.existsSync(itemParchedEarthPath)) {\n    console.log(`Copying parched_earth ...`);\n    fs.copyFileSync(itemParchedEarthPath, path.join(contractsV1Dir, 'parched_earth.contract.json'));\n} else {\n    console.log(`parched_earth not found`);\n}\nif(fs.existsSync(itemFreshBreezePath)) {\n    console.log(`Copying fresh_breeze ...`);\n    fs.copyFileSync(itemFreshBreezePath, path.join(contractsV1Dir, 'fresh_breeze.contract.json'));\n} else {\n    console.log(`fresh_breeze not found`);\n}\nif(fs.existsSync(itemGroundwaterPath)) {\n    console.log(`Copying groundwater ...`);\n    fs.copyFileSync(itemGroundwaterPath, path.join(contractsV1Dir, 'groundwater.contract.json'));\n} else {\n    console.log(`groundwater not found`);\n}\nif(fs.existsSync(itemReservoirPath)) {\n    console.log(`Copying reservoir ...`);\n    fs.copyFileSync(itemReservoirPath, path.join(contractsV1Dir, 'reservoir.contract.json'));\n} else {\n    console.log(`reservoir not found`);\n}\nif(fs.existsSync(itemGeothermalSpringPath)) {\n    console.log(`Copying geothermal_spring ...`);\n    fs.copyFileSync(itemGeothermalSpringPath, path.join(contractsV1Dir, 'geothermal_spring.contract.json'));\n} else {\n    console.log(`geothermal_spring not found`);\n}\nif(fs.existsSync(itemArtesianWellPath)) {\n    console.log(`Copying artesian_well ...`);\n    fs.copyFileSync(itemArtesianWellPath, path.join(contractsV1Dir, 'artesian_well.contract.json'));\n} else {\n    console.log(`artesian_well not found`);\n}\nif(fs.existsSync(itemBasinPath)) {\n    console.log(`Copying basin ...`);\n    fs.copyFileSync(itemBasinPath, path.join(contractsV1Dir, 'basin.contract.json'));\n} else {\n    console.log(`basin not found`);\n}\nif(fs.existsSync(itemLakePath)) {\n    console.log(`Copying lake ...`);\n    fs.copyFileSync(itemLakePath, path.join(contractsV1Dir, 'lake.contract.json'));\n} else {\n    console.log(`lake not found`);\n}\nif(fs.existsSync(itemDryBasinPath)) {\n    console.log(`Copying dry_basin ...`);\n    fs.copyFileSync(itemDryBasinPath, path.join(contractsV1Dir, 'dry_basin.contract.json'));\n} else {\n    console.log(`dry_basin not found`);\n}\nif(fs.existsSync(itemDepressionPath)) {\n    console.log(`Copying depression ...`);\n    fs.copyFileSync(itemDepressionPath, path.join(contractsV1Dir, 'depression.contract.json'));\n} else {\n    console.log(`depression not found`);\n}\nif(fs.existsSync(itemIslandPath)) {\n    console.log(`Copying island ...`);\n    fs.copyFileSync(itemIslandPath, path.join(contractsV1Dir, 'island.contract.json'));\n} else {\n    console.log(`island not found`);\n}\nif(fs.existsSync(itemLagoonPath)) {\n    console.log(`Copying lagoon ...`);\n    fs.copyFileSync(itemLagoonPath, path.join(contractsV1Dir, 'lagoon.contract.json'));\n} else {\n    console.log(`lagoon not found`);\n}\nif(fs.existsSync(itemWavePath)) {\n    console.log(`Copying wave ...`);\n    fs.copyFileSync(itemWavePath, path.join(contractsV1Dir, 'wave.contract.json'));\n} else {\n    console.log(`wave not found`);\n}\nif(fs.existsSync(itemReefPath)) {\n    console.log(`Copying reef ...`);\n    fs.copyFileSync(itemReefPath, path.join(contractsV1Dir, 'reef.contract.json'));\n} else {\n    console.log(`reef not found`);\n}\nif(fs.existsSync(itemCoralPath)) {\n    console.log(`Copying coral ...`);\n    fs.copyFileSync(itemCoralPath, path.join(contractsV1Dir, 'coral.contract.json'));\n} else {\n    console.log(`coral not found`);\n}\nif(fs.existsSync(itemWhirlPath)) {\n    console.log(`Copying whirl ...`);\n    fs.copyFileSync(itemWhirlPath, path.join(contractsV1Dir, 'whirl.contract.json'));\n} else {\n    console.log(`whirl not found`);\n}\nif(fs.existsSync(itemLimestonePath)) {\n    console.log(`Copying limestone ...`);\n    fs.copyFileSync(itemLimestonePath, path.join(contractsV1Dir, 'limestone.contract.json'));\n} else {\n    console.log(`limestone not found`);\n}\nif(fs.existsSync(itemKarstPath)) {\n    console.log(`Copying karst ...`);\n    fs.copyFileSync(itemKarstPath, path.join(contractsV1Dir, 'karst.contract.json'));\n} else {\n    console.log(`karst not found`);\n}\nif(fs.existsSync(itemQuicklimePath)) {\n    console.log(`Copying quicklime ...`);\n    fs.copyFileSync(itemQuicklimePath, path.join(contractsV1Dir, 'quicklime.contract.json'));\n} else {\n    console.log(`quicklime not found`);\n}\nif(fs.existsSync(itemBlowholePath)) {\n    console.log(`Copying blowhole ...`);\n    fs.copyFileSync(itemBlowholePath, path.join(contractsV1Dir, 'blowhole.contract.json'));\n} else {\n    console.log(`blowhole not found`);\n}\n\nif(fs.existsSync(gameUnifiersPath)) {\n    console.log(`Copying unifiers ...`);\n    fs.copyFileSync(gameUnifiersPath, path.join(contractsV1Dir, 'unifiers.contract.json'));\n} else {\n    console.log(`unifiers not found`);\n}\nif(fs.existsSync(gameElementyPath)) {\n    console.log(`Copying elementy ...`);\n    fs.copyFileSync(gameElementyPath, path.join(contractsV1Dir, 'elementy.contract.json'));\n} else {\n    console.log(`elementy not found`);\n}\n",
      "contentHash": "cbf076d47fe9c50866102ffd0eecbdeb055a59051b0e4a22e54f2e31a1615f53",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/deployer/extract-metadata.js",
      "content": "const fs = require('fs');\nconst path = require('path');\n\nconst POSSIBLE_CONTRACTS_V1_README_MD_FILES = [\n    \"../../contracts.v1/README.md\",\n    \"../../../contracts.v1/README.md\",\n    \"contracts.v1/README.md\",\n]\n\nconst realContractsV1ReadmeMdIndex = POSSIBLE_CONTRACTS_V1_README_MD_FILES.findIndex((file) => fs.existsSync(file));\nconst contractsV1ReadmeMd = POSSIBLE_CONTRACTS_V1_README_MD_FILES[realContractsV1ReadmeMdIndex];\nconst contractsV1Dir = path.join(path.dirname(contractsV1ReadmeMd), \"artifacts\");\nconst contractInterfacesV1Dir = path.join(path.dirname(contractsV1ReadmeMd), \"interfaces\");\n\nconsole.log(`Loading contracts from ${contractsV1Dir} ...`);\n\nif (!fs.existsSync(contractsV1Dir)) {\n    throw new Error(`Contracts not found at ${contractsV1Dir}`);\n}\n\nif (!fs.existsSync(contractInterfacesV1Dir)) {\n    fs.mkdirSync(contractInterfacesV1Dir, { recursive: true });\n}\n\nconst monkeyPath = path.join(contractsV1Dir, \"monkey.contract.json\");\nconst monkeyInterfacePath = path.join(contractInterfacesV1Dir, \"monkey.interface.json\");\nif(fs.existsSync(monkeyPath)) {\n    const monkeyData = JSON.parse(\n        fs.readFileSync(monkeyPath, { encoding: 'utf-8' })\n    );\n    if(!monkeyData.source) {\n        console.log(`No source found for Monkey at ${ monkeyPath }`)\n        return;\n    }\n    delete monkeyData.source.wasm;\n    fs.writeFileSync(monkeyInterfacePath, JSON.stringify(monkeyData, null, 4));\n    console.log(`Extracted metadata for Monkey to ${ monkeyInterfacePath }`)\n} else {\n    console.log(`No metadata found for Monkey at ${ monkeyPath }`)\n}\nconst giraffePath = path.join(contractsV1Dir, \"giraffe.contract.json\");\nconst giraffeInterfacePath = path.join(contractInterfacesV1Dir, \"giraffe.interface.json\");\nif(fs.existsSync(giraffePath)) {\n    const giraffeData = JSON.parse(\n        fs.readFileSync(giraffePath, { encoding: 'utf-8' })\n    );\n    if(!giraffeData.source) {\n        console.log(`No source found for Giraffe at ${ giraffePath }`)\n        return;\n    }\n    delete giraffeData.source.wasm;\n    fs.writeFileSync(giraffeInterfacePath, JSON.stringify(giraffeData, null, 4));\n    console.log(`Extracted metadata for Giraffe to ${ giraffeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Giraffe at ${ giraffePath }`)\n}\nconst beePath = path.join(contractsV1Dir, \"bee.contract.json\");\nconst beeInterfacePath = path.join(contractInterfacesV1Dir, \"bee.interface.json\");\nif(fs.existsSync(beePath)) {\n    const beeData = JSON.parse(\n        fs.readFileSync(beePath, { encoding: 'utf-8' })\n    );\n    if(!beeData.source) {\n        console.log(`No source found for Bee at ${ beePath }`)\n        return;\n    }\n    delete beeData.source.wasm;\n    fs.writeFileSync(beeInterfacePath, JSON.stringify(beeData, null, 4));\n    console.log(`Extracted metadata for Bee to ${ beeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Bee at ${ beePath }`)\n}\nconst coinPath = path.join(contractsV1Dir, \"coin.contract.json\");\nconst coinInterfacePath = path.join(contractInterfacesV1Dir, \"coin.interface.json\");\nif(fs.existsSync(coinPath)) {\n    const coinData = JSON.parse(\n        fs.readFileSync(coinPath, { encoding: 'utf-8' })\n    );\n    if(!coinData.source) {\n        console.log(`No source found for Coin at ${ coinPath }`)\n        return;\n    }\n    delete coinData.source.wasm;\n    fs.writeFileSync(coinInterfacePath, JSON.stringify(coinData, null, 4));\n    console.log(`Extracted metadata for Coin to ${ coinInterfacePath }`)\n} else {\n    console.log(`No metadata found for Coin at ${ coinPath }`)\n}\nconst swarmPath = path.join(contractsV1Dir, \"swarm.contract.json\");\nconst swarmInterfacePath = path.join(contractInterfacesV1Dir, \"swarm.interface.json\");\nif(fs.existsSync(swarmPath)) {\n    const swarmData = JSON.parse(\n        fs.readFileSync(swarmPath, { encoding: 'utf-8' })\n    );\n    if(!swarmData.source) {\n        console.log(`No source found for SWARM at ${ swarmPath }`)\n        return;\n    }\n    delete swarmData.source.wasm;\n    fs.writeFileSync(swarmInterfacePath, JSON.stringify(swarmData, null, 4));\n    console.log(`Extracted metadata for SWARM to ${ swarmInterfacePath }`)\n} else {\n    console.log(`No metadata found for SWARM at ${ swarmPath }`)\n}\nconst hydraPath = path.join(contractsV1Dir, \"hydra.contract.json\");\nconst hydraInterfacePath = path.join(contractInterfacesV1Dir, \"hydra.interface.json\");\nif(fs.existsSync(hydraPath)) {\n    const hydraData = JSON.parse(\n        fs.readFileSync(hydraPath, { encoding: 'utf-8' })\n    );\n    if(!hydraData.source) {\n        console.log(`No source found for Hydra at ${ hydraPath }`)\n        return;\n    }\n    delete hydraData.source.wasm;\n    fs.writeFileSync(hydraInterfacePath, JSON.stringify(hydraData, null, 4));\n    console.log(`Extracted metadata for Hydra to ${ hydraInterfacePath }`)\n} else {\n    console.log(`No metadata found for Hydra at ${ hydraPath }`)\n}\nconst monkeyBranchPath = path.join(contractsV1Dir, \"monkey_branch.contract.json\");\nconst monkeyBranchInterfacePath = path.join(contractInterfacesV1Dir, \"monkey_branch.interface.json\");\nif(fs.existsSync(monkeyBranchPath)) {\n    const monkeyBranchData = JSON.parse(\n        fs.readFileSync(monkeyBranchPath, { encoding: 'utf-8' })\n    );\n    if(!monkeyBranchData.source) {\n        console.log(`No source found for MonkeyBranch at ${ monkeyBranchPath }`)\n        return;\n    }\n    delete monkeyBranchData.source.wasm;\n    fs.writeFileSync(monkeyBranchInterfacePath, JSON.stringify(monkeyBranchData, null, 4));\n    console.log(`Extracted metadata for MonkeyBranch to ${ monkeyBranchInterfacePath }`)\n} else {\n    console.log(`No metadata found for MonkeyBranch at ${ monkeyBranchPath }`)\n}\nconst bridgePath = path.join(contractsV1Dir, \"bridge.contract.json\");\nconst bridgeInterfacePath = path.join(contractInterfacesV1Dir, \"bridge.interface.json\");\nif(fs.existsSync(bridgePath)) {\n    const bridgeData = JSON.parse(\n        fs.readFileSync(bridgePath, { encoding: 'utf-8' })\n    );\n    if(!bridgeData.source) {\n        console.log(`No source found for Bridge at ${ bridgePath }`)\n        return;\n    }\n    delete bridgeData.source.wasm;\n    fs.writeFileSync(bridgeInterfacePath, JSON.stringify(bridgeData, null, 4));\n    console.log(`Extracted metadata for Bridge to ${ bridgeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Bridge at ${ bridgePath }`)\n}\nconst goldenGatePath = path.join(contractsV1Dir, \"golden_gate.contract.json\");\nconst goldenGateInterfacePath = path.join(contractInterfacesV1Dir, \"golden_gate.interface.json\");\nif(fs.existsSync(goldenGatePath)) {\n    const goldenGateData = JSON.parse(\n        fs.readFileSync(goldenGatePath, { encoding: 'utf-8' })\n    );\n    if(!goldenGateData.source) {\n        console.log(`No source found for GoldenGate at ${ goldenGatePath }`)\n        return;\n    }\n    delete goldenGateData.source.wasm;\n    fs.writeFileSync(goldenGateInterfacePath, JSON.stringify(goldenGateData, null, 4));\n    console.log(`Extracted metadata for GoldenGate to ${ goldenGateInterfacePath }`)\n} else {\n    console.log(`No metadata found for GoldenGate at ${ goldenGatePath }`)\n}\nconst goldPath = path.join(contractsV1Dir, \"gold.contract.json\");\nconst goldInterfacePath = path.join(contractInterfacesV1Dir, \"gold.interface.json\");\nif(fs.existsSync(goldPath)) {\n    const goldData = JSON.parse(\n        fs.readFileSync(goldPath, { encoding: 'utf-8' })\n    );\n    if(!goldData.source) {\n        console.log(`No source found for Gold at ${ goldPath }`)\n        return;\n    }\n    delete goldData.source.wasm;\n    fs.writeFileSync(goldInterfacePath, JSON.stringify(goldData, null, 4));\n    console.log(`Extracted metadata for Gold to ${ goldInterfacePath }`)\n} else {\n    console.log(`No metadata found for Gold at ${ goldPath }`)\n}\nconst silverPath = path.join(contractsV1Dir, \"silver.contract.json\");\nconst silverInterfacePath = path.join(contractInterfacesV1Dir, \"silver.interface.json\");\nif(fs.existsSync(silverPath)) {\n    const silverData = JSON.parse(\n        fs.readFileSync(silverPath, { encoding: 'utf-8' })\n    );\n    if(!silverData.source) {\n        console.log(`No source found for Silver at ${ silverPath }`)\n        return;\n    }\n    delete silverData.source.wasm;\n    fs.writeFileSync(silverInterfacePath, JSON.stringify(silverData, null, 4));\n    console.log(`Extracted metadata for Silver to ${ silverInterfacePath }`)\n} else {\n    console.log(`No metadata found for Silver at ${ silverPath }`)\n}\nconst rhodiumPath = path.join(contractsV1Dir, \"rhodium.contract.json\");\nconst rhodiumInterfacePath = path.join(contractInterfacesV1Dir, \"rhodium.interface.json\");\nif(fs.existsSync(rhodiumPath)) {\n    const rhodiumData = JSON.parse(\n        fs.readFileSync(rhodiumPath, { encoding: 'utf-8' })\n    );\n    if(!rhodiumData.source) {\n        console.log(`No source found for Rhodium at ${ rhodiumPath }`)\n        return;\n    }\n    delete rhodiumData.source.wasm;\n    fs.writeFileSync(rhodiumInterfacePath, JSON.stringify(rhodiumData, null, 4));\n    console.log(`Extracted metadata for Rhodium to ${ rhodiumInterfacePath }`)\n} else {\n    console.log(`No metadata found for Rhodium at ${ rhodiumPath }`)\n}\nconst hivePath = path.join(contractsV1Dir, \"hive.contract.json\");\nconst hiveInterfacePath = path.join(contractInterfacesV1Dir, \"hive.interface.json\");\nif(fs.existsSync(hivePath)) {\n    const hiveData = JSON.parse(\n        fs.readFileSync(hivePath, { encoding: 'utf-8' })\n    );\n    if(!hiveData.source) {\n        console.log(`No source found for Hive at ${ hivePath }`)\n        return;\n    }\n    delete hiveData.source.wasm;\n    fs.writeFileSync(hiveInterfacePath, JSON.stringify(hiveData, null, 4));\n    console.log(`Extracted metadata for Hive to ${ hiveInterfacePath }`)\n} else {\n    console.log(`No metadata found for Hive at ${ hivePath }`)\n}\nconst transactionPath = path.join(contractsV1Dir, \"transaction.contract.json\");\nconst transactionInterfacePath = path.join(contractInterfacesV1Dir, \"transaction.interface.json\");\nif(fs.existsSync(transactionPath)) {\n    const transactionData = JSON.parse(\n        fs.readFileSync(transactionPath, { encoding: 'utf-8' })\n    );\n    if(!transactionData.source) {\n        console.log(`No source found for Transaction at ${ transactionPath }`)\n        return;\n    }\n    delete transactionData.source.wasm;\n    fs.writeFileSync(transactionInterfacePath, JSON.stringify(transactionData, null, 4));\n    console.log(`Extracted metadata for Transaction to ${ transactionInterfacePath }`)\n} else {\n    console.log(`No metadata found for Transaction at ${ transactionPath }`)\n}\nconst blockPath = path.join(contractsV1Dir, \"block.contract.json\");\nconst blockInterfacePath = path.join(contractInterfacesV1Dir, \"block.interface.json\");\nif(fs.existsSync(blockPath)) {\n    const blockData = JSON.parse(\n        fs.readFileSync(blockPath, { encoding: 'utf-8' })\n    );\n    if(!blockData.source) {\n        console.log(`No source found for Block at ${ blockPath }`)\n        return;\n    }\n    delete blockData.source.wasm;\n    fs.writeFileSync(blockInterfacePath, JSON.stringify(blockData, null, 4));\n    console.log(`Extracted metadata for Block to ${ blockInterfacePath }`)\n} else {\n    console.log(`No metadata found for Block at ${ blockPath }`)\n}\nconst blockchainPath = path.join(contractsV1Dir, \"blockchain.contract.json\");\nconst blockchainInterfacePath = path.join(contractInterfacesV1Dir, \"blockchain.interface.json\");\nif(fs.existsSync(blockchainPath)) {\n    const blockchainData = JSON.parse(\n        fs.readFileSync(blockchainPath, { encoding: 'utf-8' })\n    );\n    if(!blockchainData.source) {\n        console.log(`No source found for Blockchain at ${ blockchainPath }`)\n        return;\n    }\n    delete blockchainData.source.wasm;\n    fs.writeFileSync(blockchainInterfacePath, JSON.stringify(blockchainData, null, 4));\n    console.log(`Extracted metadata for Blockchain to ${ blockchainInterfacePath }`)\n} else {\n    console.log(`No metadata found for Blockchain at ${ blockchainPath }`)\n}\nconst polkadotPath = path.join(contractsV1Dir, \"polkadot.contract.json\");\nconst polkadotInterfacePath = path.join(contractInterfacesV1Dir, \"polkadot.interface.json\");\nif(fs.existsSync(polkadotPath)) {\n    const polkadotData = JSON.parse(\n        fs.readFileSync(polkadotPath, { encoding: 'utf-8' })\n    );\n    if(!polkadotData.source) {\n        console.log(`No source found for Polkadot at ${ polkadotPath }`)\n        return;\n    }\n    delete polkadotData.source.wasm;\n    fs.writeFileSync(polkadotInterfacePath, JSON.stringify(polkadotData, null, 4));\n    console.log(`Extracted metadata for Polkadot to ${ polkadotInterfacePath }`)\n} else {\n    console.log(`No metadata found for Polkadot at ${ polkadotPath }`)\n}\nconst peerReviewPath = path.join(contractsV1Dir, \"peer_review.contract.json\");\nconst peerReviewInterfacePath = path.join(contractInterfacesV1Dir, \"peer_review.interface.json\");\nif(fs.existsSync(peerReviewPath)) {\n    const peerReviewData = JSON.parse(\n        fs.readFileSync(peerReviewPath, { encoding: 'utf-8' })\n    );\n    if(!peerReviewData.source) {\n        console.log(`No source found for PeerReview at ${ peerReviewPath }`)\n        return;\n    }\n    delete peerReviewData.source.wasm;\n    fs.writeFileSync(peerReviewInterfacePath, JSON.stringify(peerReviewData, null, 4));\n    console.log(`Extracted metadata for PeerReview to ${ peerReviewInterfacePath }`)\n} else {\n    console.log(`No metadata found for PeerReview at ${ peerReviewPath }`)\n}\nconst cardanoPath = path.join(contractsV1Dir, \"cardano.contract.json\");\nconst cardanoInterfacePath = path.join(contractInterfacesV1Dir, \"cardano.interface.json\");\nif(fs.existsSync(cardanoPath)) {\n    const cardanoData = JSON.parse(\n        fs.readFileSync(cardanoPath, { encoding: 'utf-8' })\n    );\n    if(!cardanoData.source) {\n        console.log(`No source found for Cardano at ${ cardanoPath }`)\n        return;\n    }\n    delete cardanoData.source.wasm;\n    fs.writeFileSync(cardanoInterfacePath, JSON.stringify(cardanoData, null, 4));\n    console.log(`Extracted metadata for Cardano to ${ cardanoInterfacePath }`)\n} else {\n    console.log(`No metadata found for Cardano at ${ cardanoPath }`)\n}\nconst bearPath = path.join(contractsV1Dir, \"bear.contract.json\");\nconst bearInterfacePath = path.join(contractInterfacesV1Dir, \"bear.interface.json\");\nif(fs.existsSync(bearPath)) {\n    const bearData = JSON.parse(\n        fs.readFileSync(bearPath, { encoding: 'utf-8' })\n    );\n    if(!bearData.source) {\n        console.log(`No source found for Bear at ${ bearPath }`)\n        return;\n    }\n    delete bearData.source.wasm;\n    fs.writeFileSync(bearInterfacePath, JSON.stringify(bearData, null, 4));\n    console.log(`Extracted metadata for Bear to ${ bearInterfacePath }`)\n} else {\n    console.log(`No metadata found for Bear at ${ bearPath }`)\n}\nconst beerPath = path.join(contractsV1Dir, \"beer.contract.json\");\nconst beerInterfacePath = path.join(contractInterfacesV1Dir, \"beer.interface.json\");\nif(fs.existsSync(beerPath)) {\n    const beerData = JSON.parse(\n        fs.readFileSync(beerPath, { encoding: 'utf-8' })\n    );\n    if(!beerData.source) {\n        console.log(`No source found for Beer at ${ beerPath }`)\n        return;\n    }\n    delete beerData.source.wasm;\n    fs.writeFileSync(beerInterfacePath, JSON.stringify(beerData, null, 4));\n    console.log(`Extracted metadata for Beer to ${ beerInterfacePath }`)\n} else {\n    console.log(`No metadata found for Beer at ${ beerPath }`)\n}\nconst lockPath = path.join(contractsV1Dir, \"lock.contract.json\");\nconst lockInterfacePath = path.join(contractInterfacesV1Dir, \"lock.interface.json\");\nif(fs.existsSync(lockPath)) {\n    const lockData = JSON.parse(\n        fs.readFileSync(lockPath, { encoding: 'utf-8' })\n    );\n    if(!lockData.source) {\n        console.log(`No source found for Lock at ${ lockPath }`)\n        return;\n    }\n    delete lockData.source.wasm;\n    fs.writeFileSync(lockInterfacePath, JSON.stringify(lockData, null, 4));\n    console.log(`Extracted metadata for Lock to ${ lockInterfacePath }`)\n} else {\n    console.log(`No metadata found for Lock at ${ lockPath }`)\n}\nconst marmaladePath = path.join(contractsV1Dir, \"marmalade.contract.json\");\nconst marmaladeInterfacePath = path.join(contractInterfacesV1Dir, \"marmalade.interface.json\");\nif(fs.existsSync(marmaladePath)) {\n    const marmaladeData = JSON.parse(\n        fs.readFileSync(marmaladePath, { encoding: 'utf-8' })\n    );\n    if(!marmaladeData.source) {\n        console.log(`No source found for Marmalade at ${ marmaladePath }`)\n        return;\n    }\n    delete marmaladeData.source.wasm;\n    fs.writeFileSync(marmaladeInterfacePath, JSON.stringify(marmaladeData, null, 4));\n    console.log(`Extracted metadata for Marmalade to ${ marmaladeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Marmalade at ${ marmaladePath }`)\n}\nconst superMarmaladePath = path.join(contractsV1Dir, \"super_marmalade.contract.json\");\nconst superMarmaladeInterfacePath = path.join(contractInterfacesV1Dir, \"super_marmalade.interface.json\");\nif(fs.existsSync(superMarmaladePath)) {\n    const superMarmaladeData = JSON.parse(\n        fs.readFileSync(superMarmaladePath, { encoding: 'utf-8' })\n    );\n    if(!superMarmaladeData.source) {\n        console.log(`No source found for SuperMarmalade at ${ superMarmaladePath }`)\n        return;\n    }\n    delete superMarmaladeData.source.wasm;\n    fs.writeFileSync(superMarmaladeInterfacePath, JSON.stringify(superMarmaladeData, null, 4));\n    console.log(`Extracted metadata for SuperMarmalade to ${ superMarmaladeInterfacePath }`)\n} else {\n    console.log(`No metadata found for SuperMarmalade at ${ superMarmaladePath }`)\n}\nconst hyperMarmaladePath = path.join(contractsV1Dir, \"hyper_marmalade.contract.json\");\nconst hyperMarmaladeInterfacePath = path.join(contractInterfacesV1Dir, \"hyper_marmalade.interface.json\");\nif(fs.existsSync(hyperMarmaladePath)) {\n    const hyperMarmaladeData = JSON.parse(\n        fs.readFileSync(hyperMarmaladePath, { encoding: 'utf-8' })\n    );\n    if(!hyperMarmaladeData.source) {\n        console.log(`No source found for HyperMarmalade at ${ hyperMarmaladePath }`)\n        return;\n    }\n    delete hyperMarmaladeData.source.wasm;\n    fs.writeFileSync(hyperMarmaladeInterfacePath, JSON.stringify(hyperMarmaladeData, null, 4));\n    console.log(`Extracted metadata for HyperMarmalade to ${ hyperMarmaladeInterfacePath }`)\n} else {\n    console.log(`No metadata found for HyperMarmalade at ${ hyperMarmaladePath }`)\n}\nconst waterPath = path.join(contractsV1Dir, \"water.contract.json\");\nconst waterInterfacePath = path.join(contractInterfacesV1Dir, \"water.interface.json\");\nif(fs.existsSync(waterPath)) {\n    const waterData = JSON.parse(\n        fs.readFileSync(waterPath, { encoding: 'utf-8' })\n    );\n    if(!waterData.source) {\n        console.log(`No source found for Water at ${ waterPath }`)\n        return;\n    }\n    delete waterData.source.wasm;\n    fs.writeFileSync(waterInterfacePath, JSON.stringify(waterData, null, 4));\n    console.log(`Extracted metadata for Water to ${ waterInterfacePath }`)\n} else {\n    console.log(`No metadata found for Water at ${ waterPath }`)\n}\nconst firePath = path.join(contractsV1Dir, \"fire.contract.json\");\nconst fireInterfacePath = path.join(contractInterfacesV1Dir, \"fire.interface.json\");\nif(fs.existsSync(firePath)) {\n    const fireData = JSON.parse(\n        fs.readFileSync(firePath, { encoding: 'utf-8' })\n    );\n    if(!fireData.source) {\n        console.log(`No source found for Fire at ${ firePath }`)\n        return;\n    }\n    delete fireData.source.wasm;\n    fs.writeFileSync(fireInterfacePath, JSON.stringify(fireData, null, 4));\n    console.log(`Extracted metadata for Fire to ${ fireInterfacePath }`)\n} else {\n    console.log(`No metadata found for Fire at ${ firePath }`)\n}\nconst steamPath = path.join(contractsV1Dir, \"steam.contract.json\");\nconst steamInterfacePath = path.join(contractInterfacesV1Dir, \"steam.interface.json\");\nif(fs.existsSync(steamPath)) {\n    const steamData = JSON.parse(\n        fs.readFileSync(steamPath, { encoding: 'utf-8' })\n    );\n    if(!steamData.source) {\n        console.log(`No source found for Steam at ${ steamPath }`)\n        return;\n    }\n    delete steamData.source.wasm;\n    fs.writeFileSync(steamInterfacePath, JSON.stringify(steamData, null, 4));\n    console.log(`Extracted metadata for Steam to ${ steamInterfacePath }`)\n} else {\n    console.log(`No metadata found for Steam at ${ steamPath }`)\n}\nconst earthPath = path.join(contractsV1Dir, \"earth.contract.json\");\nconst earthInterfacePath = path.join(contractInterfacesV1Dir, \"earth.interface.json\");\nif(fs.existsSync(earthPath)) {\n    const earthData = JSON.parse(\n        fs.readFileSync(earthPath, { encoding: 'utf-8' })\n    );\n    if(!earthData.source) {\n        console.log(`No source found for Earth at ${ earthPath }`)\n        return;\n    }\n    delete earthData.source.wasm;\n    fs.writeFileSync(earthInterfacePath, JSON.stringify(earthData, null, 4));\n    console.log(`Extracted metadata for Earth to ${ earthInterfacePath }`)\n} else {\n    console.log(`No metadata found for Earth at ${ earthPath }`)\n}\nconst mudPath = path.join(contractsV1Dir, \"mud.contract.json\");\nconst mudInterfacePath = path.join(contractInterfacesV1Dir, \"mud.interface.json\");\nif(fs.existsSync(mudPath)) {\n    const mudData = JSON.parse(\n        fs.readFileSync(mudPath, { encoding: 'utf-8' })\n    );\n    if(!mudData.source) {\n        console.log(`No source found for Mud at ${ mudPath }`)\n        return;\n    }\n    delete mudData.source.wasm;\n    fs.writeFileSync(mudInterfacePath, JSON.stringify(mudData, null, 4));\n    console.log(`Extracted metadata for Mud to ${ mudInterfacePath }`)\n} else {\n    console.log(`No metadata found for Mud at ${ mudPath }`)\n}\nconst lavaPath = path.join(contractsV1Dir, \"lava.contract.json\");\nconst lavaInterfacePath = path.join(contractInterfacesV1Dir, \"lava.interface.json\");\nif(fs.existsSync(lavaPath)) {\n    const lavaData = JSON.parse(\n        fs.readFileSync(lavaPath, { encoding: 'utf-8' })\n    );\n    if(!lavaData.source) {\n        console.log(`No source found for Lava at ${ lavaPath }`)\n        return;\n    }\n    delete lavaData.source.wasm;\n    fs.writeFileSync(lavaInterfacePath, JSON.stringify(lavaData, null, 4));\n    console.log(`Extracted metadata for Lava to ${ lavaInterfacePath }`)\n} else {\n    console.log(`No metadata found for Lava at ${ lavaPath }`)\n}\nconst windPath = path.join(contractsV1Dir, \"wind.contract.json\");\nconst windInterfacePath = path.join(contractInterfacesV1Dir, \"wind.interface.json\");\nif(fs.existsSync(windPath)) {\n    const windData = JSON.parse(\n        fs.readFileSync(windPath, { encoding: 'utf-8' })\n    );\n    if(!windData.source) {\n        console.log(`No source found for Wind at ${ windPath }`)\n        return;\n    }\n    delete windData.source.wasm;\n    fs.writeFileSync(windInterfacePath, JSON.stringify(windData, null, 4));\n    console.log(`Extracted metadata for Wind to ${ windInterfacePath }`)\n} else {\n    console.log(`No metadata found for Wind at ${ windPath }`)\n}\nconst dustPath = path.join(contractsV1Dir, \"dust.contract.json\");\nconst dustInterfacePath = path.join(contractInterfacesV1Dir, \"dust.interface.json\");\nif(fs.existsSync(dustPath)) {\n    const dustData = JSON.parse(\n        fs.readFileSync(dustPath, { encoding: 'utf-8' })\n    );\n    if(!dustData.source) {\n        console.log(`No source found for Dust at ${ dustPath }`)\n        return;\n    }\n    delete dustData.source.wasm;\n    fs.writeFileSync(dustInterfacePath, JSON.stringify(dustData, null, 4));\n    console.log(`Extracted metadata for Dust to ${ dustInterfacePath }`)\n} else {\n    console.log(`No metadata found for Dust at ${ dustPath }`)\n}\nconst rainPath = path.join(contractsV1Dir, \"rain.contract.json\");\nconst rainInterfacePath = path.join(contractInterfacesV1Dir, \"rain.interface.json\");\nif(fs.existsSync(rainPath)) {\n    const rainData = JSON.parse(\n        fs.readFileSync(rainPath, { encoding: 'utf-8' })\n    );\n    if(!rainData.source) {\n        console.log(`No source found for Rain at ${ rainPath }`)\n        return;\n    }\n    delete rainData.source.wasm;\n    fs.writeFileSync(rainInterfacePath, JSON.stringify(rainData, null, 4));\n    console.log(`Extracted metadata for Rain to ${ rainInterfacePath }`)\n} else {\n    console.log(`No metadata found for Rain at ${ rainPath }`)\n}\nconst smokePath = path.join(contractsV1Dir, \"smoke.contract.json\");\nconst smokeInterfacePath = path.join(contractInterfacesV1Dir, \"smoke.interface.json\");\nif(fs.existsSync(smokePath)) {\n    const smokeData = JSON.parse(\n        fs.readFileSync(smokePath, { encoding: 'utf-8' })\n    );\n    if(!smokeData.source) {\n        console.log(`No source found for Smoke at ${ smokePath }`)\n        return;\n    }\n    delete smokeData.source.wasm;\n    fs.writeFileSync(smokeInterfacePath, JSON.stringify(smokeData, null, 4));\n    console.log(`Extracted metadata for Smoke to ${ smokeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Smoke at ${ smokePath }`)\n}\nconst geyserPath = path.join(contractsV1Dir, \"geyser.contract.json\");\nconst geyserInterfacePath = path.join(contractInterfacesV1Dir, \"geyser.interface.json\");\nif(fs.existsSync(geyserPath)) {\n    const geyserData = JSON.parse(\n        fs.readFileSync(geyserPath, { encoding: 'utf-8' })\n    );\n    if(!geyserData.source) {\n        console.log(`No source found for Geyser at ${ geyserPath }`)\n        return;\n    }\n    delete geyserData.source.wasm;\n    fs.writeFileSync(geyserInterfacePath, JSON.stringify(geyserData, null, 4));\n    console.log(`Extracted metadata for Geyser to ${ geyserInterfacePath }`)\n} else {\n    console.log(`No metadata found for Geyser at ${ geyserPath }`)\n}\nconst clayPath = path.join(contractsV1Dir, \"clay.contract.json\");\nconst clayInterfacePath = path.join(contractInterfacesV1Dir, \"clay.interface.json\");\nif(fs.existsSync(clayPath)) {\n    const clayData = JSON.parse(\n        fs.readFileSync(clayPath, { encoding: 'utf-8' })\n    );\n    if(!clayData.source) {\n        console.log(`No source found for Clay at ${ clayPath }`)\n        return;\n    }\n    delete clayData.source.wasm;\n    fs.writeFileSync(clayInterfacePath, JSON.stringify(clayData, null, 4));\n    console.log(`Extracted metadata for Clay to ${ clayInterfacePath }`)\n} else {\n    console.log(`No metadata found for Clay at ${ clayPath }`)\n}\nconst sandPath = path.join(contractsV1Dir, \"sand.contract.json\");\nconst sandInterfacePath = path.join(contractInterfacesV1Dir, \"sand.interface.json\");\nif(fs.existsSync(sandPath)) {\n    const sandData = JSON.parse(\n        fs.readFileSync(sandPath, { encoding: 'utf-8' })\n    );\n    if(!sandData.source) {\n        console.log(`No source found for Sand at ${ sandPath }`)\n        return;\n    }\n    delete sandData.source.wasm;\n    fs.writeFileSync(sandInterfacePath, JSON.stringify(sandData, null, 4));\n    console.log(`Extracted metadata for Sand to ${ sandInterfacePath }`)\n} else {\n    console.log(`No metadata found for Sand at ${ sandPath }`)\n}\nconst plantPath = path.join(contractsV1Dir, \"plant.contract.json\");\nconst plantInterfacePath = path.join(contractInterfacesV1Dir, \"plant.interface.json\");\nif(fs.existsSync(plantPath)) {\n    const plantData = JSON.parse(\n        fs.readFileSync(plantPath, { encoding: 'utf-8' })\n    );\n    if(!plantData.source) {\n        console.log(`No source found for Plant at ${ plantPath }`)\n        return;\n    }\n    delete plantData.source.wasm;\n    fs.writeFileSync(plantInterfacePath, JSON.stringify(plantData, null, 4));\n    console.log(`Extracted metadata for Plant to ${ plantInterfacePath }`)\n} else {\n    console.log(`No metadata found for Plant at ${ plantPath }`)\n}\nconst rainbowPath = path.join(contractsV1Dir, \"rainbow.contract.json\");\nconst rainbowInterfacePath = path.join(contractInterfacesV1Dir, \"rainbow.interface.json\");\nif(fs.existsSync(rainbowPath)) {\n    const rainbowData = JSON.parse(\n        fs.readFileSync(rainbowPath, { encoding: 'utf-8' })\n    );\n    if(!rainbowData.source) {\n        console.log(`No source found for Rainbow at ${ rainbowPath }`)\n        return;\n    }\n    delete rainbowData.source.wasm;\n    fs.writeFileSync(rainbowInterfacePath, JSON.stringify(rainbowData, null, 4));\n    console.log(`Extracted metadata for Rainbow to ${ rainbowInterfacePath }`)\n} else {\n    console.log(`No metadata found for Rainbow at ${ rainbowPath }`)\n}\nconst stormPath = path.join(contractsV1Dir, \"storm.contract.json\");\nconst stormInterfacePath = path.join(contractInterfacesV1Dir, \"storm.interface.json\");\nif(fs.existsSync(stormPath)) {\n    const stormData = JSON.parse(\n        fs.readFileSync(stormPath, { encoding: 'utf-8' })\n    );\n    if(!stormData.source) {\n        console.log(`No source found for Storm at ${ stormPath }`)\n        return;\n    }\n    delete stormData.source.wasm;\n    fs.writeFileSync(stormInterfacePath, JSON.stringify(stormData, null, 4));\n    console.log(`Extracted metadata for Storm to ${ stormInterfacePath }`)\n} else {\n    console.log(`No metadata found for Storm at ${ stormPath }`)\n}\nconst obsidianPath = path.join(contractsV1Dir, \"obsidian.contract.json\");\nconst obsidianInterfacePath = path.join(contractInterfacesV1Dir, \"obsidian.interface.json\");\nif(fs.existsSync(obsidianPath)) {\n    const obsidianData = JSON.parse(\n        fs.readFileSync(obsidianPath, { encoding: 'utf-8' })\n    );\n    if(!obsidianData.source) {\n        console.log(`No source found for Obsidian at ${ obsidianPath }`)\n        return;\n    }\n    delete obsidianData.source.wasm;\n    fs.writeFileSync(obsidianInterfacePath, JSON.stringify(obsidianData, null, 4));\n    console.log(`Extracted metadata for Obsidian to ${ obsidianInterfacePath }`)\n} else {\n    console.log(`No metadata found for Obsidian at ${ obsidianPath }`)\n}\nconst ashPath = path.join(contractsV1Dir, \"ash.contract.json\");\nconst ashInterfacePath = path.join(contractInterfacesV1Dir, \"ash.interface.json\");\nif(fs.existsSync(ashPath)) {\n    const ashData = JSON.parse(\n        fs.readFileSync(ashPath, { encoding: 'utf-8' })\n    );\n    if(!ashData.source) {\n        console.log(`No source found for Ash at ${ ashPath }`)\n        return;\n    }\n    delete ashData.source.wasm;\n    fs.writeFileSync(ashInterfacePath, JSON.stringify(ashData, null, 4));\n    console.log(`Extracted metadata for Ash to ${ ashInterfacePath }`)\n} else {\n    console.log(`No metadata found for Ash at ${ ashPath }`)\n}\nconst volcanoPath = path.join(contractsV1Dir, \"volcano.contract.json\");\nconst volcanoInterfacePath = path.join(contractInterfacesV1Dir, \"volcano.interface.json\");\nif(fs.existsSync(volcanoPath)) {\n    const volcanoData = JSON.parse(\n        fs.readFileSync(volcanoPath, { encoding: 'utf-8' })\n    );\n    if(!volcanoData.source) {\n        console.log(`No source found for Volcano at ${ volcanoPath }`)\n        return;\n    }\n    delete volcanoData.source.wasm;\n    fs.writeFileSync(volcanoInterfacePath, JSON.stringify(volcanoData, null, 4));\n    console.log(`Extracted metadata for Volcano to ${ volcanoInterfacePath }`)\n} else {\n    console.log(`No metadata found for Volcano at ${ volcanoPath }`)\n}\nconst sandstormPath = path.join(contractsV1Dir, \"sandstorm.contract.json\");\nconst sandstormInterfacePath = path.join(contractInterfacesV1Dir, \"sandstorm.interface.json\");\nif(fs.existsSync(sandstormPath)) {\n    const sandstormData = JSON.parse(\n        fs.readFileSync(sandstormPath, { encoding: 'utf-8' })\n    );\n    if(!sandstormData.source) {\n        console.log(`No source found for Sandstorm at ${ sandstormPath }`)\n        return;\n    }\n    delete sandstormData.source.wasm;\n    fs.writeFileSync(sandstormInterfacePath, JSON.stringify(sandstormData, null, 4));\n    console.log(`Extracted metadata for Sandstorm to ${ sandstormInterfacePath }`)\n} else {\n    console.log(`No metadata found for Sandstorm at ${ sandstormPath }`)\n}\nconst cloudPath = path.join(contractsV1Dir, \"cloud.contract.json\");\nconst cloudInterfacePath = path.join(contractInterfacesV1Dir, \"cloud.interface.json\");\nif(fs.existsSync(cloudPath)) {\n    const cloudData = JSON.parse(\n        fs.readFileSync(cloudPath, { encoding: 'utf-8' })\n    );\n    if(!cloudData.source) {\n        console.log(`No source found for Cloud at ${ cloudPath }`)\n        return;\n    }\n    delete cloudData.source.wasm;\n    fs.writeFileSync(cloudInterfacePath, JSON.stringify(cloudData, null, 4));\n    console.log(`Extracted metadata for Cloud to ${ cloudInterfacePath }`)\n} else {\n    console.log(`No metadata found for Cloud at ${ cloudPath }`)\n}\nconst fogPath = path.join(contractsV1Dir, \"fog.contract.json\");\nconst fogInterfacePath = path.join(contractInterfacesV1Dir, \"fog.interface.json\");\nif(fs.existsSync(fogPath)) {\n    const fogData = JSON.parse(\n        fs.readFileSync(fogPath, { encoding: 'utf-8' })\n    );\n    if(!fogData.source) {\n        console.log(`No source found for Fog at ${ fogPath }`)\n        return;\n    }\n    delete fogData.source.wasm;\n    fs.writeFileSync(fogInterfacePath, JSON.stringify(fogData, null, 4));\n    console.log(`Extracted metadata for Fog to ${ fogInterfacePath }`)\n} else {\n    console.log(`No metadata found for Fog at ${ fogPath }`)\n}\nconst treePath = path.join(contractsV1Dir, \"tree.contract.json\");\nconst treeInterfacePath = path.join(contractInterfacesV1Dir, \"tree.interface.json\");\nif(fs.existsSync(treePath)) {\n    const treeData = JSON.parse(\n        fs.readFileSync(treePath, { encoding: 'utf-8' })\n    );\n    if(!treeData.source) {\n        console.log(`No source found for Tree at ${ treePath }`)\n        return;\n    }\n    delete treeData.source.wasm;\n    fs.writeFileSync(treeInterfacePath, JSON.stringify(treeData, null, 4));\n    console.log(`Extracted metadata for Tree to ${ treeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Tree at ${ treePath }`)\n}\nconst forestPath = path.join(contractsV1Dir, \"forest.contract.json\");\nconst forestInterfacePath = path.join(contractInterfacesV1Dir, \"forest.interface.json\");\nif(fs.existsSync(forestPath)) {\n    const forestData = JSON.parse(\n        fs.readFileSync(forestPath, { encoding: 'utf-8' })\n    );\n    if(!forestData.source) {\n        console.log(`No source found for Forest at ${ forestPath }`)\n        return;\n    }\n    delete forestData.source.wasm;\n    fs.writeFileSync(forestInterfacePath, JSON.stringify(forestData, null, 4));\n    console.log(`Extracted metadata for Forest to ${ forestInterfacePath }`)\n} else {\n    console.log(`No metadata found for Forest at ${ forestPath }`)\n}\nconst seedsPath = path.join(contractsV1Dir, \"seeds.contract.json\");\nconst seedsInterfacePath = path.join(contractInterfacesV1Dir, \"seeds.interface.json\");\nif(fs.existsSync(seedsPath)) {\n    const seedsData = JSON.parse(\n        fs.readFileSync(seedsPath, { encoding: 'utf-8' })\n    );\n    if(!seedsData.source) {\n        console.log(`No source found for Seeds at ${ seedsPath }`)\n        return;\n    }\n    delete seedsData.source.wasm;\n    fs.writeFileSync(seedsInterfacePath, JSON.stringify(seedsData, null, 4));\n    console.log(`Extracted metadata for Seeds to ${ seedsInterfacePath }`)\n} else {\n    console.log(`No metadata found for Seeds at ${ seedsPath }`)\n}\nconst potteryPath = path.join(contractsV1Dir, \"pottery.contract.json\");\nconst potteryInterfacePath = path.join(contractInterfacesV1Dir, \"pottery.interface.json\");\nif(fs.existsSync(potteryPath)) {\n    const potteryData = JSON.parse(\n        fs.readFileSync(potteryPath, { encoding: 'utf-8' })\n    );\n    if(!potteryData.source) {\n        console.log(`No source found for Pottery at ${ potteryPath }`)\n        return;\n    }\n    delete potteryData.source.wasm;\n    fs.writeFileSync(potteryInterfacePath, JSON.stringify(potteryData, null, 4));\n    console.log(`Extracted metadata for Pottery to ${ potteryInterfacePath }`)\n} else {\n    console.log(`No metadata found for Pottery at ${ potteryPath }`)\n}\nconst brickPath = path.join(contractsV1Dir, \"brick.contract.json\");\nconst brickInterfacePath = path.join(contractInterfacesV1Dir, \"brick.interface.json\");\nif(fs.existsSync(brickPath)) {\n    const brickData = JSON.parse(\n        fs.readFileSync(brickPath, { encoding: 'utf-8' })\n    );\n    if(!brickData.source) {\n        console.log(`No source found for Brick at ${ brickPath }`)\n        return;\n    }\n    delete brickData.source.wasm;\n    fs.writeFileSync(brickInterfacePath, JSON.stringify(brickData, null, 4));\n    console.log(`Extracted metadata for Brick to ${ brickInterfacePath }`)\n} else {\n    console.log(`No metadata found for Brick at ${ brickPath }`)\n}\nconst quicksandPath = path.join(contractsV1Dir, \"quicksand.contract.json\");\nconst quicksandInterfacePath = path.join(contractInterfacesV1Dir, \"quicksand.interface.json\");\nif(fs.existsSync(quicksandPath)) {\n    const quicksandData = JSON.parse(\n        fs.readFileSync(quicksandPath, { encoding: 'utf-8' })\n    );\n    if(!quicksandData.source) {\n        console.log(`No source found for Quicksand at ${ quicksandPath }`)\n        return;\n    }\n    delete quicksandData.source.wasm;\n    fs.writeFileSync(quicksandInterfacePath, JSON.stringify(quicksandData, null, 4));\n    console.log(`Extracted metadata for Quicksand to ${ quicksandInterfacePath }`)\n} else {\n    console.log(`No metadata found for Quicksand at ${ quicksandPath }`)\n}\nconst glassPath = path.join(contractsV1Dir, \"glass.contract.json\");\nconst glassInterfacePath = path.join(contractInterfacesV1Dir, \"glass.interface.json\");\nif(fs.existsSync(glassPath)) {\n    const glassData = JSON.parse(\n        fs.readFileSync(glassPath, { encoding: 'utf-8' })\n    );\n    if(!glassData.source) {\n        console.log(`No source found for Glass at ${ glassPath }`)\n        return;\n    }\n    delete glassData.source.wasm;\n    fs.writeFileSync(glassInterfacePath, JSON.stringify(glassData, null, 4));\n    console.log(`Extracted metadata for Glass to ${ glassInterfacePath }`)\n} else {\n    console.log(`No metadata found for Glass at ${ glassPath }`)\n}\nconst dunePath = path.join(contractsV1Dir, \"dune.contract.json\");\nconst duneInterfacePath = path.join(contractInterfacesV1Dir, \"dune.interface.json\");\nif(fs.existsSync(dunePath)) {\n    const duneData = JSON.parse(\n        fs.readFileSync(dunePath, { encoding: 'utf-8' })\n    );\n    if(!duneData.source) {\n        console.log(`No source found for Dune at ${ dunePath }`)\n        return;\n    }\n    delete duneData.source.wasm;\n    fs.writeFileSync(duneInterfacePath, JSON.stringify(duneData, null, 4));\n    console.log(`Extracted metadata for Dune to ${ duneInterfacePath }`)\n} else {\n    console.log(`No metadata found for Dune at ${ dunePath }`)\n}\nconst charcoalPath = path.join(contractsV1Dir, \"charcoal.contract.json\");\nconst charcoalInterfacePath = path.join(contractInterfacesV1Dir, \"charcoal.interface.json\");\nif(fs.existsSync(charcoalPath)) {\n    const charcoalData = JSON.parse(\n        fs.readFileSync(charcoalPath, { encoding: 'utf-8' })\n    );\n    if(!charcoalData.source) {\n        console.log(`No source found for Charcoal at ${ charcoalPath }`)\n        return;\n    }\n    delete charcoalData.source.wasm;\n    fs.writeFileSync(charcoalInterfacePath, JSON.stringify(charcoalData, null, 4));\n    console.log(`Extracted metadata for Charcoal to ${ charcoalInterfacePath }`)\n} else {\n    console.log(`No metadata found for Charcoal at ${ charcoalPath }`)\n}\nconst leavesPath = path.join(contractsV1Dir, \"leaves.contract.json\");\nconst leavesInterfacePath = path.join(contractInterfacesV1Dir, \"leaves.interface.json\");\nif(fs.existsSync(leavesPath)) {\n    const leavesData = JSON.parse(\n        fs.readFileSync(leavesPath, { encoding: 'utf-8' })\n    );\n    if(!leavesData.source) {\n        console.log(`No source found for Leaves at ${ leavesPath }`)\n        return;\n    }\n    delete leavesData.source.wasm;\n    fs.writeFileSync(leavesInterfacePath, JSON.stringify(leavesData, null, 4));\n    console.log(`Extracted metadata for Leaves to ${ leavesInterfacePath }`)\n} else {\n    console.log(`No metadata found for Leaves at ${ leavesPath }`)\n}\nconst wildfirePath = path.join(contractsV1Dir, \"wildfire.contract.json\");\nconst wildfireInterfacePath = path.join(contractInterfacesV1Dir, \"wildfire.interface.json\");\nif(fs.existsSync(wildfirePath)) {\n    const wildfireData = JSON.parse(\n        fs.readFileSync(wildfirePath, { encoding: 'utf-8' })\n    );\n    if(!wildfireData.source) {\n        console.log(`No source found for Wildfire at ${ wildfirePath }`)\n        return;\n    }\n    delete wildfireData.source.wasm;\n    fs.writeFileSync(wildfireInterfacePath, JSON.stringify(wildfireData, null, 4));\n    console.log(`Extracted metadata for Wildfire to ${ wildfireInterfacePath }`)\n} else {\n    console.log(`No metadata found for Wildfire at ${ wildfirePath }`)\n}\nconst junglePath = path.join(contractsV1Dir, \"jungle.contract.json\");\nconst jungleInterfacePath = path.join(contractInterfacesV1Dir, \"jungle.interface.json\");\nif(fs.existsSync(junglePath)) {\n    const jungleData = JSON.parse(\n        fs.readFileSync(junglePath, { encoding: 'utf-8' })\n    );\n    if(!jungleData.source) {\n        console.log(`No source found for Jungle at ${ junglePath }`)\n        return;\n    }\n    delete jungleData.source.wasm;\n    fs.writeFileSync(jungleInterfacePath, JSON.stringify(jungleData, null, 4));\n    console.log(`Extracted metadata for Jungle to ${ jungleInterfacePath }`)\n} else {\n    console.log(`No metadata found for Jungle at ${ junglePath }`)\n}\nconst frostedGlassPath = path.join(contractsV1Dir, \"frosted_glass.contract.json\");\nconst frostedGlassInterfacePath = path.join(contractInterfacesV1Dir, \"frosted_glass.interface.json\");\nif(fs.existsSync(frostedGlassPath)) {\n    const frostedGlassData = JSON.parse(\n        fs.readFileSync(frostedGlassPath, { encoding: 'utf-8' })\n    );\n    if(!frostedGlassData.source) {\n        console.log(`No source found for FrostedGlass at ${ frostedGlassPath }`)\n        return;\n    }\n    delete frostedGlassData.source.wasm;\n    fs.writeFileSync(frostedGlassInterfacePath, JSON.stringify(frostedGlassData, null, 4));\n    console.log(`Extracted metadata for FrostedGlass to ${ frostedGlassInterfacePath }`)\n} else {\n    console.log(`No metadata found for FrostedGlass at ${ frostedGlassPath }`)\n}\nconst crystalPath = path.join(contractsV1Dir, \"crystal.contract.json\");\nconst crystalInterfacePath = path.join(contractInterfacesV1Dir, \"crystal.interface.json\");\nif(fs.existsSync(crystalPath)) {\n    const crystalData = JSON.parse(\n        fs.readFileSync(crystalPath, { encoding: 'utf-8' })\n    );\n    if(!crystalData.source) {\n        console.log(`No source found for Crystal at ${ crystalPath }`)\n        return;\n    }\n    delete crystalData.source.wasm;\n    fs.writeFileSync(crystalInterfacePath, JSON.stringify(crystalData, null, 4));\n    console.log(`Extracted metadata for Crystal to ${ crystalInterfacePath }`)\n} else {\n    console.log(`No metadata found for Crystal at ${ crystalPath }`)\n}\nconst magmaPath = path.join(contractsV1Dir, \"magma.contract.json\");\nconst magmaInterfacePath = path.join(contractInterfacesV1Dir, \"magma.interface.json\");\nif(fs.existsSync(magmaPath)) {\n    const magmaData = JSON.parse(\n        fs.readFileSync(magmaPath, { encoding: 'utf-8' })\n    );\n    if(!magmaData.source) {\n        console.log(`No source found for Magma at ${ magmaPath }`)\n        return;\n    }\n    delete magmaData.source.wasm;\n    fs.writeFileSync(magmaInterfacePath, JSON.stringify(magmaData, null, 4));\n    console.log(`Extracted metadata for Magma to ${ magmaInterfacePath }`)\n} else {\n    console.log(`No metadata found for Magma at ${ magmaPath }`)\n}\nconst rockPath = path.join(contractsV1Dir, \"rock.contract.json\");\nconst rockInterfacePath = path.join(contractInterfacesV1Dir, \"rock.interface.json\");\nif(fs.existsSync(rockPath)) {\n    const rockData = JSON.parse(\n        fs.readFileSync(rockPath, { encoding: 'utf-8' })\n    );\n    if(!rockData.source) {\n        console.log(`No source found for Rock at ${ rockPath }`)\n        return;\n    }\n    delete rockData.source.wasm;\n    fs.writeFileSync(rockInterfacePath, JSON.stringify(rockData, null, 4));\n    console.log(`Extracted metadata for Rock to ${ rockInterfacePath }`)\n} else {\n    console.log(`No metadata found for Rock at ${ rockPath }`)\n}\nconst shardPath = path.join(contractsV1Dir, \"shard.contract.json\");\nconst shardInterfacePath = path.join(contractInterfacesV1Dir, \"shard.interface.json\");\nif(fs.existsSync(shardPath)) {\n    const shardData = JSON.parse(\n        fs.readFileSync(shardPath, { encoding: 'utf-8' })\n    );\n    if(!shardData.source) {\n        console.log(`No source found for Shard at ${ shardPath }`)\n        return;\n    }\n    delete shardData.source.wasm;\n    fs.writeFileSync(shardInterfacePath, JSON.stringify(shardData, null, 4));\n    console.log(`Extracted metadata for Shard to ${ shardInterfacePath }`)\n} else {\n    console.log(`No metadata found for Shard at ${ shardPath }`)\n}\nconst pebblePath = path.join(contractsV1Dir, \"pebble.contract.json\");\nconst pebbleInterfacePath = path.join(contractInterfacesV1Dir, \"pebble.interface.json\");\nif(fs.existsSync(pebblePath)) {\n    const pebbleData = JSON.parse(\n        fs.readFileSync(pebblePath, { encoding: 'utf-8' })\n    );\n    if(!pebbleData.source) {\n        console.log(`No source found for Pebble at ${ pebblePath }`)\n        return;\n    }\n    delete pebbleData.source.wasm;\n    fs.writeFileSync(pebbleInterfacePath, JSON.stringify(pebbleData, null, 4));\n    console.log(`Extracted metadata for Pebble to ${ pebbleInterfacePath }`)\n} else {\n    console.log(`No metadata found for Pebble at ${ pebblePath }`)\n}\nconst mountainPath = path.join(contractsV1Dir, \"mountain.contract.json\");\nconst mountainInterfacePath = path.join(contractInterfacesV1Dir, \"mountain.interface.json\");\nif(fs.existsSync(mountainPath)) {\n    const mountainData = JSON.parse(\n        fs.readFileSync(mountainPath, { encoding: 'utf-8' })\n    );\n    if(!mountainData.source) {\n        console.log(`No source found for Mountain at ${ mountainPath }`)\n        return;\n    }\n    delete mountainData.source.wasm;\n    fs.writeFileSync(mountainInterfacePath, JSON.stringify(mountainData, null, 4));\n    console.log(`Extracted metadata for Mountain to ${ mountainInterfacePath }`)\n} else {\n    console.log(`No metadata found for Mountain at ${ mountainPath }`)\n}\nconst fertilizerPath = path.join(contractsV1Dir, \"fertilizer.contract.json\");\nconst fertilizerInterfacePath = path.join(contractInterfacesV1Dir, \"fertilizer.interface.json\");\nif(fs.existsSync(fertilizerPath)) {\n    const fertilizerData = JSON.parse(\n        fs.readFileSync(fertilizerPath, { encoding: 'utf-8' })\n    );\n    if(!fertilizerData.source) {\n        console.log(`No source found for Fertilizer at ${ fertilizerPath }`)\n        return;\n    }\n    delete fertilizerData.source.wasm;\n    fs.writeFileSync(fertilizerInterfacePath, JSON.stringify(fertilizerData, null, 4));\n    console.log(`Extracted metadata for Fertilizer to ${ fertilizerInterfacePath }`)\n} else {\n    console.log(`No metadata found for Fertilizer at ${ fertilizerPath }`)\n}\nconst sootPath = path.join(contractsV1Dir, \"soot.contract.json\");\nconst sootInterfacePath = path.join(contractInterfacesV1Dir, \"soot.interface.json\");\nif(fs.existsSync(sootPath)) {\n    const sootData = JSON.parse(\n        fs.readFileSync(sootPath, { encoding: 'utf-8' })\n    );\n    if(!sootData.source) {\n        console.log(`No source found for Soot at ${ sootPath }`)\n        return;\n    }\n    delete sootData.source.wasm;\n    fs.writeFileSync(sootInterfacePath, JSON.stringify(sootData, null, 4));\n    console.log(`Extracted metadata for Soot to ${ sootInterfacePath }`)\n} else {\n    console.log(`No metadata found for Soot at ${ sootPath }`)\n}\nconst lightningPath = path.join(contractsV1Dir, \"lightning.contract.json\");\nconst lightningInterfacePath = path.join(contractInterfacesV1Dir, \"lightning.interface.json\");\nif(fs.existsSync(lightningPath)) {\n    const lightningData = JSON.parse(\n        fs.readFileSync(lightningPath, { encoding: 'utf-8' })\n    );\n    if(!lightningData.source) {\n        console.log(`No source found for Lightning at ${ lightningPath }`)\n        return;\n    }\n    delete lightningData.source.wasm;\n    fs.writeFileSync(lightningInterfacePath, JSON.stringify(lightningData, null, 4));\n    console.log(`Extracted metadata for Lightning to ${ lightningInterfacePath }`)\n} else {\n    console.log(`No metadata found for Lightning at ${ lightningPath }`)\n}\nconst mistPath = path.join(contractsV1Dir, \"mist.contract.json\");\nconst mistInterfacePath = path.join(contractInterfacesV1Dir, \"mist.interface.json\");\nif(fs.existsSync(mistPath)) {\n    const mistData = JSON.parse(\n        fs.readFileSync(mistPath, { encoding: 'utf-8' })\n    );\n    if(!mistData.source) {\n        console.log(`No source found for Mist at ${ mistPath }`)\n        return;\n    }\n    delete mistData.source.wasm;\n    fs.writeFileSync(mistInterfacePath, JSON.stringify(mistData, null, 4));\n    console.log(`Extracted metadata for Mist to ${ mistInterfacePath }`)\n} else {\n    console.log(`No metadata found for Mist at ${ mistPath }`)\n}\nconst hazePath = path.join(contractsV1Dir, \"haze.contract.json\");\nconst hazeInterfacePath = path.join(contractInterfacesV1Dir, \"haze.interface.json\");\nif(fs.existsSync(hazePath)) {\n    const hazeData = JSON.parse(\n        fs.readFileSync(hazePath, { encoding: 'utf-8' })\n    );\n    if(!hazeData.source) {\n        console.log(`No source found for Haze at ${ hazePath }`)\n        return;\n    }\n    delete hazeData.source.wasm;\n    fs.writeFileSync(hazeInterfacePath, JSON.stringify(hazeData, null, 4));\n    console.log(`Extracted metadata for Haze to ${ hazeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Haze at ${ hazePath }`)\n}\nconst floodPath = path.join(contractsV1Dir, \"flood.contract.json\");\nconst floodInterfacePath = path.join(contractInterfacesV1Dir, \"flood.interface.json\");\nif(fs.existsSync(floodPath)) {\n    const floodData = JSON.parse(\n        fs.readFileSync(floodPath, { encoding: 'utf-8' })\n    );\n    if(!floodData.source) {\n        console.log(`No source found for Flood at ${ floodPath }`)\n        return;\n    }\n    delete floodData.source.wasm;\n    fs.writeFileSync(floodInterfacePath, JSON.stringify(floodData, null, 4));\n    console.log(`Extracted metadata for Flood to ${ floodInterfacePath }`)\n} else {\n    console.log(`No metadata found for Flood at ${ floodPath }`)\n}\nconst landslidePath = path.join(contractsV1Dir, \"landslide.contract.json\");\nconst landslideInterfacePath = path.join(contractInterfacesV1Dir, \"landslide.interface.json\");\nif(fs.existsSync(landslidePath)) {\n    const landslideData = JSON.parse(\n        fs.readFileSync(landslidePath, { encoding: 'utf-8' })\n    );\n    if(!landslideData.source) {\n        console.log(`No source found for Landslide at ${ landslidePath }`)\n        return;\n    }\n    delete landslideData.source.wasm;\n    fs.writeFileSync(landslideInterfacePath, JSON.stringify(landslideData, null, 4));\n    console.log(`Extracted metadata for Landslide to ${ landslideInterfacePath }`)\n} else {\n    console.log(`No metadata found for Landslide at ${ landslidePath }`)\n}\nconst thunderPath = path.join(contractsV1Dir, \"thunder.contract.json\");\nconst thunderInterfacePath = path.join(contractInterfacesV1Dir, \"thunder.interface.json\");\nif(fs.existsSync(thunderPath)) {\n    const thunderData = JSON.parse(\n        fs.readFileSync(thunderPath, { encoding: 'utf-8' })\n    );\n    if(!thunderData.source) {\n        console.log(`No source found for Thunder at ${ thunderPath }`)\n        return;\n    }\n    delete thunderData.source.wasm;\n    fs.writeFileSync(thunderInterfacePath, JSON.stringify(thunderData, null, 4));\n    console.log(`Extracted metadata for Thunder to ${ thunderInterfacePath }`)\n} else {\n    console.log(`No metadata found for Thunder at ${ thunderPath }`)\n}\nconst tornadoPath = path.join(contractsV1Dir, \"tornado.contract.json\");\nconst tornadoInterfacePath = path.join(contractInterfacesV1Dir, \"tornado.interface.json\");\nif(fs.existsSync(tornadoPath)) {\n    const tornadoData = JSON.parse(\n        fs.readFileSync(tornadoPath, { encoding: 'utf-8' })\n    );\n    if(!tornadoData.source) {\n        console.log(`No source found for Tornado at ${ tornadoPath }`)\n        return;\n    }\n    delete tornadoData.source.wasm;\n    fs.writeFileSync(tornadoInterfacePath, JSON.stringify(tornadoData, null, 4));\n    console.log(`Extracted metadata for Tornado to ${ tornadoInterfacePath }`)\n} else {\n    console.log(`No metadata found for Tornado at ${ tornadoPath }`)\n}\nconst gardenPath = path.join(contractsV1Dir, \"garden.contract.json\");\nconst gardenInterfacePath = path.join(contractInterfacesV1Dir, \"garden.interface.json\");\nif(fs.existsSync(gardenPath)) {\n    const gardenData = JSON.parse(\n        fs.readFileSync(gardenPath, { encoding: 'utf-8' })\n    );\n    if(!gardenData.source) {\n        console.log(`No source found for Garden at ${ gardenPath }`)\n        return;\n    }\n    delete gardenData.source.wasm;\n    fs.writeFileSync(gardenInterfacePath, JSON.stringify(gardenData, null, 4));\n    console.log(`Extracted metadata for Garden to ${ gardenInterfacePath }`)\n} else {\n    console.log(`No metadata found for Garden at ${ gardenPath }`)\n}\nconst emberPath = path.join(contractsV1Dir, \"ember.contract.json\");\nconst emberInterfacePath = path.join(contractInterfacesV1Dir, \"ember.interface.json\");\nif(fs.existsSync(emberPath)) {\n    const emberData = JSON.parse(\n        fs.readFileSync(emberPath, { encoding: 'utf-8' })\n    );\n    if(!emberData.source) {\n        console.log(`No source found for Ember at ${ emberPath }`)\n        return;\n    }\n    delete emberData.source.wasm;\n    fs.writeFileSync(emberInterfacePath, JSON.stringify(emberData, null, 4));\n    console.log(`Extracted metadata for Ember to ${ emberInterfacePath }`)\n} else {\n    console.log(`No metadata found for Ember at ${ emberPath }`)\n}\nconst kilnPath = path.join(contractsV1Dir, \"kiln.contract.json\");\nconst kilnInterfacePath = path.join(contractInterfacesV1Dir, \"kiln.interface.json\");\nif(fs.existsSync(kilnPath)) {\n    const kilnData = JSON.parse(\n        fs.readFileSync(kilnPath, { encoding: 'utf-8' })\n    );\n    if(!kilnData.source) {\n        console.log(`No source found for Kiln at ${ kilnPath }`)\n        return;\n    }\n    delete kilnData.source.wasm;\n    fs.writeFileSync(kilnInterfacePath, JSON.stringify(kilnData, null, 4));\n    console.log(`Extracted metadata for Kiln to ${ kilnInterfacePath }`)\n} else {\n    console.log(`No metadata found for Kiln at ${ kilnPath }`)\n}\nconst pollinationPath = path.join(contractsV1Dir, \"pollination.contract.json\");\nconst pollinationInterfacePath = path.join(contractInterfacesV1Dir, \"pollination.interface.json\");\nif(fs.existsSync(pollinationPath)) {\n    const pollinationData = JSON.parse(\n        fs.readFileSync(pollinationPath, { encoding: 'utf-8' })\n    );\n    if(!pollinationData.source) {\n        console.log(`No source found for Pollination at ${ pollinationPath }`)\n        return;\n    }\n    delete pollinationData.source.wasm;\n    fs.writeFileSync(pollinationInterfacePath, JSON.stringify(pollinationData, null, 4));\n    console.log(`Extracted metadata for Pollination to ${ pollinationInterfacePath }`)\n} else {\n    console.log(`No metadata found for Pollination at ${ pollinationPath }`)\n}\nconst sinkholePath = path.join(contractsV1Dir, \"sinkhole.contract.json\");\nconst sinkholeInterfacePath = path.join(contractInterfacesV1Dir, \"sinkhole.interface.json\");\nif(fs.existsSync(sinkholePath)) {\n    const sinkholeData = JSON.parse(\n        fs.readFileSync(sinkholePath, { encoding: 'utf-8' })\n    );\n    if(!sinkholeData.source) {\n        console.log(`No source found for Sinkhole at ${ sinkholePath }`)\n        return;\n    }\n    delete sinkholeData.source.wasm;\n    fs.writeFileSync(sinkholeInterfacePath, JSON.stringify(sinkholeData, null, 4));\n    console.log(`Extracted metadata for Sinkhole to ${ sinkholeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Sinkhole at ${ sinkholePath }`)\n}\nconst beachPath = path.join(contractsV1Dir, \"beach.contract.json\");\nconst beachInterfacePath = path.join(contractInterfacesV1Dir, \"beach.interface.json\");\nif(fs.existsSync(beachPath)) {\n    const beachData = JSON.parse(\n        fs.readFileSync(beachPath, { encoding: 'utf-8' })\n    );\n    if(!beachData.source) {\n        console.log(`No source found for Beach at ${ beachPath }`)\n        return;\n    }\n    delete beachData.source.wasm;\n    fs.writeFileSync(beachInterfacePath, JSON.stringify(beachData, null, 4));\n    console.log(`Extracted metadata for Beach to ${ beachInterfacePath }`)\n} else {\n    console.log(`No metadata found for Beach at ${ beachPath }`)\n}\nconst wetstonePath = path.join(contractsV1Dir, \"wetstone.contract.json\");\nconst wetstoneInterfacePath = path.join(contractInterfacesV1Dir, \"wetstone.interface.json\");\nif(fs.existsSync(wetstonePath)) {\n    const wetstoneData = JSON.parse(\n        fs.readFileSync(wetstonePath, { encoding: 'utf-8' })\n    );\n    if(!wetstoneData.source) {\n        console.log(`No source found for Wetstone at ${ wetstonePath }`)\n        return;\n    }\n    delete wetstoneData.source.wasm;\n    fs.writeFileSync(wetstoneInterfacePath, JSON.stringify(wetstoneData, null, 4));\n    console.log(`Extracted metadata for Wetstone to ${ wetstoneInterfacePath }`)\n} else {\n    console.log(`No metadata found for Wetstone at ${ wetstonePath }`)\n}\nconst erosionPath = path.join(contractsV1Dir, \"erosion.contract.json\");\nconst erosionInterfacePath = path.join(contractInterfacesV1Dir, \"erosion.interface.json\");\nif(fs.existsSync(erosionPath)) {\n    const erosionData = JSON.parse(\n        fs.readFileSync(erosionPath, { encoding: 'utf-8' })\n    );\n    if(!erosionData.source) {\n        console.log(`No source found for Erosion at ${ erosionPath }`)\n        return;\n    }\n    delete erosionData.source.wasm;\n    fs.writeFileSync(erosionInterfacePath, JSON.stringify(erosionData, null, 4));\n    console.log(`Extracted metadata for Erosion to ${ erosionInterfacePath }`)\n} else {\n    console.log(`No metadata found for Erosion at ${ erosionPath }`)\n}\nconst basaltPath = path.join(contractsV1Dir, \"basalt.contract.json\");\nconst basaltInterfacePath = path.join(contractInterfacesV1Dir, \"basalt.interface.json\");\nif(fs.existsSync(basaltPath)) {\n    const basaltData = JSON.parse(\n        fs.readFileSync(basaltPath, { encoding: 'utf-8' })\n    );\n    if(!basaltData.source) {\n        console.log(`No source found for Basalt at ${ basaltPath }`)\n        return;\n    }\n    delete basaltData.source.wasm;\n    fs.writeFileSync(basaltInterfacePath, JSON.stringify(basaltData, null, 4));\n    console.log(`Extracted metadata for Basalt to ${ basaltInterfacePath }`)\n} else {\n    console.log(`No metadata found for Basalt at ${ basaltPath }`)\n}\nconst magmaChamberPath = path.join(contractsV1Dir, \"magma_chamber.contract.json\");\nconst magmaChamberInterfacePath = path.join(contractInterfacesV1Dir, \"magma_chamber.interface.json\");\nif(fs.existsSync(magmaChamberPath)) {\n    const magmaChamberData = JSON.parse(\n        fs.readFileSync(magmaChamberPath, { encoding: 'utf-8' })\n    );\n    if(!magmaChamberData.source) {\n        console.log(`No source found for MagmaChamber at ${ magmaChamberPath }`)\n        return;\n    }\n    delete magmaChamberData.source.wasm;\n    fs.writeFileSync(magmaChamberInterfacePath, JSON.stringify(magmaChamberData, null, 4));\n    console.log(`Extracted metadata for MagmaChamber to ${ magmaChamberInterfacePath }`)\n} else {\n    console.log(`No metadata found for MagmaChamber at ${ magmaChamberPath }`)\n}\nconst breezePath = path.join(contractsV1Dir, \"breeze.contract.json\");\nconst breezeInterfacePath = path.join(contractInterfacesV1Dir, \"breeze.interface.json\");\nif(fs.existsSync(breezePath)) {\n    const breezeData = JSON.parse(\n        fs.readFileSync(breezePath, { encoding: 'utf-8' })\n    );\n    if(!breezeData.source) {\n        console.log(`No source found for Breeze at ${ breezePath }`)\n        return;\n    }\n    delete breezeData.source.wasm;\n    fs.writeFileSync(breezeInterfacePath, JSON.stringify(breezeData, null, 4));\n    console.log(`Extracted metadata for Breeze to ${ breezeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Breeze at ${ breezePath }`)\n}\nconst warmBreezePath = path.join(contractsV1Dir, \"warm_breeze.contract.json\");\nconst warmBreezeInterfacePath = path.join(contractInterfacesV1Dir, \"warm_breeze.interface.json\");\nif(fs.existsSync(warmBreezePath)) {\n    const warmBreezeData = JSON.parse(\n        fs.readFileSync(warmBreezePath, { encoding: 'utf-8' })\n    );\n    if(!warmBreezeData.source) {\n        console.log(`No source found for WarmBreeze at ${ warmBreezePath }`)\n        return;\n    }\n    delete warmBreezeData.source.wasm;\n    fs.writeFileSync(warmBreezeInterfacePath, JSON.stringify(warmBreezeData, null, 4));\n    console.log(`Extracted metadata for WarmBreeze to ${ warmBreezeInterfacePath }`)\n} else {\n    console.log(`No metadata found for WarmBreeze at ${ warmBreezePath }`)\n}\nconst soilPath = path.join(contractsV1Dir, \"soil.contract.json\");\nconst soilInterfacePath = path.join(contractInterfacesV1Dir, \"soil.interface.json\");\nif(fs.existsSync(soilPath)) {\n    const soilData = JSON.parse(\n        fs.readFileSync(soilPath, { encoding: 'utf-8' })\n    );\n    if(!soilData.source) {\n        console.log(`No source found for Soil at ${ soilPath }`)\n        return;\n    }\n    delete soilData.source.wasm;\n    fs.writeFileSync(soilInterfacePath, JSON.stringify(soilData, null, 4));\n    console.log(`Extracted metadata for Soil to ${ soilInterfacePath }`)\n} else {\n    console.log(`No metadata found for Soil at ${ soilPath }`)\n}\nconst canyonPath = path.join(contractsV1Dir, \"canyon.contract.json\");\nconst canyonInterfacePath = path.join(contractInterfacesV1Dir, \"canyon.interface.json\");\nif(fs.existsSync(canyonPath)) {\n    const canyonData = JSON.parse(\n        fs.readFileSync(canyonPath, { encoding: 'utf-8' })\n    );\n    if(!canyonData.source) {\n        console.log(`No source found for Canyon at ${ canyonPath }`)\n        return;\n    }\n    delete canyonData.source.wasm;\n    fs.writeFileSync(canyonInterfacePath, JSON.stringify(canyonData, null, 4));\n    console.log(`Extracted metadata for Canyon to ${ canyonInterfacePath }`)\n} else {\n    console.log(`No metadata found for Canyon at ${ canyonPath }`)\n}\nconst windmillPath = path.join(contractsV1Dir, \"windmill.contract.json\");\nconst windmillInterfacePath = path.join(contractInterfacesV1Dir, \"windmill.interface.json\");\nif(fs.existsSync(windmillPath)) {\n    const windmillData = JSON.parse(\n        fs.readFileSync(windmillPath, { encoding: 'utf-8' })\n    );\n    if(!windmillData.source) {\n        console.log(`No source found for Windmill at ${ windmillPath }`)\n        return;\n    }\n    delete windmillData.source.wasm;\n    fs.writeFileSync(windmillInterfacePath, JSON.stringify(windmillData, null, 4));\n    console.log(`Extracted metadata for Windmill to ${ windmillInterfacePath }`)\n} else {\n    console.log(`No metadata found for Windmill at ${ windmillPath }`)\n}\nconst adobePath = path.join(contractsV1Dir, \"adobe.contract.json\");\nconst adobeInterfacePath = path.join(contractInterfacesV1Dir, \"adobe.interface.json\");\nif(fs.existsSync(adobePath)) {\n    const adobeData = JSON.parse(\n        fs.readFileSync(adobePath, { encoding: 'utf-8' })\n    );\n    if(!adobeData.source) {\n        console.log(`No source found for Adobe at ${ adobePath }`)\n        return;\n    }\n    delete adobeData.source.wasm;\n    fs.writeFileSync(adobeInterfacePath, JSON.stringify(adobeData, null, 4));\n    console.log(`Extracted metadata for Adobe to ${ adobeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Adobe at ${ adobePath }`)\n}\nconst wallPath = path.join(contractsV1Dir, \"wall.contract.json\");\nconst wallInterfacePath = path.join(contractInterfacesV1Dir, \"wall.interface.json\");\nif(fs.existsSync(wallPath)) {\n    const wallData = JSON.parse(\n        fs.readFileSync(wallPath, { encoding: 'utf-8' })\n    );\n    if(!wallData.source) {\n        console.log(`No source found for Wall at ${ wallPath }`)\n        return;\n    }\n    delete wallData.source.wasm;\n    fs.writeFileSync(wallInterfacePath, JSON.stringify(wallData, null, 4));\n    console.log(`Extracted metadata for Wall to ${ wallInterfacePath }`)\n} else {\n    console.log(`No metadata found for Wall at ${ wallPath }`)\n}\nconst pumicePath = path.join(contractsV1Dir, \"pumice.contract.json\");\nconst pumiceInterfacePath = path.join(contractInterfacesV1Dir, \"pumice.interface.json\");\nif(fs.existsSync(pumicePath)) {\n    const pumiceData = JSON.parse(\n        fs.readFileSync(pumicePath, { encoding: 'utf-8' })\n    );\n    if(!pumiceData.source) {\n        console.log(`No source found for Pumice at ${ pumicePath }`)\n        return;\n    }\n    delete pumiceData.source.wasm;\n    fs.writeFileSync(pumiceInterfacePath, JSON.stringify(pumiceData, null, 4));\n    console.log(`Extracted metadata for Pumice to ${ pumiceInterfacePath }`)\n} else {\n    console.log(`No metadata found for Pumice at ${ pumicePath }`)\n}\nconst barbecuePath = path.join(contractsV1Dir, \"barbecue.contract.json\");\nconst barbecueInterfacePath = path.join(contractInterfacesV1Dir, \"barbecue.interface.json\");\nif(fs.existsSync(barbecuePath)) {\n    const barbecueData = JSON.parse(\n        fs.readFileSync(barbecuePath, { encoding: 'utf-8' })\n    );\n    if(!barbecueData.source) {\n        console.log(`No source found for Barbecue at ${ barbecuePath }`)\n        return;\n    }\n    delete barbecueData.source.wasm;\n    fs.writeFileSync(barbecueInterfacePath, JSON.stringify(barbecueData, null, 4));\n    console.log(`Extracted metadata for Barbecue to ${ barbecueInterfacePath }`)\n} else {\n    console.log(`No metadata found for Barbecue at ${ barbecuePath }`)\n}\nconst farmPath = path.join(contractsV1Dir, \"farm.contract.json\");\nconst farmInterfacePath = path.join(contractInterfacesV1Dir, \"farm.interface.json\");\nif(fs.existsSync(farmPath)) {\n    const farmData = JSON.parse(\n        fs.readFileSync(farmPath, { encoding: 'utf-8' })\n    );\n    if(!farmData.source) {\n        console.log(`No source found for Farm at ${ farmPath }`)\n        return;\n    }\n    delete farmData.source.wasm;\n    fs.writeFileSync(farmInterfacePath, JSON.stringify(farmData, null, 4));\n    console.log(`Extracted metadata for Farm to ${ farmInterfacePath }`)\n} else {\n    console.log(`No metadata found for Farm at ${ farmPath }`)\n}\nconst shardsPath = path.join(contractsV1Dir, \"shards.contract.json\");\nconst shardsInterfacePath = path.join(contractInterfacesV1Dir, \"shards.interface.json\");\nif(fs.existsSync(shardsPath)) {\n    const shardsData = JSON.parse(\n        fs.readFileSync(shardsPath, { encoding: 'utf-8' })\n    );\n    if(!shardsData.source) {\n        console.log(`No source found for Shards at ${ shardsPath }`)\n        return;\n    }\n    delete shardsData.source.wasm;\n    fs.writeFileSync(shardsInterfacePath, JSON.stringify(shardsData, null, 4));\n    console.log(`Extracted metadata for Shards to ${ shardsInterfacePath }`)\n} else {\n    console.log(`No metadata found for Shards at ${ shardsPath }`)\n}\nconst moltenGlassPath = path.join(contractsV1Dir, \"molten_glass.contract.json\");\nconst moltenGlassInterfacePath = path.join(contractInterfacesV1Dir, \"molten_glass.interface.json\");\nif(fs.existsSync(moltenGlassPath)) {\n    const moltenGlassData = JSON.parse(\n        fs.readFileSync(moltenGlassPath, { encoding: 'utf-8' })\n    );\n    if(!moltenGlassData.source) {\n        console.log(`No source found for MoltenGlass at ${ moltenGlassPath }`)\n        return;\n    }\n    delete moltenGlassData.source.wasm;\n    fs.writeFileSync(moltenGlassInterfacePath, JSON.stringify(moltenGlassData, null, 4));\n    console.log(`Extracted metadata for MoltenGlass to ${ moltenGlassInterfacePath }`)\n} else {\n    console.log(`No metadata found for MoltenGlass at ${ moltenGlassPath }`)\n}\nconst prismPath = path.join(contractsV1Dir, \"prism.contract.json\");\nconst prismInterfacePath = path.join(contractInterfacesV1Dir, \"prism.interface.json\");\nif(fs.existsSync(prismPath)) {\n    const prismData = JSON.parse(\n        fs.readFileSync(prismPath, { encoding: 'utf-8' })\n    );\n    if(!prismData.source) {\n        console.log(`No source found for Prism at ${ prismPath }`)\n        return;\n    }\n    delete prismData.source.wasm;\n    fs.writeFileSync(prismInterfacePath, JSON.stringify(prismData, null, 4));\n    console.log(`Extracted metadata for Prism to ${ prismInterfacePath }`)\n} else {\n    console.log(`No metadata found for Prism at ${ prismPath }`)\n}\nconst sparklePath = path.join(contractsV1Dir, \"sparkle.contract.json\");\nconst sparkleInterfacePath = path.join(contractInterfacesV1Dir, \"sparkle.interface.json\");\nif(fs.existsSync(sparklePath)) {\n    const sparkleData = JSON.parse(\n        fs.readFileSync(sparklePath, { encoding: 'utf-8' })\n    );\n    if(!sparkleData.source) {\n        console.log(`No source found for Sparkle at ${ sparklePath }`)\n        return;\n    }\n    delete sparkleData.source.wasm;\n    fs.writeFileSync(sparkleInterfacePath, JSON.stringify(sparkleData, null, 4));\n    console.log(`Extracted metadata for Sparkle to ${ sparkleInterfacePath }`)\n} else {\n    console.log(`No metadata found for Sparkle at ${ sparklePath }`)\n}\nconst desertPath = path.join(contractsV1Dir, \"desert.contract.json\");\nconst desertInterfacePath = path.join(contractInterfacesV1Dir, \"desert.interface.json\");\nif(fs.existsSync(desertPath)) {\n    const desertData = JSON.parse(\n        fs.readFileSync(desertPath, { encoding: 'utf-8' })\n    );\n    if(!desertData.source) {\n        console.log(`No source found for Desert at ${ desertPath }`)\n        return;\n    }\n    delete desertData.source.wasm;\n    fs.writeFileSync(desertInterfacePath, JSON.stringify(desertData, null, 4));\n    console.log(`Extracted metadata for Desert to ${ desertInterfacePath }`)\n} else {\n    console.log(`No metadata found for Desert at ${ desertPath }`)\n}\nconst oasisPath = path.join(contractsV1Dir, \"oasis.contract.json\");\nconst oasisInterfacePath = path.join(contractInterfacesV1Dir, \"oasis.interface.json\");\nif(fs.existsSync(oasisPath)) {\n    const oasisData = JSON.parse(\n        fs.readFileSync(oasisPath, { encoding: 'utf-8' })\n    );\n    if(!oasisData.source) {\n        console.log(`No source found for Oasis at ${ oasisPath }`)\n        return;\n    }\n    delete oasisData.source.wasm;\n    fs.writeFileSync(oasisInterfacePath, JSON.stringify(oasisData, null, 4));\n    console.log(`Extracted metadata for Oasis to ${ oasisInterfacePath }`)\n} else {\n    console.log(`No metadata found for Oasis at ${ oasisPath }`)\n}\nconst miragePath = path.join(contractsV1Dir, \"mirage.contract.json\");\nconst mirageInterfacePath = path.join(contractInterfacesV1Dir, \"mirage.interface.json\");\nif(fs.existsSync(miragePath)) {\n    const mirageData = JSON.parse(\n        fs.readFileSync(miragePath, { encoding: 'utf-8' })\n    );\n    if(!mirageData.source) {\n        console.log(`No source found for Mirage at ${ miragePath }`)\n        return;\n    }\n    delete mirageData.source.wasm;\n    fs.writeFileSync(mirageInterfacePath, JSON.stringify(mirageData, null, 4));\n    console.log(`Extracted metadata for Mirage to ${ mirageInterfacePath }`)\n} else {\n    console.log(`No metadata found for Mirage at ${ miragePath }`)\n}\nconst sandDunePath = path.join(contractsV1Dir, \"sand_dune.contract.json\");\nconst sandDuneInterfacePath = path.join(contractInterfacesV1Dir, \"sand_dune.interface.json\");\nif(fs.existsSync(sandDunePath)) {\n    const sandDuneData = JSON.parse(\n        fs.readFileSync(sandDunePath, { encoding: 'utf-8' })\n    );\n    if(!sandDuneData.source) {\n        console.log(`No source found for SandDune at ${ sandDunePath }`)\n        return;\n    }\n    delete sandDuneData.source.wasm;\n    fs.writeFileSync(sandDuneInterfacePath, JSON.stringify(sandDuneData, null, 4));\n    console.log(`Extracted metadata for SandDune to ${ sandDuneInterfacePath }`)\n} else {\n    console.log(`No metadata found for SandDune at ${ sandDunePath }`)\n}\nconst damPath = path.join(contractsV1Dir, \"dam.contract.json\");\nconst damInterfacePath = path.join(contractInterfacesV1Dir, \"dam.interface.json\");\nif(fs.existsSync(damPath)) {\n    const damData = JSON.parse(\n        fs.readFileSync(damPath, { encoding: 'utf-8' })\n    );\n    if(!damData.source) {\n        console.log(`No source found for Dam at ${ damPath }`)\n        return;\n    }\n    delete damData.source.wasm;\n    fs.writeFileSync(damInterfacePath, JSON.stringify(damData, null, 4));\n    console.log(`Extracted metadata for Dam to ${ damInterfacePath }`)\n} else {\n    console.log(`No metadata found for Dam at ${ damPath }`)\n}\nconst firewallPath = path.join(contractsV1Dir, \"firewall.contract.json\");\nconst firewallInterfacePath = path.join(contractInterfacesV1Dir, \"firewall.interface.json\");\nif(fs.existsSync(firewallPath)) {\n    const firewallData = JSON.parse(\n        fs.readFileSync(firewallPath, { encoding: 'utf-8' })\n    );\n    if(!firewallData.source) {\n        console.log(`No source found for Firewall at ${ firewallPath }`)\n        return;\n    }\n    delete firewallData.source.wasm;\n    fs.writeFileSync(firewallInterfacePath, JSON.stringify(firewallData, null, 4));\n    console.log(`Extracted metadata for Firewall to ${ firewallInterfacePath }`)\n} else {\n    console.log(`No metadata found for Firewall at ${ firewallPath }`)\n}\nconst barricadePath = path.join(contractsV1Dir, \"barricade.contract.json\");\nconst barricadeInterfacePath = path.join(contractInterfacesV1Dir, \"barricade.interface.json\");\nif(fs.existsSync(barricadePath)) {\n    const barricadeData = JSON.parse(\n        fs.readFileSync(barricadePath, { encoding: 'utf-8' })\n    );\n    if(!barricadeData.source) {\n        console.log(`No source found for Barricade at ${ barricadePath }`)\n        return;\n    }\n    delete barricadeData.source.wasm;\n    fs.writeFileSync(barricadeInterfacePath, JSON.stringify(barricadeData, null, 4));\n    console.log(`Extracted metadata for Barricade to ${ barricadeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Barricade at ${ barricadePath }`)\n}\nconst plateauPath = path.join(contractsV1Dir, \"plateau.contract.json\");\nconst plateauInterfacePath = path.join(contractInterfacesV1Dir, \"plateau.interface.json\");\nif(fs.existsSync(plateauPath)) {\n    const plateauData = JSON.parse(\n        fs.readFileSync(plateauPath, { encoding: 'utf-8' })\n    );\n    if(!plateauData.source) {\n        console.log(`No source found for Plateau at ${ plateauPath }`)\n        return;\n    }\n    delete plateauData.source.wasm;\n    fs.writeFileSync(plateauInterfacePath, JSON.stringify(plateauData, null, 4));\n    console.log(`Extracted metadata for Plateau to ${ plateauInterfacePath }`)\n} else {\n    console.log(`No metadata found for Plateau at ${ plateauPath }`)\n}\nconst pondPath = path.join(contractsV1Dir, \"pond.contract.json\");\nconst pondInterfacePath = path.join(contractInterfacesV1Dir, \"pond.interface.json\");\nif(fs.existsSync(pondPath)) {\n    const pondData = JSON.parse(\n        fs.readFileSync(pondPath, { encoding: 'utf-8' })\n    );\n    if(!pondData.source) {\n        console.log(`No source found for Pond at ${ pondPath }`)\n        return;\n    }\n    delete pondData.source.wasm;\n    fs.writeFileSync(pondInterfacePath, JSON.stringify(pondData, null, 4));\n    console.log(`Extracted metadata for Pond to ${ pondInterfacePath }`)\n} else {\n    console.log(`No metadata found for Pond at ${ pondPath }`)\n}\nconst aromasPath = path.join(contractsV1Dir, \"aromas.contract.json\");\nconst aromasInterfacePath = path.join(contractInterfacesV1Dir, \"aromas.interface.json\");\nif(fs.existsSync(aromasPath)) {\n    const aromasData = JSON.parse(\n        fs.readFileSync(aromasPath, { encoding: 'utf-8' })\n    );\n    if(!aromasData.source) {\n        console.log(`No source found for Aromas at ${ aromasPath }`)\n        return;\n    }\n    delete aromasData.source.wasm;\n    fs.writeFileSync(aromasInterfacePath, JSON.stringify(aromasData, null, 4));\n    console.log(`Extracted metadata for Aromas to ${ aromasInterfacePath }`)\n} else {\n    console.log(`No metadata found for Aromas at ${ aromasPath }`)\n}\nconst flowerPath = path.join(contractsV1Dir, \"flower.contract.json\");\nconst flowerInterfacePath = path.join(contractInterfacesV1Dir, \"flower.interface.json\");\nif(fs.existsSync(flowerPath)) {\n    const flowerData = JSON.parse(\n        fs.readFileSync(flowerPath, { encoding: 'utf-8' })\n    );\n    if(!flowerData.source) {\n        console.log(`No source found for Flower at ${ flowerPath }`)\n        return;\n    }\n    delete flowerData.source.wasm;\n    fs.writeFileSync(flowerInterfacePath, JSON.stringify(flowerData, null, 4));\n    console.log(`Extracted metadata for Flower to ${ flowerInterfacePath }`)\n} else {\n    console.log(`No metadata found for Flower at ${ flowerPath }`)\n}\nconst sporePath = path.join(contractsV1Dir, \"spore.contract.json\");\nconst sporeInterfacePath = path.join(contractInterfacesV1Dir, \"spore.interface.json\");\nif(fs.existsSync(sporePath)) {\n    const sporeData = JSON.parse(\n        fs.readFileSync(sporePath, { encoding: 'utf-8' })\n    );\n    if(!sporeData.source) {\n        console.log(`No source found for Spore at ${ sporePath }`)\n        return;\n    }\n    delete sporeData.source.wasm;\n    fs.writeFileSync(sporeInterfacePath, JSON.stringify(sporeData, null, 4));\n    console.log(`Extracted metadata for Spore to ${ sporeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Spore at ${ sporePath }`)\n}\nconst spreadPath = path.join(contractsV1Dir, \"spread.contract.json\");\nconst spreadInterfacePath = path.join(contractInterfacesV1Dir, \"spread.interface.json\");\nif(fs.existsSync(spreadPath)) {\n    const spreadData = JSON.parse(\n        fs.readFileSync(spreadPath, { encoding: 'utf-8' })\n    );\n    if(!spreadData.source) {\n        console.log(`No source found for Spread at ${ spreadPath }`)\n        return;\n    }\n    delete spreadData.source.wasm;\n    fs.writeFileSync(spreadInterfacePath, JSON.stringify(spreadData, null, 4));\n    console.log(`Extracted metadata for Spread to ${ spreadInterfacePath }`)\n} else {\n    console.log(`No metadata found for Spread at ${ spreadPath }`)\n}\nconst fertileLandPath = path.join(contractsV1Dir, \"fertile_land.contract.json\");\nconst fertileLandInterfacePath = path.join(contractInterfacesV1Dir, \"fertile_land.interface.json\");\nif(fs.existsSync(fertileLandPath)) {\n    const fertileLandData = JSON.parse(\n        fs.readFileSync(fertileLandPath, { encoding: 'utf-8' })\n    );\n    if(!fertileLandData.source) {\n        console.log(`No source found for FertileLand at ${ fertileLandPath }`)\n        return;\n    }\n    delete fertileLandData.source.wasm;\n    fs.writeFileSync(fertileLandInterfacePath, JSON.stringify(fertileLandData, null, 4));\n    console.log(`Extracted metadata for FertileLand to ${ fertileLandInterfacePath }`)\n} else {\n    console.log(`No metadata found for FertileLand at ${ fertileLandPath }`)\n}\nconst wetlandPath = path.join(contractsV1Dir, \"wetland.contract.json\");\nconst wetlandInterfacePath = path.join(contractInterfacesV1Dir, \"wetland.interface.json\");\nif(fs.existsSync(wetlandPath)) {\n    const wetlandData = JSON.parse(\n        fs.readFileSync(wetlandPath, { encoding: 'utf-8' })\n    );\n    if(!wetlandData.source) {\n        console.log(`No source found for Wetland at ${ wetlandPath }`)\n        return;\n    }\n    delete wetlandData.source.wasm;\n    fs.writeFileSync(wetlandInterfacePath, JSON.stringify(wetlandData, null, 4));\n    console.log(`Extracted metadata for Wetland to ${ wetlandInterfacePath }`)\n} else {\n    console.log(`No metadata found for Wetland at ${ wetlandPath }`)\n}\nconst peatPath = path.join(contractsV1Dir, \"peat.contract.json\");\nconst peatInterfacePath = path.join(contractInterfacesV1Dir, \"peat.interface.json\");\nif(fs.existsSync(peatPath)) {\n    const peatData = JSON.parse(\n        fs.readFileSync(peatPath, { encoding: 'utf-8' })\n    );\n    if(!peatData.source) {\n        console.log(`No source found for Peat at ${ peatPath }`)\n        return;\n    }\n    delete peatData.source.wasm;\n    fs.writeFileSync(peatInterfacePath, JSON.stringify(peatData, null, 4));\n    console.log(`Extracted metadata for Peat to ${ peatInterfacePath }`)\n} else {\n    console.log(`No metadata found for Peat at ${ peatPath }`)\n}\nconst reedsPath = path.join(contractsV1Dir, \"reeds.contract.json\");\nconst reedsInterfacePath = path.join(contractInterfacesV1Dir, \"reeds.interface.json\");\nif(fs.existsSync(reedsPath)) {\n    const reedsData = JSON.parse(\n        fs.readFileSync(reedsPath, { encoding: 'utf-8' })\n    );\n    if(!reedsData.source) {\n        console.log(`No source found for Reeds at ${ reedsPath }`)\n        return;\n    }\n    delete reedsData.source.wasm;\n    fs.writeFileSync(reedsInterfacePath, JSON.stringify(reedsData, null, 4));\n    console.log(`Extracted metadata for Reeds to ${ reedsInterfacePath }`)\n} else {\n    console.log(`No metadata found for Reeds at ${ reedsPath }`)\n}\nconst valleyPath = path.join(contractsV1Dir, \"valley.contract.json\");\nconst valleyInterfacePath = path.join(contractInterfacesV1Dir, \"valley.interface.json\");\nif(fs.existsSync(valleyPath)) {\n    const valleyData = JSON.parse(\n        fs.readFileSync(valleyPath, { encoding: 'utf-8' })\n    );\n    if(!valleyData.source) {\n        console.log(`No source found for Valley at ${ valleyPath }`)\n        return;\n    }\n    delete valleyData.source.wasm;\n    fs.writeFileSync(valleyInterfacePath, JSON.stringify(valleyData, null, 4));\n    console.log(`Extracted metadata for Valley to ${ valleyInterfacePath }`)\n} else {\n    console.log(`No metadata found for Valley at ${ valleyPath }`)\n}\nconst riverPath = path.join(contractsV1Dir, \"river.contract.json\");\nconst riverInterfacePath = path.join(contractInterfacesV1Dir, \"river.interface.json\");\nif(fs.existsSync(riverPath)) {\n    const riverData = JSON.parse(\n        fs.readFileSync(riverPath, { encoding: 'utf-8' })\n    );\n    if(!riverData.source) {\n        console.log(`No source found for River at ${ riverPath }`)\n        return;\n    }\n    delete riverData.source.wasm;\n    fs.writeFileSync(riverInterfacePath, JSON.stringify(riverData, null, 4));\n    console.log(`Extracted metadata for River to ${ riverInterfacePath }`)\n} else {\n    console.log(`No metadata found for River at ${ riverPath }`)\n}\nconst scorchedEarthPath = path.join(contractsV1Dir, \"scorched_earth.contract.json\");\nconst scorchedEarthInterfacePath = path.join(contractInterfacesV1Dir, \"scorched_earth.interface.json\");\nif(fs.existsSync(scorchedEarthPath)) {\n    const scorchedEarthData = JSON.parse(\n        fs.readFileSync(scorchedEarthPath, { encoding: 'utf-8' })\n    );\n    if(!scorchedEarthData.source) {\n        console.log(`No source found for ScorchedEarth at ${ scorchedEarthPath }`)\n        return;\n    }\n    delete scorchedEarthData.source.wasm;\n    fs.writeFileSync(scorchedEarthInterfacePath, JSON.stringify(scorchedEarthData, null, 4));\n    console.log(`Extracted metadata for ScorchedEarth to ${ scorchedEarthInterfacePath }`)\n} else {\n    console.log(`No metadata found for ScorchedEarth at ${ scorchedEarthPath }`)\n}\nconst deltaPath = path.join(contractsV1Dir, \"delta.contract.json\");\nconst deltaInterfacePath = path.join(contractInterfacesV1Dir, \"delta.interface.json\");\nif(fs.existsSync(deltaPath)) {\n    const deltaData = JSON.parse(\n        fs.readFileSync(deltaPath, { encoding: 'utf-8' })\n    );\n    if(!deltaData.source) {\n        console.log(`No source found for Delta at ${ deltaPath }`)\n        return;\n    }\n    delete deltaData.source.wasm;\n    fs.writeFileSync(deltaInterfacePath, JSON.stringify(deltaData, null, 4));\n    console.log(`Extracted metadata for Delta to ${ deltaInterfacePath }`)\n} else {\n    console.log(`No metadata found for Delta at ${ deltaPath }`)\n}\nconst estuaryPath = path.join(contractsV1Dir, \"estuary.contract.json\");\nconst estuaryInterfacePath = path.join(contractInterfacesV1Dir, \"estuary.interface.json\");\nif(fs.existsSync(estuaryPath)) {\n    const estuaryData = JSON.parse(\n        fs.readFileSync(estuaryPath, { encoding: 'utf-8' })\n    );\n    if(!estuaryData.source) {\n        console.log(`No source found for Estuary at ${ estuaryPath }`)\n        return;\n    }\n    delete estuaryData.source.wasm;\n    fs.writeFileSync(estuaryInterfacePath, JSON.stringify(estuaryData, null, 4));\n    console.log(`Extracted metadata for Estuary to ${ estuaryInterfacePath }`)\n} else {\n    console.log(`No metadata found for Estuary at ${ estuaryPath }`)\n}\nconst fireSwampPath = path.join(contractsV1Dir, \"fire_swamp.contract.json\");\nconst fireSwampInterfacePath = path.join(contractInterfacesV1Dir, \"fire_swamp.interface.json\");\nif(fs.existsSync(fireSwampPath)) {\n    const fireSwampData = JSON.parse(\n        fs.readFileSync(fireSwampPath, { encoding: 'utf-8' })\n    );\n    if(!fireSwampData.source) {\n        console.log(`No source found for FireSwamp at ${ fireSwampPath }`)\n        return;\n    }\n    delete fireSwampData.source.wasm;\n    fs.writeFileSync(fireSwampInterfacePath, JSON.stringify(fireSwampData, null, 4));\n    console.log(`Extracted metadata for FireSwamp to ${ fireSwampInterfacePath }`)\n} else {\n    console.log(`No metadata found for FireSwamp at ${ fireSwampPath }`)\n}\nconst riverbankPath = path.join(contractsV1Dir, \"riverbank.contract.json\");\nconst riverbankInterfacePath = path.join(contractInterfacesV1Dir, \"riverbank.interface.json\");\nif(fs.existsSync(riverbankPath)) {\n    const riverbankData = JSON.parse(\n        fs.readFileSync(riverbankPath, { encoding: 'utf-8' })\n    );\n    if(!riverbankData.source) {\n        console.log(`No source found for Riverbank at ${ riverbankPath }`)\n        return;\n    }\n    delete riverbankData.source.wasm;\n    fs.writeFileSync(riverbankInterfacePath, JSON.stringify(riverbankData, null, 4));\n    console.log(`Extracted metadata for Riverbank to ${ riverbankInterfacePath }`)\n} else {\n    console.log(`No metadata found for Riverbank at ${ riverbankPath }`)\n}\nconst ravinePath = path.join(contractsV1Dir, \"ravine.contract.json\");\nconst ravineInterfacePath = path.join(contractInterfacesV1Dir, \"ravine.interface.json\");\nif(fs.existsSync(ravinePath)) {\n    const ravineData = JSON.parse(\n        fs.readFileSync(ravinePath, { encoding: 'utf-8' })\n    );\n    if(!ravineData.source) {\n        console.log(`No source found for Ravine at ${ ravinePath }`)\n        return;\n    }\n    delete ravineData.source.wasm;\n    fs.writeFileSync(ravineInterfacePath, JSON.stringify(ravineData, null, 4));\n    console.log(`Extracted metadata for Ravine to ${ ravineInterfacePath }`)\n} else {\n    console.log(`No metadata found for Ravine at ${ ravinePath }`)\n}\nconst gorgePath = path.join(contractsV1Dir, \"gorge.contract.json\");\nconst gorgeInterfacePath = path.join(contractInterfacesV1Dir, \"gorge.interface.json\");\nif(fs.existsSync(gorgePath)) {\n    const gorgeData = JSON.parse(\n        fs.readFileSync(gorgePath, { encoding: 'utf-8' })\n    );\n    if(!gorgeData.source) {\n        console.log(`No source found for Gorge at ${ gorgePath }`)\n        return;\n    }\n    delete gorgeData.source.wasm;\n    fs.writeFileSync(gorgeInterfacePath, JSON.stringify(gorgeData, null, 4));\n    console.log(`Extracted metadata for Gorge to ${ gorgeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Gorge at ${ gorgePath }`)\n}\nconst charredRavinePath = path.join(contractsV1Dir, \"charred_ravine.contract.json\");\nconst charredRavineInterfacePath = path.join(contractInterfacesV1Dir, \"charred_ravine.interface.json\");\nif(fs.existsSync(charredRavinePath)) {\n    const charredRavineData = JSON.parse(\n        fs.readFileSync(charredRavinePath, { encoding: 'utf-8' })\n    );\n    if(!charredRavineData.source) {\n        console.log(`No source found for CharredRavine at ${ charredRavinePath }`)\n        return;\n    }\n    delete charredRavineData.source.wasm;\n    fs.writeFileSync(charredRavineInterfacePath, JSON.stringify(charredRavineData, null, 4));\n    console.log(`Extracted metadata for CharredRavine to ${ charredRavineInterfacePath }`)\n} else {\n    console.log(`No metadata found for CharredRavine at ${ charredRavinePath }`)\n}\nconst echoPath = path.join(contractsV1Dir, \"echo.contract.json\");\nconst echoInterfacePath = path.join(contractInterfacesV1Dir, \"echo.interface.json\");\nif(fs.existsSync(echoPath)) {\n    const echoData = JSON.parse(\n        fs.readFileSync(echoPath, { encoding: 'utf-8' })\n    );\n    if(!echoData.source) {\n        console.log(`No source found for Echo at ${ echoPath }`)\n        return;\n    }\n    delete echoData.source.wasm;\n    fs.writeFileSync(echoInterfacePath, JSON.stringify(echoData, null, 4));\n    console.log(`Extracted metadata for Echo to ${ echoInterfacePath }`)\n} else {\n    console.log(`No metadata found for Echo at ${ echoPath }`)\n}\nconst cavePath = path.join(contractsV1Dir, \"cave.contract.json\");\nconst caveInterfacePath = path.join(contractInterfacesV1Dir, \"cave.interface.json\");\nif(fs.existsSync(cavePath)) {\n    const caveData = JSON.parse(\n        fs.readFileSync(cavePath, { encoding: 'utf-8' })\n    );\n    if(!caveData.source) {\n        console.log(`No source found for Cave at ${ cavePath }`)\n        return;\n    }\n    delete caveData.source.wasm;\n    fs.writeFileSync(caveInterfacePath, JSON.stringify(caveData, null, 4));\n    console.log(`Extracted metadata for Cave to ${ caveInterfacePath }`)\n} else {\n    console.log(`No metadata found for Cave at ${ cavePath }`)\n}\nconst undergroundLakePath = path.join(contractsV1Dir, \"underground_lake.contract.json\");\nconst undergroundLakeInterfacePath = path.join(contractInterfacesV1Dir, \"underground_lake.interface.json\");\nif(fs.existsSync(undergroundLakePath)) {\n    const undergroundLakeData = JSON.parse(\n        fs.readFileSync(undergroundLakePath, { encoding: 'utf-8' })\n    );\n    if(!undergroundLakeData.source) {\n        console.log(`No source found for UndergroundLake at ${ undergroundLakePath }`)\n        return;\n    }\n    delete undergroundLakeData.source.wasm;\n    fs.writeFileSync(undergroundLakeInterfacePath, JSON.stringify(undergroundLakeData, null, 4));\n    console.log(`Extracted metadata for UndergroundLake to ${ undergroundLakeInterfacePath }`)\n} else {\n    console.log(`No metadata found for UndergroundLake at ${ undergroundLakePath }`)\n}\nconst lavaCavePath = path.join(contractsV1Dir, \"lava_cave.contract.json\");\nconst lavaCaveInterfacePath = path.join(contractInterfacesV1Dir, \"lava_cave.interface.json\");\nif(fs.existsSync(lavaCavePath)) {\n    const lavaCaveData = JSON.parse(\n        fs.readFileSync(lavaCavePath, { encoding: 'utf-8' })\n    );\n    if(!lavaCaveData.source) {\n        console.log(`No source found for LavaCave at ${ lavaCavePath }`)\n        return;\n    }\n    delete lavaCaveData.source.wasm;\n    fs.writeFileSync(lavaCaveInterfacePath, JSON.stringify(lavaCaveData, null, 4));\n    console.log(`Extracted metadata for LavaCave to ${ lavaCaveInterfacePath }`)\n} else {\n    console.log(`No metadata found for LavaCave at ${ lavaCavePath }`)\n}\nconst whisperingCavePath = path.join(contractsV1Dir, \"whispering_cave.contract.json\");\nconst whisperingCaveInterfacePath = path.join(contractInterfacesV1Dir, \"whispering_cave.interface.json\");\nif(fs.existsSync(whisperingCavePath)) {\n    const whisperingCaveData = JSON.parse(\n        fs.readFileSync(whisperingCavePath, { encoding: 'utf-8' })\n    );\n    if(!whisperingCaveData.source) {\n        console.log(`No source found for WhisperingCave at ${ whisperingCavePath }`)\n        return;\n    }\n    delete whisperingCaveData.source.wasm;\n    fs.writeFileSync(whisperingCaveInterfacePath, JSON.stringify(whisperingCaveData, null, 4));\n    console.log(`Extracted metadata for WhisperingCave to ${ whisperingCaveInterfacePath }`)\n} else {\n    console.log(`No metadata found for WhisperingCave at ${ whisperingCavePath }`)\n}\nconst subterraneanPoolPath = path.join(contractsV1Dir, \"subterranean_pool.contract.json\");\nconst subterraneanPoolInterfacePath = path.join(contractInterfacesV1Dir, \"subterranean_pool.interface.json\");\nif(fs.existsSync(subterraneanPoolPath)) {\n    const subterraneanPoolData = JSON.parse(\n        fs.readFileSync(subterraneanPoolPath, { encoding: 'utf-8' })\n    );\n    if(!subterraneanPoolData.source) {\n        console.log(`No source found for SubterraneanPool at ${ subterraneanPoolPath }`)\n        return;\n    }\n    delete subterraneanPoolData.source.wasm;\n    fs.writeFileSync(subterraneanPoolInterfacePath, JSON.stringify(subterraneanPoolData, null, 4));\n    console.log(`Extracted metadata for SubterraneanPool to ${ subterraneanPoolInterfacePath }`)\n} else {\n    console.log(`No metadata found for SubterraneanPool at ${ subterraneanPoolPath }`)\n}\nconst springPath = path.join(contractsV1Dir, \"spring.contract.json\");\nconst springInterfacePath = path.join(contractInterfacesV1Dir, \"spring.interface.json\");\nif(fs.existsSync(springPath)) {\n    const springData = JSON.parse(\n        fs.readFileSync(springPath, { encoding: 'utf-8' })\n    );\n    if(!springData.source) {\n        console.log(`No source found for Spring at ${ springPath }`)\n        return;\n    }\n    delete springData.source.wasm;\n    fs.writeFileSync(springInterfacePath, JSON.stringify(springData, null, 4));\n    console.log(`Extracted metadata for Spring to ${ springInterfacePath }`)\n} else {\n    console.log(`No metadata found for Spring at ${ springPath }`)\n}\nconst hotSpringPath = path.join(contractsV1Dir, \"hot_spring.contract.json\");\nconst hotSpringInterfacePath = path.join(contractInterfacesV1Dir, \"hot_spring.interface.json\");\nif(fs.existsSync(hotSpringPath)) {\n    const hotSpringData = JSON.parse(\n        fs.readFileSync(hotSpringPath, { encoding: 'utf-8' })\n    );\n    if(!hotSpringData.source) {\n        console.log(`No source found for HotSpring at ${ hotSpringPath }`)\n        return;\n    }\n    delete hotSpringData.source.wasm;\n    fs.writeFileSync(hotSpringInterfacePath, JSON.stringify(hotSpringData, null, 4));\n    console.log(`Extracted metadata for HotSpring to ${ hotSpringInterfacePath }`)\n} else {\n    console.log(`No metadata found for HotSpring at ${ hotSpringPath }`)\n}\nconst grottoPath = path.join(contractsV1Dir, \"grotto.contract.json\");\nconst grottoInterfacePath = path.join(contractInterfacesV1Dir, \"grotto.interface.json\");\nif(fs.existsSync(grottoPath)) {\n    const grottoData = JSON.parse(\n        fs.readFileSync(grottoPath, { encoding: 'utf-8' })\n    );\n    if(!grottoData.source) {\n        console.log(`No source found for Grotto at ${ grottoPath }`)\n        return;\n    }\n    delete grottoData.source.wasm;\n    fs.writeFileSync(grottoInterfacePath, JSON.stringify(grottoData, null, 4));\n    console.log(`Extracted metadata for Grotto to ${ grottoInterfacePath }`)\n} else {\n    console.log(`No metadata found for Grotto at ${ grottoPath }`)\n}\nconst fountainPath = path.join(contractsV1Dir, \"fountain.contract.json\");\nconst fountainInterfacePath = path.join(contractInterfacesV1Dir, \"fountain.interface.json\");\nif(fs.existsSync(fountainPath)) {\n    const fountainData = JSON.parse(\n        fs.readFileSync(fountainPath, { encoding: 'utf-8' })\n    );\n    if(!fountainData.source) {\n        console.log(`No source found for Fountain at ${ fountainPath }`)\n        return;\n    }\n    delete fountainData.source.wasm;\n    fs.writeFileSync(fountainInterfacePath, JSON.stringify(fountainData, null, 4));\n    console.log(`Extracted metadata for Fountain to ${ fountainInterfacePath }`)\n} else {\n    console.log(`No metadata found for Fountain at ${ fountainPath }`)\n}\nconst steamVentPath = path.join(contractsV1Dir, \"steam_vent.contract.json\");\nconst steamVentInterfacePath = path.join(contractInterfacesV1Dir, \"steam_vent.interface.json\");\nif(fs.existsSync(steamVentPath)) {\n    const steamVentData = JSON.parse(\n        fs.readFileSync(steamVentPath, { encoding: 'utf-8' })\n    );\n    if(!steamVentData.source) {\n        console.log(`No source found for SteamVent at ${ steamVentPath }`)\n        return;\n    }\n    delete steamVentData.source.wasm;\n    fs.writeFileSync(steamVentInterfacePath, JSON.stringify(steamVentData, null, 4));\n    console.log(`Extracted metadata for SteamVent to ${ steamVentInterfacePath }`)\n} else {\n    console.log(`No metadata found for SteamVent at ${ steamVentPath }`)\n}\nconst coolBreezePath = path.join(contractsV1Dir, \"cool_breeze.contract.json\");\nconst coolBreezeInterfacePath = path.join(contractInterfacesV1Dir, \"cool_breeze.interface.json\");\nif(fs.existsSync(coolBreezePath)) {\n    const coolBreezeData = JSON.parse(\n        fs.readFileSync(coolBreezePath, { encoding: 'utf-8' })\n    );\n    if(!coolBreezeData.source) {\n        console.log(`No source found for CoolBreeze at ${ coolBreezePath }`)\n        return;\n    }\n    delete coolBreezeData.source.wasm;\n    fs.writeFileSync(coolBreezeInterfacePath, JSON.stringify(coolBreezeData, null, 4));\n    console.log(`Extracted metadata for CoolBreeze to ${ coolBreezeInterfacePath }`)\n} else {\n    console.log(`No metadata found for CoolBreeze at ${ coolBreezePath }`)\n}\nconst monumentPath = path.join(contractsV1Dir, \"monument.contract.json\");\nconst monumentInterfacePath = path.join(contractInterfacesV1Dir, \"monument.interface.json\");\nif(fs.existsSync(monumentPath)) {\n    const monumentData = JSON.parse(\n        fs.readFileSync(monumentPath, { encoding: 'utf-8' })\n    );\n    if(!monumentData.source) {\n        console.log(`No source found for Monument at ${ monumentPath }`)\n        return;\n    }\n    delete monumentData.source.wasm;\n    fs.writeFileSync(monumentInterfacePath, JSON.stringify(monumentData, null, 4));\n    console.log(`Extracted metadata for Monument to ${ monumentInterfacePath }`)\n} else {\n    console.log(`No metadata found for Monument at ${ monumentPath }`)\n}\nconst waterfallPath = path.join(contractsV1Dir, \"waterfall.contract.json\");\nconst waterfallInterfacePath = path.join(contractInterfacesV1Dir, \"waterfall.interface.json\");\nif(fs.existsSync(waterfallPath)) {\n    const waterfallData = JSON.parse(\n        fs.readFileSync(waterfallPath, { encoding: 'utf-8' })\n    );\n    if(!waterfallData.source) {\n        console.log(`No source found for Waterfall at ${ waterfallPath }`)\n        return;\n    }\n    delete waterfallData.source.wasm;\n    fs.writeFileSync(waterfallInterfacePath, JSON.stringify(waterfallData, null, 4));\n    console.log(`Extracted metadata for Waterfall to ${ waterfallInterfacePath }`)\n} else {\n    console.log(`No metadata found for Waterfall at ${ waterfallPath }`)\n}\nconst eternalFlamePath = path.join(contractsV1Dir, \"eternal_flame.contract.json\");\nconst eternalFlameInterfacePath = path.join(contractInterfacesV1Dir, \"eternal_flame.interface.json\");\nif(fs.existsSync(eternalFlamePath)) {\n    const eternalFlameData = JSON.parse(\n        fs.readFileSync(eternalFlamePath, { encoding: 'utf-8' })\n    );\n    if(!eternalFlameData.source) {\n        console.log(`No source found for EternalFlame at ${ eternalFlamePath }`)\n        return;\n    }\n    delete eternalFlameData.source.wasm;\n    fs.writeFileSync(eternalFlameInterfacePath, JSON.stringify(eternalFlameData, null, 4));\n    console.log(`Extracted metadata for EternalFlame to ${ eternalFlameInterfacePath }`)\n} else {\n    console.log(`No metadata found for EternalFlame at ${ eternalFlamePath }`)\n}\nconst pillarOfWindPath = path.join(contractsV1Dir, \"pillar_of_wind.contract.json\");\nconst pillarOfWindInterfacePath = path.join(contractInterfacesV1Dir, \"pillar_of_wind.interface.json\");\nif(fs.existsSync(pillarOfWindPath)) {\n    const pillarOfWindData = JSON.parse(\n        fs.readFileSync(pillarOfWindPath, { encoding: 'utf-8' })\n    );\n    if(!pillarOfWindData.source) {\n        console.log(`No source found for PillarOfWind at ${ pillarOfWindPath }`)\n        return;\n    }\n    delete pillarOfWindData.source.wasm;\n    fs.writeFileSync(pillarOfWindInterfacePath, JSON.stringify(pillarOfWindData, null, 4));\n    console.log(`Extracted metadata for PillarOfWind to ${ pillarOfWindInterfacePath }`)\n} else {\n    console.log(`No metadata found for PillarOfWind at ${ pillarOfWindPath }`)\n}\nconst streamPath = path.join(contractsV1Dir, \"stream.contract.json\");\nconst streamInterfacePath = path.join(contractInterfacesV1Dir, \"stream.interface.json\");\nif(fs.existsSync(streamPath)) {\n    const streamData = JSON.parse(\n        fs.readFileSync(streamPath, { encoding: 'utf-8' })\n    );\n    if(!streamData.source) {\n        console.log(`No source found for Stream at ${ streamPath }`)\n        return;\n    }\n    delete streamData.source.wasm;\n    fs.writeFileSync(streamInterfacePath, JSON.stringify(streamData, null, 4));\n    console.log(`Extracted metadata for Stream to ${ streamInterfacePath }`)\n} else {\n    console.log(`No metadata found for Stream at ${ streamPath }`)\n}\nconst zephyrPath = path.join(contractsV1Dir, \"zephyr.contract.json\");\nconst zephyrInterfacePath = path.join(contractInterfacesV1Dir, \"zephyr.interface.json\");\nif(fs.existsSync(zephyrPath)) {\n    const zephyrData = JSON.parse(\n        fs.readFileSync(zephyrPath, { encoding: 'utf-8' })\n    );\n    if(!zephyrData.source) {\n        console.log(`No source found for Zephyr at ${ zephyrPath }`)\n        return;\n    }\n    delete zephyrData.source.wasm;\n    fs.writeFileSync(zephyrInterfacePath, JSON.stringify(zephyrData, null, 4));\n    console.log(`Extracted metadata for Zephyr to ${ zephyrInterfacePath }`)\n} else {\n    console.log(`No metadata found for Zephyr at ${ zephyrPath }`)\n}\nconst creekPath = path.join(contractsV1Dir, \"creek.contract.json\");\nconst creekInterfacePath = path.join(contractInterfacesV1Dir, \"creek.interface.json\");\nif(fs.existsSync(creekPath)) {\n    const creekData = JSON.parse(\n        fs.readFileSync(creekPath, { encoding: 'utf-8' })\n    );\n    if(!creekData.source) {\n        console.log(`No source found for Creek at ${ creekPath }`)\n        return;\n    }\n    delete creekData.source.wasm;\n    fs.writeFileSync(creekInterfacePath, JSON.stringify(creekData, null, 4));\n    console.log(`Extracted metadata for Creek to ${ creekInterfacePath }`)\n} else {\n    console.log(`No metadata found for Creek at ${ creekPath }`)\n}\nconst brookPath = path.join(contractsV1Dir, \"brook.contract.json\");\nconst brookInterfacePath = path.join(contractInterfacesV1Dir, \"brook.interface.json\");\nif(fs.existsSync(brookPath)) {\n    const brookData = JSON.parse(\n        fs.readFileSync(brookPath, { encoding: 'utf-8' })\n    );\n    if(!brookData.source) {\n        console.log(`No source found for Brook at ${ brookPath }`)\n        return;\n    }\n    delete brookData.source.wasm;\n    fs.writeFileSync(brookInterfacePath, JSON.stringify(brookData, null, 4));\n    console.log(`Extracted metadata for Brook to ${ brookInterfacePath }`)\n} else {\n    console.log(`No metadata found for Brook at ${ brookPath }`)\n}\nconst whisperPath = path.join(contractsV1Dir, \"whisper.contract.json\");\nconst whisperInterfacePath = path.join(contractInterfacesV1Dir, \"whisper.interface.json\");\nif(fs.existsSync(whisperPath)) {\n    const whisperData = JSON.parse(\n        fs.readFileSync(whisperPath, { encoding: 'utf-8' })\n    );\n    if(!whisperData.source) {\n        console.log(`No source found for Whisper at ${ whisperPath }`)\n        return;\n    }\n    delete whisperData.source.wasm;\n    fs.writeFileSync(whisperInterfacePath, JSON.stringify(whisperData, null, 4));\n    console.log(`Extracted metadata for Whisper to ${ whisperInterfacePath }`)\n} else {\n    console.log(`No metadata found for Whisper at ${ whisperPath }`)\n}\nconst rivuletPath = path.join(contractsV1Dir, \"rivulet.contract.json\");\nconst rivuletInterfacePath = path.join(contractInterfacesV1Dir, \"rivulet.interface.json\");\nif(fs.existsSync(rivuletPath)) {\n    const rivuletData = JSON.parse(\n        fs.readFileSync(rivuletPath, { encoding: 'utf-8' })\n    );\n    if(!rivuletData.source) {\n        console.log(`No source found for Rivulet at ${ rivuletPath }`)\n        return;\n    }\n    delete rivuletData.source.wasm;\n    fs.writeFileSync(rivuletInterfacePath, JSON.stringify(rivuletData, null, 4));\n    console.log(`Extracted metadata for Rivulet to ${ rivuletInterfacePath }`)\n} else {\n    console.log(`No metadata found for Rivulet at ${ rivuletPath }`)\n}\nconst tributaryPath = path.join(contractsV1Dir, \"tributary.contract.json\");\nconst tributaryInterfacePath = path.join(contractInterfacesV1Dir, \"tributary.interface.json\");\nif(fs.existsSync(tributaryPath)) {\n    const tributaryData = JSON.parse(\n        fs.readFileSync(tributaryPath, { encoding: 'utf-8' })\n    );\n    if(!tributaryData.source) {\n        console.log(`No source found for Tributary at ${ tributaryPath }`)\n        return;\n    }\n    delete tributaryData.source.wasm;\n    fs.writeFileSync(tributaryInterfacePath, JSON.stringify(tributaryData, null, 4));\n    console.log(`Extracted metadata for Tributary to ${ tributaryInterfacePath }`)\n} else {\n    console.log(`No metadata found for Tributary at ${ tributaryPath }`)\n}\nconst murmurPath = path.join(contractsV1Dir, \"murmur.contract.json\");\nconst murmurInterfacePath = path.join(contractInterfacesV1Dir, \"murmur.interface.json\");\nif(fs.existsSync(murmurPath)) {\n    const murmurData = JSON.parse(\n        fs.readFileSync(murmurPath, { encoding: 'utf-8' })\n    );\n    if(!murmurData.source) {\n        console.log(`No source found for Murmur at ${ murmurPath }`)\n        return;\n    }\n    delete murmurData.source.wasm;\n    fs.writeFileSync(murmurInterfacePath, JSON.stringify(murmurData, null, 4));\n    console.log(`Extracted metadata for Murmur to ${ murmurInterfacePath }`)\n} else {\n    console.log(`No metadata found for Murmur at ${ murmurPath }`)\n}\nconst watershedPath = path.join(contractsV1Dir, \"watershed.contract.json\");\nconst watershedInterfacePath = path.join(contractInterfacesV1Dir, \"watershed.interface.json\");\nif(fs.existsSync(watershedPath)) {\n    const watershedData = JSON.parse(\n        fs.readFileSync(watershedPath, { encoding: 'utf-8' })\n    );\n    if(!watershedData.source) {\n        console.log(`No source found for Watershed at ${ watershedPath }`)\n        return;\n    }\n    delete watershedData.source.wasm;\n    fs.writeFileSync(watershedInterfacePath, JSON.stringify(watershedData, null, 4));\n    console.log(`Extracted metadata for Watershed to ${ watershedInterfacePath }`)\n} else {\n    console.log(`No metadata found for Watershed at ${ watershedPath }`)\n}\nconst aquiferPath = path.join(contractsV1Dir, \"aquifer.contract.json\");\nconst aquiferInterfacePath = path.join(contractInterfacesV1Dir, \"aquifer.interface.json\");\nif(fs.existsSync(aquiferPath)) {\n    const aquiferData = JSON.parse(\n        fs.readFileSync(aquiferPath, { encoding: 'utf-8' })\n    );\n    if(!aquiferData.source) {\n        console.log(`No source found for Aquifer at ${ aquiferPath }`)\n        return;\n    }\n    delete aquiferData.source.wasm;\n    fs.writeFileSync(aquiferInterfacePath, JSON.stringify(aquiferData, null, 4));\n    console.log(`Extracted metadata for Aquifer to ${ aquiferInterfacePath }`)\n} else {\n    console.log(`No metadata found for Aquifer at ${ aquiferPath }`)\n}\nconst parchedEarthPath = path.join(contractsV1Dir, \"parched_earth.contract.json\");\nconst parchedEarthInterfacePath = path.join(contractInterfacesV1Dir, \"parched_earth.interface.json\");\nif(fs.existsSync(parchedEarthPath)) {\n    const parchedEarthData = JSON.parse(\n        fs.readFileSync(parchedEarthPath, { encoding: 'utf-8' })\n    );\n    if(!parchedEarthData.source) {\n        console.log(`No source found for ParchedEarth at ${ parchedEarthPath }`)\n        return;\n    }\n    delete parchedEarthData.source.wasm;\n    fs.writeFileSync(parchedEarthInterfacePath, JSON.stringify(parchedEarthData, null, 4));\n    console.log(`Extracted metadata for ParchedEarth to ${ parchedEarthInterfacePath }`)\n} else {\n    console.log(`No metadata found for ParchedEarth at ${ parchedEarthPath }`)\n}\nconst freshBreezePath = path.join(contractsV1Dir, \"fresh_breeze.contract.json\");\nconst freshBreezeInterfacePath = path.join(contractInterfacesV1Dir, \"fresh_breeze.interface.json\");\nif(fs.existsSync(freshBreezePath)) {\n    const freshBreezeData = JSON.parse(\n        fs.readFileSync(freshBreezePath, { encoding: 'utf-8' })\n    );\n    if(!freshBreezeData.source) {\n        console.log(`No source found for FreshBreeze at ${ freshBreezePath }`)\n        return;\n    }\n    delete freshBreezeData.source.wasm;\n    fs.writeFileSync(freshBreezeInterfacePath, JSON.stringify(freshBreezeData, null, 4));\n    console.log(`Extracted metadata for FreshBreeze to ${ freshBreezeInterfacePath }`)\n} else {\n    console.log(`No metadata found for FreshBreeze at ${ freshBreezePath }`)\n}\nconst groundwaterPath = path.join(contractsV1Dir, \"groundwater.contract.json\");\nconst groundwaterInterfacePath = path.join(contractInterfacesV1Dir, \"groundwater.interface.json\");\nif(fs.existsSync(groundwaterPath)) {\n    const groundwaterData = JSON.parse(\n        fs.readFileSync(groundwaterPath, { encoding: 'utf-8' })\n    );\n    if(!groundwaterData.source) {\n        console.log(`No source found for Groundwater at ${ groundwaterPath }`)\n        return;\n    }\n    delete groundwaterData.source.wasm;\n    fs.writeFileSync(groundwaterInterfacePath, JSON.stringify(groundwaterData, null, 4));\n    console.log(`Extracted metadata for Groundwater to ${ groundwaterInterfacePath }`)\n} else {\n    console.log(`No metadata found for Groundwater at ${ groundwaterPath }`)\n}\nconst reservoirPath = path.join(contractsV1Dir, \"reservoir.contract.json\");\nconst reservoirInterfacePath = path.join(contractInterfacesV1Dir, \"reservoir.interface.json\");\nif(fs.existsSync(reservoirPath)) {\n    const reservoirData = JSON.parse(\n        fs.readFileSync(reservoirPath, { encoding: 'utf-8' })\n    );\n    if(!reservoirData.source) {\n        console.log(`No source found for Reservoir at ${ reservoirPath }`)\n        return;\n    }\n    delete reservoirData.source.wasm;\n    fs.writeFileSync(reservoirInterfacePath, JSON.stringify(reservoirData, null, 4));\n    console.log(`Extracted metadata for Reservoir to ${ reservoirInterfacePath }`)\n} else {\n    console.log(`No metadata found for Reservoir at ${ reservoirPath }`)\n}\nconst geothermalSpringPath = path.join(contractsV1Dir, \"geothermal_spring.contract.json\");\nconst geothermalSpringInterfacePath = path.join(contractInterfacesV1Dir, \"geothermal_spring.interface.json\");\nif(fs.existsSync(geothermalSpringPath)) {\n    const geothermalSpringData = JSON.parse(\n        fs.readFileSync(geothermalSpringPath, { encoding: 'utf-8' })\n    );\n    if(!geothermalSpringData.source) {\n        console.log(`No source found for GeothermalSpring at ${ geothermalSpringPath }`)\n        return;\n    }\n    delete geothermalSpringData.source.wasm;\n    fs.writeFileSync(geothermalSpringInterfacePath, JSON.stringify(geothermalSpringData, null, 4));\n    console.log(`Extracted metadata for GeothermalSpring to ${ geothermalSpringInterfacePath }`)\n} else {\n    console.log(`No metadata found for GeothermalSpring at ${ geothermalSpringPath }`)\n}\nconst artesianWellPath = path.join(contractsV1Dir, \"artesian_well.contract.json\");\nconst artesianWellInterfacePath = path.join(contractInterfacesV1Dir, \"artesian_well.interface.json\");\nif(fs.existsSync(artesianWellPath)) {\n    const artesianWellData = JSON.parse(\n        fs.readFileSync(artesianWellPath, { encoding: 'utf-8' })\n    );\n    if(!artesianWellData.source) {\n        console.log(`No source found for ArtesianWell at ${ artesianWellPath }`)\n        return;\n    }\n    delete artesianWellData.source.wasm;\n    fs.writeFileSync(artesianWellInterfacePath, JSON.stringify(artesianWellData, null, 4));\n    console.log(`Extracted metadata for ArtesianWell to ${ artesianWellInterfacePath }`)\n} else {\n    console.log(`No metadata found for ArtesianWell at ${ artesianWellPath }`)\n}\nconst basinPath = path.join(contractsV1Dir, \"basin.contract.json\");\nconst basinInterfacePath = path.join(contractInterfacesV1Dir, \"basin.interface.json\");\nif(fs.existsSync(basinPath)) {\n    const basinData = JSON.parse(\n        fs.readFileSync(basinPath, { encoding: 'utf-8' })\n    );\n    if(!basinData.source) {\n        console.log(`No source found for Basin at ${ basinPath }`)\n        return;\n    }\n    delete basinData.source.wasm;\n    fs.writeFileSync(basinInterfacePath, JSON.stringify(basinData, null, 4));\n    console.log(`Extracted metadata for Basin to ${ basinInterfacePath }`)\n} else {\n    console.log(`No metadata found for Basin at ${ basinPath }`)\n}\nconst lakePath = path.join(contractsV1Dir, \"lake.contract.json\");\nconst lakeInterfacePath = path.join(contractInterfacesV1Dir, \"lake.interface.json\");\nif(fs.existsSync(lakePath)) {\n    const lakeData = JSON.parse(\n        fs.readFileSync(lakePath, { encoding: 'utf-8' })\n    );\n    if(!lakeData.source) {\n        console.log(`No source found for Lake at ${ lakePath }`)\n        return;\n    }\n    delete lakeData.source.wasm;\n    fs.writeFileSync(lakeInterfacePath, JSON.stringify(lakeData, null, 4));\n    console.log(`Extracted metadata for Lake to ${ lakeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Lake at ${ lakePath }`)\n}\nconst dryBasinPath = path.join(contractsV1Dir, \"dry_basin.contract.json\");\nconst dryBasinInterfacePath = path.join(contractInterfacesV1Dir, \"dry_basin.interface.json\");\nif(fs.existsSync(dryBasinPath)) {\n    const dryBasinData = JSON.parse(\n        fs.readFileSync(dryBasinPath, { encoding: 'utf-8' })\n    );\n    if(!dryBasinData.source) {\n        console.log(`No source found for DryBasin at ${ dryBasinPath }`)\n        return;\n    }\n    delete dryBasinData.source.wasm;\n    fs.writeFileSync(dryBasinInterfacePath, JSON.stringify(dryBasinData, null, 4));\n    console.log(`Extracted metadata for DryBasin to ${ dryBasinInterfacePath }`)\n} else {\n    console.log(`No metadata found for DryBasin at ${ dryBasinPath }`)\n}\nconst depressionPath = path.join(contractsV1Dir, \"depression.contract.json\");\nconst depressionInterfacePath = path.join(contractInterfacesV1Dir, \"depression.interface.json\");\nif(fs.existsSync(depressionPath)) {\n    const depressionData = JSON.parse(\n        fs.readFileSync(depressionPath, { encoding: 'utf-8' })\n    );\n    if(!depressionData.source) {\n        console.log(`No source found for Depression at ${ depressionPath }`)\n        return;\n    }\n    delete depressionData.source.wasm;\n    fs.writeFileSync(depressionInterfacePath, JSON.stringify(depressionData, null, 4));\n    console.log(`Extracted metadata for Depression to ${ depressionInterfacePath }`)\n} else {\n    console.log(`No metadata found for Depression at ${ depressionPath }`)\n}\nconst islandPath = path.join(contractsV1Dir, \"island.contract.json\");\nconst islandInterfacePath = path.join(contractInterfacesV1Dir, \"island.interface.json\");\nif(fs.existsSync(islandPath)) {\n    const islandData = JSON.parse(\n        fs.readFileSync(islandPath, { encoding: 'utf-8' })\n    );\n    if(!islandData.source) {\n        console.log(`No source found for Island at ${ islandPath }`)\n        return;\n    }\n    delete islandData.source.wasm;\n    fs.writeFileSync(islandInterfacePath, JSON.stringify(islandData, null, 4));\n    console.log(`Extracted metadata for Island to ${ islandInterfacePath }`)\n} else {\n    console.log(`No metadata found for Island at ${ islandPath }`)\n}\nconst lagoonPath = path.join(contractsV1Dir, \"lagoon.contract.json\");\nconst lagoonInterfacePath = path.join(contractInterfacesV1Dir, \"lagoon.interface.json\");\nif(fs.existsSync(lagoonPath)) {\n    const lagoonData = JSON.parse(\n        fs.readFileSync(lagoonPath, { encoding: 'utf-8' })\n    );\n    if(!lagoonData.source) {\n        console.log(`No source found for Lagoon at ${ lagoonPath }`)\n        return;\n    }\n    delete lagoonData.source.wasm;\n    fs.writeFileSync(lagoonInterfacePath, JSON.stringify(lagoonData, null, 4));\n    console.log(`Extracted metadata for Lagoon to ${ lagoonInterfacePath }`)\n} else {\n    console.log(`No metadata found for Lagoon at ${ lagoonPath }`)\n}\nconst wavePath = path.join(contractsV1Dir, \"wave.contract.json\");\nconst waveInterfacePath = path.join(contractInterfacesV1Dir, \"wave.interface.json\");\nif(fs.existsSync(wavePath)) {\n    const waveData = JSON.parse(\n        fs.readFileSync(wavePath, { encoding: 'utf-8' })\n    );\n    if(!waveData.source) {\n        console.log(`No source found for Wave at ${ wavePath }`)\n        return;\n    }\n    delete waveData.source.wasm;\n    fs.writeFileSync(waveInterfacePath, JSON.stringify(waveData, null, 4));\n    console.log(`Extracted metadata for Wave to ${ waveInterfacePath }`)\n} else {\n    console.log(`No metadata found for Wave at ${ wavePath }`)\n}\nconst reefPath = path.join(contractsV1Dir, \"reef.contract.json\");\nconst reefInterfacePath = path.join(contractInterfacesV1Dir, \"reef.interface.json\");\nif(fs.existsSync(reefPath)) {\n    const reefData = JSON.parse(\n        fs.readFileSync(reefPath, { encoding: 'utf-8' })\n    );\n    if(!reefData.source) {\n        console.log(`No source found for Reef at ${ reefPath }`)\n        return;\n    }\n    delete reefData.source.wasm;\n    fs.writeFileSync(reefInterfacePath, JSON.stringify(reefData, null, 4));\n    console.log(`Extracted metadata for Reef to ${ reefInterfacePath }`)\n} else {\n    console.log(`No metadata found for Reef at ${ reefPath }`)\n}\nconst coralPath = path.join(contractsV1Dir, \"coral.contract.json\");\nconst coralInterfacePath = path.join(contractInterfacesV1Dir, \"coral.interface.json\");\nif(fs.existsSync(coralPath)) {\n    const coralData = JSON.parse(\n        fs.readFileSync(coralPath, { encoding: 'utf-8' })\n    );\n    if(!coralData.source) {\n        console.log(`No source found for Coral at ${ coralPath }`)\n        return;\n    }\n    delete coralData.source.wasm;\n    fs.writeFileSync(coralInterfacePath, JSON.stringify(coralData, null, 4));\n    console.log(`Extracted metadata for Coral to ${ coralInterfacePath }`)\n} else {\n    console.log(`No metadata found for Coral at ${ coralPath }`)\n}\nconst whirlPath = path.join(contractsV1Dir, \"whirl.contract.json\");\nconst whirlInterfacePath = path.join(contractInterfacesV1Dir, \"whirl.interface.json\");\nif(fs.existsSync(whirlPath)) {\n    const whirlData = JSON.parse(\n        fs.readFileSync(whirlPath, { encoding: 'utf-8' })\n    );\n    if(!whirlData.source) {\n        console.log(`No source found for Whirl at ${ whirlPath }`)\n        return;\n    }\n    delete whirlData.source.wasm;\n    fs.writeFileSync(whirlInterfacePath, JSON.stringify(whirlData, null, 4));\n    console.log(`Extracted metadata for Whirl to ${ whirlInterfacePath }`)\n} else {\n    console.log(`No metadata found for Whirl at ${ whirlPath }`)\n}\nconst limestonePath = path.join(contractsV1Dir, \"limestone.contract.json\");\nconst limestoneInterfacePath = path.join(contractInterfacesV1Dir, \"limestone.interface.json\");\nif(fs.existsSync(limestonePath)) {\n    const limestoneData = JSON.parse(\n        fs.readFileSync(limestonePath, { encoding: 'utf-8' })\n    );\n    if(!limestoneData.source) {\n        console.log(`No source found for Limestone at ${ limestonePath }`)\n        return;\n    }\n    delete limestoneData.source.wasm;\n    fs.writeFileSync(limestoneInterfacePath, JSON.stringify(limestoneData, null, 4));\n    console.log(`Extracted metadata for Limestone to ${ limestoneInterfacePath }`)\n} else {\n    console.log(`No metadata found for Limestone at ${ limestonePath }`)\n}\nconst karstPath = path.join(contractsV1Dir, \"karst.contract.json\");\nconst karstInterfacePath = path.join(contractInterfacesV1Dir, \"karst.interface.json\");\nif(fs.existsSync(karstPath)) {\n    const karstData = JSON.parse(\n        fs.readFileSync(karstPath, { encoding: 'utf-8' })\n    );\n    if(!karstData.source) {\n        console.log(`No source found for Karst at ${ karstPath }`)\n        return;\n    }\n    delete karstData.source.wasm;\n    fs.writeFileSync(karstInterfacePath, JSON.stringify(karstData, null, 4));\n    console.log(`Extracted metadata for Karst to ${ karstInterfacePath }`)\n} else {\n    console.log(`No metadata found for Karst at ${ karstPath }`)\n}\nconst quicklimePath = path.join(contractsV1Dir, \"quicklime.contract.json\");\nconst quicklimeInterfacePath = path.join(contractInterfacesV1Dir, \"quicklime.interface.json\");\nif(fs.existsSync(quicklimePath)) {\n    const quicklimeData = JSON.parse(\n        fs.readFileSync(quicklimePath, { encoding: 'utf-8' })\n    );\n    if(!quicklimeData.source) {\n        console.log(`No source found for Quicklime at ${ quicklimePath }`)\n        return;\n    }\n    delete quicklimeData.source.wasm;\n    fs.writeFileSync(quicklimeInterfacePath, JSON.stringify(quicklimeData, null, 4));\n    console.log(`Extracted metadata for Quicklime to ${ quicklimeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Quicklime at ${ quicklimePath }`)\n}\nconst blowholePath = path.join(contractsV1Dir, \"blowhole.contract.json\");\nconst blowholeInterfacePath = path.join(contractInterfacesV1Dir, \"blowhole.interface.json\");\nif(fs.existsSync(blowholePath)) {\n    const blowholeData = JSON.parse(\n        fs.readFileSync(blowholePath, { encoding: 'utf-8' })\n    );\n    if(!blowholeData.source) {\n        console.log(`No source found for Blowhole at ${ blowholePath }`)\n        return;\n    }\n    delete blowholeData.source.wasm;\n    fs.writeFileSync(blowholeInterfacePath, JSON.stringify(blowholeData, null, 4));\n    console.log(`Extracted metadata for Blowhole to ${ blowholeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Blowhole at ${ blowholePath }`)\n}\n\nconst unifiersPath = path.join(contractsV1Dir, \"unifiers.contract.json\");\nconst unifiersInterfacePath = path.join(contractInterfacesV1Dir, \"unifiers.interface.json\");\nif(fs.existsSync(unifiersPath)) {\n    const unifiersData = JSON.parse(\n        fs.readFileSync(unifiersPath, { encoding: 'utf-8' })\n    );\n    if(!unifiersData.source) {\n        console.log(`No source found for unifiers at ${ unifiersPath }`)\n        return;\n    }\n    delete unifiersData.source.wasm;\n    fs.writeFileSync(unifiersInterfacePath, JSON.stringify(unifiersData, null, 4));\n    console.log(`Extracted metadata for unifiers to ${ unifiersInterfacePath }`)\n} else {\n    console.log(`No metadata found for unifiers at ${ unifiersPath }`)\n}\nconst elementyPath = path.join(contractsV1Dir, \"elementy.contract.json\");\nconst elementyInterfacePath = path.join(contractInterfacesV1Dir, \"elementy.interface.json\");\nif(fs.existsSync(elementyPath)) {\n    const elementyData = JSON.parse(\n        fs.readFileSync(elementyPath, { encoding: 'utf-8' })\n    );\n    if(!elementyData.source) {\n        console.log(`No source found for elementy at ${ elementyPath }`)\n        return;\n    }\n    delete elementyData.source.wasm;\n    fs.writeFileSync(elementyInterfacePath, JSON.stringify(elementyData, null, 4));\n    console.log(`Extracted metadata for elementy to ${ elementyInterfacePath }`)\n} else {\n    console.log(`No metadata found for elementy at ${ elementyPath }`)\n}\n",
      "contentHash": "8441c26fc17281d8ee0f0a2469c776f9cef169881ebca73521d5456fd8e9a725",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/deployer/src/game.ts",
      "content": "import UNIFIERS_CONTRACT from \"../../../contracts.v1/artifacts/unifiers.contract.json\";\nimport ELEMENTY_CONTRACT from \"../../../contracts.v1/artifacts/elementy.contract.json\";\nimport ELEMENT_MONKEY_CONTRACT from \"../../../contracts.v1/artifacts/monkey.contract.json\";\nimport ELEMENT_GIRAFFE_CONTRACT from \"../../../contracts.v1/artifacts/giraffe.contract.json\";\nimport ELEMENT_BEE_CONTRACT from \"../../../contracts.v1/artifacts/bee.contract.json\";\nimport ELEMENT_COIN_CONTRACT from \"../../../contracts.v1/artifacts/coin.contract.json\";\nimport ELEMENT_SWARM_CONTRACT from \"../../../contracts.v1/artifacts/swarm.contract.json\";\nimport ELEMENT_HYDRA_CONTRACT from \"../../../contracts.v1/artifacts/hydra.contract.json\";\nimport ELEMENT_MONKEY_BRANCH_CONTRACT from \"../../../contracts.v1/artifacts/monkey_branch.contract.json\";\nimport ELEMENT_BRIDGE_CONTRACT from \"../../../contracts.v1/artifacts/bridge.contract.json\";\nimport ELEMENT_GOLDEN_GATE_CONTRACT from \"../../../contracts.v1/artifacts/golden_gate.contract.json\";\nimport ELEMENT_GOLD_CONTRACT from \"../../../contracts.v1/artifacts/gold.contract.json\";\nimport ELEMENT_SILVER_CONTRACT from \"../../../contracts.v1/artifacts/silver.contract.json\";\nimport ELEMENT_RHODIUM_CONTRACT from \"../../../contracts.v1/artifacts/rhodium.contract.json\";\nimport ELEMENT_HIVE_CONTRACT from \"../../../contracts.v1/artifacts/hive.contract.json\";\nimport ELEMENT_TRANSACTION_CONTRACT from \"../../../contracts.v1/artifacts/transaction.contract.json\";\nimport ELEMENT_BLOCK_CONTRACT from \"../../../contracts.v1/artifacts/block.contract.json\";\nimport ELEMENT_BLOCKCHAIN_CONTRACT from \"../../../contracts.v1/artifacts/blockchain.contract.json\";\nimport ELEMENT_POLKADOT_CONTRACT from \"../../../contracts.v1/artifacts/polkadot.contract.json\";\nimport ELEMENT_PEER_REVIEW_CONTRACT from \"../../../contracts.v1/artifacts/peer_review.contract.json\";\nimport ELEMENT_CARDANO_CONTRACT from \"../../../contracts.v1/artifacts/cardano.contract.json\";\nimport ELEMENT_BEAR_CONTRACT from \"../../../contracts.v1/artifacts/bear.contract.json\";\nimport ELEMENT_BEER_CONTRACT from \"../../../contracts.v1/artifacts/beer.contract.json\";\nimport ELEMENT_LOCK_CONTRACT from \"../../../contracts.v1/artifacts/lock.contract.json\";\nimport ELEMENT_MARMALADE_CONTRACT from \"../../../contracts.v1/artifacts/marmalade.contract.json\";\nimport ELEMENT_SUPER_MARMALADE_CONTRACT from \"../../../contracts.v1/artifacts/super_marmalade.contract.json\";\nimport ELEMENT_HYPER_MARMALADE_CONTRACT from \"../../../contracts.v1/artifacts/hyper_marmalade.contract.json\";\nimport ELEMENT_WATER_CONTRACT from \"../../../contracts.v1/artifacts/water.contract.json\";\nimport ELEMENT_FIRE_CONTRACT from \"../../../contracts.v1/artifacts/fire.contract.json\";\nimport ELEMENT_STEAM_CONTRACT from \"../../../contracts.v1/artifacts/steam.contract.json\";\nimport ELEMENT_EARTH_CONTRACT from \"../../../contracts.v1/artifacts/earth.contract.json\";\nimport ELEMENT_MUD_CONTRACT from \"../../../contracts.v1/artifacts/mud.contract.json\";\nimport ELEMENT_LAVA_CONTRACT from \"../../../contracts.v1/artifacts/lava.contract.json\";\nimport ELEMENT_WIND_CONTRACT from \"../../../contracts.v1/artifacts/wind.contract.json\";\nimport ELEMENT_DUST_CONTRACT from \"../../../contracts.v1/artifacts/dust.contract.json\";\nimport ELEMENT_RAIN_CONTRACT from \"../../../contracts.v1/artifacts/rain.contract.json\";\nimport ELEMENT_SMOKE_CONTRACT from \"../../../contracts.v1/artifacts/smoke.contract.json\";\nimport ELEMENT_GEYSER_CONTRACT from \"../../../contracts.v1/artifacts/geyser.contract.json\";\nimport ELEMENT_CLAY_CONTRACT from \"../../../contracts.v1/artifacts/clay.contract.json\";\nimport ELEMENT_SAND_CONTRACT from \"../../../contracts.v1/artifacts/sand.contract.json\";\nimport ELEMENT_PLANT_CONTRACT from \"../../../contracts.v1/artifacts/plant.contract.json\";\nimport ELEMENT_RAINBOW_CONTRACT from \"../../../contracts.v1/artifacts/rainbow.contract.json\";\nimport ELEMENT_STORM_CONTRACT from \"../../../contracts.v1/artifacts/storm.contract.json\";\nimport ELEMENT_OBSIDIAN_CONTRACT from \"../../../contracts.v1/artifacts/obsidian.contract.json\";\nimport ELEMENT_ASH_CONTRACT from \"../../../contracts.v1/artifacts/ash.contract.json\";\nimport ELEMENT_VOLCANO_CONTRACT from \"../../../contracts.v1/artifacts/volcano.contract.json\";\nimport ELEMENT_SANDSTORM_CONTRACT from \"../../../contracts.v1/artifacts/sandstorm.contract.json\";\nimport ELEMENT_CLOUD_CONTRACT from \"../../../contracts.v1/artifacts/cloud.contract.json\";\nimport ELEMENT_FOG_CONTRACT from \"../../../contracts.v1/artifacts/fog.contract.json\";\nimport ELEMENT_TREE_CONTRACT from \"../../../contracts.v1/artifacts/tree.contract.json\";\nimport ELEMENT_FOREST_CONTRACT from \"../../../contracts.v1/artifacts/forest.contract.json\";\nimport ELEMENT_SEEDS_CONTRACT from \"../../../contracts.v1/artifacts/seeds.contract.json\";\nimport ELEMENT_POTTERY_CONTRACT from \"../../../contracts.v1/artifacts/pottery.contract.json\";\nimport ELEMENT_BRICK_CONTRACT from \"../../../contracts.v1/artifacts/brick.contract.json\";\nimport ELEMENT_QUICKSAND_CONTRACT from \"../../../contracts.v1/artifacts/quicksand.contract.json\";\nimport ELEMENT_GLASS_CONTRACT from \"../../../contracts.v1/artifacts/glass.contract.json\";\nimport ELEMENT_DUNE_CONTRACT from \"../../../contracts.v1/artifacts/dune.contract.json\";\nimport ELEMENT_CHARCOAL_CONTRACT from \"../../../contracts.v1/artifacts/charcoal.contract.json\";\nimport ELEMENT_LEAVES_CONTRACT from \"../../../contracts.v1/artifacts/leaves.contract.json\";\nimport ELEMENT_WILDFIRE_CONTRACT from \"../../../contracts.v1/artifacts/wildfire.contract.json\";\nimport ELEMENT_JUNGLE_CONTRACT from \"../../../contracts.v1/artifacts/jungle.contract.json\";\nimport ELEMENT_FROSTED_GLASS_CONTRACT from \"../../../contracts.v1/artifacts/frosted_glass.contract.json\";\nimport ELEMENT_CRYSTAL_CONTRACT from \"../../../contracts.v1/artifacts/crystal.contract.json\";\nimport ELEMENT_MAGMA_CONTRACT from \"../../../contracts.v1/artifacts/magma.contract.json\";\nimport ELEMENT_ROCK_CONTRACT from \"../../../contracts.v1/artifacts/rock.contract.json\";\nimport ELEMENT_SHARD_CONTRACT from \"../../../contracts.v1/artifacts/shard.contract.json\";\nimport ELEMENT_PEBBLE_CONTRACT from \"../../../contracts.v1/artifacts/pebble.contract.json\";\nimport ELEMENT_MOUNTAIN_CONTRACT from \"../../../contracts.v1/artifacts/mountain.contract.json\";\nimport ELEMENT_FERTILIZER_CONTRACT from \"../../../contracts.v1/artifacts/fertilizer.contract.json\";\nimport ELEMENT_SOOT_CONTRACT from \"../../../contracts.v1/artifacts/soot.contract.json\";\nimport ELEMENT_LIGHTNING_CONTRACT from \"../../../contracts.v1/artifacts/lightning.contract.json\";\nimport ELEMENT_MIST_CONTRACT from \"../../../contracts.v1/artifacts/mist.contract.json\";\nimport ELEMENT_HAZE_CONTRACT from \"../../../contracts.v1/artifacts/haze.contract.json\";\nimport ELEMENT_FLOOD_CONTRACT from \"../../../contracts.v1/artifacts/flood.contract.json\";\nimport ELEMENT_LANDSLIDE_CONTRACT from \"../../../contracts.v1/artifacts/landslide.contract.json\";\nimport ELEMENT_THUNDER_CONTRACT from \"../../../contracts.v1/artifacts/thunder.contract.json\";\nimport ELEMENT_TORNADO_CONTRACT from \"../../../contracts.v1/artifacts/tornado.contract.json\";\nimport ELEMENT_GARDEN_CONTRACT from \"../../../contracts.v1/artifacts/garden.contract.json\";\nimport ELEMENT_EMBER_CONTRACT from \"../../../contracts.v1/artifacts/ember.contract.json\";\nimport ELEMENT_KILN_CONTRACT from \"../../../contracts.v1/artifacts/kiln.contract.json\";\nimport ELEMENT_POLLINATION_CONTRACT from \"../../../contracts.v1/artifacts/pollination.contract.json\";\nimport ELEMENT_SINKHOLE_CONTRACT from \"../../../contracts.v1/artifacts/sinkhole.contract.json\";\nimport ELEMENT_BEACH_CONTRACT from \"../../../contracts.v1/artifacts/beach.contract.json\";\nimport ELEMENT_WETSTONE_CONTRACT from \"../../../contracts.v1/artifacts/wetstone.contract.json\";\nimport ELEMENT_EROSION_CONTRACT from \"../../../contracts.v1/artifacts/erosion.contract.json\";\nimport ELEMENT_BASALT_CONTRACT from \"../../../contracts.v1/artifacts/basalt.contract.json\";\nimport ELEMENT_MAGMA_CHAMBER_CONTRACT from \"../../../contracts.v1/artifacts/magma_chamber.contract.json\";\nimport ELEMENT_BREEZE_CONTRACT from \"../../../contracts.v1/artifacts/breeze.contract.json\";\nimport ELEMENT_WARM_BREEZE_CONTRACT from \"../../../contracts.v1/artifacts/warm_breeze.contract.json\";\nimport ELEMENT_SOIL_CONTRACT from \"../../../contracts.v1/artifacts/soil.contract.json\";\nimport ELEMENT_CANYON_CONTRACT from \"../../../contracts.v1/artifacts/canyon.contract.json\";\nimport ELEMENT_WINDMILL_CONTRACT from \"../../../contracts.v1/artifacts/windmill.contract.json\";\nimport ELEMENT_ADOBE_CONTRACT from \"../../../contracts.v1/artifacts/adobe.contract.json\";\nimport ELEMENT_WALL_CONTRACT from \"../../../contracts.v1/artifacts/wall.contract.json\";\nimport ELEMENT_PUMICE_CONTRACT from \"../../../contracts.v1/artifacts/pumice.contract.json\";\nimport ELEMENT_BARBECUE_CONTRACT from \"../../../contracts.v1/artifacts/barbecue.contract.json\";\nimport ELEMENT_FARM_CONTRACT from \"../../../contracts.v1/artifacts/farm.contract.json\";\nimport ELEMENT_SHARDS_CONTRACT from \"../../../contracts.v1/artifacts/shards.contract.json\";\nimport ELEMENT_MOLTEN_GLASS_CONTRACT from \"../../../contracts.v1/artifacts/molten_glass.contract.json\";\nimport ELEMENT_PRISM_CONTRACT from \"../../../contracts.v1/artifacts/prism.contract.json\";\nimport ELEMENT_SPARKLE_CONTRACT from \"../../../contracts.v1/artifacts/sparkle.contract.json\";\nimport ELEMENT_DESERT_CONTRACT from \"../../../contracts.v1/artifacts/desert.contract.json\";\nimport ELEMENT_OASIS_CONTRACT from \"../../../contracts.v1/artifacts/oasis.contract.json\";\nimport ELEMENT_MIRAGE_CONTRACT from \"../../../contracts.v1/artifacts/mirage.contract.json\";\nimport ELEMENT_SAND_DUNE_CONTRACT from \"../../../contracts.v1/artifacts/sand_dune.contract.json\";\nimport ELEMENT_DAM_CONTRACT from \"../../../contracts.v1/artifacts/dam.contract.json\";\nimport ELEMENT_FIREWALL_CONTRACT from \"../../../contracts.v1/artifacts/firewall.contract.json\";\nimport ELEMENT_BARRICADE_CONTRACT from \"../../../contracts.v1/artifacts/barricade.contract.json\";\nimport ELEMENT_PLATEAU_CONTRACT from \"../../../contracts.v1/artifacts/plateau.contract.json\";\nimport ELEMENT_POND_CONTRACT from \"../../../contracts.v1/artifacts/pond.contract.json\";\nimport ELEMENT_AROMAS_CONTRACT from \"../../../contracts.v1/artifacts/aromas.contract.json\";\nimport ELEMENT_FLOWER_CONTRACT from \"../../../contracts.v1/artifacts/flower.contract.json\";\nimport ELEMENT_SPORE_CONTRACT from \"../../../contracts.v1/artifacts/spore.contract.json\";\nimport ELEMENT_SPREAD_CONTRACT from \"../../../contracts.v1/artifacts/spread.contract.json\";\nimport ELEMENT_FERTILE_LAND_CONTRACT from \"../../../contracts.v1/artifacts/fertile_land.contract.json\";\nimport ELEMENT_WETLAND_CONTRACT from \"../../../contracts.v1/artifacts/wetland.contract.json\";\nimport ELEMENT_PEAT_CONTRACT from \"../../../contracts.v1/artifacts/peat.contract.json\";\nimport ELEMENT_REEDS_CONTRACT from \"../../../contracts.v1/artifacts/reeds.contract.json\";\nimport ELEMENT_VALLEY_CONTRACT from \"../../../contracts.v1/artifacts/valley.contract.json\";\nimport ELEMENT_RIVER_CONTRACT from \"../../../contracts.v1/artifacts/river.contract.json\";\nimport ELEMENT_SCORCHED_EARTH_CONTRACT from \"../../../contracts.v1/artifacts/scorched_earth.contract.json\";\nimport ELEMENT_DELTA_CONTRACT from \"../../../contracts.v1/artifacts/delta.contract.json\";\nimport ELEMENT_ESTUARY_CONTRACT from \"../../../contracts.v1/artifacts/estuary.contract.json\";\nimport ELEMENT_FIRE_SWAMP_CONTRACT from \"../../../contracts.v1/artifacts/fire_swamp.contract.json\";\nimport ELEMENT_RIVERBANK_CONTRACT from \"../../../contracts.v1/artifacts/riverbank.contract.json\";\nimport ELEMENT_RAVINE_CONTRACT from \"../../../contracts.v1/artifacts/ravine.contract.json\";\nimport ELEMENT_GORGE_CONTRACT from \"../../../contracts.v1/artifacts/gorge.contract.json\";\nimport ELEMENT_CHARRED_RAVINE_CONTRACT from \"../../../contracts.v1/artifacts/charred_ravine.contract.json\";\nimport ELEMENT_ECHO_CONTRACT from \"../../../contracts.v1/artifacts/echo.contract.json\";\nimport ELEMENT_CAVE_CONTRACT from \"../../../contracts.v1/artifacts/cave.contract.json\";\nimport ELEMENT_UNDERGROUND_LAKE_CONTRACT from \"../../../contracts.v1/artifacts/underground_lake.contract.json\";\nimport ELEMENT_LAVA_CAVE_CONTRACT from \"../../../contracts.v1/artifacts/lava_cave.contract.json\";\nimport ELEMENT_WHISPERING_CAVE_CONTRACT from \"../../../contracts.v1/artifacts/whispering_cave.contract.json\";\nimport ELEMENT_SUBTERRANEAN_POOL_CONTRACT from \"../../../contracts.v1/artifacts/subterranean_pool.contract.json\";\nimport ELEMENT_SPRING_CONTRACT from \"../../../contracts.v1/artifacts/spring.contract.json\";\nimport ELEMENT_HOT_SPRING_CONTRACT from \"../../../contracts.v1/artifacts/hot_spring.contract.json\";\nimport ELEMENT_GROTTO_CONTRACT from \"../../../contracts.v1/artifacts/grotto.contract.json\";\nimport ELEMENT_FOUNTAIN_CONTRACT from \"../../../contracts.v1/artifacts/fountain.contract.json\";\nimport ELEMENT_STEAM_VENT_CONTRACT from \"../../../contracts.v1/artifacts/steam_vent.contract.json\";\nimport ELEMENT_COOL_BREEZE_CONTRACT from \"../../../contracts.v1/artifacts/cool_breeze.contract.json\";\nimport ELEMENT_MONUMENT_CONTRACT from \"../../../contracts.v1/artifacts/monument.contract.json\";\nimport ELEMENT_WATERFALL_CONTRACT from \"../../../contracts.v1/artifacts/waterfall.contract.json\";\nimport ELEMENT_ETERNAL_FLAME_CONTRACT from \"../../../contracts.v1/artifacts/eternal_flame.contract.json\";\nimport ELEMENT_PILLAR_OF_WIND_CONTRACT from \"../../../contracts.v1/artifacts/pillar_of_wind.contract.json\";\nimport ELEMENT_STREAM_CONTRACT from \"../../../contracts.v1/artifacts/stream.contract.json\";\nimport ELEMENT_ZEPHYR_CONTRACT from \"../../../contracts.v1/artifacts/zephyr.contract.json\";\nimport ELEMENT_CREEK_CONTRACT from \"../../../contracts.v1/artifacts/creek.contract.json\";\nimport ELEMENT_BROOK_CONTRACT from \"../../../contracts.v1/artifacts/brook.contract.json\";\nimport ELEMENT_WHISPER_CONTRACT from \"../../../contracts.v1/artifacts/whisper.contract.json\";\nimport ELEMENT_RIVULET_CONTRACT from \"../../../contracts.v1/artifacts/rivulet.contract.json\";\nimport ELEMENT_TRIBUTARY_CONTRACT from \"../../../contracts.v1/artifacts/tributary.contract.json\";\nimport ELEMENT_MURMUR_CONTRACT from \"../../../contracts.v1/artifacts/murmur.contract.json\";\nimport ELEMENT_WATERSHED_CONTRACT from \"../../../contracts.v1/artifacts/watershed.contract.json\";\nimport ELEMENT_AQUIFER_CONTRACT from \"../../../contracts.v1/artifacts/aquifer.contract.json\";\nimport ELEMENT_PARCHED_EARTH_CONTRACT from \"../../../contracts.v1/artifacts/parched_earth.contract.json\";\nimport ELEMENT_FRESH_BREEZE_CONTRACT from \"../../../contracts.v1/artifacts/fresh_breeze.contract.json\";\nimport ELEMENT_GROUNDWATER_CONTRACT from \"../../../contracts.v1/artifacts/groundwater.contract.json\";\nimport ELEMENT_RESERVOIR_CONTRACT from \"../../../contracts.v1/artifacts/reservoir.contract.json\";\nimport ELEMENT_GEOTHERMAL_SPRING_CONTRACT from \"../../../contracts.v1/artifacts/geothermal_spring.contract.json\";\nimport ELEMENT_ARTESIAN_WELL_CONTRACT from \"../../../contracts.v1/artifacts/artesian_well.contract.json\";\nimport ELEMENT_BASIN_CONTRACT from \"../../../contracts.v1/artifacts/basin.contract.json\";\nimport ELEMENT_LAKE_CONTRACT from \"../../../contracts.v1/artifacts/lake.contract.json\";\nimport ELEMENT_DRY_BASIN_CONTRACT from \"../../../contracts.v1/artifacts/dry_basin.contract.json\";\nimport ELEMENT_DEPRESSION_CONTRACT from \"../../../contracts.v1/artifacts/depression.contract.json\";\nimport ELEMENT_ISLAND_CONTRACT from \"../../../contracts.v1/artifacts/island.contract.json\";\nimport ELEMENT_LAGOON_CONTRACT from \"../../../contracts.v1/artifacts/lagoon.contract.json\";\nimport ELEMENT_WAVE_CONTRACT from \"../../../contracts.v1/artifacts/wave.contract.json\";\nimport ELEMENT_REEF_CONTRACT from \"../../../contracts.v1/artifacts/reef.contract.json\";\nimport ELEMENT_CORAL_CONTRACT from \"../../../contracts.v1/artifacts/coral.contract.json\";\nimport ELEMENT_WHIRL_CONTRACT from \"../../../contracts.v1/artifacts/whirl.contract.json\";\nimport ELEMENT_LIMESTONE_CONTRACT from \"../../../contracts.v1/artifacts/limestone.contract.json\";\nimport ELEMENT_KARST_CONTRACT from \"../../../contracts.v1/artifacts/karst.contract.json\";\nimport ELEMENT_QUICKLIME_CONTRACT from \"../../../contracts.v1/artifacts/quicklime.contract.json\";\nimport ELEMENT_BLOWHOLE_CONTRACT from \"../../../contracts.v1/artifacts/blowhole.contract.json\";\nimport { IDeployableGame } from \"./IDeployableGame\";\nimport { IDeployableElement } from \"./IDeployableElement\";\n\nexport const DEPLOYABLE_ELEMENTS: Array<IDeployableElement> = [\n    {\n        name: \"Monkey\",\n        description: \"We need a description here\",\n        contract: ELEMENT_MONKEY_CONTRACT,\n        id: 0,\n    },\n    {\n        name: \"Giraffe\",\n        description: \"We need a description here\",\n        contract: ELEMENT_GIRAFFE_CONTRACT,\n        id: 1,\n    },\n    {\n        name: \"Bee\",\n        description: \"We need a description here\",\n        contract: ELEMENT_BEE_CONTRACT,\n        id: 2,\n    },\n    {\n        name: \"Coin\",\n        description: \"We need a description here\",\n        contract: ELEMENT_COIN_CONTRACT,\n        id: 3,\n    },\n    {\n        name: \"Swarm\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SWARM_CONTRACT,\n        id: 4,\n    },\n    {\n        name: \"Hydra\",\n        description: \"We need a description here\",\n        contract: ELEMENT_HYDRA_CONTRACT,\n        id: 5,\n    },\n    {\n        name: \"Monkey Branch\",\n        description: \"We need a description here\",\n        contract: ELEMENT_MONKEY_BRANCH_CONTRACT,\n        id: 6,\n    },\n    {\n        name: \"Bridge\",\n        description: \"We need a description here\",\n        contract: ELEMENT_BRIDGE_CONTRACT,\n        id: 7,\n    },\n    {\n        name: \"Golden Gate\",\n        description: \"We need a description here\",\n        contract: ELEMENT_GOLDEN_GATE_CONTRACT,\n        id: 8,\n    },\n    {\n        name: \"Gold\",\n        description: \"We need a description here\",\n        contract: ELEMENT_GOLD_CONTRACT,\n        id: 9,\n    },\n    {\n        name: \"Silver\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SILVER_CONTRACT,\n        id: 10,\n    },\n    {\n        name: \"Rhodium\",\n        description: \"We need a description here\",\n        contract: ELEMENT_RHODIUM_CONTRACT,\n        id: 11,\n    },\n    {\n        name: \"Hive\",\n        description: \"We need a description here\",\n        contract: ELEMENT_HIVE_CONTRACT,\n        id: 12,\n    },\n    {\n        name: \"Transaction\",\n        description: \"We need a description here\",\n        contract: ELEMENT_TRANSACTION_CONTRACT,\n        id: 13,\n    },\n    {\n        name: \"Block\",\n        description: \"We need a description here\",\n        contract: ELEMENT_BLOCK_CONTRACT,\n        id: 14,\n    },\n    {\n        name: \"Blockchain\",\n        description: \"We need a description here\",\n        contract: ELEMENT_BLOCKCHAIN_CONTRACT,\n        id: 15,\n    },\n    {\n        name: \"Polkadot\",\n        description: \"We need a description here\",\n        contract: ELEMENT_POLKADOT_CONTRACT,\n        id: 16,\n    },\n    {\n        name: \"Peer Review\",\n        description: \"We need a description here\",\n        contract: ELEMENT_PEER_REVIEW_CONTRACT,\n        id: 17,\n    },\n    {\n        name: \"Cardano\",\n        description: \"We need a description here\",\n        contract: ELEMENT_CARDANO_CONTRACT,\n        id: 18,\n    },\n    {\n        name: \"Bear\",\n        description: \"We need a description here\",\n        contract: ELEMENT_BEAR_CONTRACT,\n        id: 19,\n    },\n    {\n        name: \"Beer\",\n        description: \"We need a description here\",\n        contract: ELEMENT_BEER_CONTRACT,\n        id: 20,\n    },\n    {\n        name: \"Lock\",\n        description: \"We need a description here\",\n        contract: ELEMENT_LOCK_CONTRACT,\n        id: 21,\n    },\n    {\n        name: \"Marmalade\",\n        description: \"We need a description here\",\n        contract: ELEMENT_MARMALADE_CONTRACT,\n        id: 22,\n    },\n    {\n        name: \"Super Marmalade\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SUPER_MARMALADE_CONTRACT,\n        id: 23,\n    },\n    {\n        name: \"Hyper Marmalade\",\n        description: \"We need a description here\",\n        contract: ELEMENT_HYPER_MARMALADE_CONTRACT,\n        id: 24,\n    },\n    {\n        name: \"Water\",\n        description: \"We need a description here\",\n        contract: ELEMENT_WATER_CONTRACT,\n        id: 25,\n    },\n    {\n        name: \"Fire\",\n        description: \"We need a description here\",\n        contract: ELEMENT_FIRE_CONTRACT,\n        id: 26,\n    },\n    {\n        name: \"Steam\",\n        description: \"We need a description here\",\n        contract: ELEMENT_STEAM_CONTRACT,\n        id: 27,\n    },\n    {\n        name: \"Earth\",\n        description: \"We need a description here\",\n        contract: ELEMENT_EARTH_CONTRACT,\n        id: 28,\n    },\n    {\n        name: \"Mud\",\n        description: \"We need a description here\",\n        contract: ELEMENT_MUD_CONTRACT,\n        id: 29,\n    },\n    {\n        name: \"Lava\",\n        description: \"We need a description here\",\n        contract: ELEMENT_LAVA_CONTRACT,\n        id: 30,\n    },\n    {\n        name: \"Wind\",\n        description: \"We need a description here\",\n        contract: ELEMENT_WIND_CONTRACT,\n        id: 31,\n    },\n    {\n        name: \"Dust\",\n        description: \"We need a description here\",\n        contract: ELEMENT_DUST_CONTRACT,\n        id: 32,\n    },\n    {\n        name: \"Rain\",\n        description: \"We need a description here\",\n        contract: ELEMENT_RAIN_CONTRACT,\n        id: 33,\n    },\n    {\n        name: \"Smoke\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SMOKE_CONTRACT,\n        id: 34,\n    },\n    {\n        name: \"Geyser\",\n        description: \"We need a description here\",\n        contract: ELEMENT_GEYSER_CONTRACT,\n        id: 35,\n    },\n    {\n        name: \"Clay\",\n        description: \"We need a description here\",\n        contract: ELEMENT_CLAY_CONTRACT,\n        id: 36,\n    },\n    {\n        name: \"Sand\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SAND_CONTRACT,\n        id: 37,\n    },\n    {\n        name: \"Plant\",\n        description: \"We need a description here\",\n        contract: ELEMENT_PLANT_CONTRACT,\n        id: 38,\n    },\n    {\n        name: \"Rainbow\",\n        description: \"We need a description here\",\n        contract: ELEMENT_RAINBOW_CONTRACT,\n        id: 39,\n    },\n    {\n        name: \"Storm\",\n        description: \"We need a description here\",\n        contract: ELEMENT_STORM_CONTRACT,\n        id: 40,\n    },\n    {\n        name: \"Obsidian\",\n        description: \"We need a description here\",\n        contract: ELEMENT_OBSIDIAN_CONTRACT,\n        id: 41,\n    },\n    {\n        name: \"Ash\",\n        description: \"We need a description here\",\n        contract: ELEMENT_ASH_CONTRACT,\n        id: 42,\n    },\n    {\n        name: \"Volcano\",\n        description: \"We need a description here\",\n        contract: ELEMENT_VOLCANO_CONTRACT,\n        id: 43,\n    },\n    {\n        name: \"Sandstorm\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SANDSTORM_CONTRACT,\n        id: 44,\n    },\n    {\n        name: \"Cloud\",\n        description: \"We need a description here\",\n        contract: ELEMENT_CLOUD_CONTRACT,\n        id: 45,\n    },\n    {\n        name: \"Fog\",\n        description: \"We need a description here\",\n        contract: ELEMENT_FOG_CONTRACT,\n        id: 46,\n    },\n    {\n        name: \"Tree\",\n        description: \"We need a description here\",\n        contract: ELEMENT_TREE_CONTRACT,\n        id: 47,\n    },\n    {\n        name: \"Forest\",\n        description: \"We need a description here\",\n        contract: ELEMENT_FOREST_CONTRACT,\n        id: 48,\n    },\n    {\n        name: \"Seeds\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SEEDS_CONTRACT,\n        id: 49,\n    },\n    {\n        name: \"Pottery\",\n        description: \"We need a description here\",\n        contract: ELEMENT_POTTERY_CONTRACT,\n        id: 50,\n    },\n    {\n        name: \"Brick\",\n        description: \"We need a description here\",\n        contract: ELEMENT_BRICK_CONTRACT,\n        id: 51,\n    },\n    {\n        name: \"Quicksand\",\n        description: \"We need a description here\",\n        contract: ELEMENT_QUICKSAND_CONTRACT,\n        id: 52,\n    },\n    {\n        name: \"Glass\",\n        description: \"We need a description here\",\n        contract: ELEMENT_GLASS_CONTRACT,\n        id: 53,\n    },\n    {\n        name: \"Dune\",\n        description: \"We need a description here\",\n        contract: ELEMENT_DUNE_CONTRACT,\n        id: 54,\n    },\n    {\n        name: \"Charcoal\",\n        description: \"We need a description here\",\n        contract: ELEMENT_CHARCOAL_CONTRACT,\n        id: 55,\n    },\n    {\n        name: \"Leaves\",\n        description: \"We need a description here\",\n        contract: ELEMENT_LEAVES_CONTRACT,\n        id: 56,\n    },\n    {\n        name: \"Wildfire\",\n        description: \"We need a description here\",\n        contract: ELEMENT_WILDFIRE_CONTRACT,\n        id: 57,\n    },\n    {\n        name: \"Jungle\",\n        description: \"We need a description here\",\n        contract: ELEMENT_JUNGLE_CONTRACT,\n        id: 58,\n    },\n    {\n        name: \"Frosted Glass\",\n        description: \"We need a description here\",\n        contract: ELEMENT_FROSTED_GLASS_CONTRACT,\n        id: 59,\n    },\n    {\n        name: \"Crystal\",\n        description: \"We need a description here\",\n        contract: ELEMENT_CRYSTAL_CONTRACT,\n        id: 60,\n    },\n    {\n        name: \"Magma\",\n        description: \"We need a description here\",\n        contract: ELEMENT_MAGMA_CONTRACT,\n        id: 61,\n    },\n    {\n        name: \"Rock\",\n        description: \"We need a description here\",\n        contract: ELEMENT_ROCK_CONTRACT,\n        id: 62,\n    },\n    {\n        name: \"Shard\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SHARD_CONTRACT,\n        id: 63,\n    },\n    {\n        name: \"Pebble\",\n        description: \"We need a description here\",\n        contract: ELEMENT_PEBBLE_CONTRACT,\n        id: 64,\n    },\n    {\n        name: \"Mountain\",\n        description: \"We need a description here\",\n        contract: ELEMENT_MOUNTAIN_CONTRACT,\n        id: 65,\n    },\n    {\n        name: \"Fertilizer\",\n        description: \"We need a description here\",\n        contract: ELEMENT_FERTILIZER_CONTRACT,\n        id: 66,\n    },\n    {\n        name: \"Soot\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SOOT_CONTRACT,\n        id: 67,\n    },\n    {\n        name: \"Lightning\",\n        description: \"We need a description here\",\n        contract: ELEMENT_LIGHTNING_CONTRACT,\n        id: 68,\n    },\n    {\n        name: \"Mist\",\n        description: \"We need a description here\",\n        contract: ELEMENT_MIST_CONTRACT,\n        id: 69,\n    },\n    {\n        name: \"Haze\",\n        description: \"We need a description here\",\n        contract: ELEMENT_HAZE_CONTRACT,\n        id: 70,\n    },\n    {\n        name: \"Flood\",\n        description: \"We need a description here\",\n        contract: ELEMENT_FLOOD_CONTRACT,\n        id: 71,\n    },\n    {\n        name: \"Landslide\",\n        description: \"We need a description here\",\n        contract: ELEMENT_LANDSLIDE_CONTRACT,\n        id: 72,\n    },\n    {\n        name: \"Thunder\",\n        description: \"We need a description here\",\n        contract: ELEMENT_THUNDER_CONTRACT,\n        id: 73,\n    },\n    {\n        name: \"Tornado\",\n        description: \"We need a description here\",\n        contract: ELEMENT_TORNADO_CONTRACT,\n        id: 74,\n    },\n    {\n        name: \"Garden\",\n        description: \"We need a description here\",\n        contract: ELEMENT_GARDEN_CONTRACT,\n        id: 75,\n    },\n    {\n        name: \"Ember\",\n        description: \"We need a description here\",\n        contract: ELEMENT_EMBER_CONTRACT,\n        id: 76,\n    },\n    {\n        name: \"Kiln\",\n        description: \"We need a description here\",\n        contract: ELEMENT_KILN_CONTRACT,\n        id: 77,\n    },\n    {\n        name: \"Pollination\",\n        description: \"We need a description here\",\n        contract: ELEMENT_POLLINATION_CONTRACT,\n        id: 78,\n    },\n    {\n        name: \"Sinkhole\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SINKHOLE_CONTRACT,\n        id: 79,\n    },\n    {\n        name: \"Beach\",\n        description: \"We need a description here\",\n        contract: ELEMENT_BEACH_CONTRACT,\n        id: 80,\n    },\n    {\n        name: \"Wetstone\",\n        description: \"We need a description here\",\n        contract: ELEMENT_WETSTONE_CONTRACT,\n        id: 81,\n    },\n    {\n        name: \"Erosion\",\n        description: \"We need a description here\",\n        contract: ELEMENT_EROSION_CONTRACT,\n        id: 82,\n    },\n    {\n        name: \"Basalt\",\n        description: \"We need a description here\",\n        contract: ELEMENT_BASALT_CONTRACT,\n        id: 83,\n    },\n    {\n        name: \"Magma Chamber\",\n        description: \"We need a description here\",\n        contract: ELEMENT_MAGMA_CHAMBER_CONTRACT,\n        id: 84,\n    },\n    {\n        name: \"Breeze\",\n        description: \"We need a description here\",\n        contract: ELEMENT_BREEZE_CONTRACT,\n        id: 85,\n    },\n    {\n        name: \"Warm Breeze\",\n        description: \"We need a description here\",\n        contract: ELEMENT_WARM_BREEZE_CONTRACT,\n        id: 86,\n    },\n    {\n        name: \"Soil\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SOIL_CONTRACT,\n        id: 87,\n    },\n    {\n        name: \"Canyon\",\n        description: \"We need a description here\",\n        contract: ELEMENT_CANYON_CONTRACT,\n        id: 88,\n    },\n    {\n        name: \"Windmill\",\n        description: \"We need a description here\",\n        contract: ELEMENT_WINDMILL_CONTRACT,\n        id: 89,\n    },\n    {\n        name: \"Adobe\",\n        description: \"We need a description here\",\n        contract: ELEMENT_ADOBE_CONTRACT,\n        id: 90,\n    },\n    {\n        name: \"Wall\",\n        description: \"We need a description here\",\n        contract: ELEMENT_WALL_CONTRACT,\n        id: 91,\n    },\n    {\n        name: \"Pumice\",\n        description: \"We need a description here\",\n        contract: ELEMENT_PUMICE_CONTRACT,\n        id: 92,\n    },\n    {\n        name: \"Barbecue\",\n        description: \"We need a description here\",\n        contract: ELEMENT_BARBECUE_CONTRACT,\n        id: 93,\n    },\n    {\n        name: \"Farm\",\n        description: \"We need a description here\",\n        contract: ELEMENT_FARM_CONTRACT,\n        id: 94,\n    },\n    {\n        name: \"Shards\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SHARDS_CONTRACT,\n        id: 95,\n    },\n    {\n        name: \"Molten Glass\",\n        description: \"We need a description here\",\n        contract: ELEMENT_MOLTEN_GLASS_CONTRACT,\n        id: 96,\n    },\n    {\n        name: \"Prism\",\n        description: \"We need a description here\",\n        contract: ELEMENT_PRISM_CONTRACT,\n        id: 97,\n    },\n    {\n        name: \"Sparkle\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SPARKLE_CONTRACT,\n        id: 98,\n    },\n    {\n        name: \"Desert\",\n        description: \"We need a description here\",\n        contract: ELEMENT_DESERT_CONTRACT,\n        id: 99,\n    },\n    {\n        name: \"Oasis\",\n        description: \"We need a description here\",\n        contract: ELEMENT_OASIS_CONTRACT,\n        id: 100,\n    },\n    {\n        name: \"Mirage\",\n        description: \"We need a description here\",\n        contract: ELEMENT_MIRAGE_CONTRACT,\n        id: 101,\n    },\n    {\n        name: \"Sand Dune\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SAND_DUNE_CONTRACT,\n        id: 102,\n    },\n    {\n        name: \"Dam\",\n        description: \"We need a description here\",\n        contract: ELEMENT_DAM_CONTRACT,\n        id: 103,\n    },\n    {\n        name: \"Firewall\",\n        description: \"We need a description here\",\n        contract: ELEMENT_FIREWALL_CONTRACT,\n        id: 104,\n    },\n    {\n        name: \"Barricade\",\n        description: \"We need a description here\",\n        contract: ELEMENT_BARRICADE_CONTRACT,\n        id: 105,\n    },\n    {\n        name: \"Plateau\",\n        description: \"We need a description here\",\n        contract: ELEMENT_PLATEAU_CONTRACT,\n        id: 106,\n    },\n    {\n        name: \"Pond\",\n        description: \"We need a description here\",\n        contract: ELEMENT_POND_CONTRACT,\n        id: 107,\n    },\n    {\n        name: \"Aromas\",\n        description: \"We need a description here\",\n        contract: ELEMENT_AROMAS_CONTRACT,\n        id: 108,\n    },\n    {\n        name: \"Flower\",\n        description: \"We need a description here\",\n        contract: ELEMENT_FLOWER_CONTRACT,\n        id: 109,\n    },\n    {\n        name: \"Spore\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SPORE_CONTRACT,\n        id: 110,\n    },\n    {\n        name: \"Spread\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SPREAD_CONTRACT,\n        id: 111,\n    },\n    {\n        name: \"Fertile Land\",\n        description: \"We need a description here\",\n        contract: ELEMENT_FERTILE_LAND_CONTRACT,\n        id: 112,\n    },\n    {\n        name: \"Wetland\",\n        description: \"We need a description here\",\n        contract: ELEMENT_WETLAND_CONTRACT,\n        id: 113,\n    },\n    {\n        name: \"Peat\",\n        description: \"We need a description here\",\n        contract: ELEMENT_PEAT_CONTRACT,\n        id: 114,\n    },\n    {\n        name: \"Reeds\",\n        description: \"We need a description here\",\n        contract: ELEMENT_REEDS_CONTRACT,\n        id: 115,\n    },\n    {\n        name: \"Valley\",\n        description: \"We need a description here\",\n        contract: ELEMENT_VALLEY_CONTRACT,\n        id: 116,\n    },\n    {\n        name: \"River\",\n        description: \"We need a description here\",\n        contract: ELEMENT_RIVER_CONTRACT,\n        id: 117,\n    },\n    {\n        name: \"Scorched Earth\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SCORCHED_EARTH_CONTRACT,\n        id: 118,\n    },\n    {\n        name: \"Delta\",\n        description: \"We need a description here\",\n        contract: ELEMENT_DELTA_CONTRACT,\n        id: 119,\n    },\n    {\n        name: \"Estuary\",\n        description: \"We need a description here\",\n        contract: ELEMENT_ESTUARY_CONTRACT,\n        id: 120,\n    },\n    {\n        name: \"Fire Swamp\",\n        description: \"We need a description here\",\n        contract: ELEMENT_FIRE_SWAMP_CONTRACT,\n        id: 121,\n    },\n    {\n        name: \"Riverbank\",\n        description: \"We need a description here\",\n        contract: ELEMENT_RIVERBANK_CONTRACT,\n        id: 122,\n    },\n    {\n        name: \"Ravine\",\n        description: \"We need a description here\",\n        contract: ELEMENT_RAVINE_CONTRACT,\n        id: 123,\n    },\n    {\n        name: \"Gorge\",\n        description: \"We need a description here\",\n        contract: ELEMENT_GORGE_CONTRACT,\n        id: 124,\n    },\n    {\n        name: \"Charred Ravine\",\n        description: \"We need a description here\",\n        contract: ELEMENT_CHARRED_RAVINE_CONTRACT,\n        id: 125,\n    },\n    {\n        name: \"Echo\",\n        description: \"We need a description here\",\n        contract: ELEMENT_ECHO_CONTRACT,\n        id: 126,\n    },\n    {\n        name: \"Cave\",\n        description: \"We need a description here\",\n        contract: ELEMENT_CAVE_CONTRACT,\n        id: 127,\n    },\n    {\n        name: \"Underground Lake\",\n        description: \"We need a description here\",\n        contract: ELEMENT_UNDERGROUND_LAKE_CONTRACT,\n        id: 128,\n    },\n    {\n        name: \"Lava Cave\",\n        description: \"We need a description here\",\n        contract: ELEMENT_LAVA_CAVE_CONTRACT,\n        id: 129,\n    },\n    {\n        name: \"Whispering Cave\",\n        description: \"We need a description here\",\n        contract: ELEMENT_WHISPERING_CAVE_CONTRACT,\n        id: 130,\n    },\n    {\n        name: \"Subterranean Pool\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SUBTERRANEAN_POOL_CONTRACT,\n        id: 131,\n    },\n    {\n        name: \"Spring\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SPRING_CONTRACT,\n        id: 132,\n    },\n    {\n        name: \"Hot Spring\",\n        description: \"We need a description here\",\n        contract: ELEMENT_HOT_SPRING_CONTRACT,\n        id: 133,\n    },\n    {\n        name: \"Grotto\",\n        description: \"We need a description here\",\n        contract: ELEMENT_GROTTO_CONTRACT,\n        id: 134,\n    },\n    {\n        name: \"Fountain\",\n        description: \"We need a description here\",\n        contract: ELEMENT_FOUNTAIN_CONTRACT,\n        id: 135,\n    },\n    {\n        name: \"Steam Vent\",\n        description: \"We need a description here\",\n        contract: ELEMENT_STEAM_VENT_CONTRACT,\n        id: 136,\n    },\n    {\n        name: \"Cool Breeze\",\n        description: \"We need a description here\",\n        contract: ELEMENT_COOL_BREEZE_CONTRACT,\n        id: 137,\n    },\n    {\n        name: \"Monument\",\n        description: \"We need a description here\",\n        contract: ELEMENT_MONUMENT_CONTRACT,\n        id: 138,\n    },\n    {\n        name: \"Waterfall\",\n        description: \"We need a description here\",\n        contract: ELEMENT_WATERFALL_CONTRACT,\n        id: 139,\n    },\n    {\n        name: \"Eternal Flame\",\n        description: \"We need a description here\",\n        contract: ELEMENT_ETERNAL_FLAME_CONTRACT,\n        id: 140,\n    },\n    {\n        name: \"Pillar Of Wind\",\n        description: \"We need a description here\",\n        contract: ELEMENT_PILLAR_OF_WIND_CONTRACT,\n        id: 141,\n    },\n    {\n        name: \"Stream\",\n        description: \"We need a description here\",\n        contract: ELEMENT_STREAM_CONTRACT,\n        id: 142,\n    },\n    {\n        name: \"Zephyr\",\n        description: \"We need a description here\",\n        contract: ELEMENT_ZEPHYR_CONTRACT,\n        id: 143,\n    },\n    {\n        name: \"Creek\",\n        description: \"We need a description here\",\n        contract: ELEMENT_CREEK_CONTRACT,\n        id: 144,\n    },\n    {\n        name: \"Brook\",\n        description: \"We need a description here\",\n        contract: ELEMENT_BROOK_CONTRACT,\n        id: 145,\n    },\n    {\n        name: \"Whisper\",\n        description: \"We need a description here\",\n        contract: ELEMENT_WHISPER_CONTRACT,\n        id: 146,\n    },\n    {\n        name: \"Rivulet\",\n        description: \"We need a description here\",\n        contract: ELEMENT_RIVULET_CONTRACT,\n        id: 147,\n    },\n    {\n        name: \"Tributary\",\n        description: \"We need a description here\",\n        contract: ELEMENT_TRIBUTARY_CONTRACT,\n        id: 148,\n    },\n    {\n        name: \"Murmur\",\n        description: \"We need a description here\",\n        contract: ELEMENT_MURMUR_CONTRACT,\n        id: 149,\n    },\n    {\n        name: \"Watershed\",\n        description: \"We need a description here\",\n        contract: ELEMENT_WATERSHED_CONTRACT,\n        id: 150,\n    },\n    {\n        name: \"Aquifer\",\n        description: \"We need a description here\",\n        contract: ELEMENT_AQUIFER_CONTRACT,\n        id: 151,\n    },\n    {\n        name: \"Parched Earth\",\n        description: \"We need a description here\",\n        contract: ELEMENT_PARCHED_EARTH_CONTRACT,\n        id: 152,\n    },\n    {\n        name: \"Fresh Breeze\",\n        description: \"We need a description here\",\n        contract: ELEMENT_FRESH_BREEZE_CONTRACT,\n        id: 153,\n    },\n    {\n        name: \"Groundwater\",\n        description: \"We need a description here\",\n        contract: ELEMENT_GROUNDWATER_CONTRACT,\n        id: 154,\n    },\n    {\n        name: \"Reservoir\",\n        description: \"We need a description here\",\n        contract: ELEMENT_RESERVOIR_CONTRACT,\n        id: 155,\n    },\n    {\n        name: \"Geothermal Spring\",\n        description: \"We need a description here\",\n        contract: ELEMENT_GEOTHERMAL_SPRING_CONTRACT,\n        id: 156,\n    },\n    {\n        name: \"Artesian Well\",\n        description: \"We need a description here\",\n        contract: ELEMENT_ARTESIAN_WELL_CONTRACT,\n        id: 157,\n    },\n    {\n        name: \"Basin\",\n        description: \"We need a description here\",\n        contract: ELEMENT_BASIN_CONTRACT,\n        id: 158,\n    },\n    {\n        name: \"Lake\",\n        description: \"We need a description here\",\n        contract: ELEMENT_LAKE_CONTRACT,\n        id: 159,\n    },\n    {\n        name: \"Dry Basin\",\n        description: \"We need a description here\",\n        contract: ELEMENT_DRY_BASIN_CONTRACT,\n        id: 160,\n    },\n    {\n        name: \"Depression\",\n        description: \"We need a description here\",\n        contract: ELEMENT_DEPRESSION_CONTRACT,\n        id: 161,\n    },\n    {\n        name: \"Island\",\n        description: \"We need a description here\",\n        contract: ELEMENT_ISLAND_CONTRACT,\n        id: 162,\n    },\n    {\n        name: \"Lagoon\",\n        description: \"We need a description here\",\n        contract: ELEMENT_LAGOON_CONTRACT,\n        id: 163,\n    },\n    {\n        name: \"Wave\",\n        description: \"We need a description here\",\n        contract: ELEMENT_WAVE_CONTRACT,\n        id: 164,\n    },\n    {\n        name: \"Reef\",\n        description: \"We need a description here\",\n        contract: ELEMENT_REEF_CONTRACT,\n        id: 165,\n    },\n    {\n        name: \"Coral\",\n        description: \"We need a description here\",\n        contract: ELEMENT_CORAL_CONTRACT,\n        id: 166,\n    },\n    {\n        name: \"Whirl\",\n        description: \"We need a description here\",\n        contract: ELEMENT_WHIRL_CONTRACT,\n        id: 167,\n    },\n    {\n        name: \"Limestone\",\n        description: \"We need a description here\",\n        contract: ELEMENT_LIMESTONE_CONTRACT,\n        id: 168,\n    },\n    {\n        name: \"Karst\",\n        description: \"We need a description here\",\n        contract: ELEMENT_KARST_CONTRACT,\n        id: 169,\n    },\n    {\n        name: \"Quicklime\",\n        description: \"We need a description here\",\n        contract: ELEMENT_QUICKLIME_CONTRACT,\n        id: 170,\n    },\n    {\n        name: \"Blowhole\",\n        description: \"We need a description here\",\n        contract: ELEMENT_BLOWHOLE_CONTRACT,\n        id: 171,\n    },\n];\n\nconst UNIFIERS_ELEMENT_CONTRACTS: Record<number, any> = {\n    [0]: ELEMENT_MONKEY_CONTRACT,\n    [1]: ELEMENT_GIRAFFE_CONTRACT,\n    [2]: ELEMENT_BEE_CONTRACT,\n    [3]: ELEMENT_COIN_CONTRACT,\n    [4]: ELEMENT_SWARM_CONTRACT,\n    [5]: ELEMENT_HYDRA_CONTRACT,\n    [6]: ELEMENT_MONKEY_BRANCH_CONTRACT,\n    [7]: ELEMENT_BRIDGE_CONTRACT,\n    [8]: ELEMENT_GOLDEN_GATE_CONTRACT,\n    [9]: ELEMENT_GOLD_CONTRACT,\n    [10]: ELEMENT_SILVER_CONTRACT,\n    [11]: ELEMENT_RHODIUM_CONTRACT,\n    [12]: ELEMENT_HIVE_CONTRACT,\n    [13]: ELEMENT_TRANSACTION_CONTRACT,\n    [14]: ELEMENT_BLOCK_CONTRACT,\n    [15]: ELEMENT_BLOCKCHAIN_CONTRACT,\n    [16]: ELEMENT_POLKADOT_CONTRACT,\n    [17]: ELEMENT_PEER_REVIEW_CONTRACT,\n    [18]: ELEMENT_CARDANO_CONTRACT,\n    [19]: ELEMENT_BEAR_CONTRACT,\n    [20]: ELEMENT_BEER_CONTRACT,\n    [21]: ELEMENT_LOCK_CONTRACT,\n    [22]: ELEMENT_MARMALADE_CONTRACT,\n    [23]: ELEMENT_SUPER_MARMALADE_CONTRACT,\n    [24]: ELEMENT_HYPER_MARMALADE_CONTRACT,\n};\n\nexport const DEPLOYABLE_UNIFIERS: IDeployableGame = {\n    name: \"Unifiers\",\n    description: \"A game created with the help of the Unifiers group\",\n    gameContract: UNIFIERS_CONTRACT,\n    elementContracts: UNIFIERS_ELEMENT_CONTRACTS,\n    otherNames: {\n        camelCase: \"unifiers\",\n        snakeCase: \"unifiers\",\n        kebabCase: \"unifiers\",\n        pascalCase: \"Unifiers\",\n        constantCase: \"UNIFIERS\",\n    }\n};\nconst ELEMENTY_ELEMENT_CONTRACTS: Record<number, any> = {\n    [25]: ELEMENT_WATER_CONTRACT,\n    [26]: ELEMENT_FIRE_CONTRACT,\n    [27]: ELEMENT_STEAM_CONTRACT,\n    [28]: ELEMENT_EARTH_CONTRACT,\n    [29]: ELEMENT_MUD_CONTRACT,\n    [30]: ELEMENT_LAVA_CONTRACT,\n    [31]: ELEMENT_WIND_CONTRACT,\n    [32]: ELEMENT_DUST_CONTRACT,\n    [33]: ELEMENT_RAIN_CONTRACT,\n    [34]: ELEMENT_SMOKE_CONTRACT,\n    [35]: ELEMENT_GEYSER_CONTRACT,\n    [36]: ELEMENT_CLAY_CONTRACT,\n    [37]: ELEMENT_SAND_CONTRACT,\n    [38]: ELEMENT_PLANT_CONTRACT,\n    [39]: ELEMENT_RAINBOW_CONTRACT,\n    [40]: ELEMENT_STORM_CONTRACT,\n    [41]: ELEMENT_OBSIDIAN_CONTRACT,\n    [42]: ELEMENT_ASH_CONTRACT,\n    [43]: ELEMENT_VOLCANO_CONTRACT,\n    [44]: ELEMENT_SANDSTORM_CONTRACT,\n    [45]: ELEMENT_CLOUD_CONTRACT,\n    [46]: ELEMENT_FOG_CONTRACT,\n    [47]: ELEMENT_TREE_CONTRACT,\n    [48]: ELEMENT_FOREST_CONTRACT,\n    [49]: ELEMENT_SEEDS_CONTRACT,\n    [50]: ELEMENT_POTTERY_CONTRACT,\n    [51]: ELEMENT_BRICK_CONTRACT,\n    [52]: ELEMENT_QUICKSAND_CONTRACT,\n    [53]: ELEMENT_GLASS_CONTRACT,\n    [54]: ELEMENT_DUNE_CONTRACT,\n    [55]: ELEMENT_CHARCOAL_CONTRACT,\n    [56]: ELEMENT_LEAVES_CONTRACT,\n    [57]: ELEMENT_WILDFIRE_CONTRACT,\n    [58]: ELEMENT_JUNGLE_CONTRACT,\n    [59]: ELEMENT_FROSTED_GLASS_CONTRACT,\n    [60]: ELEMENT_CRYSTAL_CONTRACT,\n    [61]: ELEMENT_MAGMA_CONTRACT,\n    [62]: ELEMENT_ROCK_CONTRACT,\n    [63]: ELEMENT_SHARD_CONTRACT,\n    [64]: ELEMENT_PEBBLE_CONTRACT,\n    [65]: ELEMENT_MOUNTAIN_CONTRACT,\n    [66]: ELEMENT_FERTILIZER_CONTRACT,\n    [67]: ELEMENT_SOOT_CONTRACT,\n    [68]: ELEMENT_LIGHTNING_CONTRACT,\n    [69]: ELEMENT_MIST_CONTRACT,\n    [70]: ELEMENT_HAZE_CONTRACT,\n    [71]: ELEMENT_FLOOD_CONTRACT,\n    [72]: ELEMENT_LANDSLIDE_CONTRACT,\n    [73]: ELEMENT_THUNDER_CONTRACT,\n    [74]: ELEMENT_TORNADO_CONTRACT,\n    [75]: ELEMENT_GARDEN_CONTRACT,\n    [76]: ELEMENT_EMBER_CONTRACT,\n    [77]: ELEMENT_KILN_CONTRACT,\n    [78]: ELEMENT_POLLINATION_CONTRACT,\n    [79]: ELEMENT_SINKHOLE_CONTRACT,\n    [80]: ELEMENT_BEACH_CONTRACT,\n    [81]: ELEMENT_WETSTONE_CONTRACT,\n    [82]: ELEMENT_EROSION_CONTRACT,\n    [83]: ELEMENT_BASALT_CONTRACT,\n    [84]: ELEMENT_MAGMA_CHAMBER_CONTRACT,\n    [85]: ELEMENT_BREEZE_CONTRACT,\n    [86]: ELEMENT_WARM_BREEZE_CONTRACT,\n    [87]: ELEMENT_SOIL_CONTRACT,\n    [88]: ELEMENT_CANYON_CONTRACT,\n    [89]: ELEMENT_WINDMILL_CONTRACT,\n    [90]: ELEMENT_ADOBE_CONTRACT,\n    [91]: ELEMENT_WALL_CONTRACT,\n    [92]: ELEMENT_PUMICE_CONTRACT,\n    [93]: ELEMENT_BARBECUE_CONTRACT,\n    [94]: ELEMENT_FARM_CONTRACT,\n    [95]: ELEMENT_SHARDS_CONTRACT,\n    [96]: ELEMENT_MOLTEN_GLASS_CONTRACT,\n    [97]: ELEMENT_PRISM_CONTRACT,\n    [98]: ELEMENT_SPARKLE_CONTRACT,\n    [99]: ELEMENT_DESERT_CONTRACT,\n    [100]: ELEMENT_OASIS_CONTRACT,\n    [101]: ELEMENT_MIRAGE_CONTRACT,\n    [102]: ELEMENT_SAND_DUNE_CONTRACT,\n    [103]: ELEMENT_DAM_CONTRACT,\n    [104]: ELEMENT_FIREWALL_CONTRACT,\n    [105]: ELEMENT_BARRICADE_CONTRACT,\n    [106]: ELEMENT_PLATEAU_CONTRACT,\n    [107]: ELEMENT_POND_CONTRACT,\n    [108]: ELEMENT_AROMAS_CONTRACT,\n    [109]: ELEMENT_FLOWER_CONTRACT,\n    [110]: ELEMENT_SPORE_CONTRACT,\n    [111]: ELEMENT_SPREAD_CONTRACT,\n    [112]: ELEMENT_FERTILE_LAND_CONTRACT,\n    [113]: ELEMENT_WETLAND_CONTRACT,\n    [114]: ELEMENT_PEAT_CONTRACT,\n    [115]: ELEMENT_REEDS_CONTRACT,\n    [116]: ELEMENT_VALLEY_CONTRACT,\n    [117]: ELEMENT_RIVER_CONTRACT,\n    [118]: ELEMENT_SCORCHED_EARTH_CONTRACT,\n    [119]: ELEMENT_DELTA_CONTRACT,\n    [120]: ELEMENT_ESTUARY_CONTRACT,\n    [121]: ELEMENT_FIRE_SWAMP_CONTRACT,\n    [122]: ELEMENT_RIVERBANK_CONTRACT,\n    [123]: ELEMENT_RAVINE_CONTRACT,\n    [124]: ELEMENT_GORGE_CONTRACT,\n    [125]: ELEMENT_CHARRED_RAVINE_CONTRACT,\n    [126]: ELEMENT_ECHO_CONTRACT,\n    [127]: ELEMENT_CAVE_CONTRACT,\n    [128]: ELEMENT_UNDERGROUND_LAKE_CONTRACT,\n    [129]: ELEMENT_LAVA_CAVE_CONTRACT,\n    [130]: ELEMENT_WHISPERING_CAVE_CONTRACT,\n    [131]: ELEMENT_SUBTERRANEAN_POOL_CONTRACT,\n    [132]: ELEMENT_SPRING_CONTRACT,\n    [133]: ELEMENT_HOT_SPRING_CONTRACT,\n    [134]: ELEMENT_GROTTO_CONTRACT,\n    [135]: ELEMENT_FOUNTAIN_CONTRACT,\n    [136]: ELEMENT_STEAM_VENT_CONTRACT,\n    [137]: ELEMENT_COOL_BREEZE_CONTRACT,\n    [138]: ELEMENT_MONUMENT_CONTRACT,\n    [139]: ELEMENT_WATERFALL_CONTRACT,\n    [140]: ELEMENT_ETERNAL_FLAME_CONTRACT,\n    [141]: ELEMENT_PILLAR_OF_WIND_CONTRACT,\n    [142]: ELEMENT_STREAM_CONTRACT,\n    [143]: ELEMENT_ZEPHYR_CONTRACT,\n    [144]: ELEMENT_CREEK_CONTRACT,\n    [145]: ELEMENT_BROOK_CONTRACT,\n    [146]: ELEMENT_WHISPER_CONTRACT,\n    [147]: ELEMENT_RIVULET_CONTRACT,\n    [148]: ELEMENT_TRIBUTARY_CONTRACT,\n    [149]: ELEMENT_MURMUR_CONTRACT,\n    [150]: ELEMENT_WATERSHED_CONTRACT,\n    [151]: ELEMENT_AQUIFER_CONTRACT,\n    [152]: ELEMENT_PARCHED_EARTH_CONTRACT,\n    [153]: ELEMENT_FRESH_BREEZE_CONTRACT,\n    [154]: ELEMENT_GROUNDWATER_CONTRACT,\n    [155]: ELEMENT_RESERVOIR_CONTRACT,\n    [156]: ELEMENT_GEOTHERMAL_SPRING_CONTRACT,\n    [157]: ELEMENT_ARTESIAN_WELL_CONTRACT,\n    [158]: ELEMENT_BASIN_CONTRACT,\n    [159]: ELEMENT_LAKE_CONTRACT,\n    [160]: ELEMENT_DRY_BASIN_CONTRACT,\n    [161]: ELEMENT_DEPRESSION_CONTRACT,\n    [162]: ELEMENT_ISLAND_CONTRACT,\n    [163]: ELEMENT_LAGOON_CONTRACT,\n    [164]: ELEMENT_WAVE_CONTRACT,\n    [165]: ELEMENT_REEF_CONTRACT,\n    [166]: ELEMENT_CORAL_CONTRACT,\n    [167]: ELEMENT_WHIRL_CONTRACT,\n    [168]: ELEMENT_LIMESTONE_CONTRACT,\n    [169]: ELEMENT_KARST_CONTRACT,\n    [170]: ELEMENT_QUICKLIME_CONTRACT,\n    [171]: ELEMENT_BLOWHOLE_CONTRACT,\n};\n\nexport const DEPLOYABLE_ELEMENTY: IDeployableGame = {\n    name: \"Elementy\",\n    description: \"A game in which you combine elements to create new ones.\",\n    gameContract: ELEMENTY_CONTRACT,\n    elementContracts: ELEMENTY_ELEMENT_CONTRACTS,\n    otherNames: {\n        camelCase: \"elementy\",\n        snakeCase: \"elementy\",\n        kebabCase: \"elementy\",\n        pascalCase: \"Elementy\",\n        constantCase: \"ELEMENTY\",\n    }\n};\nexport const DEPLOYABLE_GAMES: Array<IDeployableGame> = [\n    DEPLOYABLE_UNIFIERS,\n    DEPLOYABLE_ELEMENTY,\n];",
      "contentHash": "7471e82b2252577158c479f2814fcf7be874c22f07b1327b6d16569d5f964a80",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements.md",
      "content": "# Elements\n\nIn _Not a Bird_ players own **elements**. Elements are full-fledged [cryptocurrencies](https://en.wikipedia.org/wiki/Cryptocurrency). They are created via _Smart Contracts_ deployed to a blockchain, and they support the [PSP-22 interface](https://github.com/w3f/PSPs/blob/master/PSPs/psp-22.md).\n\n## Tier number\n\nEach element has a **tier number**.\n\nThe _tier number_ is used when calculating the _buy price_ of elements. The game contract defines a so-called _buy offer_, which looks like this:\n\n```json\n{\n    \"nativeTokens\": \"1234.12345678\",\n    \"rewardTierPoints\": \"100\"\n}\n```\n\nThis means, that for `1234.12345678` of the _native token_ (the cryptocurrency you use to play the game), you can buy `100` _tier points_. You can convert these tier points in the buy transaction to _any element_.\n\nWhen you buy from the game contract, you will receive `floor(bought_tier_points / element_tier)` elements of the chosen element.\n\nYou must always pay an _integer multiple_ of the `nativeTokens` in the _buy offer_, because you will only get `floor(paid_tier_points / buy_offer_native_tokens) * buy_offer_reward_tier_points` tier points.\n\nElements, that cannot be crafted are \"_base elements_\", so we assign the _tier number_ `1` to them. Every other element has a tier number of `A + B + C`, where `A` and `B` are the tier numbers of the elements required to craft it, and `C` is a constant greater than zero.\n\n## List of elements\n\n* [Monkey](/wiki/elements/monkey)\n* [Giraffe](/wiki/elements/giraffe)\n* [Bee](/wiki/elements/bee)\n* [Coin](/wiki/elements/coin)\n* [Swarm](/wiki/elements/swarm)\n* [Hydra](/wiki/elements/hydra)\n* [Monkey Branch](/wiki/elements/monkey-branch)\n* [Bridge](/wiki/elements/bridge)\n* [Golden Gate](/wiki/elements/golden-gate)\n* [Gold](/wiki/elements/gold)\n* [Silver](/wiki/elements/silver)\n* [Rhodium](/wiki/elements/rhodium)\n* [Hive](/wiki/elements/hive)\n* [Transaction](/wiki/elements/transaction)\n* [Block](/wiki/elements/block)\n* [Blockchain](/wiki/elements/blockchain)\n* [Polkadot](/wiki/elements/polkadot)\n* [Peer Review](/wiki/elements/peer-review)\n* [Cardano](/wiki/elements/cardano)\n* [Bear](/wiki/elements/bear)\n* [Beer](/wiki/elements/beer)\n* [Lock](/wiki/elements/lock)\n* [Marmalade](/wiki/elements/marmalade)\n* [Super Marmalade](/wiki/elements/super-marmalade)\n* [Hyper Marmalade](/wiki/elements/hyper-marmalade)\n* [Water](/wiki/elements/water)\n* [Fire](/wiki/elements/fire)\n* [Steam](/wiki/elements/steam)\n* [Earth](/wiki/elements/earth)\n* [Mud](/wiki/elements/mud)\n* [Lava](/wiki/elements/lava)\n* [Wind](/wiki/elements/wind)\n* [Dust](/wiki/elements/dust)\n* [Rain](/wiki/elements/rain)\n* [Smoke](/wiki/elements/smoke)\n* [Geyser](/wiki/elements/geyser)\n* [Clay](/wiki/elements/clay)\n* [Sand](/wiki/elements/sand)\n* [Plant](/wiki/elements/plant)\n* [Rainbow](/wiki/elements/rainbow)\n* [Storm](/wiki/elements/storm)\n* [Obsidian](/wiki/elements/obsidian)\n* [Ash](/wiki/elements/ash)\n* [Volcano](/wiki/elements/volcano)\n* [Sandstorm](/wiki/elements/sandstorm)\n* [Cloud](/wiki/elements/cloud)\n* [Fog](/wiki/elements/fog)\n* [Tree](/wiki/elements/tree)\n* [Forest](/wiki/elements/forest)\n* [Seeds](/wiki/elements/seeds)\n* [Pottery](/wiki/elements/pottery)\n* [Brick](/wiki/elements/brick)\n* [Quicksand](/wiki/elements/quicksand)\n* [Glass](/wiki/elements/glass)\n* [Dune](/wiki/elements/dune)\n* [Charcoal](/wiki/elements/charcoal)\n* [Leaves](/wiki/elements/leaves)\n* [Wildfire](/wiki/elements/wildfire)\n* [Jungle](/wiki/elements/jungle)\n* [Frosted Glass](/wiki/elements/frosted-glass)\n* [Crystal](/wiki/elements/crystal)\n* [Magma](/wiki/elements/magma)\n* [Rock](/wiki/elements/rock)\n* [Shard](/wiki/elements/shard)\n* [Pebble](/wiki/elements/pebble)\n* [Mountain](/wiki/elements/mountain)\n* [Fertilizer](/wiki/elements/fertilizer)\n* [Soot](/wiki/elements/soot)\n* [Lightning](/wiki/elements/lightning)\n* [Mist](/wiki/elements/mist)\n* [Haze](/wiki/elements/haze)\n* [Flood](/wiki/elements/flood)\n* [Landslide](/wiki/elements/landslide)\n* [Thunder](/wiki/elements/thunder)\n* [Tornado](/wiki/elements/tornado)\n* [Garden](/wiki/elements/garden)\n* [Ember](/wiki/elements/ember)\n* [Kiln](/wiki/elements/kiln)\n* [Pollination](/wiki/elements/pollination)\n* [Sinkhole](/wiki/elements/sinkhole)\n* [Beach](/wiki/elements/beach)\n* [Wetstone](/wiki/elements/wetstone)\n* [Erosion](/wiki/elements/erosion)\n* [Basalt](/wiki/elements/basalt)\n* [Magma Chamber](/wiki/elements/magma-chamber)\n* [Breeze](/wiki/elements/breeze)\n* [Warm Breeze](/wiki/elements/warm-breeze)\n* [Soil](/wiki/elements/soil)\n* [Canyon](/wiki/elements/canyon)\n* [Windmill](/wiki/elements/windmill)\n* [Adobe](/wiki/elements/adobe)\n* [Wall](/wiki/elements/wall)\n* [Pumice](/wiki/elements/pumice)\n* [Barbecue](/wiki/elements/barbecue)\n* [Farm](/wiki/elements/farm)\n* [Shards](/wiki/elements/shards)\n* [Molten Glass](/wiki/elements/molten-glass)\n* [Prism](/wiki/elements/prism)\n* [Sparkle](/wiki/elements/sparkle)\n* [Desert](/wiki/elements/desert)\n* [Oasis](/wiki/elements/oasis)\n* [Mirage](/wiki/elements/mirage)\n* [Sand Dune](/wiki/elements/sand-dune)\n* [Dam](/wiki/elements/dam)\n* [Firewall](/wiki/elements/firewall)\n* [Barricade](/wiki/elements/barricade)\n* [Plateau](/wiki/elements/plateau)\n* [Pond](/wiki/elements/pond)\n* [Aromas](/wiki/elements/aromas)\n* [Flower](/wiki/elements/flower)\n* [Spore](/wiki/elements/spore)\n* [Spread](/wiki/elements/spread)\n* [Fertile Land](/wiki/elements/fertile-land)\n* [Wetland](/wiki/elements/wetland)\n* [Peat](/wiki/elements/peat)\n* [Reeds](/wiki/elements/reeds)\n* [Valley](/wiki/elements/valley)\n* [River](/wiki/elements/river)\n* [Scorched Earth](/wiki/elements/scorched-earth)\n* [Delta](/wiki/elements/delta)\n* [Estuary](/wiki/elements/estuary)\n* [Fire Swamp](/wiki/elements/fire-swamp)\n* [Riverbank](/wiki/elements/riverbank)\n* [Ravine](/wiki/elements/ravine)\n* [Gorge](/wiki/elements/gorge)\n* [Charred Ravine](/wiki/elements/charred-ravine)\n* [Echo](/wiki/elements/echo)\n* [Cave](/wiki/elements/cave)\n* [Underground Lake](/wiki/elements/underground-lake)\n* [Lava Cave](/wiki/elements/lava-cave)\n* [Whispering Cave](/wiki/elements/whispering-cave)\n* [Subterranean Pool](/wiki/elements/subterranean-pool)\n* [Spring](/wiki/elements/spring)\n* [Hot Spring](/wiki/elements/hot-spring)\n* [Grotto](/wiki/elements/grotto)\n* [Fountain](/wiki/elements/fountain)\n* [Steam Vent](/wiki/elements/steam-vent)\n* [Cool Breeze](/wiki/elements/cool-breeze)\n* [Monument](/wiki/elements/monument)\n* [Waterfall](/wiki/elements/waterfall)\n* [Eternal Flame](/wiki/elements/eternal-flame)\n* [Pillar Of Wind](/wiki/elements/pillar-of-wind)\n* [Stream](/wiki/elements/stream)\n* [Zephyr](/wiki/elements/zephyr)\n* [Creek](/wiki/elements/creek)\n* [Brook](/wiki/elements/brook)\n* [Whisper](/wiki/elements/whisper)\n* [Rivulet](/wiki/elements/rivulet)\n* [Tributary](/wiki/elements/tributary)\n* [Murmur](/wiki/elements/murmur)\n* [Watershed](/wiki/elements/watershed)\n* [Aquifer](/wiki/elements/aquifer)\n* [Parched Earth](/wiki/elements/parched-earth)\n* [Fresh Breeze](/wiki/elements/fresh-breeze)\n* [Groundwater](/wiki/elements/groundwater)\n* [Reservoir](/wiki/elements/reservoir)\n* [Geothermal Spring](/wiki/elements/geothermal-spring)\n* [Artesian Well](/wiki/elements/artesian-well)\n* [Basin](/wiki/elements/basin)\n* [Lake](/wiki/elements/lake)\n* [Dry Basin](/wiki/elements/dry-basin)\n* [Depression](/wiki/elements/depression)\n* [Island](/wiki/elements/island)\n* [Lagoon](/wiki/elements/lagoon)\n* [Wave](/wiki/elements/wave)\n* [Reef](/wiki/elements/reef)\n* [Coral](/wiki/elements/coral)\n* [Whirl](/wiki/elements/whirl)\n* [Limestone](/wiki/elements/limestone)\n* [Karst](/wiki/elements/karst)\n* [Quicklime](/wiki/elements/quicklime)\n* [Blowhole](/wiki/elements/blowhole)\n\nSee also:\n\n* [Games](/wiki/games)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "5f95db7dea0979ea718ab54d7476797914c8d8a6af4a281daefb6b6fb86a3a3d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/adobe.md",
      "content": "# Adobe\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "322bf9581ed83ef5b101958bee2554ae903be5b5aedee32b87aec757d80208bc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/aquifer.md",
      "content": "# Aquifer\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "7f2cbf95eb86f9671caa5d7b480a857238522cb5fdbdc7fcebb6e3911e92de94",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/aromas.md",
      "content": "# Aromas\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "14b73f5bbc95649411c1a30c5bae445ea1dd441066ea63234fc6bc6184f05cf5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/artesian-well.md",
      "content": "# Artesian Well\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "a013821890fedbc13a0997d3fdb7845fd71ff4f608208c2c932d330c006c7213",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/ash.md",
      "content": "# Ash\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "76957240e6dfefb4fc6b301b1b44c2efda1fa5a714f867b11986a47416e4993d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/barbecue.md",
      "content": "# Barbecue\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "ad18171a6e0c3c4eff730cf64555f6cebb6042371bb750ccbed7497a57d7f764",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/barricade.md",
      "content": "# Barricade\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "2e0d9d637cbe3ddf5ab0064610c7fdab70c16d96d053e9d55e2b36e3b466310b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/basalt.md",
      "content": "# Basalt\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "735ef985ef46796dca5e1d05e52f6a5ddfc7add0ddbedb137349a2d2db8a1843",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/basin.md",
      "content": "# Basin\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "149b6ecd0ed218b6062d19341c9678f085dee658418efd88b898dfb6406449a9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/beach.md",
      "content": "# Beach\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "8783ae398fbe71e35642cf3ea304ad5a6d7696359d5f8f31419c99b3a214ade0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/bear.md",
      "content": "# Bear\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "fe85213617bb23e91ef75ce2e9eadd100248ab6da041b070ff582e49bf2c34b4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/bee.md",
      "content": "# Bee\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "e47bd854ca3e985e1a9c20105a3ce04217cef78227c3b8f876f07a4d475d6b1f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/beer.md",
      "content": "# Beer\n\n**Tier**: 2\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "a199b85100a319b72829139bd085741e3379fdb6583e2d22596be15b3cbf0ce7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/block.md",
      "content": "# Block\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "b00ce34a2ef9fb492849cd59b6a3d11b144b0416c9a9d0da8352b9622423bbe7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/blockchain.md",
      "content": "# Blockchain\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "6a403f64f336eccb4f88acb49d4dde455513ba57e9fce435a328e815d79eda60",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/blowhole.md",
      "content": "# Blowhole\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "c5da4b904e4b3e478d6250224adf10124b8d98bc72de707d368fa2d85cae5df1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/breeze.md",
      "content": "# Breeze\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "cf7fd858aa94480ca66869dda10795d1feb26e9057d5e5672851385471f88dbd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/brick.md",
      "content": "# Brick\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "c8380894bd60f4727c55b08f9121adc3d2d48bd13073bab5a87a3f53348b0199",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/bridge.md",
      "content": "# Bridge\n\n**Tier**: 2\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "43961578c1427cba7817c963b9b980f50203d81dd17f7fb9a2eeb2d1d784b922",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/brook.md",
      "content": "# Brook\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "0b660003539b89b6d67869a413900d7c506d1cefebcd2c1d46bfc11ba39aca2f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/canyon.md",
      "content": "# Canyon\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "70bb41d170e9fcffd0b67dd4be67139c7c22dab9d1fd75bde30bb22dc9d6c559",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/cardano.md",
      "content": "# Cardano\n\n**Tier**: 2\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "9c66ce56a76e63e6a510b55f1102899fbb02db26542709969c502e9d345cb085",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/cave.md",
      "content": "# Cave\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "930a1cbaf70b75d0a763a61a6b3e2ad0d5b67dbe10d30cb7b453f6dba8e35034",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/charcoal.md",
      "content": "# Charcoal\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "fad8d9d22c1d566a8ac3752ae27cac67822632417a3d93b549e4e1c9c423c401",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/charred-ravine.md",
      "content": "# Charred Ravine\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "73e0d37428ba07f95e9d92c8c69e608ddc0c157f4025e3722fc13349ce650c2a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/clay.md",
      "content": "# Clay\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "7d71b6ec1a0da89daa608953b9e076f9621773b2c3325b48433388859af5ddfe",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/cloud.md",
      "content": "# Cloud\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "7a5aa46c38b19aeec67b0c964170895fb6ed62b50444d4dbee27820c851ec16a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/coin.md",
      "content": "# Coin\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "f9f4cc17124735132c4c64d179f7ffeec9d5a3403909069ca8bbc886d1ac8956",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/cool-breeze.md",
      "content": "# Cool Breeze\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "74b5145d61fe690b921c8e3d3be1147ffa1838aae6ff1a5c7dd08f3165ae4d6c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/coral.md",
      "content": "# Coral\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "8f84bf21f1288e2eeeb8790eb5f29c9eb70e0d009719eddbd76118c1bc48dffb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/creek.md",
      "content": "# Creek\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "54d3f40da4a57f317b38853ce08d1c86afccf0e396355bf0abb9ecc6c8b65040",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/crystal.md",
      "content": "# Crystal\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "aa58483089ea4f884f0dc4c4f9947f3aae7cdf259cdc2f49cae205ca7da89d59",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/dam.md",
      "content": "# Dam\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "cd063e5d9c312aa119fdc1936a9ff166837e9a80da4146802cd27735968d56fb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/delta.md",
      "content": "# Delta\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "f91dd7ad6a73acb172f0486a774bcf743ed1ef13889956eb28eb4860f33e53db",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/depression.md",
      "content": "# Depression\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "3be7fd5b1733e81d8946238c74530c7464d0ab4149971baa0d4fe3df0887ce42",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/desert.md",
      "content": "# Desert\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "cd1a5ff7f9557bc55ee48ea29593f1b3ec6a27aae898ae24500f3e9189695ace",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/dry-basin.md",
      "content": "# Dry Basin\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "28309b0331de7a9bae0c5566f907a58c0b7d0004db055c4cb3b644eb5fddf65c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/dune.md",
      "content": "# Dune\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "888f71989e62a06fa1ea92d5d84428a7fad8c7514336239f71983cb38fc727f9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/dust.md",
      "content": "# Dust\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "9db888afe46b7e401d1d8f3de0bd7d4bde336cddde45333013f5fb0ebad6afb4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/earth.md",
      "content": "# Earth\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "d055b693f12ae1a66c984946bde860feb686f8fa2d7f11c10f79857888565737",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/echo.md",
      "content": "# Echo\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "08e3eba9a95bacb6d5209c2a1dbeaaa765df8249d66df9335544fc704a8f2e2f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/ember.md",
      "content": "# Ember\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "cb23bf7f61f760d5826fd5d6a8ca84939d8f94964ba3f5611032ef32c23e897c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/erosion.md",
      "content": "# Erosion\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "ab70d14d3e2c8e548080e01cd052fb009fafa5803938b891dc7eb239ee9b2ccc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/estuary.md",
      "content": "# Estuary\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "0c29dc0cbf4cd5b2e18737ac030b4e50284dd8bd471a6ba867a7cd736a08bf94",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/eternal-flame.md",
      "content": "# Eternal Flame\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "620271af2517b84a57093575de63451182b5841f6eec96fcfa9dd72222bcfcac",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/farm.md",
      "content": "# Farm\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "b9b59e735619f16962db71fb4d4407c2b263550e266e8ff3a4e7e6dde2af4dfb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/fertile-land.md",
      "content": "# Fertile Land\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "b3a5b76e16461e8a59c7a6c17f23915c496340152b20de999cb4b83679a9b8b4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/fertilizer.md",
      "content": "# Fertilizer\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "ffa31f00fe4e88edea600cf008d5304a143ba9bf3b369709d61184b03ee46a50",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/fire-swamp.md",
      "content": "# Fire Swamp\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "3db95903b17c8cd38ae23784bb13e8460c5243298a0ebe1c8fd17dbbc7d6d855",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/fire.md",
      "content": "# Fire\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "ff6042b6f6ee58f41dcffe63a3420637a34f89366a3fecd5fecf3791040035a2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/firewall.md",
      "content": "# Firewall\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "c24c8cdd62fa390b53ebc9ad606b9693b0b1c62250a15803bb496d1ef4d46ca0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/flood.md",
      "content": "# Flood\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "673d0c0512b9c4cb0ca0a465ba773ed5c8eb19388d2065e0ef6cfe1aac9497ab",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/flower.md",
      "content": "# Flower\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "db2bb38a8ea774022f5291ffbfab6f2a27e42c470e4cac92f3cda600758b4516",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/fog.md",
      "content": "# Fog\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "7c1c62c41a3f40f700d27cd3492d5de52e6c6afaee805615362209d9f38c16cd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/forest.md",
      "content": "# Forest\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "7d96a69c5c92517ef5c3a95007d0f0f62af5bc4b59c5404450716f0a3d57d3a6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/fountain.md",
      "content": "# Fountain\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "e65b06a05bf674659d42a8dac0295f5c59767d43e140cacc283404ceab4deafa",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/fresh-breeze.md",
      "content": "# Fresh Breeze\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "1edee0f0a9842c0fd799eb2cdb88318cb4a9dde8f24461691759de0098a291e7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/frosted-glass.md",
      "content": "# Frosted Glass\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "34e59f74b7b3967bd1de2dd8ab651ba1f4df3bc09492203ac65e9314d5e7af16",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/garden.md",
      "content": "# Garden\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "e84b94ff5ad6db9373c7cd25987566b8c24ad02709d8c9c4c4c3aeceed3a403a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/geothermal-spring.md",
      "content": "# Geothermal Spring\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "ee246397bf41f5c126d6bc0c7bdba70c201ac927c2648d27d563985c09c3202f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/geyser.md",
      "content": "# Geyser\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "688bf27d5ec0648890b32f009c2a9973b77487cc31a68887f93a4d847e8e5ee8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/giraffe.md",
      "content": "# Giraffe\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "e04d1b017a426202a1edb53ba708645d40c92dac6a01d4b1d35aff0a5d427d29",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/glass.md",
      "content": "# Glass\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "3786c7c2eae3ca4057d5df7ceb7466b2061edd61001ea0d99790d2b41225ffd4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/gold.md",
      "content": "# Gold\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "a2126eaf6d71d71c4ea70eec0ae08ad32c129eb005fadf615e16c4613dca31c9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/golden-gate.md",
      "content": "# Golden Gate\n\n**Tier**: 2\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "32af756bcb5fad04e24df210be68663016523909167c5ad83cb61fc9c6868dac",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/gorge.md",
      "content": "# Gorge\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "e3d03bb5cf57bb823a4d9f9dc5ecdc1dc7efc01da582080bca73335e3cbd0d2a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/grotto.md",
      "content": "# Grotto\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "b87cfbb68d177f11563d5deb582f1c024c2635b1540eade7c3ee4ec8535fbcd2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/groundwater.md",
      "content": "# Groundwater\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "e3cf0063b5130584e820ab6dfc1289c1735e1d587d16b5df224c80f9c6081122",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/haze.md",
      "content": "# Haze\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "99e13b755a59922f677638b7926a40812512cd7cb0379ad7806835a3199ffce3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/hive.md",
      "content": "# Hive\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "3f45d3e3c0c592ada84181487c536f9b2c7c517e94249a3ca96271e2d204186b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/hot-spring.md",
      "content": "# Hot Spring\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "0742e186e1d6446217ef73bde38141c9f341fae033d00f669778d007359bb694",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/hydra.md",
      "content": "# Hydra\n\n**Tier**: 2\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "9a1e13604b57456479aa14884a50af2f75ee8c9f873e08e319b83f74fede9205",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/hyper-marmalade.md",
      "content": "# Hyper Marmalade\n\n**Tier**: 2\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "c68c829408a2fd31a53eabc7a8033107f6a1b4fb9f39e49677ae4ba0b58ba5db",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/island.md",
      "content": "# Island\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "6d2c28f7c026af1399c0b13b8a18bdb36d5fcb31f644e8c13e2198f9b9902e68",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/jungle.md",
      "content": "# Jungle\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "3ddf7280a2849ddfbef8d9e9f379d320e71ff3bcdb4a8dec65051f10e09b13d6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/karst.md",
      "content": "# Karst\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "e7ff789b3129ff23cf1766cdfbbd37793f6d857373219436527f74ac2ad68bbd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/kiln.md",
      "content": "# Kiln\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "7f0531dc5016ccf77bffa3dd92c3a7dd338ceee2acf3dc54ce6e597925edc9e6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/lagoon.md",
      "content": "# Lagoon\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "7289f77e4874be903cd6dc1c4bfd39fdaeeda48c321fbc1364c75efd01db619e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/lake.md",
      "content": "# Lake\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "60edd978ff7ef9a97b90b9af78c566dab33962d8cce42da524e1ad0b49899885",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/landslide.md",
      "content": "# Landslide\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "99886ea420b27ac027fa844b3208fe00ab5c7fe780a8d982ee823e35a677a96e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/lava-cave.md",
      "content": "# Lava Cave\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "4007625adb930382d759a5a1b95508d15770c9254b59d6004deae7bde7274106",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/lava.md",
      "content": "# Lava\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "c9ad36fd4d38551615786078cc5b0848b69cddeccc9dbe37a9c8cb8fda0b2617",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/leaves.md",
      "content": "# Leaves\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "09ea730743b9056d78642f5368033a232afd6e0c36ef2dd73f3f277706f06f92",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/lightning.md",
      "content": "# Lightning\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "8ef3f9c229187533e8c6eb9745fa2f52637ee2157a97e7a74d7ccdac67ca6056",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/limestone.md",
      "content": "# Limestone\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "c913ee7cfb04c0d94b547dafa00cbb29eca2591875c1aa63e489d17a283311bc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/lock.md",
      "content": "# Lock\n\n**Tier**: 2\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "04cd697ecdd68945ce61231c38b36af3171d40e42905c6e87a5a99e2a6c651b2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/magma-chamber.md",
      "content": "# Magma Chamber\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "c3588f908ab2e05f68d2b2d1f4c08635522316c90992aec6a17b0dd19d4a966c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/magma.md",
      "content": "# Magma\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "d7f18fafaa01b6f90c338fb36279ef525da1fec19d133a7f71070551c6829d88",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/marmalade.md",
      "content": "# Marmalade\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "42388abc33cfd35dc32d6ee22ba4fc99ca502a1066e8f2569addd386964f1048",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/mirage.md",
      "content": "# Mirage\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "0835a96997593368b14132aad3909d7acdb6f4998b65c46a8c155cb2dd7527b6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/mist.md",
      "content": "# Mist\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "40715eba4cdddc4bf7eea7f82bcc61b268fc657974120cc0b7db5ab09e184130",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/molten-glass.md",
      "content": "# Molten Glass\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "4412ba481ab36512b7c5e05b9e58476c1cd4d241c793c78bac1dd0a8ca1400a0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/monkey-branch.md",
      "content": "# Monkey Branch\n\n**Tier**: 2\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "553741cee4735dc9b3dee47c435058c0b9471f89e052c30df211e4cb04f97313",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/monkey.md",
      "content": "# Monkey\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "451fd384bbb60bc27c936517e0526c25688c839aee3bd5dba45de1cd3d97475a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/monument.md",
      "content": "# Monument\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "ffdbce4e21a7b7c680811afbe32223256f9a75a28b4e794dc8a6663405d3df76",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/mountain.md",
      "content": "# Mountain\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "5abcf960f01410ef6cf42ea75e8fdd9df33cf368f63cf94044819950a93d645a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/mud.md",
      "content": "# Mud\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "1d2c2da21d54b8f1be048500952602f3f407e320e20b4a5e74de72dad978cc3c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/murmur.md",
      "content": "# Murmur\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "6551fbad3819d52b81e0ee52f27dba54989b5c21bca1f7df5d45119e96084152",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/oasis.md",
      "content": "# Oasis\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "7e971a40cab8be807c2eba34398ed54db5cad33309120f3f8a898d46fc8c461d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/obsidian.md",
      "content": "# Obsidian\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "dca0f23ebea6d077083a55f9d1a428007610e965d1244f05208ab67762e3798e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/parched-earth.md",
      "content": "# Parched Earth\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "b8d1c4f4aa3b70f52c7d89c482096fb5a7c9c3705e4fbea83a5aaaf76877ca3d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/peat.md",
      "content": "# Peat\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "341ee288cd2a2c00e63f882b2b31824511104770e09ce94b0af26b02eefd36e6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/pebble.md",
      "content": "# Pebble\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "7f54ef4b8c3c2aeece2085f9dd62676a6238593a61d5ad2ea07eedc3ccf2d112",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/peer-review.md",
      "content": "# Peer Review\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "4a7583b4904a53fb128ae03015e8576cb84d8c5261115b6fdd59df12f2643855",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/pillar-of-wind.md",
      "content": "# Pillar Of Wind\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "21e43d19e80e0829167c587202c52e2c5b27cac68e9dd3caeb65310919dd8a31",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/plant.md",
      "content": "# Plant\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "2ca424d4b67efbe512cc9dad94633419b90e0f37addb9e50659189f9cd6c7de5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/plateau.md",
      "content": "# Plateau\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "59275f30eb1a1acad198e3aa122c529d98d1b48d8ec931698555e6d06e2165d2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/polkadot.md",
      "content": "# Polkadot\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "0b41b25d2c86bb67584bbec587907c84edea7a3a287421f5f2dc4c33b897973c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/pollination.md",
      "content": "# Pollination\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "f07480043ad4d19ac10844b7db3849d7b37128c053c3564a68961854bbc649c5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/pond.md",
      "content": "# Pond\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "73729953dfdc1154f8aae935a53302e15498d0ca784016763f9b4c1ae3e28eb5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/pottery.md",
      "content": "# Pottery\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "cae4169f3987119d4dd0b984fc7ec1ff7eddffba6267bb3662c30519ab6ec98b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/prism.md",
      "content": "# Prism\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "531b41676b4e749f1ec9aa36ce1c0dad103a27158bcdc4cdb75fbb376a046a02",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/pumice.md",
      "content": "# Pumice\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "f7ea112dd03d2754dc11a418a263fe4daf5254306cb932cdb7703fc3e10fd082",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/quicklime.md",
      "content": "# Quicklime\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "7815ce578823032ea2e1821dc7ac8b4e0531a34ece0a92be16154f5030ec6b6f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/quicksand.md",
      "content": "# Quicksand\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "22421328491211fa97eb256f9d76659b904da69c232516f7302cf99cc718bb14",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/rain.md",
      "content": "# Rain\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "fb7b144f1e64f5e04147055439c3ea6932cfef24a0b51f42f68a6c33644fb14f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/rainbow.md",
      "content": "# Rainbow\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "3a46822c619bbdd9073b28d1fb3cb601f016ca3c229ec6f16dbb4d9c45e928b1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/ravine.md",
      "content": "# Ravine\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "4575f67ded36e67157fb8c6128f447a32854bf57800e8ce0e688ac4c352aa756",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/reeds.md",
      "content": "# Reeds\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "ff955e00357f6611062c6d76c1bfaec5fa03ddcfc27adb760b87ce7fb266a059",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/reef.md",
      "content": "# Reef\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "7f6fb795d81d9dbd0e78f91cae32413138dc3ff6b4df081c43acad1ae9e7054b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/reservoir.md",
      "content": "# Reservoir\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "1d321b3a79e359c4d06dab9e4a3386841d0b88b48709527ff4ff3a79f6eccdac",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/rhodium.md",
      "content": "# Rhodium\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "fce3d9b7303b63c474a9eb48f5c7ee39d3683ee186c80e6dc4e8fd6fe60a9af3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/river.md",
      "content": "# River\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "b1a01d7f8c1b88a898f9ee7a0e98bf460ad001a449fe9f7c4a3c18c65ca96af6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/riverbank.md",
      "content": "# Riverbank\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "dcc36451c6f877eee36ce3d795fab37febcabf2ecab570f8925410051988b26d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/rivulet.md",
      "content": "# Rivulet\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "5a5286ed0ce072731c016eead282538a44ea53fb4a8e8ffc4a1e11c15e2a8c8b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/rock.md",
      "content": "# Rock\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "d9e16d33d53611a014eb1bf30d67af08d4566fc4f00036ce6313a644bdcbab29",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/sand-dune.md",
      "content": "# Sand Dune\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "2456e2517fb96be84451adfa4ef69dc1e87f49dbbe9871027aaf67222c0cff7e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/sand.md",
      "content": "# Sand\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "3c6c1ab798cd9c85fa192eedba51e624337a42084663a0fe57d7d1989c41953c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/sandstorm.md",
      "content": "# Sandstorm\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "73f1a743eb9e01f95b89daf2cde3574ce3b43b1ce0996dbaaf98e43ee294cd1b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/scorched-earth.md",
      "content": "# Scorched Earth\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "4558a6be3f848e271ca78385abdeff2373689c269b3693b0f7cd891a25020508",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/seeds.md",
      "content": "# Seeds\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "c639421fe6cd62696873bb5afe985f6a2088d95c90d4b35301cb4f5d20e3dcdc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/shard.md",
      "content": "# Shard\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "70e5b70bc7cd00272457f7c724ead75ddf09834acf0964171aa26e7dd2f541e8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/shards.md",
      "content": "# Shards\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "365d2ebe67a30d7fef3bddbb9406eb8de589b454856d29253e73b50b5fb8ce39",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/silver.md",
      "content": "# Silver\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "15842b22a2149655dd9a45dfbb483e4ee065de8b9563ca68808d7e9b5d0ae207",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/sinkhole.md",
      "content": "# Sinkhole\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "1a505c03b819e9d4b94332b9d70ff796ee2473b7203cae874d19e5ac8a9ca458",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/smoke.md",
      "content": "# Smoke\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "24655e59d727456a545195aa1b540b1a615e845bc1debac7cb29fdb21e513bb4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/soil.md",
      "content": "# Soil\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "306cfe17d1ae572fc7e0a23a256e56797dce14c9adac90ac359b55a75c5dd419",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/soot.md",
      "content": "# Soot\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "fe7ed1a601a60b9061e443ea93694a13d737cda16137cf530e212ce820280309",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/sparkle.md",
      "content": "# Sparkle\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "4cf691022b5e37dca3690d0827cbe7e049305aaa2779591a609671874bc786e5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/spore.md",
      "content": "# Spore\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "884253e67090507a4a6c33c4e27f1c6db7c3d4e9b5072e22097799237b6acc2c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/spread.md",
      "content": "# Spread\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "0c2378d01682ce578d63956ec60119da1dadb01bb70dbf47bb487da814f0a261",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/spring.md",
      "content": "# Spring\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "bdbe941ddf1f11e3cddebd8c870f8106c14d9cf3f6667cd2b5d6e242587228bb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/steam-vent.md",
      "content": "# Steam Vent\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "796c6a934f487d2e3dfdd5c1176f3a80725575083a040fb4a8f47462f7c0cbe6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/steam.md",
      "content": "# Steam\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "ea5c3489d66ee0197b6ccedb24b5d1fc62141b82560f0d739493b2949c3c2c6e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/storm.md",
      "content": "# Storm\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "82e3fa43eb65a90f3d8fb6d3277a32cc3f9eab76b5bf1c5b584c54912b962dca",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/stream.md",
      "content": "# Stream\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "6c89f9b0745e2cb2adaac2b89dc7b5d7099236c6d2f79cb15fbab1e5e4335d15",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/subterranean-pool.md",
      "content": "# Subterranean Pool\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "e888ccab34a9e18315c3c11e31540b4a2b7af555a63e2260e3dcaf1f669ed93c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/super-marmalade.md",
      "content": "# Super Marmalade\n\n**Tier**: 2\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "2fd2c25adb7cd781772d13e476fcef316d91c4e73145bdfc9d8657946bba727e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/swarm.md",
      "content": "# Swarm\n\n**Tier**: 2\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "1a8fc1a038bef00e32539d35b6c208aeefeea64428ab98885907a3b02324d900",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/thunder.md",
      "content": "# Thunder\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "5c0049e47631f7e0497a234ca24f13c437a42a9bd7479836f024741f5bad27cf",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/tornado.md",
      "content": "# Tornado\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "33db7963d0c7e91a49ba0258d86e2ed93f4efd5e091f8ada690317b093ee7d04",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/transaction.md",
      "content": "# Transaction\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "b25a70da6566ee8115a756379152d7b76aa9cb32b31aea5b3feb882d78985820",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/tree.md",
      "content": "# Tree\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "5bd179e9bd5f2d002f409e337c7efcb9eba4a919b6fd1e865324108acd3ba2bd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/tributary.md",
      "content": "# Tributary\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "c3321e629a79a0f8fddbc2d179216c05a1cfdd6c7ee47da209c37ed301a51d7e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/underground-lake.md",
      "content": "# Underground Lake\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "fb270b360aca0d0ce88efc94389b3a8d6161b7514b678c762c9eea0a013f405e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/valley.md",
      "content": "# Valley\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "552e8f58096f5c2662a30be3c7a4264e4fa9a2c1381498e7d53c6f1a2f7ad49f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/volcano.md",
      "content": "# Volcano\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "41525fbaca3a36d6bfeaa5312495b4ce74846a459297fccfab96c1f2838e5457",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/wall.md",
      "content": "# Wall\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "af56644885a81e9925ab89087cb7cfd11372a63a45d322ac515f4c0d3f8970d3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/warm-breeze.md",
      "content": "# Warm Breeze\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "da3ddc0de2313737b2c865bff2d846cd64e151b5db379642e7787336d4da3e31",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/water.md",
      "content": "# Water\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "19b10125b33a0d8b1b4541e4317c78106755d711d48c3e3a3782e29c97ebd77f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/waterfall.md",
      "content": "# Waterfall\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "6c637d6f8c423632716202bee1b67ee273e185166d2724f44f3521cb7bd4e085",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/watershed.md",
      "content": "# Watershed\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "8299d8e80b91c2803f85dac83206172c3ca43f1b8d695376aa68a8bf94d11514",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/wave.md",
      "content": "# Wave\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "e6e3e14fdab8824547465f521755d965f1ee9e18a90f31d1f169cd823152d02c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/wetland.md",
      "content": "# Wetland\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "653df05a34fe333a040682f5354b7594d5421a1272613439e98c1dac788550c4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/wetstone.md",
      "content": "# Wetstone\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "f56d069841ead82b48cb5f1ea8576354171dd32bf99305d7ad61c378f284a9c1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/whirl.md",
      "content": "# Whirl\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "93a9bbe933f7e08a15e111cfe1454a5b66e9c149303966b242e518498ca80a99",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/whisper.md",
      "content": "# Whisper\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "2c1b8aa3fae5137c913aa0be334ad2c7898136576210286a586a2c806df2bc96",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/whispering-cave.md",
      "content": "# Whispering Cave\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "cbfe660f6c1f65dd9eda80e8e027414b1f95ab08085b291222cf8919b6283ca8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/wildfire.md",
      "content": "# Wildfire\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "2073fd37c2d86938e7d8fbfe04dece03f00f5e5eae98f47fb2b270cb90602f11",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/wind.md",
      "content": "# Wind\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "6e9903068cc9f528a6a78957bb3e687264443eb20709655161c612cc4176d151",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/windmill.md",
      "content": "# Windmill\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "439f057fb568f79633a4c7e45c55a5914493e9237cd3044c3d1928cbd312f39d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/zephyr.md",
      "content": "# Zephyr\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "a793666b19f1c1223bedc09c606fee2f7b9d6e1dddedd74d0ff0022899a281c6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/games.md",
      "content": "# Games\n\n_Not a bird_ contains multiple **games**. Each game is a set of [elements](/wiki/elements) and [recipes](/wiki/recipes).\n\n## List of games\n\n* [Unifiers](/wiki/games/unifiers)\n* [Elementy](/wiki/games/elementy)\n\nSee also:\n\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "f7d9ee5357dacf5e4e22ea3b356a03164ec1dcc495a0985d42d6156e6e17de15",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/games/elementy.md",
      "content": "# Elementy\n\nA game in which you combine elements to create new ones.\n\n## Elements\n\n**Elementy** has the following elements:\n\n* [Water](/wiki/elements/water)\n* [Fire](/wiki/elements/fire)\n* [Steam](/wiki/elements/steam)\n* [Earth](/wiki/elements/earth)\n* [Mud](/wiki/elements/mud)\n* [Lava](/wiki/elements/lava)\n* [Wind](/wiki/elements/wind)\n* [Dust](/wiki/elements/dust)\n* [Rain](/wiki/elements/rain)\n* [Smoke](/wiki/elements/smoke)\n* [Geyser](/wiki/elements/geyser)\n* [Clay](/wiki/elements/clay)\n* [Sand](/wiki/elements/sand)\n* [Plant](/wiki/elements/plant)\n* [Rainbow](/wiki/elements/rainbow)\n* [Storm](/wiki/elements/storm)\n* [Obsidian](/wiki/elements/obsidian)\n* [Ash](/wiki/elements/ash)\n* [Volcano](/wiki/elements/volcano)\n* [Sandstorm](/wiki/elements/sandstorm)\n* [Cloud](/wiki/elements/cloud)\n* [Fog](/wiki/elements/fog)\n* [Tree](/wiki/elements/tree)\n* [Forest](/wiki/elements/forest)\n* [Seeds](/wiki/elements/seeds)\n* [Pottery](/wiki/elements/pottery)\n* [Brick](/wiki/elements/brick)\n* [Quicksand](/wiki/elements/quicksand)\n* [Glass](/wiki/elements/glass)\n* [Dune](/wiki/elements/dune)\n* [Charcoal](/wiki/elements/charcoal)\n* [Leaves](/wiki/elements/leaves)\n* [Wildfire](/wiki/elements/wildfire)\n* [Jungle](/wiki/elements/jungle)\n* [Frosted Glass](/wiki/elements/frosted-glass)\n* [Crystal](/wiki/elements/crystal)\n* [Magma](/wiki/elements/magma)\n* [Rock](/wiki/elements/rock)\n* [Shard](/wiki/elements/shard)\n* [Pebble](/wiki/elements/pebble)\n* [Mountain](/wiki/elements/mountain)\n* [Fertilizer](/wiki/elements/fertilizer)\n* [Soot](/wiki/elements/soot)\n* [Lightning](/wiki/elements/lightning)\n* [Mist](/wiki/elements/mist)\n* [Haze](/wiki/elements/haze)\n* [Flood](/wiki/elements/flood)\n* [Landslide](/wiki/elements/landslide)\n* [Thunder](/wiki/elements/thunder)\n* [Tornado](/wiki/elements/tornado)\n* [Garden](/wiki/elements/garden)\n* [Ember](/wiki/elements/ember)\n* [Kiln](/wiki/elements/kiln)\n* [Pollination](/wiki/elements/pollination)\n* [Sinkhole](/wiki/elements/sinkhole)\n* [Beach](/wiki/elements/beach)\n* [Wetstone](/wiki/elements/wetstone)\n* [Erosion](/wiki/elements/erosion)\n* [Basalt](/wiki/elements/basalt)\n* [Magma Chamber](/wiki/elements/magma-chamber)\n* [Breeze](/wiki/elements/breeze)\n* [Warm Breeze](/wiki/elements/warm-breeze)\n* [Soil](/wiki/elements/soil)\n* [Canyon](/wiki/elements/canyon)\n* [Windmill](/wiki/elements/windmill)\n* [Adobe](/wiki/elements/adobe)\n* [Wall](/wiki/elements/wall)\n* [Pumice](/wiki/elements/pumice)\n* [Barbecue](/wiki/elements/barbecue)\n* [Farm](/wiki/elements/farm)\n* [Shards](/wiki/elements/shards)\n* [Molten Glass](/wiki/elements/molten-glass)\n* [Prism](/wiki/elements/prism)\n* [Sparkle](/wiki/elements/sparkle)\n* [Desert](/wiki/elements/desert)\n* [Oasis](/wiki/elements/oasis)\n* [Mirage](/wiki/elements/mirage)\n* [Sand Dune](/wiki/elements/sand-dune)\n* [Dam](/wiki/elements/dam)\n* [Firewall](/wiki/elements/firewall)\n* [Barricade](/wiki/elements/barricade)\n* [Plateau](/wiki/elements/plateau)\n* [Pond](/wiki/elements/pond)\n* [Aromas](/wiki/elements/aromas)\n* [Flower](/wiki/elements/flower)\n* [Spore](/wiki/elements/spore)\n* [Spread](/wiki/elements/spread)\n* [Fertile Land](/wiki/elements/fertile-land)\n* [Wetland](/wiki/elements/wetland)\n* [Peat](/wiki/elements/peat)\n* [Reeds](/wiki/elements/reeds)\n* [Valley](/wiki/elements/valley)\n* [River](/wiki/elements/river)\n* [Scorched Earth](/wiki/elements/scorched-earth)\n* [Delta](/wiki/elements/delta)\n* [Estuary](/wiki/elements/estuary)\n* [Fire Swamp](/wiki/elements/fire-swamp)\n* [Riverbank](/wiki/elements/riverbank)\n* [Ravine](/wiki/elements/ravine)\n* [Gorge](/wiki/elements/gorge)\n* [Charred Ravine](/wiki/elements/charred-ravine)\n* [Echo](/wiki/elements/echo)\n* [Cave](/wiki/elements/cave)\n* [Underground Lake](/wiki/elements/underground-lake)\n* [Lava Cave](/wiki/elements/lava-cave)\n* [Whispering Cave](/wiki/elements/whispering-cave)\n* [Subterranean Pool](/wiki/elements/subterranean-pool)\n* [Spring](/wiki/elements/spring)\n* [Hot Spring](/wiki/elements/hot-spring)\n* [Grotto](/wiki/elements/grotto)\n* [Fountain](/wiki/elements/fountain)\n* [Steam Vent](/wiki/elements/steam-vent)\n* [Cool Breeze](/wiki/elements/cool-breeze)\n* [Monument](/wiki/elements/monument)\n* [Waterfall](/wiki/elements/waterfall)\n* [Eternal Flame](/wiki/elements/eternal-flame)\n* [Pillar Of Wind](/wiki/elements/pillar-of-wind)\n* [Stream](/wiki/elements/stream)\n* [Zephyr](/wiki/elements/zephyr)\n* [Creek](/wiki/elements/creek)\n* [Brook](/wiki/elements/brook)\n* [Whisper](/wiki/elements/whisper)\n* [Rivulet](/wiki/elements/rivulet)\n* [Tributary](/wiki/elements/tributary)\n* [Murmur](/wiki/elements/murmur)\n* [Watershed](/wiki/elements/watershed)\n* [Aquifer](/wiki/elements/aquifer)\n* [Parched Earth](/wiki/elements/parched-earth)\n* [Fresh Breeze](/wiki/elements/fresh-breeze)\n* [Groundwater](/wiki/elements/groundwater)\n* [Reservoir](/wiki/elements/reservoir)\n* [Geothermal Spring](/wiki/elements/geothermal-spring)\n* [Artesian Well](/wiki/elements/artesian-well)\n* [Basin](/wiki/elements/basin)\n* [Lake](/wiki/elements/lake)\n* [Dry Basin](/wiki/elements/dry-basin)\n* [Depression](/wiki/elements/depression)\n* [Island](/wiki/elements/island)\n* [Lagoon](/wiki/elements/lagoon)\n* [Wave](/wiki/elements/wave)\n* [Reef](/wiki/elements/reef)\n* [Coral](/wiki/elements/coral)\n* [Whirl](/wiki/elements/whirl)\n* [Limestone](/wiki/elements/limestone)\n* [Karst](/wiki/elements/karst)\n* [Quicklime](/wiki/elements/quicklime)\n* [Blowhole](/wiki/elements/blowhole)\n\n## Recipes\n\n**Elementy** has the following recipes:\n\n* [Make Steam](/wiki/recipes/make-steam)\n* [Make Mud](/wiki/recipes/make-mud)\n* [Make Lava](/wiki/recipes/make-lava)\n* [Make Dust](/wiki/recipes/make-dust)\n* [Make Rain](/wiki/recipes/make-rain)\n* [Make Smoke](/wiki/recipes/make-smoke)\n* [Make Geyser](/wiki/recipes/make-geyser)\n* [Make Clay](/wiki/recipes/make-clay)\n* [Make Sand](/wiki/recipes/make-sand)\n* [Make Plant](/wiki/recipes/make-plant)\n* [Make Rainbow](/wiki/recipes/make-rainbow)\n* [Make Storm](/wiki/recipes/make-storm)\n* [Make Obsidian](/wiki/recipes/make-obsidian)\n* [Make Ash](/wiki/recipes/make-ash)\n* [Make Volcano](/wiki/recipes/make-volcano)\n* [Make Sandstorm](/wiki/recipes/make-sandstorm)\n* [Make Cloud](/wiki/recipes/make-cloud)\n* [Make Fog](/wiki/recipes/make-fog)\n* [Make Tree](/wiki/recipes/make-tree)\n* [Make Forest](/wiki/recipes/make-forest)\n* [Make Seeds](/wiki/recipes/make-seeds)\n* [Make Pottery](/wiki/recipes/make-pottery)\n* [Make Brick](/wiki/recipes/make-brick)\n* [Make Quicksand](/wiki/recipes/make-quicksand)\n* [Make Glass](/wiki/recipes/make-glass)\n* [Make Dune](/wiki/recipes/make-dune)\n* [Make Charcoal](/wiki/recipes/make-charcoal)\n* [Make Leaves](/wiki/recipes/make-leaves)\n* [Make Wildfire](/wiki/recipes/make-wildfire)\n* [Make Jungle](/wiki/recipes/make-jungle)\n* [Make Frosted Glass](/wiki/recipes/make-frosted-glass)\n* [Make Crystal](/wiki/recipes/make-crystal)\n* [Make Magma](/wiki/recipes/make-magma)\n* [Make Rock](/wiki/recipes/make-rock)\n* [Make Shard](/wiki/recipes/make-shard)\n* [Make Pebble](/wiki/recipes/make-pebble)\n* [Make Mountain](/wiki/recipes/make-mountain)\n* [Make Fertilizer](/wiki/recipes/make-fertilizer)\n* [Make Soot](/wiki/recipes/make-soot)\n* [Make Lightning](/wiki/recipes/make-lightning)\n* [Make Mist](/wiki/recipes/make-mist)\n* [Make Haze](/wiki/recipes/make-haze)\n* [Make Flood](/wiki/recipes/make-flood)\n* [Make Landslide](/wiki/recipes/make-landslide)\n* [Make Thunder](/wiki/recipes/make-thunder)\n* [Make Tornado](/wiki/recipes/make-tornado)\n* [Make Garden](/wiki/recipes/make-garden)\n* [Make Ember](/wiki/recipes/make-ember)\n* [Make Kiln](/wiki/recipes/make-kiln)\n* [Make Pollination](/wiki/recipes/make-pollination)\n* [Make Sinkhole](/wiki/recipes/make-sinkhole)\n* [Make Beach](/wiki/recipes/make-beach)\n* [Make Wetstone](/wiki/recipes/make-wetstone)\n* [Make Erosion](/wiki/recipes/make-erosion)\n* [Make Basalt](/wiki/recipes/make-basalt)\n* [Make Magma Chamber](/wiki/recipes/make-magma-chamber)\n* [Make Breeze](/wiki/recipes/make-breeze)\n* [Make Warm Breeze](/wiki/recipes/make-warm-breeze)\n* [Make Soil](/wiki/recipes/make-soil)\n* [Make Canyon](/wiki/recipes/make-canyon)\n* [Make Windmill](/wiki/recipes/make-windmill)\n* [Make Adobe](/wiki/recipes/make-adobe)\n* [Make Wall](/wiki/recipes/make-wall)\n* [Make Pumice](/wiki/recipes/make-pumice)\n* [Make Barbecue](/wiki/recipes/make-barbecue)\n* [Make Farm](/wiki/recipes/make-farm)\n* [Make Shards](/wiki/recipes/make-shards)\n* [Make Molten Glass](/wiki/recipes/make-molten-glass)\n* [Make Prism](/wiki/recipes/make-prism)\n* [Make Sparkle](/wiki/recipes/make-sparkle)\n* [Make Desert](/wiki/recipes/make-desert)\n* [Make Oasis](/wiki/recipes/make-oasis)\n* [Make Mirage](/wiki/recipes/make-mirage)\n* [Make Sand Dune](/wiki/recipes/make-sand-dune)\n* [Make Dam](/wiki/recipes/make-dam)\n* [Make Firewall](/wiki/recipes/make-firewall)\n* [Make Barricade](/wiki/recipes/make-barricade)\n* [Make Plateau](/wiki/recipes/make-plateau)\n* [Make Pond](/wiki/recipes/make-pond)\n* [Make Aromas](/wiki/recipes/make-aromas)\n* [Make Flower](/wiki/recipes/make-flower)\n* [Make Spore](/wiki/recipes/make-spore)\n* [Make Spread](/wiki/recipes/make-spread)\n* [Make Fertile Land](/wiki/recipes/make-fertile-land)\n* [Make Wetland](/wiki/recipes/make-wetland)\n* [Make Peat](/wiki/recipes/make-peat)\n* [Make Reeds](/wiki/recipes/make-reeds)\n* [Make Valley](/wiki/recipes/make-valley)\n* [Make River](/wiki/recipes/make-river)\n* [Make Scorched Earth](/wiki/recipes/make-scorched-earth)\n* [Make Delta](/wiki/recipes/make-delta)\n* [Make Estuary](/wiki/recipes/make-estuary)\n* [Make Fire Swamp](/wiki/recipes/make-fire-swamp)\n* [Make Riverbank](/wiki/recipes/make-riverbank)\n* [Make Ravine](/wiki/recipes/make-ravine)\n* [Make Gorge](/wiki/recipes/make-gorge)\n* [Make Charred Ravine](/wiki/recipes/make-charred-ravine)\n* [Make Echo](/wiki/recipes/make-echo)\n* [Make Cave](/wiki/recipes/make-cave)\n* [Make Underground Lake](/wiki/recipes/make-underground-lake)\n* [Make Lava Cave](/wiki/recipes/make-lava-cave)\n* [Make Whispering Cave](/wiki/recipes/make-whispering-cave)\n* [Make Subterranean Pool](/wiki/recipes/make-subterranean-pool)\n* [Make Spring](/wiki/recipes/make-spring)\n* [Make Hot Spring](/wiki/recipes/make-hot-spring)\n* [Make Grotto](/wiki/recipes/make-grotto)\n* [Make Fountain](/wiki/recipes/make-fountain)\n* [Make Steam Vent](/wiki/recipes/make-steam-vent)\n* [Make Cool Breeze](/wiki/recipes/make-cool-breeze)\n* [Make Monument](/wiki/recipes/make-monument)\n* [Make Waterfall](/wiki/recipes/make-waterfall)\n* [Make Eternal Flame](/wiki/recipes/make-eternal-flame)\n* [Make Pillar Of Wind](/wiki/recipes/make-pillar-of-wind)\n* [Make Stream](/wiki/recipes/make-stream)\n* [Make Zephyr](/wiki/recipes/make-zephyr)\n* [Make Creek](/wiki/recipes/make-creek)\n* [Make Brook](/wiki/recipes/make-brook)\n* [Make Whisper](/wiki/recipes/make-whisper)\n* [Make Rivulet](/wiki/recipes/make-rivulet)\n* [Make Tributary](/wiki/recipes/make-tributary)\n* [Make Murmur](/wiki/recipes/make-murmur)\n* [Make Watershed](/wiki/recipes/make-watershed)\n* [Make Aquifer](/wiki/recipes/make-aquifer)\n* [Make Parched Earth](/wiki/recipes/make-parched-earth)\n* [Make Fresh Breeze](/wiki/recipes/make-fresh-breeze)\n* [Make Groundwater](/wiki/recipes/make-groundwater)\n* [Make Reservoir](/wiki/recipes/make-reservoir)\n* [Make Geothermal Spring](/wiki/recipes/make-geothermal-spring)\n* [Make Artesian Well](/wiki/recipes/make-artesian-well)\n* [Make Basin](/wiki/recipes/make-basin)\n* [Make Lake](/wiki/recipes/make-lake)\n* [Make Dry Basin](/wiki/recipes/make-dry-basin)\n* [Make Depression](/wiki/recipes/make-depression)\n* [Make Island](/wiki/recipes/make-island)\n* [Make Lagoon](/wiki/recipes/make-lagoon)\n* [Make Wave](/wiki/recipes/make-wave)\n* [Make Reef](/wiki/recipes/make-reef)\n* [Make Coral](/wiki/recipes/make-coral)\n* [Make Whirl](/wiki/recipes/make-whirl)\n* [Make Limestone](/wiki/recipes/make-limestone)\n* [Make Karst](/wiki/recipes/make-karst)\n* [Make Quicklime](/wiki/recipes/make-quicklime)\n* [Make Blowhole](/wiki/recipes/make-blowhole)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "7d224e22840894fae6ebb5bb6ad30d6b9c86ca6e22bc31d98a090cacf7f60253",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/games/unifiers.md",
      "content": "# Unifiers\n\nA game created with the help of the Unifiers group\n\n## Elements\n\n**Unifiers** has the following elements:\n\n* [Monkey](/wiki/elements/monkey)\n* [Giraffe](/wiki/elements/giraffe)\n* [Bee](/wiki/elements/bee)\n* [Coin](/wiki/elements/coin)\n* [Swarm](/wiki/elements/swarm)\n* [Hydra](/wiki/elements/hydra)\n* [Monkey Branch](/wiki/elements/monkey-branch)\n* [Bridge](/wiki/elements/bridge)\n* [Golden Gate](/wiki/elements/golden-gate)\n* [Gold](/wiki/elements/gold)\n* [Silver](/wiki/elements/silver)\n* [Rhodium](/wiki/elements/rhodium)\n* [Hive](/wiki/elements/hive)\n* [Transaction](/wiki/elements/transaction)\n* [Block](/wiki/elements/block)\n* [Blockchain](/wiki/elements/blockchain)\n* [Polkadot](/wiki/elements/polkadot)\n* [Peer Review](/wiki/elements/peer-review)\n* [Cardano](/wiki/elements/cardano)\n* [Bear](/wiki/elements/bear)\n* [Beer](/wiki/elements/beer)\n* [Lock](/wiki/elements/lock)\n* [Marmalade](/wiki/elements/marmalade)\n* [Super Marmalade](/wiki/elements/super-marmalade)\n* [Hyper Marmalade](/wiki/elements/hyper-marmalade)\n\n## Recipes\n\n**Unifiers** has the following recipes:\n\n* [Make Swarm](/wiki/recipes/make-swarm)\n* [Make Hydra](/wiki/recipes/make-hydra)\n* [Make Monkeybranch](/wiki/recipes/make-monkeybranch)\n* [Make Bridge](/wiki/recipes/make-bridge)\n* [Make Goldengate](/wiki/recipes/make-goldengate)\n* [Make Cardano](/wiki/recipes/make-cardano)\n* [Make Beer](/wiki/recipes/make-beer)\n* [Make Lock](/wiki/recipes/make-lock)\n* [Make Supermarmalade](/wiki/recipes/make-supermarmalade)\n* [Make Hypermarmalade](/wiki/recipes/make-hypermarmalade)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "cc4eb2d42aeabb851eeebe3e697313a8eadf53c7722a123b6697d6c9d6fd5831",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes.md",
      "content": "# Recipes\n\nIn _Not a Bird_ players can combine [elements](/wiki/elements) via **recipes**. Each recipe has a format of `A + B = C`, where `A`, `B` and `C` are elements.\n\n## List of recipes\n\n* [Make Swarm](/wiki/recipes/make-swarm)\n* [Make Hydra](/wiki/recipes/make-hydra)\n* [Make Monkeybranch](/wiki/recipes/make-monkeybranch)\n* [Make Bridge](/wiki/recipes/make-bridge)\n* [Make Goldengate](/wiki/recipes/make-goldengate)\n* [Make Cardano](/wiki/recipes/make-cardano)\n* [Make Beer](/wiki/recipes/make-beer)\n* [Make Lock](/wiki/recipes/make-lock)\n* [Make Supermarmalade](/wiki/recipes/make-supermarmalade)\n* [Make Hypermarmalade](/wiki/recipes/make-hypermarmalade)\n* [Make Steam](/wiki/recipes/make-steam)\n* [Make Mud](/wiki/recipes/make-mud)\n* [Make Lava](/wiki/recipes/make-lava)\n* [Make Dust](/wiki/recipes/make-dust)\n* [Make Rain](/wiki/recipes/make-rain)\n* [Make Smoke](/wiki/recipes/make-smoke)\n* [Make Geyser](/wiki/recipes/make-geyser)\n* [Make Clay](/wiki/recipes/make-clay)\n* [Make Sand](/wiki/recipes/make-sand)\n* [Make Plant](/wiki/recipes/make-plant)\n* [Make Rainbow](/wiki/recipes/make-rainbow)\n* [Make Storm](/wiki/recipes/make-storm)\n* [Make Obsidian](/wiki/recipes/make-obsidian)\n* [Make Ash](/wiki/recipes/make-ash)\n* [Make Volcano](/wiki/recipes/make-volcano)\n* [Make Sandstorm](/wiki/recipes/make-sandstorm)\n* [Make Cloud](/wiki/recipes/make-cloud)\n* [Make Fog](/wiki/recipes/make-fog)\n* [Make Tree](/wiki/recipes/make-tree)\n* [Make Forest](/wiki/recipes/make-forest)\n* [Make Seeds](/wiki/recipes/make-seeds)\n* [Make Pottery](/wiki/recipes/make-pottery)\n* [Make Brick](/wiki/recipes/make-brick)\n* [Make Quicksand](/wiki/recipes/make-quicksand)\n* [Make Glass](/wiki/recipes/make-glass)\n* [Make Dune](/wiki/recipes/make-dune)\n* [Make Charcoal](/wiki/recipes/make-charcoal)\n* [Make Leaves](/wiki/recipes/make-leaves)\n* [Make Wildfire](/wiki/recipes/make-wildfire)\n* [Make Jungle](/wiki/recipes/make-jungle)\n* [Make Frosted Glass](/wiki/recipes/make-frosted-glass)\n* [Make Crystal](/wiki/recipes/make-crystal)\n* [Make Magma](/wiki/recipes/make-magma)\n* [Make Rock](/wiki/recipes/make-rock)\n* [Make Shard](/wiki/recipes/make-shard)\n* [Make Pebble](/wiki/recipes/make-pebble)\n* [Make Mountain](/wiki/recipes/make-mountain)\n* [Make Fertilizer](/wiki/recipes/make-fertilizer)\n* [Make Soot](/wiki/recipes/make-soot)\n* [Make Lightning](/wiki/recipes/make-lightning)\n* [Make Mist](/wiki/recipes/make-mist)\n* [Make Haze](/wiki/recipes/make-haze)\n* [Make Flood](/wiki/recipes/make-flood)\n* [Make Landslide](/wiki/recipes/make-landslide)\n* [Make Thunder](/wiki/recipes/make-thunder)\n* [Make Tornado](/wiki/recipes/make-tornado)\n* [Make Garden](/wiki/recipes/make-garden)\n* [Make Ember](/wiki/recipes/make-ember)\n* [Make Kiln](/wiki/recipes/make-kiln)\n* [Make Pollination](/wiki/recipes/make-pollination)\n* [Make Sinkhole](/wiki/recipes/make-sinkhole)\n* [Make Beach](/wiki/recipes/make-beach)\n* [Make Wetstone](/wiki/recipes/make-wetstone)\n* [Make Erosion](/wiki/recipes/make-erosion)\n* [Make Basalt](/wiki/recipes/make-basalt)\n* [Make Magma Chamber](/wiki/recipes/make-magma-chamber)\n* [Make Breeze](/wiki/recipes/make-breeze)\n* [Make Warm Breeze](/wiki/recipes/make-warm-breeze)\n* [Make Soil](/wiki/recipes/make-soil)\n* [Make Canyon](/wiki/recipes/make-canyon)\n* [Make Windmill](/wiki/recipes/make-windmill)\n* [Make Adobe](/wiki/recipes/make-adobe)\n* [Make Wall](/wiki/recipes/make-wall)\n* [Make Pumice](/wiki/recipes/make-pumice)\n* [Make Barbecue](/wiki/recipes/make-barbecue)\n* [Make Farm](/wiki/recipes/make-farm)\n* [Make Shards](/wiki/recipes/make-shards)\n* [Make Molten Glass](/wiki/recipes/make-molten-glass)\n* [Make Prism](/wiki/recipes/make-prism)\n* [Make Sparkle](/wiki/recipes/make-sparkle)\n* [Make Desert](/wiki/recipes/make-desert)\n* [Make Oasis](/wiki/recipes/make-oasis)\n* [Make Mirage](/wiki/recipes/make-mirage)\n* [Make Sand Dune](/wiki/recipes/make-sand-dune)\n* [Make Dam](/wiki/recipes/make-dam)\n* [Make Firewall](/wiki/recipes/make-firewall)\n* [Make Barricade](/wiki/recipes/make-barricade)\n* [Make Plateau](/wiki/recipes/make-plateau)\n* [Make Pond](/wiki/recipes/make-pond)\n* [Make Aromas](/wiki/recipes/make-aromas)\n* [Make Flower](/wiki/recipes/make-flower)\n* [Make Spore](/wiki/recipes/make-spore)\n* [Make Spread](/wiki/recipes/make-spread)\n* [Make Fertile Land](/wiki/recipes/make-fertile-land)\n* [Make Wetland](/wiki/recipes/make-wetland)\n* [Make Peat](/wiki/recipes/make-peat)\n* [Make Reeds](/wiki/recipes/make-reeds)\n* [Make Valley](/wiki/recipes/make-valley)\n* [Make River](/wiki/recipes/make-river)\n* [Make Scorched Earth](/wiki/recipes/make-scorched-earth)\n* [Make Delta](/wiki/recipes/make-delta)\n* [Make Estuary](/wiki/recipes/make-estuary)\n* [Make Fire Swamp](/wiki/recipes/make-fire-swamp)\n* [Make Riverbank](/wiki/recipes/make-riverbank)\n* [Make Ravine](/wiki/recipes/make-ravine)\n* [Make Gorge](/wiki/recipes/make-gorge)\n* [Make Charred Ravine](/wiki/recipes/make-charred-ravine)\n* [Make Echo](/wiki/recipes/make-echo)\n* [Make Cave](/wiki/recipes/make-cave)\n* [Make Underground Lake](/wiki/recipes/make-underground-lake)\n* [Make Lava Cave](/wiki/recipes/make-lava-cave)\n* [Make Whispering Cave](/wiki/recipes/make-whispering-cave)\n* [Make Subterranean Pool](/wiki/recipes/make-subterranean-pool)\n* [Make Spring](/wiki/recipes/make-spring)\n* [Make Hot Spring](/wiki/recipes/make-hot-spring)\n* [Make Grotto](/wiki/recipes/make-grotto)\n* [Make Fountain](/wiki/recipes/make-fountain)\n* [Make Steam Vent](/wiki/recipes/make-steam-vent)\n* [Make Cool Breeze](/wiki/recipes/make-cool-breeze)\n* [Make Monument](/wiki/recipes/make-monument)\n* [Make Waterfall](/wiki/recipes/make-waterfall)\n* [Make Eternal Flame](/wiki/recipes/make-eternal-flame)\n* [Make Pillar Of Wind](/wiki/recipes/make-pillar-of-wind)\n* [Make Stream](/wiki/recipes/make-stream)\n* [Make Zephyr](/wiki/recipes/make-zephyr)\n* [Make Creek](/wiki/recipes/make-creek)\n* [Make Brook](/wiki/recipes/make-brook)\n* [Make Whisper](/wiki/recipes/make-whisper)\n* [Make Rivulet](/wiki/recipes/make-rivulet)\n* [Make Tributary](/wiki/recipes/make-tributary)\n* [Make Murmur](/wiki/recipes/make-murmur)\n* [Make Watershed](/wiki/recipes/make-watershed)\n* [Make Aquifer](/wiki/recipes/make-aquifer)\n* [Make Parched Earth](/wiki/recipes/make-parched-earth)\n* [Make Fresh Breeze](/wiki/recipes/make-fresh-breeze)\n* [Make Groundwater](/wiki/recipes/make-groundwater)\n* [Make Reservoir](/wiki/recipes/make-reservoir)\n* [Make Geothermal Spring](/wiki/recipes/make-geothermal-spring)\n* [Make Artesian Well](/wiki/recipes/make-artesian-well)\n* [Make Basin](/wiki/recipes/make-basin)\n* [Make Lake](/wiki/recipes/make-lake)\n* [Make Dry Basin](/wiki/recipes/make-dry-basin)\n* [Make Depression](/wiki/recipes/make-depression)\n* [Make Island](/wiki/recipes/make-island)\n* [Make Lagoon](/wiki/recipes/make-lagoon)\n* [Make Wave](/wiki/recipes/make-wave)\n* [Make Reef](/wiki/recipes/make-reef)\n* [Make Coral](/wiki/recipes/make-coral)\n* [Make Whirl](/wiki/recipes/make-whirl)\n* [Make Limestone](/wiki/recipes/make-limestone)\n* [Make Karst](/wiki/recipes/make-karst)\n* [Make Quicklime](/wiki/recipes/make-quicklime)\n* [Make Blowhole](/wiki/recipes/make-blowhole)\n\nSee also:\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "365d7908f0bf1407033023293b018043b0721cee0d0fb9a3de88121aaf672be1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-adobe.md",
      "content": "# Make Adobe\n\nWe need a description here\n\n## Ingredients\n\n* [Earth](/wiki/elements/earth)\n* [Clay](/wiki/elements/clay)\n\n## Result\n\n* [Adobe](/wiki/elements/adobe)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "e0e0b984f791acaf5bf341a2949b3769554280cedbc8194f0795a26f882c8978",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-aquifer.md",
      "content": "# Make Aquifer\n\nWe need a description here\n\n## Ingredients\n\n* [Water](/wiki/elements/water)\n* [Watershed](/wiki/elements/watershed)\n\n## Result\n\n* [Aquifer](/wiki/elements/aquifer)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "bd899e98cb5c26b5a52da50ff0d6b823dc140a61e15c43563d3f3cc90f95f53d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-aromas.md",
      "content": "# Make Aromas\n\nWe need a description here\n\n## Ingredients\n\n* [Wind](/wiki/elements/wind)\n* [Garden](/wiki/elements/garden)\n\n## Result\n\n* [Aromas](/wiki/elements/aromas)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "bf49a01731ff4f23e6a675a06def3777b77c1b0027b2ff5ebecc1f0a22bb282e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-artesian-well.md",
      "content": "# Make Artesian Well\n\nWe need a description here\n\n## Ingredients\n\n* [Wind](/wiki/elements/wind)\n* [Groundwater](/wiki/elements/groundwater)\n\n## Result\n\n* [Artesian Well](/wiki/elements/artesian-well)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "f5a21a4eb0240ef04806698b6094ef913bfb006a7adbdf89efcbe451f66527a2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-ash.md",
      "content": "# Make Ash\n\nWe need a description here\n\n## Ingredients\n\n* [Lava](/wiki/elements/lava)\n* [Wind](/wiki/elements/wind)\n\n## Result\n\n* [Ash](/wiki/elements/ash)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "48c83f0a65d5a4bced5e72d0a0c2fd6df156a1c6033d6bdc383177237234b3c9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-barbecue.md",
      "content": "# Make Barbecue\n\nWe need a description here\n\n## Ingredients\n\n* [Fire](/wiki/elements/fire)\n* [Charcoal](/wiki/elements/charcoal)\n\n## Result\n\n* [Barbecue](/wiki/elements/barbecue)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "449978c7545b36e92f9e7b2125b119baf24b66ea1eb271f8431cb9e45b40e4e4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-barricade.md",
      "content": "# Make Barricade\n\nWe need a description here\n\n## Ingredients\n\n* [Wind](/wiki/elements/wind)\n* [Wall](/wiki/elements/wall)\n\n## Result\n\n* [Barricade](/wiki/elements/barricade)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "6a1493ec1b617f68c94dbf541aecf1163c53e19365d99f704e5b54bde9806b65",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-basalt.md",
      "content": "# Make Basalt\n\nWe need a description here\n\n## Ingredients\n\n* [Water](/wiki/elements/water)\n* [Lava](/wiki/elements/lava)\n\n## Result\n\n* [Basalt](/wiki/elements/basalt)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "65513629d7706a9b7d11eef1f324dcf9393f4dc8f3628a64e430fb8911c1c12b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-basin.md",
      "content": "# Make Basin\n\nWe need a description here\n\n## Ingredients\n\n* [Earth](/wiki/elements/earth)\n* [Reservoir](/wiki/elements/reservoir)\n\n## Result\n\n* [Basin](/wiki/elements/basin)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "b0340ce37bb9fea023df6125caa32a2775ba06e51797f1cfbabe311c72dff6d5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-beach.md",
      "content": "# Make Beach\n\nWe need a description here\n\n## Ingredients\n\n* [Water](/wiki/elements/water)\n* [Sand](/wiki/elements/sand)\n\n## Result\n\n* [Beach](/wiki/elements/beach)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "7be4edb6304281ce49f9afc5b6f647bf1cdb3acfdec40216ee20eab447b3c2dc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-beer.md",
      "content": "# Make Beer\n\n\n\n## Ingredients\n\n* [Bee](/wiki/elements/bee)\n* [Bear](/wiki/elements/bear)\n\n## Result\n\n* [Beer](/wiki/elements/beer)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "0073cfd7a4f82313eb7298401386a13f7cba0deb2c9d83a39ea33da10976a2bd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-blowhole.md",
      "content": "# Make Blowhole\n\nWe need a description here\n\n## Ingredients\n\n* [Wind](/wiki/elements/wind)\n* [Karst](/wiki/elements/karst)\n\n## Result\n\n* [Blowhole](/wiki/elements/blowhole)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "a1462692d31d4a3d39382fc412a4bfde84662252ca6aa5d0a150aa3d403e44f2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-breeze.md",
      "content": "# Make Breeze\n\nWe need a description here\n\n## Ingredients\n\n* [Wind](/wiki/elements/wind)\n* [Dust](/wiki/elements/dust)\n\n## Result\n\n* [Breeze](/wiki/elements/breeze)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "db92fbea8f9a613e0493c883cbadde31a13608ac445531b797154d2d51540128",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-brick.md",
      "content": "# Make Brick\n\nWe need a description here\n\n## Ingredients\n\n* [Clay](/wiki/elements/clay)\n* [Earth](/wiki/elements/earth)\n\n## Result\n\n* [Brick](/wiki/elements/brick)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "9ab4074656988beac0de74a238b8407eb4d02654cfda70dbc52a8d8105f509fa",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-bridge.md",
      "content": "# Make Bridge\n\n\n\n## Ingredients\n\n* [Monkey Branch](/wiki/elements/monkey-branch)\n* [Monkey Branch](/wiki/elements/monkey-branch)\n\n## Result\n\n* [Bridge](/wiki/elements/bridge)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "3631d6fc9dc6e5ce2bc35aa223fcad862a0cbb409b61c69ce7d6068c19508d18",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-brook.md",
      "content": "# Make Brook\n\nWe need a description here\n\n## Ingredients\n\n* [Water](/wiki/elements/water)\n* [Creek](/wiki/elements/creek)\n\n## Result\n\n* [Brook](/wiki/elements/brook)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "774c77ed1551c46b9f63b09e66fbd1061666d39696243cfdc05e79a021b0a8a0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-canyon.md",
      "content": "# Make Canyon\n\nWe need a description here\n\n## Ingredients\n\n* [Water](/wiki/elements/water)\n* [Erosion](/wiki/elements/erosion)\n\n## Result\n\n* [Canyon](/wiki/elements/canyon)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "5d51c734cfc5af8143d908d2a2b36941f80ed44f3966352568a5638c2f76f2dc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-cardano.md",
      "content": "# Make Cardano\n\n\n\n## Ingredients\n\n* [Blockchain](/wiki/elements/blockchain)\n* [Peer Review](/wiki/elements/peer-review)\n\n## Result\n\n* [Cardano](/wiki/elements/cardano)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "77ce6bb64a53bc4c0f627182a00b94e621b236f761867e8adf2581c4f50b14b1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-cave.md",
      "content": "# Make Cave\n\nWe need a description here\n\n## Ingredients\n\n* [Earth](/wiki/elements/earth)\n* [Echo](/wiki/elements/echo)\n\n## Result\n\n* [Cave](/wiki/elements/cave)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "11222ad027d7c0aa08c9ec952a9e0ff6e8713f9e980b35d67ed00d54e0ce6b6f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-charcoal.md",
      "content": "# Make Charcoal\n\nWe need a description here\n\n## Ingredients\n\n* [Tree](/wiki/elements/tree)\n* [Fire](/wiki/elements/fire)\n\n## Result\n\n* [Charcoal](/wiki/elements/charcoal)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "02568413d178b171b717ad38d2e2a44f32c8bc793461ac02b6c2ad90b38721ae",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-charred-ravine.md",
      "content": "# Make Charred Ravine\n\nWe need a description here\n\n## Ingredients\n\n* [Fire](/wiki/elements/fire)\n* [Ravine](/wiki/elements/ravine)\n\n## Result\n\n* [Charred Ravine](/wiki/elements/charred-ravine)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "277b5c820bd1238b93b9d627443ba1899b4638c1751ecca73163d5f1d69797f6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-clay.md",
      "content": "# Make Clay\n\nWe need a description here\n\n## Ingredients\n\n* [Mud](/wiki/elements/mud)\n* [Fire](/wiki/elements/fire)\n\n## Result\n\n* [Clay](/wiki/elements/clay)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "ad821a4fe7cb5d3dbf626477874ab02aa64f79a326170af2777527cf996d7a02",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-cloud.md",
      "content": "# Make Cloud\n\nWe need a description here\n\n## Ingredients\n\n* [Smoke](/wiki/elements/smoke)\n* [Water](/wiki/elements/water)\n\n## Result\n\n* [Cloud](/wiki/elements/cloud)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "6654ffe5475f3ee917e6f8744c85b47138b864ee47028a523ad89a8a309311bc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-cool-breeze.md",
      "content": "# Make Cool Breeze\n\nWe need a description here\n\n## Ingredients\n\n* [Wind](/wiki/elements/wind)\n* [Spring](/wiki/elements/spring)\n\n## Result\n\n* [Cool Breeze](/wiki/elements/cool-breeze)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "33331a741bea160d24cdd7ac634bfc0c78bc7d1be704534bc24514e42e8e630d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-coral.md",
      "content": "# Make Coral\n\nWe need a description here\n\n## Ingredients\n\n* [Water](/wiki/elements/water)\n* [Reef](/wiki/elements/reef)\n\n## Result\n\n* [Coral](/wiki/elements/coral)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "e3e0c08619ccba8166d57209c9ba17a33e22164e3b432e963c29671e477d1ada",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-creek.md",
      "content": "# Make Creek\n\nWe need a description here\n\n## Ingredients\n\n* [Earth](/wiki/elements/earth)\n* [Stream](/wiki/elements/stream)\n\n## Result\n\n* [Creek](/wiki/elements/creek)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "34e8a41c2d48335a335d23aa5b773ce1728fc69bbce8c1c74af310a17c304573",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-crystal.md",
      "content": "# Make Crystal\n\nWe need a description here\n\n## Ingredients\n\n* [Glass](/wiki/elements/glass)\n* [Earth](/wiki/elements/earth)\n\n## Result\n\n* [Crystal](/wiki/elements/crystal)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "9f7d7942bc3ee3c2aa19dd7aa8ea232133ab1b9a8596939744d4aeb10e9aa4ff",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-dam.md",
      "content": "# Make Dam\n\nWe need a description here\n\n## Ingredients\n\n* [Water](/wiki/elements/water)\n* [Wall](/wiki/elements/wall)\n\n## Result\n\n* [Dam](/wiki/elements/dam)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "e64c8f7b86e701bd670c1c748c30ae3ee5c0d3dbc781cd60da7cd399f8a0c894",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-delta.md",
      "content": "# Make Delta\n\nWe need a description here\n\n## Ingredients\n\n* [Earth](/wiki/elements/earth)\n* [River](/wiki/elements/river)\n\n## Result\n\n* [Delta](/wiki/elements/delta)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "8730699e40d5d0b9e24c99bd9999f4b32d1d9e4fa8366b8a193819504f82b1c5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-depression.md",
      "content": "# Make Depression\n\nWe need a description here\n\n## Ingredients\n\n* [Wind](/wiki/elements/wind)\n* [Basin](/wiki/elements/basin)\n\n## Result\n\n* [Depression](/wiki/elements/depression)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "494fbdcac6cfbbb0536bbda3fca13993c432507d99745b774017f99b52ad7cdc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-desert.md",
      "content": "# Make Desert\n\nWe need a description here\n\n## Ingredients\n\n* [Earth](/wiki/elements/earth)\n* [Beach](/wiki/elements/beach)\n\n## Result\n\n* [Desert](/wiki/elements/desert)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "2918a2975d9839cc7cfd40b2eb8868fd5e31430cb6ab5da6a515e4327fe7d98a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-dry-basin.md",
      "content": "# Make Dry Basin\n\nWe need a description here\n\n## Ingredients\n\n* [Fire](/wiki/elements/fire)\n* [Basin](/wiki/elements/basin)\n\n## Result\n\n* [Dry Basin](/wiki/elements/dry-basin)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "f4c4154a5a9ebb2a4a824388f5ae37a2b3718c88b60a905bb717267939f2d2a3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-dune.md",
      "content": "# Make Dune\n\nWe need a description here\n\n## Ingredients\n\n* [Sand](/wiki/elements/sand)\n* [Wind](/wiki/elements/wind)\n\n## Result\n\n* [Dune](/wiki/elements/dune)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "6131aee03b2ede962a55c1a951561643c1ba20195568881668dca0fd27fbebcf",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-dust.md",
      "content": "# Make Dust\n\nWe need a description here\n\n## Ingredients\n\n* [Wind](/wiki/elements/wind)\n* [Earth](/wiki/elements/earth)\n\n## Result\n\n* [Dust](/wiki/elements/dust)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "38d980eb6e931ad95deaebf70239a5bb1751cd1b319a076ea97a8fde22ee774f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-echo.md",
      "content": "# Make Echo\n\nWe need a description here\n\n## Ingredients\n\n* [Wind](/wiki/elements/wind)\n* [Ravine](/wiki/elements/ravine)\n\n## Result\n\n* [Echo](/wiki/elements/echo)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "848d39c18a26ef522e0ae865aa3abbfe15b455f76ed698c34fb6adf6165793e5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-ember.md",
      "content": "# Make Ember\n\nWe need a description here\n\n## Ingredients\n\n* [Fire](/wiki/elements/fire)\n* [Ash](/wiki/elements/ash)\n\n## Result\n\n* [Ember](/wiki/elements/ember)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "f62adc7df09f35946486654b6ecc47a2ed330aead07d7570fbf6b5d4625b0255",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-erosion.md",
      "content": "# Make Erosion\n\nWe need a description here\n\n## Ingredients\n\n* [Wind](/wiki/elements/wind)\n* [Rock](/wiki/elements/rock)\n\n## Result\n\n* [Erosion](/wiki/elements/erosion)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "96800a0e3ef0e811f06c9b5bc4bc79c74bb23e01f334891238099a775223fd90",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-estuary.md",
      "content": "# Make Estuary\n\nWe need a description here\n\n## Ingredients\n\n* [Water](/wiki/elements/water)\n* [Delta](/wiki/elements/delta)\n\n## Result\n\n* [Estuary](/wiki/elements/estuary)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "5a14a9b4ea9ff46b162a552ec99c584ab03660b14baa299e6bf3f2cacfe5d681",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-eternal-flame.md",
      "content": "# Make Eternal Flame\n\nWe need a description here\n\n## Ingredients\n\n* [Fire](/wiki/elements/fire)\n* [Monument](/wiki/elements/monument)\n\n## Result\n\n* [Eternal Flame](/wiki/elements/eternal-flame)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "e429d03e793a07f980ed8fbd711334dc1c80bd5df127efc61f0fd95523ab35b5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-farm.md",
      "content": "# Make Farm\n\nWe need a description here\n\n## Ingredients\n\n* [Earth](/wiki/elements/earth)\n* [Seeds](/wiki/elements/seeds)\n\n## Result\n\n* [Farm](/wiki/elements/farm)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "fac60b26614bfd1ee1f1d7a63ab748be7bbbfd2d125dd44dd0c90ed6979a7b77",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-fertile-land.md",
      "content": "# Make Fertile Land\n\nWe need a description here\n\n## Ingredients\n\n* [Earth](/wiki/elements/earth)\n* [Soil](/wiki/elements/soil)\n\n## Result\n\n* [Fertile Land](/wiki/elements/fertile-land)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "51e4d56365edebf8100294da93f1dcfa19129fed9c1a76e0a88d9c08eeaaa9c6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-fertilizer.md",
      "content": "# Make Fertilizer\n\nWe need a description here\n\n## Ingredients\n\n* [Ash](/wiki/elements/ash)\n* [Earth](/wiki/elements/earth)\n\n## Result\n\n* [Fertilizer](/wiki/elements/fertilizer)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "8865018da9632f8967f436100ad16148b2b720e67007f99ae6cc1479545bd95d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-fire-swamp.md",
      "content": "# Make Fire Swamp\n\nWe need a description here\n\n## Ingredients\n\n* [Fire](/wiki/elements/fire)\n* [Delta](/wiki/elements/delta)\n\n## Result\n\n* [Fire Swamp](/wiki/elements/fire-swamp)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "02bdc84bb00da2673daf63461d62e3219ba90e610ae9d6c4d26b56d3b31fba72",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-firewall.md",
      "content": "# Make Firewall\n\nWe need a description here\n\n## Ingredients\n\n* [Fire](/wiki/elements/fire)\n* [Wall](/wiki/elements/wall)\n\n## Result\n\n* [Firewall](/wiki/elements/firewall)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "cba6f37e41f74878561331dcc144372c800ee46bf947e627ab84e12fb2ae6812",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-flood.md",
      "content": "# Make Flood\n\nWe need a description here\n\n## Ingredients\n\n* [Storm](/wiki/elements/storm)\n* [Water](/wiki/elements/water)\n\n## Result\n\n* [Flood](/wiki/elements/flood)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "956ef2d0b449ed1a8896db11500d490c34911acd7c40a97f107be32df79c9ef9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-flower.md",
      "content": "# Make Flower\n\nWe need a description here\n\n## Ingredients\n\n* [Water](/wiki/elements/water)\n* [Pollination](/wiki/elements/pollination)\n\n## Result\n\n* [Flower](/wiki/elements/flower)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "ad2fdddd9874ddaefb7ef33f63ea89a637e348cbb5d3b66b3eebf0656f4f2012",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-fog.md",
      "content": "# Make Fog\n\nWe need a description here\n\n## Ingredients\n\n* [Smoke](/wiki/elements/smoke)\n* [Wind](/wiki/elements/wind)\n\n## Result\n\n* [Fog](/wiki/elements/fog)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "6920851fe369fc67b8b6a0af82daabf6e9d9fe5a66612cb449f8710cb0d63a06",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-forest.md",
      "content": "# Make Forest\n\nWe need a description here\n\n## Ingredients\n\n* [Plant](/wiki/elements/plant)\n* [Earth](/wiki/elements/earth)\n\n## Result\n\n* [Forest](/wiki/elements/forest)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "acb4707c686c64a88e57ab38718eda5360365fe9f6bb939a4d7d9ca971fe3f48",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-fountain.md",
      "content": "# Make Fountain\n\nWe need a description here\n\n## Ingredients\n\n* [Water](/wiki/elements/water)\n* [Spring](/wiki/elements/spring)\n\n## Result\n\n* [Fountain](/wiki/elements/fountain)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "a84610f31aa03ce9c60aacb191687904e0055baa16953c0f323e0e8639fc1832",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-fresh-breeze.md",
      "content": "# Make Fresh Breeze\n\nWe need a description here\n\n## Ingredients\n\n* [Wind](/wiki/elements/wind)\n* [Watershed](/wiki/elements/watershed)\n\n## Result\n\n* [Fresh Breeze](/wiki/elements/fresh-breeze)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "8a268f0a5cb544efb6e338718d733689d05bedea085bf3de3154edc01ac1bb49",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-frosted-glass.md",
      "content": "# Make Frosted Glass\n\nWe need a description here\n\n## Ingredients\n\n* [Glass](/wiki/elements/glass)\n* [Water](/wiki/elements/water)\n\n## Result\n\n* [Frosted Glass](/wiki/elements/frosted-glass)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "3d2d3dbfd522a57c26c3b8194e9c2a50bbc1e07ae4b525affe1ef67c7bd325e7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-garden.md",
      "content": "# Make Garden\n\nWe need a description here\n\n## Ingredients\n\n* [Earth](/wiki/elements/earth)\n* [Plant](/wiki/elements/plant)\n\n## Result\n\n* [Garden](/wiki/elements/garden)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "dcc3c7676120ff9f37f1fe6fa1c291837576e3fa4bc909d0c9beb33e6a71b905",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-geothermal-spring.md",
      "content": "# Make Geothermal Spring\n\nWe need a description here\n\n## Ingredients\n\n* [Fire](/wiki/elements/fire)\n* [Groundwater](/wiki/elements/groundwater)\n\n## Result\n\n* [Geothermal Spring](/wiki/elements/geothermal-spring)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "dce2b4829b12940ce501f02f287e573754be106222cf29d0c1683a9a23d41a9c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-geyser.md",
      "content": "# Make Geyser\n\nWe need a description here\n\n## Ingredients\n\n* [Steam](/wiki/elements/steam)\n* [Earth](/wiki/elements/earth)\n\n## Result\n\n* [Geyser](/wiki/elements/geyser)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "423e46f7a9c9d14862e85a0c7f5f251cb92ba3d2bb7ce844722fab23944a8791",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-glass.md",
      "content": "# Make Glass\n\nWe need a description here\n\n## Ingredients\n\n* [Sand](/wiki/elements/sand)\n* [Fire](/wiki/elements/fire)\n\n## Result\n\n* [Glass](/wiki/elements/glass)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "7e994189ff6cd4fca6ddcd4a37213884ea789c277ffe727ce67dfc720c29ebd9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-goldengate.md",
      "content": "# Make Goldengate\n\n\n\n## Ingredients\n\n* [Coin](/wiki/elements/coin)\n* [Bridge](/wiki/elements/bridge)\n\n## Result\n\n* [Golden Gate](/wiki/elements/golden-gate)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "c8ea6e047cab9eb554e18ce6a31180891898b16d17d351619fa80de04e61729f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-gorge.md",
      "content": "# Make Gorge\n\nWe need a description here\n\n## Ingredients\n\n* [Water](/wiki/elements/water)\n* [Ravine](/wiki/elements/ravine)\n\n## Result\n\n* [Gorge](/wiki/elements/gorge)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "1848b00de20e25c5d66060987b961ef7103e994b7f610e46578a018f06660f01",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-grotto.md",
      "content": "# Make Grotto\n\nWe need a description here\n\n## Ingredients\n\n* [Wind](/wiki/elements/wind)\n* [Subterranean Pool](/wiki/elements/subterranean-pool)\n\n## Result\n\n* [Grotto](/wiki/elements/grotto)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "7e37c5cad82af8f2b0200dedeeb245640cfc0c5b5a563e8bfa1fcbe2c6af5eaf",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-groundwater.md",
      "content": "# Make Groundwater\n\nWe need a description here\n\n## Ingredients\n\n* [Earth](/wiki/elements/earth)\n* [Aquifer](/wiki/elements/aquifer)\n\n## Result\n\n* [Groundwater](/wiki/elements/groundwater)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "c490adc334e2d827b90953a894e107562a152d864197080c0ee7f19a43543422",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-haze.md",
      "content": "# Make Haze\n\nWe need a description here\n\n## Ingredients\n\n* [Fog](/wiki/elements/fog)\n* [Wind](/wiki/elements/wind)\n\n## Result\n\n* [Haze](/wiki/elements/haze)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "48f27e0b837fd1ce296ee68fc5c2fff73e357c7d1c301df8cab9e4656312a687",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-hot-spring.md",
      "content": "# Make Hot Spring\n\nWe need a description here\n\n## Ingredients\n\n* [Fire](/wiki/elements/fire)\n* [Subterranean Pool](/wiki/elements/subterranean-pool)\n\n## Result\n\n* [Hot Spring](/wiki/elements/hot-spring)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "ad61816e251ae4b085f105e1276a09d623cde030299024736e635afd103d9ac6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-hydra.md",
      "content": "# Make Hydra\n\n\n\n## Ingredients\n\n* [Giraffe](/wiki/elements/giraffe)\n* [Giraffe](/wiki/elements/giraffe)\n\n## Result\n\n* [Hydra](/wiki/elements/hydra)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "7c232238ded8534d56238a76696943ec8ed573690021445333042bed2b42ca00",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-hypermarmalade.md",
      "content": "# Make Hypermarmalade\n\n\n\n## Ingredients\n\n* [Super Marmalade](/wiki/elements/super-marmalade)\n* [Super Marmalade](/wiki/elements/super-marmalade)\n\n## Result\n\n* [Hyper Marmalade](/wiki/elements/hyper-marmalade)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "1c8bb95ff34bdf70a4106e3c66b7aee323e6a8a59cd2cdfaf40ccecb97e3bc2e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-island.md",
      "content": "# Make Island\n\nWe need a description here\n\n## Ingredients\n\n* [Earth](/wiki/elements/earth)\n* [Lake](/wiki/elements/lake)\n\n## Result\n\n* [Island](/wiki/elements/island)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "da12fd0f5353d927da9ba7006ac72d279208483032ca5907d1a87e5ce14578c1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-jungle.md",
      "content": "# Make Jungle\n\nWe need a description here\n\n## Ingredients\n\n* [Forest](/wiki/elements/forest)\n* [Earth](/wiki/elements/earth)\n\n## Result\n\n* [Jungle](/wiki/elements/jungle)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "2c8365c45a8eeb0cf0fa59a18314bf631f8962fc0bb2408ecfacc3648a27c60d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-karst.md",
      "content": "# Make Karst\n\nWe need a description here\n\n## Ingredients\n\n* [Water](/wiki/elements/water)\n* [Limestone](/wiki/elements/limestone)\n\n## Result\n\n* [Karst](/wiki/elements/karst)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "cbdc8d88e0d930f3adfd0363b73e93baa63c92bdf71bcb7e53fa544e908a741d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-kiln.md",
      "content": "# Make Kiln\n\nWe need a description here\n\n## Ingredients\n\n* [Fire](/wiki/elements/fire)\n* [Pottery](/wiki/elements/pottery)\n\n## Result\n\n* [Kiln](/wiki/elements/kiln)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "57b6b8270993fc986f2ceb11eb67b91b83d5e42fd48e267ef30e94e73dac7948",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-lagoon.md",
      "content": "# Make Lagoon\n\nWe need a description here\n\n## Ingredients\n\n* [Water](/wiki/elements/water)\n* [Lake](/wiki/elements/lake)\n\n## Result\n\n* [Lagoon](/wiki/elements/lagoon)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "515ccbd6f8e2cc99d07a090c644eb883c16bb7a6814e9fb17f9c326627a917a1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-lake.md",
      "content": "# Make Lake\n\nWe need a description here\n\n## Ingredients\n\n* [Water](/wiki/elements/water)\n* [Basin](/wiki/elements/basin)\n\n## Result\n\n* [Lake](/wiki/elements/lake)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "7a068d01172a833df0569b1dba2e441c08df2ed80f4057f3909bbfea974c4c9c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-landslide.md",
      "content": "# Make Landslide\n\nWe need a description here\n\n## Ingredients\n\n* [Storm](/wiki/elements/storm)\n* [Earth](/wiki/elements/earth)\n\n## Result\n\n* [Landslide](/wiki/elements/landslide)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "8fce5bf66a392c2c03b30c2774808ec2e1bd7b3e0b0bf238546c4147715092ba",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-lava-cave.md",
      "content": "# Make Lava Cave\n\nWe need a description here\n\n## Ingredients\n\n* [Fire](/wiki/elements/fire)\n* [Cave](/wiki/elements/cave)\n\n## Result\n\n* [Lava Cave](/wiki/elements/lava-cave)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "d1e1fbb669c7048082814b8d6fa837d5457ed2ca8d2024cac450b09965e47bfe",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-lava.md",
      "content": "# Make Lava\n\nWe need a description here\n\n## Ingredients\n\n* [Fire](/wiki/elements/fire)\n* [Earth](/wiki/elements/earth)\n\n## Result\n\n* [Lava](/wiki/elements/lava)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "2384ad1038a99ccbfddc48817a4414d73f218a103a7b87f8b5e784f217006f11",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-leaves.md",
      "content": "# Make Leaves\n\nWe need a description here\n\n## Ingredients\n\n* [Tree](/wiki/elements/tree)\n* [Wind](/wiki/elements/wind)\n\n## Result\n\n* [Leaves](/wiki/elements/leaves)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "d0a8efbcfa0b72028ada9f33da7d11f9e2b490575ac5c1b60c57b349adcc8783",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-lightning.md",
      "content": "# Make Lightning\n\nWe need a description here\n\n## Ingredients\n\n* [Cloud](/wiki/elements/cloud)\n* [Fire](/wiki/elements/fire)\n\n## Result\n\n* [Lightning](/wiki/elements/lightning)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "a2cf151c75f2bded0e6d2171b735973f09d3dec7d9554d6d50bfbea4e8f1b1d9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-limestone.md",
      "content": "# Make Limestone\n\nWe need a description here\n\n## Ingredients\n\n* [Earth](/wiki/elements/earth)\n* [Coral](/wiki/elements/coral)\n\n## Result\n\n* [Limestone](/wiki/elements/limestone)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "79dd0963f8bb24d6409f5b85b57314cd29a4f579678c12ea295b05f6a5a0ff10",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-lock.md",
      "content": "# Make Lock\n\n\n\n## Ingredients\n\n* [Silver](/wiki/elements/silver)\n* [Silver](/wiki/elements/silver)\n\n## Result\n\n* [Lock](/wiki/elements/lock)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "119d12f030ed5fc31ed9f3fe5fa10c08bc75e39ac3ee1597e122e712a6d74db0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-magma-chamber.md",
      "content": "# Make Magma Chamber\n\nWe need a description here\n\n## Ingredients\n\n* [Earth](/wiki/elements/earth)\n* [Lava](/wiki/elements/lava)\n\n## Result\n\n* [Magma Chamber](/wiki/elements/magma-chamber)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "3d6eba1b0db9ab2d6e9a4e18d565bfa30cf4a9e42ae3487fe488e176cdef8278",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-magma.md",
      "content": "# Make Magma\n\nWe need a description here\n\n## Ingredients\n\n* [Obsidian](/wiki/elements/obsidian)\n* [Fire](/wiki/elements/fire)\n\n## Result\n\n* [Magma](/wiki/elements/magma)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "5ea2a063ef6b4e80ae3334a214ee10f6b5b93bcd04ac39941324c505c1a8bf45",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-mirage.md",
      "content": "# Make Mirage\n\nWe need a description here\n\n## Ingredients\n\n* [Fire](/wiki/elements/fire)\n* [Desert](/wiki/elements/desert)\n\n## Result\n\n* [Mirage](/wiki/elements/mirage)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "d05c8013693da0472ddf2c49a90f85cd3588102d7dbcf50e13c1472a6ae90360",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-mist.md",
      "content": "# Make Mist\n\nWe need a description here\n\n## Ingredients\n\n* [Fog](/wiki/elements/fog)\n* [Earth](/wiki/elements/earth)\n\n## Result\n\n* [Mist](/wiki/elements/mist)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "648a7cca236afdf2f3c4bb3dd0aef802b9f7b71b067d98fc0536e754633e7b30",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-molten-glass.md",
      "content": "# Make Molten Glass\n\nWe need a description here\n\n## Ingredients\n\n* [Fire](/wiki/elements/fire)\n* [Crystal](/wiki/elements/crystal)\n\n## Result\n\n* [Molten Glass](/wiki/elements/molten-glass)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "d4ad2f0a4c93115b954c741ab6e87d63b18fad549a1f5906a3cd36db3b023ae8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-monkeybranch.md",
      "content": "# Make Monkeybranch\n\n\n\n## Ingredients\n\n* [Monkey](/wiki/elements/monkey)\n* [Hydra](/wiki/elements/hydra)\n\n## Result\n\n* [Monkey Branch](/wiki/elements/monkey-branch)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "99dad9c62f0423aa70d9a2f77b9c370bce2cd4e4ac32b3fbeb2a002de5309b38",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-monument.md",
      "content": "# Make Monument\n\nWe need a description here\n\n## Ingredients\n\n* [Earth](/wiki/elements/earth)\n* [Fountain](/wiki/elements/fountain)\n\n## Result\n\n* [Monument](/wiki/elements/monument)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "6353a277a2e0fcdb593fef39c543044a3b3ef5694c2ab35f6803955047473e4d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-mountain.md",
      "content": "# Make Mountain\n\nWe need a description here\n\n## Ingredients\n\n* [Rock](/wiki/elements/rock)\n* [Earth](/wiki/elements/earth)\n\n## Result\n\n* [Mountain](/wiki/elements/mountain)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "dac5f73c87ed01c9cbe53f34a0169e2e21f14e60bdc063afcb053b35dae48955",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-mud.md",
      "content": "# Make Mud\n\nWe need a description here\n\n## Ingredients\n\n* [Water](/wiki/elements/water)\n* [Earth](/wiki/elements/earth)\n\n## Result\n\n* [Mud](/wiki/elements/mud)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "30b5aa38a5d0f08dbe2db10207a87dbf7253981270b48ce968cc864cd83e7ce3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-murmur.md",
      "content": "# Make Murmur\n\nWe need a description here\n\n## Ingredients\n\n* [Wind](/wiki/elements/wind)\n* [Rivulet](/wiki/elements/rivulet)\n\n## Result\n\n* [Murmur](/wiki/elements/murmur)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "dcb7bdd28c04c624ff41539c4474ad4448f4b5a6256272d60162aea5b3a63091",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-oasis.md",
      "content": "# Make Oasis\n\nWe need a description here\n\n## Ingredients\n\n* [Water](/wiki/elements/water)\n* [Desert](/wiki/elements/desert)\n\n## Result\n\n* [Oasis](/wiki/elements/oasis)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "fabe313dd90800b0686ba0865ebfe4d3962d64a569da50c8d161f56f8f15ed64",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-obsidian.md",
      "content": "# Make Obsidian\n\nWe need a description here\n\n## Ingredients\n\n* [Lava](/wiki/elements/lava)\n* [Water](/wiki/elements/water)\n\n## Result\n\n* [Obsidian](/wiki/elements/obsidian)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "7a4d87fc6bed7fec502cacf4d5091d01833c6e57330a5f21e469093dcb34f830",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-parched-earth.md",
      "content": "# Make Parched Earth\n\nWe need a description here\n\n## Ingredients\n\n* [Fire](/wiki/elements/fire)\n* [Watershed](/wiki/elements/watershed)\n\n## Result\n\n* [Parched Earth](/wiki/elements/parched-earth)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "d618e146900590cc6ae3794fd157cdfc1397460973814b8e2677fce5d47114ed",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-peat.md",
      "content": "# Make Peat\n\nWe need a description here\n\n## Ingredients\n\n* [Fire](/wiki/elements/fire)\n* [Wetland](/wiki/elements/wetland)\n\n## Result\n\n* [Peat](/wiki/elements/peat)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "3508abbb872ef7585db63cb15b2c7b460ce40a365f2120a8bd5fe9f14622b473",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-pebble.md",
      "content": "# Make Pebble\n\nWe need a description here\n\n## Ingredients\n\n* [Rock](/wiki/elements/rock)\n* [Water](/wiki/elements/water)\n\n## Result\n\n* [Pebble](/wiki/elements/pebble)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "00c4d5b2d89a2d006aa083636170d8d29260fbd2b307e6ca2a7505728e12b423",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-pillar-of-wind.md",
      "content": "# Make Pillar Of Wind\n\nWe need a description here\n\n## Ingredients\n\n* [Wind](/wiki/elements/wind)\n* [Monument](/wiki/elements/monument)\n\n## Result\n\n* [Pillar Of Wind](/wiki/elements/pillar-of-wind)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "518a4495c97f3a7d7b14c5f5916f5c54b9909394785b4a08a3e42e58d55e223c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-plant.md",
      "content": "# Make Plant\n\nWe need a description here\n\n## Ingredients\n\n* [Rain](/wiki/elements/rain)\n* [Earth](/wiki/elements/earth)\n\n## Result\n\n* [Plant](/wiki/elements/plant)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "873652ea7c981e090370d0ad764d456b6dd72a26a467da73ca52e1291ae918e2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-plateau.md",
      "content": "# Make Plateau\n\nWe need a description here\n\n## Ingredients\n\n* [Earth](/wiki/elements/earth)\n* [Canyon](/wiki/elements/canyon)\n\n## Result\n\n* [Plateau](/wiki/elements/plateau)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "a94874363e780322f16702915ee132de4fb05578b10230dbfee1d4dd28209705",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-pollination.md",
      "content": "# Make Pollination\n\nWe need a description here\n\n## Ingredients\n\n* [Wind](/wiki/elements/wind)\n* [Plant](/wiki/elements/plant)\n\n## Result\n\n* [Pollination](/wiki/elements/pollination)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "26af082f2990b0be47267541f4e11a57f4895c039c2731a9691f84ddb9d6e157",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-pond.md",
      "content": "# Make Pond\n\nWe need a description here\n\n## Ingredients\n\n* [Water](/wiki/elements/water)\n* [Garden](/wiki/elements/garden)\n\n## Result\n\n* [Pond](/wiki/elements/pond)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "da9d8580597eff609fcf213d3f2670e8ed0fa9a7dd1101e3c936c720aa4d297d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-pottery.md",
      "content": "# Make Pottery\n\nWe need a description here\n\n## Ingredients\n\n* [Clay](/wiki/elements/clay)\n* [Fire](/wiki/elements/fire)\n\n## Result\n\n* [Pottery](/wiki/elements/pottery)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "6a65861f89359f631209851edfee8c5197d624af3c74ec4c12df6eede1d9d9b4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-prism.md",
      "content": "# Make Prism\n\nWe need a description here\n\n## Ingredients\n\n* [Water](/wiki/elements/water)\n* [Crystal](/wiki/elements/crystal)\n\n## Result\n\n* [Prism](/wiki/elements/prism)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "363668aa883d4f3df59711fa1c7fd006608fa26ef972624e2b28b16b173a4f02",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-pumice.md",
      "content": "# Make Pumice\n\nWe need a description here\n\n## Ingredients\n\n* [Water](/wiki/elements/water)\n* [Ash](/wiki/elements/ash)\n\n## Result\n\n* [Pumice](/wiki/elements/pumice)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "21b4d15dd7a025cb448afbbedc4f8bc2a6e761b66d292d62fad80be675cc917a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-quicklime.md",
      "content": "# Make Quicklime\n\nWe need a description here\n\n## Ingredients\n\n* [Fire](/wiki/elements/fire)\n* [Limestone](/wiki/elements/limestone)\n\n## Result\n\n* [Quicklime](/wiki/elements/quicklime)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "e2876d1edc7d25193b0e360f5289389d1182c155a7ec25b590276e4613c05026",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-quicksand.md",
      "content": "# Make Quicksand\n\nWe need a description here\n\n## Ingredients\n\n* [Sand](/wiki/elements/sand)\n* [Water](/wiki/elements/water)\n\n## Result\n\n* [Quicksand](/wiki/elements/quicksand)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "dc652ff45eedc340055e909e3f849b26a4b3c623cb5a42e46727bc4f85a9c032",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-rain.md",
      "content": "# Make Rain\n\nWe need a description here\n\n## Ingredients\n\n* [Water](/wiki/elements/water)\n* [Wind](/wiki/elements/wind)\n\n## Result\n\n* [Rain](/wiki/elements/rain)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "fec9915218d3877b2732859c13f591c0b872edbc1f4b2488c46fe25fabcfba46",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-rainbow.md",
      "content": "# Make Rainbow\n\nWe need a description here\n\n## Ingredients\n\n* [Rain](/wiki/elements/rain)\n* [Fire](/wiki/elements/fire)\n\n## Result\n\n* [Rainbow](/wiki/elements/rainbow)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "2099cb706be3b3b4cd814f84b863f06fe0dbdff91c552da7d0be354823c24e3d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-ravine.md",
      "content": "# Make Ravine\n\nWe need a description here\n\n## Ingredients\n\n* [Earth](/wiki/elements/earth)\n* [Erosion](/wiki/elements/erosion)\n\n## Result\n\n* [Ravine](/wiki/elements/ravine)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "805d37e26387d1d93406dc7fe397f2065e4f4546cf7b8e253ed994edccc75a8e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-reeds.md",
      "content": "# Make Reeds\n\nWe need a description here\n\n## Ingredients\n\n* [Wind](/wiki/elements/wind)\n* [Wetland](/wiki/elements/wetland)\n\n## Result\n\n* [Reeds](/wiki/elements/reeds)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "9cb1f17e62652de0eb184f71e8e659008e8e88c6efb0389809d5e8a8c4cfb61e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-reef.md",
      "content": "# Make Reef\n\nWe need a description here\n\n## Ingredients\n\n* [Earth](/wiki/elements/earth)\n* [Lagoon](/wiki/elements/lagoon)\n\n## Result\n\n* [Reef](/wiki/elements/reef)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "195c75b6c3245eb264475e26616c903841395911889a3748e0ea94c51f6f3e3d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-reservoir.md",
      "content": "# Make Reservoir\n\nWe need a description here\n\n## Ingredients\n\n* [Water](/wiki/elements/water)\n* [Groundwater](/wiki/elements/groundwater)\n\n## Result\n\n* [Reservoir](/wiki/elements/reservoir)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "8346b8724af2c10ff9c010dcd636d4ced630ce833d73f2af5a6ba5f620f72454",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-river.md",
      "content": "# Make River\n\nWe need a description here\n\n## Ingredients\n\n* [Water](/wiki/elements/water)\n* [Valley](/wiki/elements/valley)\n\n## Result\n\n* [River](/wiki/elements/river)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "a83c098008004c27fc8f2ee3afe30aa7aaddc26246bf1e008e521c7a3d70f8d7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-riverbank.md",
      "content": "# Make Riverbank\n\nWe need a description here\n\n## Ingredients\n\n* [Wind](/wiki/elements/wind)\n* [Delta](/wiki/elements/delta)\n\n## Result\n\n* [Riverbank](/wiki/elements/riverbank)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "3d2255f2f46d3c6d7988e11ad423efb58518a5742e3d099f6f4f588faac9911c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-rivulet.md",
      "content": "# Make Rivulet\n\nWe need a description here\n\n## Ingredients\n\n* [Earth](/wiki/elements/earth)\n* [Brook](/wiki/elements/brook)\n\n## Result\n\n* [Rivulet](/wiki/elements/rivulet)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "0828721417ae9b80b99143e79ac2f2ee72a364c96d2b6e0d0978fa6b1ac01081",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-rock.md",
      "content": "# Make Rock\n\nWe need a description here\n\n## Ingredients\n\n* [Obsidian](/wiki/elements/obsidian)\n* [Earth](/wiki/elements/earth)\n\n## Result\n\n* [Rock](/wiki/elements/rock)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "89abe0731e84074bd5401a71f312b7a04f3b73ba55b8067cca70c261659b3832",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-sand-dune.md",
      "content": "# Make Sand Dune\n\nWe need a description here\n\n## Ingredients\n\n* [Wind](/wiki/elements/wind)\n* [Desert](/wiki/elements/desert)\n\n## Result\n\n* [Sand Dune](/wiki/elements/sand-dune)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "c1d939d2f93924b98b7b00bf1361f42a67ffab3135b16ac9ccdf8c66aaae5225",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-sand.md",
      "content": "# Make Sand\n\nWe need a description here\n\n## Ingredients\n\n* [Mud](/wiki/elements/mud)\n* [Wind](/wiki/elements/wind)\n\n## Result\n\n* [Sand](/wiki/elements/sand)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "b4a356618efa5f38912c9c1ad0f959a9e15825cde199b09678439e5ed8b0933f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-sandstorm.md",
      "content": "# Make Sandstorm\n\nWe need a description here\n\n## Ingredients\n\n* [Dust](/wiki/elements/dust)\n* [Wind](/wiki/elements/wind)\n\n## Result\n\n* [Sandstorm](/wiki/elements/sandstorm)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "9bcd3aca8171d21c38a277eac6250c7e5215e0cc0c5c203d9851b8e894935d0f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-scorched-earth.md",
      "content": "# Make Scorched Earth\n\nWe need a description here\n\n## Ingredients\n\n* [Fire](/wiki/elements/fire)\n* [Valley](/wiki/elements/valley)\n\n## Result\n\n* [Scorched Earth](/wiki/elements/scorched-earth)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "06cca293b494a1d648c86962fe3e236f51bc4a511469cf6ec21c8f49cfa6a75f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-seeds.md",
      "content": "# Make Seeds\n\nWe need a description here\n\n## Ingredients\n\n* [Plant](/wiki/elements/plant)\n* [Wind](/wiki/elements/wind)\n\n## Result\n\n* [Seeds](/wiki/elements/seeds)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "be9865e4c21c19d2a2ffbd94ba29a2b6b3a3113c37e749d82135553eb74b3e85",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-shard.md",
      "content": "# Make Shard\n\nWe need a description here\n\n## Ingredients\n\n* [Obsidian](/wiki/elements/obsidian)\n* [Wind](/wiki/elements/wind)\n\n## Result\n\n* [Shard](/wiki/elements/shard)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "ba1477d9c1855c127fc0c79a325c7dc82b4250d31b39df7c8242d0a1b731209f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-shards.md",
      "content": "# Make Shards\n\nWe need a description here\n\n## Ingredients\n\n* [Wind](/wiki/elements/wind)\n* [Obsidian](/wiki/elements/obsidian)\n\n## Result\n\n* [Shards](/wiki/elements/shards)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "c5da6304de952e049ba6eca2bdbc66d4dc9b7e1f737e26bfcd58fc82f7d6ae02",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-sinkhole.md",
      "content": "# Make Sinkhole\n\nWe need a description here\n\n## Ingredients\n\n* [Earth](/wiki/elements/earth)\n* [Quicksand](/wiki/elements/quicksand)\n\n## Result\n\n* [Sinkhole](/wiki/elements/sinkhole)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "321223a3e1179f4f965638fbd318c38e61995c000014770f3cfc647332a028eb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-smoke.md",
      "content": "# Make Smoke\n\nWe need a description here\n\n## Ingredients\n\n* [Fire](/wiki/elements/fire)\n* [Wind](/wiki/elements/wind)\n\n## Result\n\n* [Smoke](/wiki/elements/smoke)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "dbbc05c8963e5bb0358873ea587569045c56a44362eaf5479ac52f652d417490",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-soil.md",
      "content": "# Make Soil\n\nWe need a description here\n\n## Ingredients\n\n* [Earth](/wiki/elements/earth)\n* [Plant](/wiki/elements/plant)\n\n## Result\n\n* [Soil](/wiki/elements/soil)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "2f663514a87a3d335fd4a506be2537100eae8656fed919478e754578a9a1d13c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-soot.md",
      "content": "# Make Soot\n\nWe need a description here\n\n## Ingredients\n\n* [Ash](/wiki/elements/ash)\n* [Wind](/wiki/elements/wind)\n\n## Result\n\n* [Soot](/wiki/elements/soot)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "e303eb847992bcb2be92dfd029ed26378890a0307d46fae734c527f4f87eccfd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-sparkle.md",
      "content": "# Make Sparkle\n\nWe need a description here\n\n## Ingredients\n\n* [Wind](/wiki/elements/wind)\n* [Crystal](/wiki/elements/crystal)\n\n## Result\n\n* [Sparkle](/wiki/elements/sparkle)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "93ed9bbd8e925a4f9b7271a5554ac97510dc3843ca54c740423fa4d0c113f3dc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-spore.md",
      "content": "# Make Spore\n\nWe need a description here\n\n## Ingredients\n\n* [Fire](/wiki/elements/fire)\n* [Pollination](/wiki/elements/pollination)\n\n## Result\n\n* [Spore](/wiki/elements/spore)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "b90a8ad668b1efcb226fd6a01398f3c464c085e5c7af2966c919c61eb035094f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-spread.md",
      "content": "# Make Spread\n\nWe need a description here\n\n## Ingredients\n\n* [Wind](/wiki/elements/wind)\n* [Pollination](/wiki/elements/pollination)\n\n## Result\n\n* [Spread](/wiki/elements/spread)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "0cf3b9072f77483348824bef4c96ab0f7bc5caa568e25ebd48260f4000f6d12c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-spring.md",
      "content": "# Make Spring\n\nWe need a description here\n\n## Ingredients\n\n* [Water](/wiki/elements/water)\n* [Subterranean Pool](/wiki/elements/subterranean-pool)\n\n## Result\n\n* [Spring](/wiki/elements/spring)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "4da67cdf4cdd17905db913dfca01159d2fdda5215b79f53588cf03dd69380bbb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-steam-vent.md",
      "content": "# Make Steam Vent\n\nWe need a description here\n\n## Ingredients\n\n* [Fire](/wiki/elements/fire)\n* [Spring](/wiki/elements/spring)\n\n## Result\n\n* [Steam Vent](/wiki/elements/steam-vent)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "3e99de83486a0b901a2b7c98d84e8a06bedcb654db821f9d42da33c7c9a9312f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-steam.md",
      "content": "# Make Steam\n\nWe need a description here\n\n## Ingredients\n\n* [Water](/wiki/elements/water)\n* [Fire](/wiki/elements/fire)\n\n## Result\n\n* [Steam](/wiki/elements/steam)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "f409f450cbff031ad832b7dcb2a741c9e21dc2c52a18c9598ee872173883fa4f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-storm.md",
      "content": "# Make Storm\n\nWe need a description here\n\n## Ingredients\n\n* [Rain](/wiki/elements/rain)\n* [Wind](/wiki/elements/wind)\n\n## Result\n\n* [Storm](/wiki/elements/storm)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "62143e2cdfe2e2c470dd93023b0254f2963f8b81090ddc042921cf6831add5f0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-stream.md",
      "content": "# Make Stream\n\nWe need a description here\n\n## Ingredients\n\n* [Water](/wiki/elements/water)\n* [River](/wiki/elements/river)\n\n## Result\n\n* [Stream](/wiki/elements/stream)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "5f80924967ee8bbcbb03673ae8b3f4e113c3f9a59b9a0949f70e63ed7b195210",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-subterranean-pool.md",
      "content": "# Make Subterranean Pool\n\nWe need a description here\n\n## Ingredients\n\n* [Earth](/wiki/elements/earth)\n* [Underground Lake](/wiki/elements/underground-lake)\n\n## Result\n\n* [Subterranean Pool](/wiki/elements/subterranean-pool)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "e179e3af76e7383357f0a289b834d8c0d56367ffba7a2b7342186bb68627fb31",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-supermarmalade.md",
      "content": "# Make Supermarmalade\n\n\n\n## Ingredients\n\n* [Marmalade](/wiki/elements/marmalade)\n* [Marmalade](/wiki/elements/marmalade)\n\n## Result\n\n* [Super Marmalade](/wiki/elements/super-marmalade)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "eda916c07bc22c78f1aba1937e9c5ddeb94d916130395ce0f9f0ecac3b51f897",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-swarm.md",
      "content": "# Make Swarm\n\n\n\n## Ingredients\n\n* [Bee](/wiki/elements/bee)\n* [Bee](/wiki/elements/bee)\n\n## Result\n\n* [Swarm](/wiki/elements/swarm)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "36c83f13de262a9a1e3f18158717e789bc30591b47bf9af5e41c48b41b17b9c3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-thunder.md",
      "content": "# Make Thunder\n\nWe need a description here\n\n## Ingredients\n\n* [Storm](/wiki/elements/storm)\n* [Fire](/wiki/elements/fire)\n\n## Result\n\n* [Thunder](/wiki/elements/thunder)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "fb6ca9fe42780cb61ec6645602f8a88c610e86e51d3f79d94a5692d7869bff6e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-tornado.md",
      "content": "# Make Tornado\n\nWe need a description here\n\n## Ingredients\n\n* [Storm](/wiki/elements/storm)\n* [Wind](/wiki/elements/wind)\n\n## Result\n\n* [Tornado](/wiki/elements/tornado)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "ccf350ac2794f426459de4d5feeaa8386d6d4b11f50d45776f33bdbc4a901043",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-tree.md",
      "content": "# Make Tree\n\nWe need a description here\n\n## Ingredients\n\n* [Plant](/wiki/elements/plant)\n* [Water](/wiki/elements/water)\n\n## Result\n\n* [Tree](/wiki/elements/tree)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "21c14c6eb5fdc86085e97f68239655a83851225edbbe7ab330205b96939a658d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-tributary.md",
      "content": "# Make Tributary\n\nWe need a description here\n\n## Ingredients\n\n* [Water](/wiki/elements/water)\n* [Rivulet](/wiki/elements/rivulet)\n\n## Result\n\n* [Tributary](/wiki/elements/tributary)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "b16799939f2af5886a39dfff2a9039cb54e1f21467a548d2fb7180a0d4c3557f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-underground-lake.md",
      "content": "# Make Underground Lake\n\nWe need a description here\n\n## Ingredients\n\n* [Water](/wiki/elements/water)\n* [Cave](/wiki/elements/cave)\n\n## Result\n\n* [Underground Lake](/wiki/elements/underground-lake)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "f5ace0e0aa465c9c52f2d15c6d612dc1092fe8f005eac3fcb303a515ef221afa",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-valley.md",
      "content": "# Make Valley\n\nWe need a description here\n\n## Ingredients\n\n* [Earth](/wiki/elements/earth)\n* [Canyon](/wiki/elements/canyon)\n\n## Result\n\n* [Valley](/wiki/elements/valley)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "bef375863d3d6f7396dd69431849e2f37b730c39b6fa7b6b41f6d3386d732cc5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-volcano.md",
      "content": "# Make Volcano\n\nWe need a description here\n\n## Ingredients\n\n* [Lava](/wiki/elements/lava)\n* [Earth](/wiki/elements/earth)\n\n## Result\n\n* [Volcano](/wiki/elements/volcano)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "3dd0479dcc6d3a940ea62ef088437e9075391fb117f5e9441e7fc3e9b9ec972d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-wall.md",
      "content": "# Make Wall\n\nWe need a description here\n\n## Ingredients\n\n* [Earth](/wiki/elements/earth)\n* [Brick](/wiki/elements/brick)\n\n## Result\n\n* [Wall](/wiki/elements/wall)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "2e3eaa1b8e4f3c01bbc87c64174d5ce00eead3a4e42dde407dcd9aa0f186bf12",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-warm-breeze.md",
      "content": "# Make Warm Breeze\n\nWe need a description here\n\n## Ingredients\n\n* [Fire](/wiki/elements/fire)\n* [Breeze](/wiki/elements/breeze)\n\n## Result\n\n* [Warm Breeze](/wiki/elements/warm-breeze)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "489551507c8eaa43f7e8a285244a14f5e4f7424426a029922ecfe1f8ed874a6d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-waterfall.md",
      "content": "# Make Waterfall\n\nWe need a description here\n\n## Ingredients\n\n* [Water](/wiki/elements/water)\n* [Monument](/wiki/elements/monument)\n\n## Result\n\n* [Waterfall](/wiki/elements/waterfall)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "59fd45976693f460eb874aac2c12ba50a532981651ccfb5de11fd44af832cd7a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-watershed.md",
      "content": "# Make Watershed\n\nWe need a description here\n\n## Ingredients\n\n* [Earth](/wiki/elements/earth)\n* [Tributary](/wiki/elements/tributary)\n\n## Result\n\n* [Watershed](/wiki/elements/watershed)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "15431918f674fa4a584a4892a1e63fd28494a29df79a4d4c6ed23106b00d93d7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-wave.md",
      "content": "# Make Wave\n\nWe need a description here\n\n## Ingredients\n\n* [Wind](/wiki/elements/wind)\n* [Lake](/wiki/elements/lake)\n\n## Result\n\n* [Wave](/wiki/elements/wave)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "c1eab310beb7cdf1a91d18da7615130752d91c346348e4733ee45b80cb787ece",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-wetland.md",
      "content": "# Make Wetland\n\nWe need a description here\n\n## Ingredients\n\n* [Water](/wiki/elements/water)\n* [Fertile Land](/wiki/elements/fertile-land)\n\n## Result\n\n* [Wetland](/wiki/elements/wetland)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "a487b4927c07d1a8c3894f9a115f0a46c526f1b385e1f93501df32420cdbc399",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-wetstone.md",
      "content": "# Make Wetstone\n\nWe need a description here\n\n## Ingredients\n\n* [Water](/wiki/elements/water)\n* [Obsidian](/wiki/elements/obsidian)\n\n## Result\n\n* [Wetstone](/wiki/elements/wetstone)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "7f24febab0ed140ef20f8bf0c9000ed2f83b8f4a29e30541c11e69b1377ee3f2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-whirl.md",
      "content": "# Make Whirl\n\nWe need a description here\n\n## Ingredients\n\n* [Wind](/wiki/elements/wind)\n* [Reef](/wiki/elements/reef)\n\n## Result\n\n* [Whirl](/wiki/elements/whirl)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "e61380cd4c59da86550348058575afc2f1fd4015a147b21acf51fc433111a162",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-whisper.md",
      "content": "# Make Whisper\n\nWe need a description here\n\n## Ingredients\n\n* [Wind](/wiki/elements/wind)\n* [Creek](/wiki/elements/creek)\n\n## Result\n\n* [Whisper](/wiki/elements/whisper)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "e2328a1c5187a7a5a3a30cc41282f255f2484c3ba770f6a58acb9c178d4ca55e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-whispering-cave.md",
      "content": "# Make Whispering Cave\n\nWe need a description here\n\n## Ingredients\n\n* [Wind](/wiki/elements/wind)\n* [Cave](/wiki/elements/cave)\n\n## Result\n\n* [Whispering Cave](/wiki/elements/whispering-cave)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "1037ee8f986333c8060673859b41c0de88b1ce5b80916ee8c30c6e02ff4df16c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-wildfire.md",
      "content": "# Make Wildfire\n\nWe need a description here\n\n## Ingredients\n\n* [Forest](/wiki/elements/forest)\n* [Fire](/wiki/elements/fire)\n\n## Result\n\n* [Wildfire](/wiki/elements/wildfire)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "e791727b32d4b44956ca0617181a39c1df7e5a988ccf440da7ec404d43e11407",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-windmill.md",
      "content": "# Make Windmill\n\nWe need a description here\n\n## Ingredients\n\n* [Wind](/wiki/elements/wind)\n* [Plant](/wiki/elements/plant)\n\n## Result\n\n* [Windmill](/wiki/elements/windmill)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "9ae500a97e893d0edc375155eba57c3ea8816747e0317df2354e4c384b2a0784",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-zephyr.md",
      "content": "# Make Zephyr\n\nWe need a description here\n\n## Ingredients\n\n* [Wind](/wiki/elements/wind)\n* [River](/wiki/elements/river)\n\n## Result\n\n* [Zephyr](/wiki/elements/zephyr)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "4ceeb2a8ae0cd97ffac7973a78c86158dcd149c4e09122d20a90788e1a4791af",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/model/src/achievements.ts",
      "content": "import {\n    IAchievement,\n} from \"./IAchievement\";\n\nexport const ACHIEVEMENT_BUY_1_MONKEY: IAchievement = {\n    id: \"buy:0/1\",\n    name: \"Buy one Monkey\",\n    description: \"You have bought 1 Monkey. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_MONKEY: IAchievement = {\n    id: \"buy:0/100\",\n    name: \"Buy 100 Monkey\",\n    description: \"You have bought 100 Monkey! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_MONKEY: IAchievement = {\n    id: \"sacrifice:0/1\",\n    name: \"Sacrifice one Monkey\",\n    description: \"You have sacrificed 1 Monkey. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_MONKEY: IAchievement = {\n    id: \"sacrifice:0/100\",\n    name: \"Sacrifice 100 Monkey\",\n    description: \"You have sacrificed 100 Monkey! Here, shake my hand!\",\n};\nexport const ITEM_MONKEY_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_MONKEY,\n    ACHIEVEMENT_BUY_100_MONKEY,\n    ACHIEVEMENT_SACRIFICE_1_MONKEY,\n    ACHIEVEMENT_SACRIFICE_100_MONKEY,\n];\nexport const ACHIEVEMENT_BUY_1_GIRAFFE: IAchievement = {\n    id: \"buy:1/1\",\n    name: \"Buy one Giraffe\",\n    description: \"You have bought 1 Giraffe. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_GIRAFFE: IAchievement = {\n    id: \"buy:1/100\",\n    name: \"Buy 100 Giraffe\",\n    description: \"You have bought 100 Giraffe! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_GIRAFFE: IAchievement = {\n    id: \"sacrifice:1/1\",\n    name: \"Sacrifice one Giraffe\",\n    description: \"You have sacrificed 1 Giraffe. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_GIRAFFE: IAchievement = {\n    id: \"sacrifice:1/100\",\n    name: \"Sacrifice 100 Giraffe\",\n    description: \"You have sacrificed 100 Giraffe! Here, shake my hand!\",\n};\nexport const ITEM_GIRAFFE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_GIRAFFE,\n    ACHIEVEMENT_BUY_100_GIRAFFE,\n    ACHIEVEMENT_SACRIFICE_1_GIRAFFE,\n    ACHIEVEMENT_SACRIFICE_100_GIRAFFE,\n];\nexport const ACHIEVEMENT_BUY_1_BEE: IAchievement = {\n    id: \"buy:2/1\",\n    name: \"Buy one Bee\",\n    description: \"You have bought 1 Bee. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_BEE: IAchievement = {\n    id: \"buy:2/100\",\n    name: \"Buy 100 Bee\",\n    description: \"You have bought 100 Bee! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_BEE: IAchievement = {\n    id: \"sacrifice:2/1\",\n    name: \"Sacrifice one Bee\",\n    description: \"You have sacrificed 1 Bee. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_BEE: IAchievement = {\n    id: \"sacrifice:2/100\",\n    name: \"Sacrifice 100 Bee\",\n    description: \"You have sacrificed 100 Bee! Here, shake my hand!\",\n};\nexport const ITEM_BEE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_BEE,\n    ACHIEVEMENT_BUY_100_BEE,\n    ACHIEVEMENT_SACRIFICE_1_BEE,\n    ACHIEVEMENT_SACRIFICE_100_BEE,\n];\nexport const ACHIEVEMENT_BUY_1_COIN: IAchievement = {\n    id: \"buy:3/1\",\n    name: \"Buy one Coin\",\n    description: \"You have bought 1 Coin. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_COIN: IAchievement = {\n    id: \"buy:3/100\",\n    name: \"Buy 100 Coin\",\n    description: \"You have bought 100 Coin! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_COIN: IAchievement = {\n    id: \"sacrifice:3/1\",\n    name: \"Sacrifice one Coin\",\n    description: \"You have sacrificed 1 Coin. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_COIN: IAchievement = {\n    id: \"sacrifice:3/100\",\n    name: \"Sacrifice 100 Coin\",\n    description: \"You have sacrificed 100 Coin! Here, shake my hand!\",\n};\nexport const ITEM_COIN_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_COIN,\n    ACHIEVEMENT_BUY_100_COIN,\n    ACHIEVEMENT_SACRIFICE_1_COIN,\n    ACHIEVEMENT_SACRIFICE_100_COIN,\n];\nexport const ACHIEVEMENT_BUY_1_SWARM: IAchievement = {\n    id: \"buy:4/1\",\n    name: \"Buy one Swarm\",\n    description: \"You have bought 1 Swarm. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_SWARM: IAchievement = {\n    id: \"buy:4/100\",\n    name: \"Buy 100 Swarm\",\n    description: \"You have bought 100 Swarm! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_SWARM: IAchievement = {\n    id: \"sacrifice:4/1\",\n    name: \"Sacrifice one Swarm\",\n    description: \"You have sacrificed 1 Swarm. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_SWARM: IAchievement = {\n    id: \"sacrifice:4/100\",\n    name: \"Sacrifice 100 Swarm\",\n    description: \"You have sacrificed 100 Swarm! Here, shake my hand!\",\n};\nexport const ITEM_SWARM_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_SWARM,\n    ACHIEVEMENT_BUY_100_SWARM,\n    ACHIEVEMENT_SACRIFICE_1_SWARM,\n    ACHIEVEMENT_SACRIFICE_100_SWARM,\n];\nexport const ACHIEVEMENT_BUY_1_HYDRA: IAchievement = {\n    id: \"buy:5/1\",\n    name: \"Buy one Hydra\",\n    description: \"You have bought 1 Hydra. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_HYDRA: IAchievement = {\n    id: \"buy:5/100\",\n    name: \"Buy 100 Hydra\",\n    description: \"You have bought 100 Hydra! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_HYDRA: IAchievement = {\n    id: \"sacrifice:5/1\",\n    name: \"Sacrifice one Hydra\",\n    description: \"You have sacrificed 1 Hydra. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_HYDRA: IAchievement = {\n    id: \"sacrifice:5/100\",\n    name: \"Sacrifice 100 Hydra\",\n    description: \"You have sacrificed 100 Hydra! Here, shake my hand!\",\n};\nexport const ITEM_HYDRA_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_HYDRA,\n    ACHIEVEMENT_BUY_100_HYDRA,\n    ACHIEVEMENT_SACRIFICE_1_HYDRA,\n    ACHIEVEMENT_SACRIFICE_100_HYDRA,\n];\nexport const ACHIEVEMENT_BUY_1_MONKEY_BRANCH: IAchievement = {\n    id: \"buy:6/1\",\n    name: \"Buy one Monkey Branch\",\n    description: \"You have bought 1 Monkey Branch. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_MONKEY_BRANCH: IAchievement = {\n    id: \"buy:6/100\",\n    name: \"Buy 100 Monkey Branch\",\n    description: \"You have bought 100 Monkey Branch! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_MONKEY_BRANCH: IAchievement = {\n    id: \"sacrifice:6/1\",\n    name: \"Sacrifice one Monkey Branch\",\n    description: \"You have sacrificed 1 Monkey Branch. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_MONKEY_BRANCH: IAchievement = {\n    id: \"sacrifice:6/100\",\n    name: \"Sacrifice 100 Monkey Branch\",\n    description: \"You have sacrificed 100 Monkey Branch! Here, shake my hand!\",\n};\nexport const ITEM_MONKEY_BRANCH_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_MONKEY_BRANCH,\n    ACHIEVEMENT_BUY_100_MONKEY_BRANCH,\n    ACHIEVEMENT_SACRIFICE_1_MONKEY_BRANCH,\n    ACHIEVEMENT_SACRIFICE_100_MONKEY_BRANCH,\n];\nexport const ACHIEVEMENT_BUY_1_BRIDGE: IAchievement = {\n    id: \"buy:7/1\",\n    name: \"Buy one Bridge\",\n    description: \"You have bought 1 Bridge. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_BRIDGE: IAchievement = {\n    id: \"buy:7/100\",\n    name: \"Buy 100 Bridge\",\n    description: \"You have bought 100 Bridge! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_BRIDGE: IAchievement = {\n    id: \"sacrifice:7/1\",\n    name: \"Sacrifice one Bridge\",\n    description: \"You have sacrificed 1 Bridge. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_BRIDGE: IAchievement = {\n    id: \"sacrifice:7/100\",\n    name: \"Sacrifice 100 Bridge\",\n    description: \"You have sacrificed 100 Bridge! Here, shake my hand!\",\n};\nexport const ITEM_BRIDGE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_BRIDGE,\n    ACHIEVEMENT_BUY_100_BRIDGE,\n    ACHIEVEMENT_SACRIFICE_1_BRIDGE,\n    ACHIEVEMENT_SACRIFICE_100_BRIDGE,\n];\nexport const ACHIEVEMENT_BUY_1_GOLDEN_GATE: IAchievement = {\n    id: \"buy:8/1\",\n    name: \"Buy one Golden Gate\",\n    description: \"You have bought 1 Golden Gate. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_GOLDEN_GATE: IAchievement = {\n    id: \"buy:8/100\",\n    name: \"Buy 100 Golden Gate\",\n    description: \"You have bought 100 Golden Gate! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_GOLDEN_GATE: IAchievement = {\n    id: \"sacrifice:8/1\",\n    name: \"Sacrifice one Golden Gate\",\n    description: \"You have sacrificed 1 Golden Gate. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_GOLDEN_GATE: IAchievement = {\n    id: \"sacrifice:8/100\",\n    name: \"Sacrifice 100 Golden Gate\",\n    description: \"You have sacrificed 100 Golden Gate! Here, shake my hand!\",\n};\nexport const ITEM_GOLDEN_GATE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_GOLDEN_GATE,\n    ACHIEVEMENT_BUY_100_GOLDEN_GATE,\n    ACHIEVEMENT_SACRIFICE_1_GOLDEN_GATE,\n    ACHIEVEMENT_SACRIFICE_100_GOLDEN_GATE,\n];\nexport const ACHIEVEMENT_BUY_1_GOLD: IAchievement = {\n    id: \"buy:9/1\",\n    name: \"Buy one Gold\",\n    description: \"You have bought 1 Gold. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_GOLD: IAchievement = {\n    id: \"buy:9/100\",\n    name: \"Buy 100 Gold\",\n    description: \"You have bought 100 Gold! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_GOLD: IAchievement = {\n    id: \"sacrifice:9/1\",\n    name: \"Sacrifice one Gold\",\n    description: \"You have sacrificed 1 Gold. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_GOLD: IAchievement = {\n    id: \"sacrifice:9/100\",\n    name: \"Sacrifice 100 Gold\",\n    description: \"You have sacrificed 100 Gold! Here, shake my hand!\",\n};\nexport const ITEM_GOLD_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_GOLD,\n    ACHIEVEMENT_BUY_100_GOLD,\n    ACHIEVEMENT_SACRIFICE_1_GOLD,\n    ACHIEVEMENT_SACRIFICE_100_GOLD,\n];\nexport const ACHIEVEMENT_BUY_1_SILVER: IAchievement = {\n    id: \"buy:10/1\",\n    name: \"Buy one Silver\",\n    description: \"You have bought 1 Silver. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_SILVER: IAchievement = {\n    id: \"buy:10/100\",\n    name: \"Buy 100 Silver\",\n    description: \"You have bought 100 Silver! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_SILVER: IAchievement = {\n    id: \"sacrifice:10/1\",\n    name: \"Sacrifice one Silver\",\n    description: \"You have sacrificed 1 Silver. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_SILVER: IAchievement = {\n    id: \"sacrifice:10/100\",\n    name: \"Sacrifice 100 Silver\",\n    description: \"You have sacrificed 100 Silver! Here, shake my hand!\",\n};\nexport const ITEM_SILVER_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_SILVER,\n    ACHIEVEMENT_BUY_100_SILVER,\n    ACHIEVEMENT_SACRIFICE_1_SILVER,\n    ACHIEVEMENT_SACRIFICE_100_SILVER,\n];\nexport const ACHIEVEMENT_BUY_1_RHODIUM: IAchievement = {\n    id: \"buy:11/1\",\n    name: \"Buy one Rhodium\",\n    description: \"You have bought 1 Rhodium. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_RHODIUM: IAchievement = {\n    id: \"buy:11/100\",\n    name: \"Buy 100 Rhodium\",\n    description: \"You have bought 100 Rhodium! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_RHODIUM: IAchievement = {\n    id: \"sacrifice:11/1\",\n    name: \"Sacrifice one Rhodium\",\n    description: \"You have sacrificed 1 Rhodium. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_RHODIUM: IAchievement = {\n    id: \"sacrifice:11/100\",\n    name: \"Sacrifice 100 Rhodium\",\n    description: \"You have sacrificed 100 Rhodium! Here, shake my hand!\",\n};\nexport const ITEM_RHODIUM_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_RHODIUM,\n    ACHIEVEMENT_BUY_100_RHODIUM,\n    ACHIEVEMENT_SACRIFICE_1_RHODIUM,\n    ACHIEVEMENT_SACRIFICE_100_RHODIUM,\n];\nexport const ACHIEVEMENT_BUY_1_HIVE: IAchievement = {\n    id: \"buy:12/1\",\n    name: \"Buy one Hive\",\n    description: \"You have bought 1 Hive. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_HIVE: IAchievement = {\n    id: \"buy:12/100\",\n    name: \"Buy 100 Hive\",\n    description: \"You have bought 100 Hive! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_HIVE: IAchievement = {\n    id: \"sacrifice:12/1\",\n    name: \"Sacrifice one Hive\",\n    description: \"You have sacrificed 1 Hive. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_HIVE: IAchievement = {\n    id: \"sacrifice:12/100\",\n    name: \"Sacrifice 100 Hive\",\n    description: \"You have sacrificed 100 Hive! Here, shake my hand!\",\n};\nexport const ITEM_HIVE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_HIVE,\n    ACHIEVEMENT_BUY_100_HIVE,\n    ACHIEVEMENT_SACRIFICE_1_HIVE,\n    ACHIEVEMENT_SACRIFICE_100_HIVE,\n];\nexport const ACHIEVEMENT_BUY_1_TRANSACTION: IAchievement = {\n    id: \"buy:13/1\",\n    name: \"Buy one Transaction\",\n    description: \"You have bought 1 Transaction. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_TRANSACTION: IAchievement = {\n    id: \"buy:13/100\",\n    name: \"Buy 100 Transaction\",\n    description: \"You have bought 100 Transaction! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_TRANSACTION: IAchievement = {\n    id: \"sacrifice:13/1\",\n    name: \"Sacrifice one Transaction\",\n    description: \"You have sacrificed 1 Transaction. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_TRANSACTION: IAchievement = {\n    id: \"sacrifice:13/100\",\n    name: \"Sacrifice 100 Transaction\",\n    description: \"You have sacrificed 100 Transaction! Here, shake my hand!\",\n};\nexport const ITEM_TRANSACTION_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_TRANSACTION,\n    ACHIEVEMENT_BUY_100_TRANSACTION,\n    ACHIEVEMENT_SACRIFICE_1_TRANSACTION,\n    ACHIEVEMENT_SACRIFICE_100_TRANSACTION,\n];\nexport const ACHIEVEMENT_BUY_1_BLOCK: IAchievement = {\n    id: \"buy:14/1\",\n    name: \"Buy one Block\",\n    description: \"You have bought 1 Block. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_BLOCK: IAchievement = {\n    id: \"buy:14/100\",\n    name: \"Buy 100 Block\",\n    description: \"You have bought 100 Block! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_BLOCK: IAchievement = {\n    id: \"sacrifice:14/1\",\n    name: \"Sacrifice one Block\",\n    description: \"You have sacrificed 1 Block. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_BLOCK: IAchievement = {\n    id: \"sacrifice:14/100\",\n    name: \"Sacrifice 100 Block\",\n    description: \"You have sacrificed 100 Block! Here, shake my hand!\",\n};\nexport const ITEM_BLOCK_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_BLOCK,\n    ACHIEVEMENT_BUY_100_BLOCK,\n    ACHIEVEMENT_SACRIFICE_1_BLOCK,\n    ACHIEVEMENT_SACRIFICE_100_BLOCK,\n];\nexport const ACHIEVEMENT_BUY_1_BLOCKCHAIN: IAchievement = {\n    id: \"buy:15/1\",\n    name: \"Buy one Blockchain\",\n    description: \"You have bought 1 Blockchain. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_BLOCKCHAIN: IAchievement = {\n    id: \"buy:15/100\",\n    name: \"Buy 100 Blockchain\",\n    description: \"You have bought 100 Blockchain! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_BLOCKCHAIN: IAchievement = {\n    id: \"sacrifice:15/1\",\n    name: \"Sacrifice one Blockchain\",\n    description: \"You have sacrificed 1 Blockchain. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_BLOCKCHAIN: IAchievement = {\n    id: \"sacrifice:15/100\",\n    name: \"Sacrifice 100 Blockchain\",\n    description: \"You have sacrificed 100 Blockchain! Here, shake my hand!\",\n};\nexport const ITEM_BLOCKCHAIN_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_BLOCKCHAIN,\n    ACHIEVEMENT_BUY_100_BLOCKCHAIN,\n    ACHIEVEMENT_SACRIFICE_1_BLOCKCHAIN,\n    ACHIEVEMENT_SACRIFICE_100_BLOCKCHAIN,\n];\nexport const ACHIEVEMENT_BUY_1_POLKADOT: IAchievement = {\n    id: \"buy:16/1\",\n    name: \"Buy one Polkadot\",\n    description: \"You have bought 1 Polkadot. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_POLKADOT: IAchievement = {\n    id: \"buy:16/100\",\n    name: \"Buy 100 Polkadot\",\n    description: \"You have bought 100 Polkadot! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_POLKADOT: IAchievement = {\n    id: \"sacrifice:16/1\",\n    name: \"Sacrifice one Polkadot\",\n    description: \"You have sacrificed 1 Polkadot. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_POLKADOT: IAchievement = {\n    id: \"sacrifice:16/100\",\n    name: \"Sacrifice 100 Polkadot\",\n    description: \"You have sacrificed 100 Polkadot! Here, shake my hand!\",\n};\nexport const ITEM_POLKADOT_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_POLKADOT,\n    ACHIEVEMENT_BUY_100_POLKADOT,\n    ACHIEVEMENT_SACRIFICE_1_POLKADOT,\n    ACHIEVEMENT_SACRIFICE_100_POLKADOT,\n];\nexport const ACHIEVEMENT_BUY_1_PEER_REVIEW: IAchievement = {\n    id: \"buy:17/1\",\n    name: \"Buy one Peer Review\",\n    description: \"You have bought 1 Peer Review. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_PEER_REVIEW: IAchievement = {\n    id: \"buy:17/100\",\n    name: \"Buy 100 Peer Review\",\n    description: \"You have bought 100 Peer Review! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_PEER_REVIEW: IAchievement = {\n    id: \"sacrifice:17/1\",\n    name: \"Sacrifice one Peer Review\",\n    description: \"You have sacrificed 1 Peer Review. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_PEER_REVIEW: IAchievement = {\n    id: \"sacrifice:17/100\",\n    name: \"Sacrifice 100 Peer Review\",\n    description: \"You have sacrificed 100 Peer Review! Here, shake my hand!\",\n};\nexport const ITEM_PEER_REVIEW_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_PEER_REVIEW,\n    ACHIEVEMENT_BUY_100_PEER_REVIEW,\n    ACHIEVEMENT_SACRIFICE_1_PEER_REVIEW,\n    ACHIEVEMENT_SACRIFICE_100_PEER_REVIEW,\n];\nexport const ACHIEVEMENT_BUY_1_CARDANO: IAchievement = {\n    id: \"buy:18/1\",\n    name: \"Buy one Cardano\",\n    description: \"You have bought 1 Cardano. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_CARDANO: IAchievement = {\n    id: \"buy:18/100\",\n    name: \"Buy 100 Cardano\",\n    description: \"You have bought 100 Cardano! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_CARDANO: IAchievement = {\n    id: \"sacrifice:18/1\",\n    name: \"Sacrifice one Cardano\",\n    description: \"You have sacrificed 1 Cardano. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_CARDANO: IAchievement = {\n    id: \"sacrifice:18/100\",\n    name: \"Sacrifice 100 Cardano\",\n    description: \"You have sacrificed 100 Cardano! Here, shake my hand!\",\n};\nexport const ITEM_CARDANO_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_CARDANO,\n    ACHIEVEMENT_BUY_100_CARDANO,\n    ACHIEVEMENT_SACRIFICE_1_CARDANO,\n    ACHIEVEMENT_SACRIFICE_100_CARDANO,\n];\nexport const ACHIEVEMENT_BUY_1_BEAR: IAchievement = {\n    id: \"buy:19/1\",\n    name: \"Buy one Bear\",\n    description: \"You have bought 1 Bear. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_BEAR: IAchievement = {\n    id: \"buy:19/100\",\n    name: \"Buy 100 Bear\",\n    description: \"You have bought 100 Bear! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_BEAR: IAchievement = {\n    id: \"sacrifice:19/1\",\n    name: \"Sacrifice one Bear\",\n    description: \"You have sacrificed 1 Bear. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_BEAR: IAchievement = {\n    id: \"sacrifice:19/100\",\n    name: \"Sacrifice 100 Bear\",\n    description: \"You have sacrificed 100 Bear! Here, shake my hand!\",\n};\nexport const ITEM_BEAR_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_BEAR,\n    ACHIEVEMENT_BUY_100_BEAR,\n    ACHIEVEMENT_SACRIFICE_1_BEAR,\n    ACHIEVEMENT_SACRIFICE_100_BEAR,\n];\nexport const ACHIEVEMENT_BUY_1_BEER: IAchievement = {\n    id: \"buy:20/1\",\n    name: \"Buy one Beer\",\n    description: \"You have bought 1 Beer. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_BEER: IAchievement = {\n    id: \"buy:20/100\",\n    name: \"Buy 100 Beer\",\n    description: \"You have bought 100 Beer! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_BEER: IAchievement = {\n    id: \"sacrifice:20/1\",\n    name: \"Sacrifice one Beer\",\n    description: \"You have sacrificed 1 Beer. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_BEER: IAchievement = {\n    id: \"sacrifice:20/100\",\n    name: \"Sacrifice 100 Beer\",\n    description: \"You have sacrificed 100 Beer! Here, shake my hand!\",\n};\nexport const ITEM_BEER_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_BEER,\n    ACHIEVEMENT_BUY_100_BEER,\n    ACHIEVEMENT_SACRIFICE_1_BEER,\n    ACHIEVEMENT_SACRIFICE_100_BEER,\n];\nexport const ACHIEVEMENT_BUY_1_LOCK: IAchievement = {\n    id: \"buy:21/1\",\n    name: \"Buy one Lock\",\n    description: \"You have bought 1 Lock. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_LOCK: IAchievement = {\n    id: \"buy:21/100\",\n    name: \"Buy 100 Lock\",\n    description: \"You have bought 100 Lock! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_LOCK: IAchievement = {\n    id: \"sacrifice:21/1\",\n    name: \"Sacrifice one Lock\",\n    description: \"You have sacrificed 1 Lock. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_LOCK: IAchievement = {\n    id: \"sacrifice:21/100\",\n    name: \"Sacrifice 100 Lock\",\n    description: \"You have sacrificed 100 Lock! Here, shake my hand!\",\n};\nexport const ITEM_LOCK_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_LOCK,\n    ACHIEVEMENT_BUY_100_LOCK,\n    ACHIEVEMENT_SACRIFICE_1_LOCK,\n    ACHIEVEMENT_SACRIFICE_100_LOCK,\n];\nexport const ACHIEVEMENT_BUY_1_MARMALADE: IAchievement = {\n    id: \"buy:22/1\",\n    name: \"Buy one Marmalade\",\n    description: \"You have bought 1 Marmalade. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_MARMALADE: IAchievement = {\n    id: \"buy:22/100\",\n    name: \"Buy 100 Marmalade\",\n    description: \"You have bought 100 Marmalade! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_MARMALADE: IAchievement = {\n    id: \"sacrifice:22/1\",\n    name: \"Sacrifice one Marmalade\",\n    description: \"You have sacrificed 1 Marmalade. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_MARMALADE: IAchievement = {\n    id: \"sacrifice:22/100\",\n    name: \"Sacrifice 100 Marmalade\",\n    description: \"You have sacrificed 100 Marmalade! Here, shake my hand!\",\n};\nexport const ITEM_MARMALADE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_MARMALADE,\n    ACHIEVEMENT_BUY_100_MARMALADE,\n    ACHIEVEMENT_SACRIFICE_1_MARMALADE,\n    ACHIEVEMENT_SACRIFICE_100_MARMALADE,\n];\nexport const ACHIEVEMENT_BUY_1_SUPER_MARMALADE: IAchievement = {\n    id: \"buy:23/1\",\n    name: \"Buy one Super Marmalade\",\n    description: \"You have bought 1 Super Marmalade. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_SUPER_MARMALADE: IAchievement = {\n    id: \"buy:23/100\",\n    name: \"Buy 100 Super Marmalade\",\n    description: \"You have bought 100 Super Marmalade! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_SUPER_MARMALADE: IAchievement = {\n    id: \"sacrifice:23/1\",\n    name: \"Sacrifice one Super Marmalade\",\n    description: \"You have sacrificed 1 Super Marmalade. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_SUPER_MARMALADE: IAchievement = {\n    id: \"sacrifice:23/100\",\n    name: \"Sacrifice 100 Super Marmalade\",\n    description: \"You have sacrificed 100 Super Marmalade! Here, shake my hand!\",\n};\nexport const ITEM_SUPER_MARMALADE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_SUPER_MARMALADE,\n    ACHIEVEMENT_BUY_100_SUPER_MARMALADE,\n    ACHIEVEMENT_SACRIFICE_1_SUPER_MARMALADE,\n    ACHIEVEMENT_SACRIFICE_100_SUPER_MARMALADE,\n];\nexport const ACHIEVEMENT_BUY_1_HYPER_MARMALADE: IAchievement = {\n    id: \"buy:24/1\",\n    name: \"Buy one Hyper Marmalade\",\n    description: \"You have bought 1 Hyper Marmalade. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_HYPER_MARMALADE: IAchievement = {\n    id: \"buy:24/100\",\n    name: \"Buy 100 Hyper Marmalade\",\n    description: \"You have bought 100 Hyper Marmalade! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_HYPER_MARMALADE: IAchievement = {\n    id: \"sacrifice:24/1\",\n    name: \"Sacrifice one Hyper Marmalade\",\n    description: \"You have sacrificed 1 Hyper Marmalade. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_HYPER_MARMALADE: IAchievement = {\n    id: \"sacrifice:24/100\",\n    name: \"Sacrifice 100 Hyper Marmalade\",\n    description: \"You have sacrificed 100 Hyper Marmalade! Here, shake my hand!\",\n};\nexport const ITEM_HYPER_MARMALADE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_HYPER_MARMALADE,\n    ACHIEVEMENT_BUY_100_HYPER_MARMALADE,\n    ACHIEVEMENT_SACRIFICE_1_HYPER_MARMALADE,\n    ACHIEVEMENT_SACRIFICE_100_HYPER_MARMALADE,\n];\nexport const ACHIEVEMENT_BUY_1_WATER: IAchievement = {\n    id: \"buy:25/1\",\n    name: \"Buy one Water\",\n    description: \"You have bought 1 Water. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_WATER: IAchievement = {\n    id: \"buy:25/100\",\n    name: \"Buy 100 Water\",\n    description: \"You have bought 100 Water! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_WATER: IAchievement = {\n    id: \"sacrifice:25/1\",\n    name: \"Sacrifice one Water\",\n    description: \"You have sacrificed 1 Water. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_WATER: IAchievement = {\n    id: \"sacrifice:25/100\",\n    name: \"Sacrifice 100 Water\",\n    description: \"You have sacrificed 100 Water! Here, shake my hand!\",\n};\nexport const ITEM_WATER_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_WATER,\n    ACHIEVEMENT_BUY_100_WATER,\n    ACHIEVEMENT_SACRIFICE_1_WATER,\n    ACHIEVEMENT_SACRIFICE_100_WATER,\n];\nexport const ACHIEVEMENT_BUY_1_FIRE: IAchievement = {\n    id: \"buy:26/1\",\n    name: \"Buy one Fire\",\n    description: \"You have bought 1 Fire. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_FIRE: IAchievement = {\n    id: \"buy:26/100\",\n    name: \"Buy 100 Fire\",\n    description: \"You have bought 100 Fire! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_FIRE: IAchievement = {\n    id: \"sacrifice:26/1\",\n    name: \"Sacrifice one Fire\",\n    description: \"You have sacrificed 1 Fire. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_FIRE: IAchievement = {\n    id: \"sacrifice:26/100\",\n    name: \"Sacrifice 100 Fire\",\n    description: \"You have sacrificed 100 Fire! Here, shake my hand!\",\n};\nexport const ITEM_FIRE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_FIRE,\n    ACHIEVEMENT_BUY_100_FIRE,\n    ACHIEVEMENT_SACRIFICE_1_FIRE,\n    ACHIEVEMENT_SACRIFICE_100_FIRE,\n];\nexport const ACHIEVEMENT_BUY_1_STEAM: IAchievement = {\n    id: \"buy:27/1\",\n    name: \"Buy one Steam\",\n    description: \"You have bought 1 Steam. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_STEAM: IAchievement = {\n    id: \"buy:27/100\",\n    name: \"Buy 100 Steam\",\n    description: \"You have bought 100 Steam! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_STEAM: IAchievement = {\n    id: \"sacrifice:27/1\",\n    name: \"Sacrifice one Steam\",\n    description: \"You have sacrificed 1 Steam. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_STEAM: IAchievement = {\n    id: \"sacrifice:27/100\",\n    name: \"Sacrifice 100 Steam\",\n    description: \"You have sacrificed 100 Steam! Here, shake my hand!\",\n};\nexport const ITEM_STEAM_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_STEAM,\n    ACHIEVEMENT_BUY_100_STEAM,\n    ACHIEVEMENT_SACRIFICE_1_STEAM,\n    ACHIEVEMENT_SACRIFICE_100_STEAM,\n];\nexport const ACHIEVEMENT_BUY_1_EARTH: IAchievement = {\n    id: \"buy:28/1\",\n    name: \"Buy one Earth\",\n    description: \"You have bought 1 Earth. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_EARTH: IAchievement = {\n    id: \"buy:28/100\",\n    name: \"Buy 100 Earth\",\n    description: \"You have bought 100 Earth! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_EARTH: IAchievement = {\n    id: \"sacrifice:28/1\",\n    name: \"Sacrifice one Earth\",\n    description: \"You have sacrificed 1 Earth. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_EARTH: IAchievement = {\n    id: \"sacrifice:28/100\",\n    name: \"Sacrifice 100 Earth\",\n    description: \"You have sacrificed 100 Earth! Here, shake my hand!\",\n};\nexport const ITEM_EARTH_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_EARTH,\n    ACHIEVEMENT_BUY_100_EARTH,\n    ACHIEVEMENT_SACRIFICE_1_EARTH,\n    ACHIEVEMENT_SACRIFICE_100_EARTH,\n];\nexport const ACHIEVEMENT_BUY_1_MUD: IAchievement = {\n    id: \"buy:29/1\",\n    name: \"Buy one Mud\",\n    description: \"You have bought 1 Mud. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_MUD: IAchievement = {\n    id: \"buy:29/100\",\n    name: \"Buy 100 Mud\",\n    description: \"You have bought 100 Mud! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_MUD: IAchievement = {\n    id: \"sacrifice:29/1\",\n    name: \"Sacrifice one Mud\",\n    description: \"You have sacrificed 1 Mud. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_MUD: IAchievement = {\n    id: \"sacrifice:29/100\",\n    name: \"Sacrifice 100 Mud\",\n    description: \"You have sacrificed 100 Mud! Here, shake my hand!\",\n};\nexport const ITEM_MUD_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_MUD,\n    ACHIEVEMENT_BUY_100_MUD,\n    ACHIEVEMENT_SACRIFICE_1_MUD,\n    ACHIEVEMENT_SACRIFICE_100_MUD,\n];\nexport const ACHIEVEMENT_BUY_1_LAVA: IAchievement = {\n    id: \"buy:30/1\",\n    name: \"Buy one Lava\",\n    description: \"You have bought 1 Lava. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_LAVA: IAchievement = {\n    id: \"buy:30/100\",\n    name: \"Buy 100 Lava\",\n    description: \"You have bought 100 Lava! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_LAVA: IAchievement = {\n    id: \"sacrifice:30/1\",\n    name: \"Sacrifice one Lava\",\n    description: \"You have sacrificed 1 Lava. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_LAVA: IAchievement = {\n    id: \"sacrifice:30/100\",\n    name: \"Sacrifice 100 Lava\",\n    description: \"You have sacrificed 100 Lava! Here, shake my hand!\",\n};\nexport const ITEM_LAVA_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_LAVA,\n    ACHIEVEMENT_BUY_100_LAVA,\n    ACHIEVEMENT_SACRIFICE_1_LAVA,\n    ACHIEVEMENT_SACRIFICE_100_LAVA,\n];\nexport const ACHIEVEMENT_BUY_1_WIND: IAchievement = {\n    id: \"buy:31/1\",\n    name: \"Buy one Wind\",\n    description: \"You have bought 1 Wind. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_WIND: IAchievement = {\n    id: \"buy:31/100\",\n    name: \"Buy 100 Wind\",\n    description: \"You have bought 100 Wind! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_WIND: IAchievement = {\n    id: \"sacrifice:31/1\",\n    name: \"Sacrifice one Wind\",\n    description: \"You have sacrificed 1 Wind. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_WIND: IAchievement = {\n    id: \"sacrifice:31/100\",\n    name: \"Sacrifice 100 Wind\",\n    description: \"You have sacrificed 100 Wind! Here, shake my hand!\",\n};\nexport const ITEM_WIND_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_WIND,\n    ACHIEVEMENT_BUY_100_WIND,\n    ACHIEVEMENT_SACRIFICE_1_WIND,\n    ACHIEVEMENT_SACRIFICE_100_WIND,\n];\nexport const ACHIEVEMENT_BUY_1_DUST: IAchievement = {\n    id: \"buy:32/1\",\n    name: \"Buy one Dust\",\n    description: \"You have bought 1 Dust. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_DUST: IAchievement = {\n    id: \"buy:32/100\",\n    name: \"Buy 100 Dust\",\n    description: \"You have bought 100 Dust! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_DUST: IAchievement = {\n    id: \"sacrifice:32/1\",\n    name: \"Sacrifice one Dust\",\n    description: \"You have sacrificed 1 Dust. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_DUST: IAchievement = {\n    id: \"sacrifice:32/100\",\n    name: \"Sacrifice 100 Dust\",\n    description: \"You have sacrificed 100 Dust! Here, shake my hand!\",\n};\nexport const ITEM_DUST_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_DUST,\n    ACHIEVEMENT_BUY_100_DUST,\n    ACHIEVEMENT_SACRIFICE_1_DUST,\n    ACHIEVEMENT_SACRIFICE_100_DUST,\n];\nexport const ACHIEVEMENT_BUY_1_RAIN: IAchievement = {\n    id: \"buy:33/1\",\n    name: \"Buy one Rain\",\n    description: \"You have bought 1 Rain. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_RAIN: IAchievement = {\n    id: \"buy:33/100\",\n    name: \"Buy 100 Rain\",\n    description: \"You have bought 100 Rain! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_RAIN: IAchievement = {\n    id: \"sacrifice:33/1\",\n    name: \"Sacrifice one Rain\",\n    description: \"You have sacrificed 1 Rain. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_RAIN: IAchievement = {\n    id: \"sacrifice:33/100\",\n    name: \"Sacrifice 100 Rain\",\n    description: \"You have sacrificed 100 Rain! Here, shake my hand!\",\n};\nexport const ITEM_RAIN_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_RAIN,\n    ACHIEVEMENT_BUY_100_RAIN,\n    ACHIEVEMENT_SACRIFICE_1_RAIN,\n    ACHIEVEMENT_SACRIFICE_100_RAIN,\n];\nexport const ACHIEVEMENT_BUY_1_SMOKE: IAchievement = {\n    id: \"buy:34/1\",\n    name: \"Buy one Smoke\",\n    description: \"You have bought 1 Smoke. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_SMOKE: IAchievement = {\n    id: \"buy:34/100\",\n    name: \"Buy 100 Smoke\",\n    description: \"You have bought 100 Smoke! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_SMOKE: IAchievement = {\n    id: \"sacrifice:34/1\",\n    name: \"Sacrifice one Smoke\",\n    description: \"You have sacrificed 1 Smoke. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_SMOKE: IAchievement = {\n    id: \"sacrifice:34/100\",\n    name: \"Sacrifice 100 Smoke\",\n    description: \"You have sacrificed 100 Smoke! Here, shake my hand!\",\n};\nexport const ITEM_SMOKE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_SMOKE,\n    ACHIEVEMENT_BUY_100_SMOKE,\n    ACHIEVEMENT_SACRIFICE_1_SMOKE,\n    ACHIEVEMENT_SACRIFICE_100_SMOKE,\n];\nexport const ACHIEVEMENT_BUY_1_GEYSER: IAchievement = {\n    id: \"buy:35/1\",\n    name: \"Buy one Geyser\",\n    description: \"You have bought 1 Geyser. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_GEYSER: IAchievement = {\n    id: \"buy:35/100\",\n    name: \"Buy 100 Geyser\",\n    description: \"You have bought 100 Geyser! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_GEYSER: IAchievement = {\n    id: \"sacrifice:35/1\",\n    name: \"Sacrifice one Geyser\",\n    description: \"You have sacrificed 1 Geyser. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_GEYSER: IAchievement = {\n    id: \"sacrifice:35/100\",\n    name: \"Sacrifice 100 Geyser\",\n    description: \"You have sacrificed 100 Geyser! Here, shake my hand!\",\n};\nexport const ITEM_GEYSER_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_GEYSER,\n    ACHIEVEMENT_BUY_100_GEYSER,\n    ACHIEVEMENT_SACRIFICE_1_GEYSER,\n    ACHIEVEMENT_SACRIFICE_100_GEYSER,\n];\nexport const ACHIEVEMENT_BUY_1_CLAY: IAchievement = {\n    id: \"buy:36/1\",\n    name: \"Buy one Clay\",\n    description: \"You have bought 1 Clay. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_CLAY: IAchievement = {\n    id: \"buy:36/100\",\n    name: \"Buy 100 Clay\",\n    description: \"You have bought 100 Clay! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_CLAY: IAchievement = {\n    id: \"sacrifice:36/1\",\n    name: \"Sacrifice one Clay\",\n    description: \"You have sacrificed 1 Clay. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_CLAY: IAchievement = {\n    id: \"sacrifice:36/100\",\n    name: \"Sacrifice 100 Clay\",\n    description: \"You have sacrificed 100 Clay! Here, shake my hand!\",\n};\nexport const ITEM_CLAY_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_CLAY,\n    ACHIEVEMENT_BUY_100_CLAY,\n    ACHIEVEMENT_SACRIFICE_1_CLAY,\n    ACHIEVEMENT_SACRIFICE_100_CLAY,\n];\nexport const ACHIEVEMENT_BUY_1_SAND: IAchievement = {\n    id: \"buy:37/1\",\n    name: \"Buy one Sand\",\n    description: \"You have bought 1 Sand. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_SAND: IAchievement = {\n    id: \"buy:37/100\",\n    name: \"Buy 100 Sand\",\n    description: \"You have bought 100 Sand! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_SAND: IAchievement = {\n    id: \"sacrifice:37/1\",\n    name: \"Sacrifice one Sand\",\n    description: \"You have sacrificed 1 Sand. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_SAND: IAchievement = {\n    id: \"sacrifice:37/100\",\n    name: \"Sacrifice 100 Sand\",\n    description: \"You have sacrificed 100 Sand! Here, shake my hand!\",\n};\nexport const ITEM_SAND_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_SAND,\n    ACHIEVEMENT_BUY_100_SAND,\n    ACHIEVEMENT_SACRIFICE_1_SAND,\n    ACHIEVEMENT_SACRIFICE_100_SAND,\n];\nexport const ACHIEVEMENT_BUY_1_PLANT: IAchievement = {\n    id: \"buy:38/1\",\n    name: \"Buy one Plant\",\n    description: \"You have bought 1 Plant. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_PLANT: IAchievement = {\n    id: \"buy:38/100\",\n    name: \"Buy 100 Plant\",\n    description: \"You have bought 100 Plant! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_PLANT: IAchievement = {\n    id: \"sacrifice:38/1\",\n    name: \"Sacrifice one Plant\",\n    description: \"You have sacrificed 1 Plant. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_PLANT: IAchievement = {\n    id: \"sacrifice:38/100\",\n    name: \"Sacrifice 100 Plant\",\n    description: \"You have sacrificed 100 Plant! Here, shake my hand!\",\n};\nexport const ITEM_PLANT_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_PLANT,\n    ACHIEVEMENT_BUY_100_PLANT,\n    ACHIEVEMENT_SACRIFICE_1_PLANT,\n    ACHIEVEMENT_SACRIFICE_100_PLANT,\n];\nexport const ACHIEVEMENT_BUY_1_RAINBOW: IAchievement = {\n    id: \"buy:39/1\",\n    name: \"Buy one Rainbow\",\n    description: \"You have bought 1 Rainbow. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_RAINBOW: IAchievement = {\n    id: \"buy:39/100\",\n    name: \"Buy 100 Rainbow\",\n    description: \"You have bought 100 Rainbow! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_RAINBOW: IAchievement = {\n    id: \"sacrifice:39/1\",\n    name: \"Sacrifice one Rainbow\",\n    description: \"You have sacrificed 1 Rainbow. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_RAINBOW: IAchievement = {\n    id: \"sacrifice:39/100\",\n    name: \"Sacrifice 100 Rainbow\",\n    description: \"You have sacrificed 100 Rainbow! Here, shake my hand!\",\n};\nexport const ITEM_RAINBOW_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_RAINBOW,\n    ACHIEVEMENT_BUY_100_RAINBOW,\n    ACHIEVEMENT_SACRIFICE_1_RAINBOW,\n    ACHIEVEMENT_SACRIFICE_100_RAINBOW,\n];\nexport const ACHIEVEMENT_BUY_1_STORM: IAchievement = {\n    id: \"buy:40/1\",\n    name: \"Buy one Storm\",\n    description: \"You have bought 1 Storm. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_STORM: IAchievement = {\n    id: \"buy:40/100\",\n    name: \"Buy 100 Storm\",\n    description: \"You have bought 100 Storm! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_STORM: IAchievement = {\n    id: \"sacrifice:40/1\",\n    name: \"Sacrifice one Storm\",\n    description: \"You have sacrificed 1 Storm. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_STORM: IAchievement = {\n    id: \"sacrifice:40/100\",\n    name: \"Sacrifice 100 Storm\",\n    description: \"You have sacrificed 100 Storm! Here, shake my hand!\",\n};\nexport const ITEM_STORM_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_STORM,\n    ACHIEVEMENT_BUY_100_STORM,\n    ACHIEVEMENT_SACRIFICE_1_STORM,\n    ACHIEVEMENT_SACRIFICE_100_STORM,\n];\nexport const ACHIEVEMENT_BUY_1_OBSIDIAN: IAchievement = {\n    id: \"buy:41/1\",\n    name: \"Buy one Obsidian\",\n    description: \"You have bought 1 Obsidian. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_OBSIDIAN: IAchievement = {\n    id: \"buy:41/100\",\n    name: \"Buy 100 Obsidian\",\n    description: \"You have bought 100 Obsidian! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_OBSIDIAN: IAchievement = {\n    id: \"sacrifice:41/1\",\n    name: \"Sacrifice one Obsidian\",\n    description: \"You have sacrificed 1 Obsidian. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_OBSIDIAN: IAchievement = {\n    id: \"sacrifice:41/100\",\n    name: \"Sacrifice 100 Obsidian\",\n    description: \"You have sacrificed 100 Obsidian! Here, shake my hand!\",\n};\nexport const ITEM_OBSIDIAN_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_OBSIDIAN,\n    ACHIEVEMENT_BUY_100_OBSIDIAN,\n    ACHIEVEMENT_SACRIFICE_1_OBSIDIAN,\n    ACHIEVEMENT_SACRIFICE_100_OBSIDIAN,\n];\nexport const ACHIEVEMENT_BUY_1_ASH: IAchievement = {\n    id: \"buy:42/1\",\n    name: \"Buy one Ash\",\n    description: \"You have bought 1 Ash. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_ASH: IAchievement = {\n    id: \"buy:42/100\",\n    name: \"Buy 100 Ash\",\n    description: \"You have bought 100 Ash! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_ASH: IAchievement = {\n    id: \"sacrifice:42/1\",\n    name: \"Sacrifice one Ash\",\n    description: \"You have sacrificed 1 Ash. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_ASH: IAchievement = {\n    id: \"sacrifice:42/100\",\n    name: \"Sacrifice 100 Ash\",\n    description: \"You have sacrificed 100 Ash! Here, shake my hand!\",\n};\nexport const ITEM_ASH_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_ASH,\n    ACHIEVEMENT_BUY_100_ASH,\n    ACHIEVEMENT_SACRIFICE_1_ASH,\n    ACHIEVEMENT_SACRIFICE_100_ASH,\n];\nexport const ACHIEVEMENT_BUY_1_VOLCANO: IAchievement = {\n    id: \"buy:43/1\",\n    name: \"Buy one Volcano\",\n    description: \"You have bought 1 Volcano. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_VOLCANO: IAchievement = {\n    id: \"buy:43/100\",\n    name: \"Buy 100 Volcano\",\n    description: \"You have bought 100 Volcano! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_VOLCANO: IAchievement = {\n    id: \"sacrifice:43/1\",\n    name: \"Sacrifice one Volcano\",\n    description: \"You have sacrificed 1 Volcano. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_VOLCANO: IAchievement = {\n    id: \"sacrifice:43/100\",\n    name: \"Sacrifice 100 Volcano\",\n    description: \"You have sacrificed 100 Volcano! Here, shake my hand!\",\n};\nexport const ITEM_VOLCANO_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_VOLCANO,\n    ACHIEVEMENT_BUY_100_VOLCANO,\n    ACHIEVEMENT_SACRIFICE_1_VOLCANO,\n    ACHIEVEMENT_SACRIFICE_100_VOLCANO,\n];\nexport const ACHIEVEMENT_BUY_1_SANDSTORM: IAchievement = {\n    id: \"buy:44/1\",\n    name: \"Buy one Sandstorm\",\n    description: \"You have bought 1 Sandstorm. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_SANDSTORM: IAchievement = {\n    id: \"buy:44/100\",\n    name: \"Buy 100 Sandstorm\",\n    description: \"You have bought 100 Sandstorm! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_SANDSTORM: IAchievement = {\n    id: \"sacrifice:44/1\",\n    name: \"Sacrifice one Sandstorm\",\n    description: \"You have sacrificed 1 Sandstorm. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_SANDSTORM: IAchievement = {\n    id: \"sacrifice:44/100\",\n    name: \"Sacrifice 100 Sandstorm\",\n    description: \"You have sacrificed 100 Sandstorm! Here, shake my hand!\",\n};\nexport const ITEM_SANDSTORM_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_SANDSTORM,\n    ACHIEVEMENT_BUY_100_SANDSTORM,\n    ACHIEVEMENT_SACRIFICE_1_SANDSTORM,\n    ACHIEVEMENT_SACRIFICE_100_SANDSTORM,\n];\nexport const ACHIEVEMENT_BUY_1_CLOUD: IAchievement = {\n    id: \"buy:45/1\",\n    name: \"Buy one Cloud\",\n    description: \"You have bought 1 Cloud. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_CLOUD: IAchievement = {\n    id: \"buy:45/100\",\n    name: \"Buy 100 Cloud\",\n    description: \"You have bought 100 Cloud! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_CLOUD: IAchievement = {\n    id: \"sacrifice:45/1\",\n    name: \"Sacrifice one Cloud\",\n    description: \"You have sacrificed 1 Cloud. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_CLOUD: IAchievement = {\n    id: \"sacrifice:45/100\",\n    name: \"Sacrifice 100 Cloud\",\n    description: \"You have sacrificed 100 Cloud! Here, shake my hand!\",\n};\nexport const ITEM_CLOUD_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_CLOUD,\n    ACHIEVEMENT_BUY_100_CLOUD,\n    ACHIEVEMENT_SACRIFICE_1_CLOUD,\n    ACHIEVEMENT_SACRIFICE_100_CLOUD,\n];\nexport const ACHIEVEMENT_BUY_1_FOG: IAchievement = {\n    id: \"buy:46/1\",\n    name: \"Buy one Fog\",\n    description: \"You have bought 1 Fog. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_FOG: IAchievement = {\n    id: \"buy:46/100\",\n    name: \"Buy 100 Fog\",\n    description: \"You have bought 100 Fog! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_FOG: IAchievement = {\n    id: \"sacrifice:46/1\",\n    name: \"Sacrifice one Fog\",\n    description: \"You have sacrificed 1 Fog. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_FOG: IAchievement = {\n    id: \"sacrifice:46/100\",\n    name: \"Sacrifice 100 Fog\",\n    description: \"You have sacrificed 100 Fog! Here, shake my hand!\",\n};\nexport const ITEM_FOG_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_FOG,\n    ACHIEVEMENT_BUY_100_FOG,\n    ACHIEVEMENT_SACRIFICE_1_FOG,\n    ACHIEVEMENT_SACRIFICE_100_FOG,\n];\nexport const ACHIEVEMENT_BUY_1_TREE: IAchievement = {\n    id: \"buy:47/1\",\n    name: \"Buy one Tree\",\n    description: \"You have bought 1 Tree. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_TREE: IAchievement = {\n    id: \"buy:47/100\",\n    name: \"Buy 100 Tree\",\n    description: \"You have bought 100 Tree! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_TREE: IAchievement = {\n    id: \"sacrifice:47/1\",\n    name: \"Sacrifice one Tree\",\n    description: \"You have sacrificed 1 Tree. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_TREE: IAchievement = {\n    id: \"sacrifice:47/100\",\n    name: \"Sacrifice 100 Tree\",\n    description: \"You have sacrificed 100 Tree! Here, shake my hand!\",\n};\nexport const ITEM_TREE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_TREE,\n    ACHIEVEMENT_BUY_100_TREE,\n    ACHIEVEMENT_SACRIFICE_1_TREE,\n    ACHIEVEMENT_SACRIFICE_100_TREE,\n];\nexport const ACHIEVEMENT_BUY_1_FOREST: IAchievement = {\n    id: \"buy:48/1\",\n    name: \"Buy one Forest\",\n    description: \"You have bought 1 Forest. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_FOREST: IAchievement = {\n    id: \"buy:48/100\",\n    name: \"Buy 100 Forest\",\n    description: \"You have bought 100 Forest! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_FOREST: IAchievement = {\n    id: \"sacrifice:48/1\",\n    name: \"Sacrifice one Forest\",\n    description: \"You have sacrificed 1 Forest. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_FOREST: IAchievement = {\n    id: \"sacrifice:48/100\",\n    name: \"Sacrifice 100 Forest\",\n    description: \"You have sacrificed 100 Forest! Here, shake my hand!\",\n};\nexport const ITEM_FOREST_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_FOREST,\n    ACHIEVEMENT_BUY_100_FOREST,\n    ACHIEVEMENT_SACRIFICE_1_FOREST,\n    ACHIEVEMENT_SACRIFICE_100_FOREST,\n];\nexport const ACHIEVEMENT_BUY_1_SEEDS: IAchievement = {\n    id: \"buy:49/1\",\n    name: \"Buy one Seeds\",\n    description: \"You have bought 1 Seeds. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_SEEDS: IAchievement = {\n    id: \"buy:49/100\",\n    name: \"Buy 100 Seeds\",\n    description: \"You have bought 100 Seeds! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_SEEDS: IAchievement = {\n    id: \"sacrifice:49/1\",\n    name: \"Sacrifice one Seeds\",\n    description: \"You have sacrificed 1 Seeds. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_SEEDS: IAchievement = {\n    id: \"sacrifice:49/100\",\n    name: \"Sacrifice 100 Seeds\",\n    description: \"You have sacrificed 100 Seeds! Here, shake my hand!\",\n};\nexport const ITEM_SEEDS_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_SEEDS,\n    ACHIEVEMENT_BUY_100_SEEDS,\n    ACHIEVEMENT_SACRIFICE_1_SEEDS,\n    ACHIEVEMENT_SACRIFICE_100_SEEDS,\n];\nexport const ACHIEVEMENT_BUY_1_POTTERY: IAchievement = {\n    id: \"buy:50/1\",\n    name: \"Buy one Pottery\",\n    description: \"You have bought 1 Pottery. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_POTTERY: IAchievement = {\n    id: \"buy:50/100\",\n    name: \"Buy 100 Pottery\",\n    description: \"You have bought 100 Pottery! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_POTTERY: IAchievement = {\n    id: \"sacrifice:50/1\",\n    name: \"Sacrifice one Pottery\",\n    description: \"You have sacrificed 1 Pottery. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_POTTERY: IAchievement = {\n    id: \"sacrifice:50/100\",\n    name: \"Sacrifice 100 Pottery\",\n    description: \"You have sacrificed 100 Pottery! Here, shake my hand!\",\n};\nexport const ITEM_POTTERY_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_POTTERY,\n    ACHIEVEMENT_BUY_100_POTTERY,\n    ACHIEVEMENT_SACRIFICE_1_POTTERY,\n    ACHIEVEMENT_SACRIFICE_100_POTTERY,\n];\nexport const ACHIEVEMENT_BUY_1_BRICK: IAchievement = {\n    id: \"buy:51/1\",\n    name: \"Buy one Brick\",\n    description: \"You have bought 1 Brick. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_BRICK: IAchievement = {\n    id: \"buy:51/100\",\n    name: \"Buy 100 Brick\",\n    description: \"You have bought 100 Brick! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_BRICK: IAchievement = {\n    id: \"sacrifice:51/1\",\n    name: \"Sacrifice one Brick\",\n    description: \"You have sacrificed 1 Brick. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_BRICK: IAchievement = {\n    id: \"sacrifice:51/100\",\n    name: \"Sacrifice 100 Brick\",\n    description: \"You have sacrificed 100 Brick! Here, shake my hand!\",\n};\nexport const ITEM_BRICK_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_BRICK,\n    ACHIEVEMENT_BUY_100_BRICK,\n    ACHIEVEMENT_SACRIFICE_1_BRICK,\n    ACHIEVEMENT_SACRIFICE_100_BRICK,\n];\nexport const ACHIEVEMENT_BUY_1_QUICKSAND: IAchievement = {\n    id: \"buy:52/1\",\n    name: \"Buy one Quicksand\",\n    description: \"You have bought 1 Quicksand. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_QUICKSAND: IAchievement = {\n    id: \"buy:52/100\",\n    name: \"Buy 100 Quicksand\",\n    description: \"You have bought 100 Quicksand! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_QUICKSAND: IAchievement = {\n    id: \"sacrifice:52/1\",\n    name: \"Sacrifice one Quicksand\",\n    description: \"You have sacrificed 1 Quicksand. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_QUICKSAND: IAchievement = {\n    id: \"sacrifice:52/100\",\n    name: \"Sacrifice 100 Quicksand\",\n    description: \"You have sacrificed 100 Quicksand! Here, shake my hand!\",\n};\nexport const ITEM_QUICKSAND_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_QUICKSAND,\n    ACHIEVEMENT_BUY_100_QUICKSAND,\n    ACHIEVEMENT_SACRIFICE_1_QUICKSAND,\n    ACHIEVEMENT_SACRIFICE_100_QUICKSAND,\n];\nexport const ACHIEVEMENT_BUY_1_GLASS: IAchievement = {\n    id: \"buy:53/1\",\n    name: \"Buy one Glass\",\n    description: \"You have bought 1 Glass. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_GLASS: IAchievement = {\n    id: \"buy:53/100\",\n    name: \"Buy 100 Glass\",\n    description: \"You have bought 100 Glass! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_GLASS: IAchievement = {\n    id: \"sacrifice:53/1\",\n    name: \"Sacrifice one Glass\",\n    description: \"You have sacrificed 1 Glass. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_GLASS: IAchievement = {\n    id: \"sacrifice:53/100\",\n    name: \"Sacrifice 100 Glass\",\n    description: \"You have sacrificed 100 Glass! Here, shake my hand!\",\n};\nexport const ITEM_GLASS_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_GLASS,\n    ACHIEVEMENT_BUY_100_GLASS,\n    ACHIEVEMENT_SACRIFICE_1_GLASS,\n    ACHIEVEMENT_SACRIFICE_100_GLASS,\n];\nexport const ACHIEVEMENT_BUY_1_DUNE: IAchievement = {\n    id: \"buy:54/1\",\n    name: \"Buy one Dune\",\n    description: \"You have bought 1 Dune. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_DUNE: IAchievement = {\n    id: \"buy:54/100\",\n    name: \"Buy 100 Dune\",\n    description: \"You have bought 100 Dune! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_DUNE: IAchievement = {\n    id: \"sacrifice:54/1\",\n    name: \"Sacrifice one Dune\",\n    description: \"You have sacrificed 1 Dune. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_DUNE: IAchievement = {\n    id: \"sacrifice:54/100\",\n    name: \"Sacrifice 100 Dune\",\n    description: \"You have sacrificed 100 Dune! Here, shake my hand!\",\n};\nexport const ITEM_DUNE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_DUNE,\n    ACHIEVEMENT_BUY_100_DUNE,\n    ACHIEVEMENT_SACRIFICE_1_DUNE,\n    ACHIEVEMENT_SACRIFICE_100_DUNE,\n];\nexport const ACHIEVEMENT_BUY_1_CHARCOAL: IAchievement = {\n    id: \"buy:55/1\",\n    name: \"Buy one Charcoal\",\n    description: \"You have bought 1 Charcoal. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_CHARCOAL: IAchievement = {\n    id: \"buy:55/100\",\n    name: \"Buy 100 Charcoal\",\n    description: \"You have bought 100 Charcoal! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_CHARCOAL: IAchievement = {\n    id: \"sacrifice:55/1\",\n    name: \"Sacrifice one Charcoal\",\n    description: \"You have sacrificed 1 Charcoal. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_CHARCOAL: IAchievement = {\n    id: \"sacrifice:55/100\",\n    name: \"Sacrifice 100 Charcoal\",\n    description: \"You have sacrificed 100 Charcoal! Here, shake my hand!\",\n};\nexport const ITEM_CHARCOAL_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_CHARCOAL,\n    ACHIEVEMENT_BUY_100_CHARCOAL,\n    ACHIEVEMENT_SACRIFICE_1_CHARCOAL,\n    ACHIEVEMENT_SACRIFICE_100_CHARCOAL,\n];\nexport const ACHIEVEMENT_BUY_1_LEAVES: IAchievement = {\n    id: \"buy:56/1\",\n    name: \"Buy one Leaves\",\n    description: \"You have bought 1 Leaves. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_LEAVES: IAchievement = {\n    id: \"buy:56/100\",\n    name: \"Buy 100 Leaves\",\n    description: \"You have bought 100 Leaves! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_LEAVES: IAchievement = {\n    id: \"sacrifice:56/1\",\n    name: \"Sacrifice one Leaves\",\n    description: \"You have sacrificed 1 Leaves. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_LEAVES: IAchievement = {\n    id: \"sacrifice:56/100\",\n    name: \"Sacrifice 100 Leaves\",\n    description: \"You have sacrificed 100 Leaves! Here, shake my hand!\",\n};\nexport const ITEM_LEAVES_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_LEAVES,\n    ACHIEVEMENT_BUY_100_LEAVES,\n    ACHIEVEMENT_SACRIFICE_1_LEAVES,\n    ACHIEVEMENT_SACRIFICE_100_LEAVES,\n];\nexport const ACHIEVEMENT_BUY_1_WILDFIRE: IAchievement = {\n    id: \"buy:57/1\",\n    name: \"Buy one Wildfire\",\n    description: \"You have bought 1 Wildfire. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_WILDFIRE: IAchievement = {\n    id: \"buy:57/100\",\n    name: \"Buy 100 Wildfire\",\n    description: \"You have bought 100 Wildfire! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_WILDFIRE: IAchievement = {\n    id: \"sacrifice:57/1\",\n    name: \"Sacrifice one Wildfire\",\n    description: \"You have sacrificed 1 Wildfire. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_WILDFIRE: IAchievement = {\n    id: \"sacrifice:57/100\",\n    name: \"Sacrifice 100 Wildfire\",\n    description: \"You have sacrificed 100 Wildfire! Here, shake my hand!\",\n};\nexport const ITEM_WILDFIRE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_WILDFIRE,\n    ACHIEVEMENT_BUY_100_WILDFIRE,\n    ACHIEVEMENT_SACRIFICE_1_WILDFIRE,\n    ACHIEVEMENT_SACRIFICE_100_WILDFIRE,\n];\nexport const ACHIEVEMENT_BUY_1_JUNGLE: IAchievement = {\n    id: \"buy:58/1\",\n    name: \"Buy one Jungle\",\n    description: \"You have bought 1 Jungle. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_JUNGLE: IAchievement = {\n    id: \"buy:58/100\",\n    name: \"Buy 100 Jungle\",\n    description: \"You have bought 100 Jungle! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_JUNGLE: IAchievement = {\n    id: \"sacrifice:58/1\",\n    name: \"Sacrifice one Jungle\",\n    description: \"You have sacrificed 1 Jungle. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_JUNGLE: IAchievement = {\n    id: \"sacrifice:58/100\",\n    name: \"Sacrifice 100 Jungle\",\n    description: \"You have sacrificed 100 Jungle! Here, shake my hand!\",\n};\nexport const ITEM_JUNGLE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_JUNGLE,\n    ACHIEVEMENT_BUY_100_JUNGLE,\n    ACHIEVEMENT_SACRIFICE_1_JUNGLE,\n    ACHIEVEMENT_SACRIFICE_100_JUNGLE,\n];\nexport const ACHIEVEMENT_BUY_1_FROSTED_GLASS: IAchievement = {\n    id: \"buy:59/1\",\n    name: \"Buy one Frosted Glass\",\n    description: \"You have bought 1 Frosted Glass. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_FROSTED_GLASS: IAchievement = {\n    id: \"buy:59/100\",\n    name: \"Buy 100 Frosted Glass\",\n    description: \"You have bought 100 Frosted Glass! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_FROSTED_GLASS: IAchievement = {\n    id: \"sacrifice:59/1\",\n    name: \"Sacrifice one Frosted Glass\",\n    description: \"You have sacrificed 1 Frosted Glass. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_FROSTED_GLASS: IAchievement = {\n    id: \"sacrifice:59/100\",\n    name: \"Sacrifice 100 Frosted Glass\",\n    description: \"You have sacrificed 100 Frosted Glass! Here, shake my hand!\",\n};\nexport const ITEM_FROSTED_GLASS_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_FROSTED_GLASS,\n    ACHIEVEMENT_BUY_100_FROSTED_GLASS,\n    ACHIEVEMENT_SACRIFICE_1_FROSTED_GLASS,\n    ACHIEVEMENT_SACRIFICE_100_FROSTED_GLASS,\n];\nexport const ACHIEVEMENT_BUY_1_CRYSTAL: IAchievement = {\n    id: \"buy:60/1\",\n    name: \"Buy one Crystal\",\n    description: \"You have bought 1 Crystal. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_CRYSTAL: IAchievement = {\n    id: \"buy:60/100\",\n    name: \"Buy 100 Crystal\",\n    description: \"You have bought 100 Crystal! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_CRYSTAL: IAchievement = {\n    id: \"sacrifice:60/1\",\n    name: \"Sacrifice one Crystal\",\n    description: \"You have sacrificed 1 Crystal. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_CRYSTAL: IAchievement = {\n    id: \"sacrifice:60/100\",\n    name: \"Sacrifice 100 Crystal\",\n    description: \"You have sacrificed 100 Crystal! Here, shake my hand!\",\n};\nexport const ITEM_CRYSTAL_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_CRYSTAL,\n    ACHIEVEMENT_BUY_100_CRYSTAL,\n    ACHIEVEMENT_SACRIFICE_1_CRYSTAL,\n    ACHIEVEMENT_SACRIFICE_100_CRYSTAL,\n];\nexport const ACHIEVEMENT_BUY_1_MAGMA: IAchievement = {\n    id: \"buy:61/1\",\n    name: \"Buy one Magma\",\n    description: \"You have bought 1 Magma. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_MAGMA: IAchievement = {\n    id: \"buy:61/100\",\n    name: \"Buy 100 Magma\",\n    description: \"You have bought 100 Magma! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_MAGMA: IAchievement = {\n    id: \"sacrifice:61/1\",\n    name: \"Sacrifice one Magma\",\n    description: \"You have sacrificed 1 Magma. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_MAGMA: IAchievement = {\n    id: \"sacrifice:61/100\",\n    name: \"Sacrifice 100 Magma\",\n    description: \"You have sacrificed 100 Magma! Here, shake my hand!\",\n};\nexport const ITEM_MAGMA_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_MAGMA,\n    ACHIEVEMENT_BUY_100_MAGMA,\n    ACHIEVEMENT_SACRIFICE_1_MAGMA,\n    ACHIEVEMENT_SACRIFICE_100_MAGMA,\n];\nexport const ACHIEVEMENT_BUY_1_ROCK: IAchievement = {\n    id: \"buy:62/1\",\n    name: \"Buy one Rock\",\n    description: \"You have bought 1 Rock. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_ROCK: IAchievement = {\n    id: \"buy:62/100\",\n    name: \"Buy 100 Rock\",\n    description: \"You have bought 100 Rock! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_ROCK: IAchievement = {\n    id: \"sacrifice:62/1\",\n    name: \"Sacrifice one Rock\",\n    description: \"You have sacrificed 1 Rock. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_ROCK: IAchievement = {\n    id: \"sacrifice:62/100\",\n    name: \"Sacrifice 100 Rock\",\n    description: \"You have sacrificed 100 Rock! Here, shake my hand!\",\n};\nexport const ITEM_ROCK_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_ROCK,\n    ACHIEVEMENT_BUY_100_ROCK,\n    ACHIEVEMENT_SACRIFICE_1_ROCK,\n    ACHIEVEMENT_SACRIFICE_100_ROCK,\n];\nexport const ACHIEVEMENT_BUY_1_SHARD: IAchievement = {\n    id: \"buy:63/1\",\n    name: \"Buy one Shard\",\n    description: \"You have bought 1 Shard. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_SHARD: IAchievement = {\n    id: \"buy:63/100\",\n    name: \"Buy 100 Shard\",\n    description: \"You have bought 100 Shard! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_SHARD: IAchievement = {\n    id: \"sacrifice:63/1\",\n    name: \"Sacrifice one Shard\",\n    description: \"You have sacrificed 1 Shard. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_SHARD: IAchievement = {\n    id: \"sacrifice:63/100\",\n    name: \"Sacrifice 100 Shard\",\n    description: \"You have sacrificed 100 Shard! Here, shake my hand!\",\n};\nexport const ITEM_SHARD_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_SHARD,\n    ACHIEVEMENT_BUY_100_SHARD,\n    ACHIEVEMENT_SACRIFICE_1_SHARD,\n    ACHIEVEMENT_SACRIFICE_100_SHARD,\n];\nexport const ACHIEVEMENT_BUY_1_PEBBLE: IAchievement = {\n    id: \"buy:64/1\",\n    name: \"Buy one Pebble\",\n    description: \"You have bought 1 Pebble. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_PEBBLE: IAchievement = {\n    id: \"buy:64/100\",\n    name: \"Buy 100 Pebble\",\n    description: \"You have bought 100 Pebble! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_PEBBLE: IAchievement = {\n    id: \"sacrifice:64/1\",\n    name: \"Sacrifice one Pebble\",\n    description: \"You have sacrificed 1 Pebble. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_PEBBLE: IAchievement = {\n    id: \"sacrifice:64/100\",\n    name: \"Sacrifice 100 Pebble\",\n    description: \"You have sacrificed 100 Pebble! Here, shake my hand!\",\n};\nexport const ITEM_PEBBLE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_PEBBLE,\n    ACHIEVEMENT_BUY_100_PEBBLE,\n    ACHIEVEMENT_SACRIFICE_1_PEBBLE,\n    ACHIEVEMENT_SACRIFICE_100_PEBBLE,\n];\nexport const ACHIEVEMENT_BUY_1_MOUNTAIN: IAchievement = {\n    id: \"buy:65/1\",\n    name: \"Buy one Mountain\",\n    description: \"You have bought 1 Mountain. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_MOUNTAIN: IAchievement = {\n    id: \"buy:65/100\",\n    name: \"Buy 100 Mountain\",\n    description: \"You have bought 100 Mountain! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_MOUNTAIN: IAchievement = {\n    id: \"sacrifice:65/1\",\n    name: \"Sacrifice one Mountain\",\n    description: \"You have sacrificed 1 Mountain. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_MOUNTAIN: IAchievement = {\n    id: \"sacrifice:65/100\",\n    name: \"Sacrifice 100 Mountain\",\n    description: \"You have sacrificed 100 Mountain! Here, shake my hand!\",\n};\nexport const ITEM_MOUNTAIN_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_MOUNTAIN,\n    ACHIEVEMENT_BUY_100_MOUNTAIN,\n    ACHIEVEMENT_SACRIFICE_1_MOUNTAIN,\n    ACHIEVEMENT_SACRIFICE_100_MOUNTAIN,\n];\nexport const ACHIEVEMENT_BUY_1_FERTILIZER: IAchievement = {\n    id: \"buy:66/1\",\n    name: \"Buy one Fertilizer\",\n    description: \"You have bought 1 Fertilizer. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_FERTILIZER: IAchievement = {\n    id: \"buy:66/100\",\n    name: \"Buy 100 Fertilizer\",\n    description: \"You have bought 100 Fertilizer! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_FERTILIZER: IAchievement = {\n    id: \"sacrifice:66/1\",\n    name: \"Sacrifice one Fertilizer\",\n    description: \"You have sacrificed 1 Fertilizer. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_FERTILIZER: IAchievement = {\n    id: \"sacrifice:66/100\",\n    name: \"Sacrifice 100 Fertilizer\",\n    description: \"You have sacrificed 100 Fertilizer! Here, shake my hand!\",\n};\nexport const ITEM_FERTILIZER_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_FERTILIZER,\n    ACHIEVEMENT_BUY_100_FERTILIZER,\n    ACHIEVEMENT_SACRIFICE_1_FERTILIZER,\n    ACHIEVEMENT_SACRIFICE_100_FERTILIZER,\n];\nexport const ACHIEVEMENT_BUY_1_SOOT: IAchievement = {\n    id: \"buy:67/1\",\n    name: \"Buy one Soot\",\n    description: \"You have bought 1 Soot. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_SOOT: IAchievement = {\n    id: \"buy:67/100\",\n    name: \"Buy 100 Soot\",\n    description: \"You have bought 100 Soot! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_SOOT: IAchievement = {\n    id: \"sacrifice:67/1\",\n    name: \"Sacrifice one Soot\",\n    description: \"You have sacrificed 1 Soot. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_SOOT: IAchievement = {\n    id: \"sacrifice:67/100\",\n    name: \"Sacrifice 100 Soot\",\n    description: \"You have sacrificed 100 Soot! Here, shake my hand!\",\n};\nexport const ITEM_SOOT_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_SOOT,\n    ACHIEVEMENT_BUY_100_SOOT,\n    ACHIEVEMENT_SACRIFICE_1_SOOT,\n    ACHIEVEMENT_SACRIFICE_100_SOOT,\n];\nexport const ACHIEVEMENT_BUY_1_LIGHTNING: IAchievement = {\n    id: \"buy:68/1\",\n    name: \"Buy one Lightning\",\n    description: \"You have bought 1 Lightning. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_LIGHTNING: IAchievement = {\n    id: \"buy:68/100\",\n    name: \"Buy 100 Lightning\",\n    description: \"You have bought 100 Lightning! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_LIGHTNING: IAchievement = {\n    id: \"sacrifice:68/1\",\n    name: \"Sacrifice one Lightning\",\n    description: \"You have sacrificed 1 Lightning. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_LIGHTNING: IAchievement = {\n    id: \"sacrifice:68/100\",\n    name: \"Sacrifice 100 Lightning\",\n    description: \"You have sacrificed 100 Lightning! Here, shake my hand!\",\n};\nexport const ITEM_LIGHTNING_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_LIGHTNING,\n    ACHIEVEMENT_BUY_100_LIGHTNING,\n    ACHIEVEMENT_SACRIFICE_1_LIGHTNING,\n    ACHIEVEMENT_SACRIFICE_100_LIGHTNING,\n];\nexport const ACHIEVEMENT_BUY_1_MIST: IAchievement = {\n    id: \"buy:69/1\",\n    name: \"Buy one Mist\",\n    description: \"You have bought 1 Mist. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_MIST: IAchievement = {\n    id: \"buy:69/100\",\n    name: \"Buy 100 Mist\",\n    description: \"You have bought 100 Mist! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_MIST: IAchievement = {\n    id: \"sacrifice:69/1\",\n    name: \"Sacrifice one Mist\",\n    description: \"You have sacrificed 1 Mist. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_MIST: IAchievement = {\n    id: \"sacrifice:69/100\",\n    name: \"Sacrifice 100 Mist\",\n    description: \"You have sacrificed 100 Mist! Here, shake my hand!\",\n};\nexport const ITEM_MIST_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_MIST,\n    ACHIEVEMENT_BUY_100_MIST,\n    ACHIEVEMENT_SACRIFICE_1_MIST,\n    ACHIEVEMENT_SACRIFICE_100_MIST,\n];\nexport const ACHIEVEMENT_BUY_1_HAZE: IAchievement = {\n    id: \"buy:70/1\",\n    name: \"Buy one Haze\",\n    description: \"You have bought 1 Haze. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_HAZE: IAchievement = {\n    id: \"buy:70/100\",\n    name: \"Buy 100 Haze\",\n    description: \"You have bought 100 Haze! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_HAZE: IAchievement = {\n    id: \"sacrifice:70/1\",\n    name: \"Sacrifice one Haze\",\n    description: \"You have sacrificed 1 Haze. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_HAZE: IAchievement = {\n    id: \"sacrifice:70/100\",\n    name: \"Sacrifice 100 Haze\",\n    description: \"You have sacrificed 100 Haze! Here, shake my hand!\",\n};\nexport const ITEM_HAZE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_HAZE,\n    ACHIEVEMENT_BUY_100_HAZE,\n    ACHIEVEMENT_SACRIFICE_1_HAZE,\n    ACHIEVEMENT_SACRIFICE_100_HAZE,\n];\nexport const ACHIEVEMENT_BUY_1_FLOOD: IAchievement = {\n    id: \"buy:71/1\",\n    name: \"Buy one Flood\",\n    description: \"You have bought 1 Flood. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_FLOOD: IAchievement = {\n    id: \"buy:71/100\",\n    name: \"Buy 100 Flood\",\n    description: \"You have bought 100 Flood! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_FLOOD: IAchievement = {\n    id: \"sacrifice:71/1\",\n    name: \"Sacrifice one Flood\",\n    description: \"You have sacrificed 1 Flood. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_FLOOD: IAchievement = {\n    id: \"sacrifice:71/100\",\n    name: \"Sacrifice 100 Flood\",\n    description: \"You have sacrificed 100 Flood! Here, shake my hand!\",\n};\nexport const ITEM_FLOOD_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_FLOOD,\n    ACHIEVEMENT_BUY_100_FLOOD,\n    ACHIEVEMENT_SACRIFICE_1_FLOOD,\n    ACHIEVEMENT_SACRIFICE_100_FLOOD,\n];\nexport const ACHIEVEMENT_BUY_1_LANDSLIDE: IAchievement = {\n    id: \"buy:72/1\",\n    name: \"Buy one Landslide\",\n    description: \"You have bought 1 Landslide. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_LANDSLIDE: IAchievement = {\n    id: \"buy:72/100\",\n    name: \"Buy 100 Landslide\",\n    description: \"You have bought 100 Landslide! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_LANDSLIDE: IAchievement = {\n    id: \"sacrifice:72/1\",\n    name: \"Sacrifice one Landslide\",\n    description: \"You have sacrificed 1 Landslide. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_LANDSLIDE: IAchievement = {\n    id: \"sacrifice:72/100\",\n    name: \"Sacrifice 100 Landslide\",\n    description: \"You have sacrificed 100 Landslide! Here, shake my hand!\",\n};\nexport const ITEM_LANDSLIDE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_LANDSLIDE,\n    ACHIEVEMENT_BUY_100_LANDSLIDE,\n    ACHIEVEMENT_SACRIFICE_1_LANDSLIDE,\n    ACHIEVEMENT_SACRIFICE_100_LANDSLIDE,\n];\nexport const ACHIEVEMENT_BUY_1_THUNDER: IAchievement = {\n    id: \"buy:73/1\",\n    name: \"Buy one Thunder\",\n    description: \"You have bought 1 Thunder. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_THUNDER: IAchievement = {\n    id: \"buy:73/100\",\n    name: \"Buy 100 Thunder\",\n    description: \"You have bought 100 Thunder! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_THUNDER: IAchievement = {\n    id: \"sacrifice:73/1\",\n    name: \"Sacrifice one Thunder\",\n    description: \"You have sacrificed 1 Thunder. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_THUNDER: IAchievement = {\n    id: \"sacrifice:73/100\",\n    name: \"Sacrifice 100 Thunder\",\n    description: \"You have sacrificed 100 Thunder! Here, shake my hand!\",\n};\nexport const ITEM_THUNDER_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_THUNDER,\n    ACHIEVEMENT_BUY_100_THUNDER,\n    ACHIEVEMENT_SACRIFICE_1_THUNDER,\n    ACHIEVEMENT_SACRIFICE_100_THUNDER,\n];\nexport const ACHIEVEMENT_BUY_1_TORNADO: IAchievement = {\n    id: \"buy:74/1\",\n    name: \"Buy one Tornado\",\n    description: \"You have bought 1 Tornado. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_TORNADO: IAchievement = {\n    id: \"buy:74/100\",\n    name: \"Buy 100 Tornado\",\n    description: \"You have bought 100 Tornado! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_TORNADO: IAchievement = {\n    id: \"sacrifice:74/1\",\n    name: \"Sacrifice one Tornado\",\n    description: \"You have sacrificed 1 Tornado. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_TORNADO: IAchievement = {\n    id: \"sacrifice:74/100\",\n    name: \"Sacrifice 100 Tornado\",\n    description: \"You have sacrificed 100 Tornado! Here, shake my hand!\",\n};\nexport const ITEM_TORNADO_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_TORNADO,\n    ACHIEVEMENT_BUY_100_TORNADO,\n    ACHIEVEMENT_SACRIFICE_1_TORNADO,\n    ACHIEVEMENT_SACRIFICE_100_TORNADO,\n];\nexport const ACHIEVEMENT_BUY_1_GARDEN: IAchievement = {\n    id: \"buy:75/1\",\n    name: \"Buy one Garden\",\n    description: \"You have bought 1 Garden. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_GARDEN: IAchievement = {\n    id: \"buy:75/100\",\n    name: \"Buy 100 Garden\",\n    description: \"You have bought 100 Garden! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_GARDEN: IAchievement = {\n    id: \"sacrifice:75/1\",\n    name: \"Sacrifice one Garden\",\n    description: \"You have sacrificed 1 Garden. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_GARDEN: IAchievement = {\n    id: \"sacrifice:75/100\",\n    name: \"Sacrifice 100 Garden\",\n    description: \"You have sacrificed 100 Garden! Here, shake my hand!\",\n};\nexport const ITEM_GARDEN_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_GARDEN,\n    ACHIEVEMENT_BUY_100_GARDEN,\n    ACHIEVEMENT_SACRIFICE_1_GARDEN,\n    ACHIEVEMENT_SACRIFICE_100_GARDEN,\n];\nexport const ACHIEVEMENT_BUY_1_EMBER: IAchievement = {\n    id: \"buy:76/1\",\n    name: \"Buy one Ember\",\n    description: \"You have bought 1 Ember. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_EMBER: IAchievement = {\n    id: \"buy:76/100\",\n    name: \"Buy 100 Ember\",\n    description: \"You have bought 100 Ember! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_EMBER: IAchievement = {\n    id: \"sacrifice:76/1\",\n    name: \"Sacrifice one Ember\",\n    description: \"You have sacrificed 1 Ember. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_EMBER: IAchievement = {\n    id: \"sacrifice:76/100\",\n    name: \"Sacrifice 100 Ember\",\n    description: \"You have sacrificed 100 Ember! Here, shake my hand!\",\n};\nexport const ITEM_EMBER_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_EMBER,\n    ACHIEVEMENT_BUY_100_EMBER,\n    ACHIEVEMENT_SACRIFICE_1_EMBER,\n    ACHIEVEMENT_SACRIFICE_100_EMBER,\n];\nexport const ACHIEVEMENT_BUY_1_KILN: IAchievement = {\n    id: \"buy:77/1\",\n    name: \"Buy one Kiln\",\n    description: \"You have bought 1 Kiln. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_KILN: IAchievement = {\n    id: \"buy:77/100\",\n    name: \"Buy 100 Kiln\",\n    description: \"You have bought 100 Kiln! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_KILN: IAchievement = {\n    id: \"sacrifice:77/1\",\n    name: \"Sacrifice one Kiln\",\n    description: \"You have sacrificed 1 Kiln. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_KILN: IAchievement = {\n    id: \"sacrifice:77/100\",\n    name: \"Sacrifice 100 Kiln\",\n    description: \"You have sacrificed 100 Kiln! Here, shake my hand!\",\n};\nexport const ITEM_KILN_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_KILN,\n    ACHIEVEMENT_BUY_100_KILN,\n    ACHIEVEMENT_SACRIFICE_1_KILN,\n    ACHIEVEMENT_SACRIFICE_100_KILN,\n];\nexport const ACHIEVEMENT_BUY_1_POLLINATION: IAchievement = {\n    id: \"buy:78/1\",\n    name: \"Buy one Pollination\",\n    description: \"You have bought 1 Pollination. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_POLLINATION: IAchievement = {\n    id: \"buy:78/100\",\n    name: \"Buy 100 Pollination\",\n    description: \"You have bought 100 Pollination! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_POLLINATION: IAchievement = {\n    id: \"sacrifice:78/1\",\n    name: \"Sacrifice one Pollination\",\n    description: \"You have sacrificed 1 Pollination. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_POLLINATION: IAchievement = {\n    id: \"sacrifice:78/100\",\n    name: \"Sacrifice 100 Pollination\",\n    description: \"You have sacrificed 100 Pollination! Here, shake my hand!\",\n};\nexport const ITEM_POLLINATION_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_POLLINATION,\n    ACHIEVEMENT_BUY_100_POLLINATION,\n    ACHIEVEMENT_SACRIFICE_1_POLLINATION,\n    ACHIEVEMENT_SACRIFICE_100_POLLINATION,\n];\nexport const ACHIEVEMENT_BUY_1_SINKHOLE: IAchievement = {\n    id: \"buy:79/1\",\n    name: \"Buy one Sinkhole\",\n    description: \"You have bought 1 Sinkhole. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_SINKHOLE: IAchievement = {\n    id: \"buy:79/100\",\n    name: \"Buy 100 Sinkhole\",\n    description: \"You have bought 100 Sinkhole! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_SINKHOLE: IAchievement = {\n    id: \"sacrifice:79/1\",\n    name: \"Sacrifice one Sinkhole\",\n    description: \"You have sacrificed 1 Sinkhole. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_SINKHOLE: IAchievement = {\n    id: \"sacrifice:79/100\",\n    name: \"Sacrifice 100 Sinkhole\",\n    description: \"You have sacrificed 100 Sinkhole! Here, shake my hand!\",\n};\nexport const ITEM_SINKHOLE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_SINKHOLE,\n    ACHIEVEMENT_BUY_100_SINKHOLE,\n    ACHIEVEMENT_SACRIFICE_1_SINKHOLE,\n    ACHIEVEMENT_SACRIFICE_100_SINKHOLE,\n];\nexport const ACHIEVEMENT_BUY_1_BEACH: IAchievement = {\n    id: \"buy:80/1\",\n    name: \"Buy one Beach\",\n    description: \"You have bought 1 Beach. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_BEACH: IAchievement = {\n    id: \"buy:80/100\",\n    name: \"Buy 100 Beach\",\n    description: \"You have bought 100 Beach! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_BEACH: IAchievement = {\n    id: \"sacrifice:80/1\",\n    name: \"Sacrifice one Beach\",\n    description: \"You have sacrificed 1 Beach. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_BEACH: IAchievement = {\n    id: \"sacrifice:80/100\",\n    name: \"Sacrifice 100 Beach\",\n    description: \"You have sacrificed 100 Beach! Here, shake my hand!\",\n};\nexport const ITEM_BEACH_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_BEACH,\n    ACHIEVEMENT_BUY_100_BEACH,\n    ACHIEVEMENT_SACRIFICE_1_BEACH,\n    ACHIEVEMENT_SACRIFICE_100_BEACH,\n];\nexport const ACHIEVEMENT_BUY_1_WETSTONE: IAchievement = {\n    id: \"buy:81/1\",\n    name: \"Buy one Wetstone\",\n    description: \"You have bought 1 Wetstone. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_WETSTONE: IAchievement = {\n    id: \"buy:81/100\",\n    name: \"Buy 100 Wetstone\",\n    description: \"You have bought 100 Wetstone! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_WETSTONE: IAchievement = {\n    id: \"sacrifice:81/1\",\n    name: \"Sacrifice one Wetstone\",\n    description: \"You have sacrificed 1 Wetstone. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_WETSTONE: IAchievement = {\n    id: \"sacrifice:81/100\",\n    name: \"Sacrifice 100 Wetstone\",\n    description: \"You have sacrificed 100 Wetstone! Here, shake my hand!\",\n};\nexport const ITEM_WETSTONE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_WETSTONE,\n    ACHIEVEMENT_BUY_100_WETSTONE,\n    ACHIEVEMENT_SACRIFICE_1_WETSTONE,\n    ACHIEVEMENT_SACRIFICE_100_WETSTONE,\n];\nexport const ACHIEVEMENT_BUY_1_EROSION: IAchievement = {\n    id: \"buy:82/1\",\n    name: \"Buy one Erosion\",\n    description: \"You have bought 1 Erosion. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_EROSION: IAchievement = {\n    id: \"buy:82/100\",\n    name: \"Buy 100 Erosion\",\n    description: \"You have bought 100 Erosion! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_EROSION: IAchievement = {\n    id: \"sacrifice:82/1\",\n    name: \"Sacrifice one Erosion\",\n    description: \"You have sacrificed 1 Erosion. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_EROSION: IAchievement = {\n    id: \"sacrifice:82/100\",\n    name: \"Sacrifice 100 Erosion\",\n    description: \"You have sacrificed 100 Erosion! Here, shake my hand!\",\n};\nexport const ITEM_EROSION_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_EROSION,\n    ACHIEVEMENT_BUY_100_EROSION,\n    ACHIEVEMENT_SACRIFICE_1_EROSION,\n    ACHIEVEMENT_SACRIFICE_100_EROSION,\n];\nexport const ACHIEVEMENT_BUY_1_BASALT: IAchievement = {\n    id: \"buy:83/1\",\n    name: \"Buy one Basalt\",\n    description: \"You have bought 1 Basalt. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_BASALT: IAchievement = {\n    id: \"buy:83/100\",\n    name: \"Buy 100 Basalt\",\n    description: \"You have bought 100 Basalt! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_BASALT: IAchievement = {\n    id: \"sacrifice:83/1\",\n    name: \"Sacrifice one Basalt\",\n    description: \"You have sacrificed 1 Basalt. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_BASALT: IAchievement = {\n    id: \"sacrifice:83/100\",\n    name: \"Sacrifice 100 Basalt\",\n    description: \"You have sacrificed 100 Basalt! Here, shake my hand!\",\n};\nexport const ITEM_BASALT_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_BASALT,\n    ACHIEVEMENT_BUY_100_BASALT,\n    ACHIEVEMENT_SACRIFICE_1_BASALT,\n    ACHIEVEMENT_SACRIFICE_100_BASALT,\n];\nexport const ACHIEVEMENT_BUY_1_MAGMA_CHAMBER: IAchievement = {\n    id: \"buy:84/1\",\n    name: \"Buy one Magma Chamber\",\n    description: \"You have bought 1 Magma Chamber. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_MAGMA_CHAMBER: IAchievement = {\n    id: \"buy:84/100\",\n    name: \"Buy 100 Magma Chamber\",\n    description: \"You have bought 100 Magma Chamber! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_MAGMA_CHAMBER: IAchievement = {\n    id: \"sacrifice:84/1\",\n    name: \"Sacrifice one Magma Chamber\",\n    description: \"You have sacrificed 1 Magma Chamber. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_MAGMA_CHAMBER: IAchievement = {\n    id: \"sacrifice:84/100\",\n    name: \"Sacrifice 100 Magma Chamber\",\n    description: \"You have sacrificed 100 Magma Chamber! Here, shake my hand!\",\n};\nexport const ITEM_MAGMA_CHAMBER_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_MAGMA_CHAMBER,\n    ACHIEVEMENT_BUY_100_MAGMA_CHAMBER,\n    ACHIEVEMENT_SACRIFICE_1_MAGMA_CHAMBER,\n    ACHIEVEMENT_SACRIFICE_100_MAGMA_CHAMBER,\n];\nexport const ACHIEVEMENT_BUY_1_BREEZE: IAchievement = {\n    id: \"buy:85/1\",\n    name: \"Buy one Breeze\",\n    description: \"You have bought 1 Breeze. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_BREEZE: IAchievement = {\n    id: \"buy:85/100\",\n    name: \"Buy 100 Breeze\",\n    description: \"You have bought 100 Breeze! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_BREEZE: IAchievement = {\n    id: \"sacrifice:85/1\",\n    name: \"Sacrifice one Breeze\",\n    description: \"You have sacrificed 1 Breeze. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_BREEZE: IAchievement = {\n    id: \"sacrifice:85/100\",\n    name: \"Sacrifice 100 Breeze\",\n    description: \"You have sacrificed 100 Breeze! Here, shake my hand!\",\n};\nexport const ITEM_BREEZE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_BREEZE,\n    ACHIEVEMENT_BUY_100_BREEZE,\n    ACHIEVEMENT_SACRIFICE_1_BREEZE,\n    ACHIEVEMENT_SACRIFICE_100_BREEZE,\n];\nexport const ACHIEVEMENT_BUY_1_WARM_BREEZE: IAchievement = {\n    id: \"buy:86/1\",\n    name: \"Buy one Warm Breeze\",\n    description: \"You have bought 1 Warm Breeze. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_WARM_BREEZE: IAchievement = {\n    id: \"buy:86/100\",\n    name: \"Buy 100 Warm Breeze\",\n    description: \"You have bought 100 Warm Breeze! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_WARM_BREEZE: IAchievement = {\n    id: \"sacrifice:86/1\",\n    name: \"Sacrifice one Warm Breeze\",\n    description: \"You have sacrificed 1 Warm Breeze. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_WARM_BREEZE: IAchievement = {\n    id: \"sacrifice:86/100\",\n    name: \"Sacrifice 100 Warm Breeze\",\n    description: \"You have sacrificed 100 Warm Breeze! Here, shake my hand!\",\n};\nexport const ITEM_WARM_BREEZE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_WARM_BREEZE,\n    ACHIEVEMENT_BUY_100_WARM_BREEZE,\n    ACHIEVEMENT_SACRIFICE_1_WARM_BREEZE,\n    ACHIEVEMENT_SACRIFICE_100_WARM_BREEZE,\n];\nexport const ACHIEVEMENT_BUY_1_SOIL: IAchievement = {\n    id: \"buy:87/1\",\n    name: \"Buy one Soil\",\n    description: \"You have bought 1 Soil. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_SOIL: IAchievement = {\n    id: \"buy:87/100\",\n    name: \"Buy 100 Soil\",\n    description: \"You have bought 100 Soil! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_SOIL: IAchievement = {\n    id: \"sacrifice:87/1\",\n    name: \"Sacrifice one Soil\",\n    description: \"You have sacrificed 1 Soil. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_SOIL: IAchievement = {\n    id: \"sacrifice:87/100\",\n    name: \"Sacrifice 100 Soil\",\n    description: \"You have sacrificed 100 Soil! Here, shake my hand!\",\n};\nexport const ITEM_SOIL_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_SOIL,\n    ACHIEVEMENT_BUY_100_SOIL,\n    ACHIEVEMENT_SACRIFICE_1_SOIL,\n    ACHIEVEMENT_SACRIFICE_100_SOIL,\n];\nexport const ACHIEVEMENT_BUY_1_CANYON: IAchievement = {\n    id: \"buy:88/1\",\n    name: \"Buy one Canyon\",\n    description: \"You have bought 1 Canyon. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_CANYON: IAchievement = {\n    id: \"buy:88/100\",\n    name: \"Buy 100 Canyon\",\n    description: \"You have bought 100 Canyon! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_CANYON: IAchievement = {\n    id: \"sacrifice:88/1\",\n    name: \"Sacrifice one Canyon\",\n    description: \"You have sacrificed 1 Canyon. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_CANYON: IAchievement = {\n    id: \"sacrifice:88/100\",\n    name: \"Sacrifice 100 Canyon\",\n    description: \"You have sacrificed 100 Canyon! Here, shake my hand!\",\n};\nexport const ITEM_CANYON_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_CANYON,\n    ACHIEVEMENT_BUY_100_CANYON,\n    ACHIEVEMENT_SACRIFICE_1_CANYON,\n    ACHIEVEMENT_SACRIFICE_100_CANYON,\n];\nexport const ACHIEVEMENT_BUY_1_WINDMILL: IAchievement = {\n    id: \"buy:89/1\",\n    name: \"Buy one Windmill\",\n    description: \"You have bought 1 Windmill. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_WINDMILL: IAchievement = {\n    id: \"buy:89/100\",\n    name: \"Buy 100 Windmill\",\n    description: \"You have bought 100 Windmill! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_WINDMILL: IAchievement = {\n    id: \"sacrifice:89/1\",\n    name: \"Sacrifice one Windmill\",\n    description: \"You have sacrificed 1 Windmill. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_WINDMILL: IAchievement = {\n    id: \"sacrifice:89/100\",\n    name: \"Sacrifice 100 Windmill\",\n    description: \"You have sacrificed 100 Windmill! Here, shake my hand!\",\n};\nexport const ITEM_WINDMILL_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_WINDMILL,\n    ACHIEVEMENT_BUY_100_WINDMILL,\n    ACHIEVEMENT_SACRIFICE_1_WINDMILL,\n    ACHIEVEMENT_SACRIFICE_100_WINDMILL,\n];\nexport const ACHIEVEMENT_BUY_1_ADOBE: IAchievement = {\n    id: \"buy:90/1\",\n    name: \"Buy one Adobe\",\n    description: \"You have bought 1 Adobe. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_ADOBE: IAchievement = {\n    id: \"buy:90/100\",\n    name: \"Buy 100 Adobe\",\n    description: \"You have bought 100 Adobe! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_ADOBE: IAchievement = {\n    id: \"sacrifice:90/1\",\n    name: \"Sacrifice one Adobe\",\n    description: \"You have sacrificed 1 Adobe. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_ADOBE: IAchievement = {\n    id: \"sacrifice:90/100\",\n    name: \"Sacrifice 100 Adobe\",\n    description: \"You have sacrificed 100 Adobe! Here, shake my hand!\",\n};\nexport const ITEM_ADOBE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_ADOBE,\n    ACHIEVEMENT_BUY_100_ADOBE,\n    ACHIEVEMENT_SACRIFICE_1_ADOBE,\n    ACHIEVEMENT_SACRIFICE_100_ADOBE,\n];\nexport const ACHIEVEMENT_BUY_1_WALL: IAchievement = {\n    id: \"buy:91/1\",\n    name: \"Buy one Wall\",\n    description: \"You have bought 1 Wall. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_WALL: IAchievement = {\n    id: \"buy:91/100\",\n    name: \"Buy 100 Wall\",\n    description: \"You have bought 100 Wall! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_WALL: IAchievement = {\n    id: \"sacrifice:91/1\",\n    name: \"Sacrifice one Wall\",\n    description: \"You have sacrificed 1 Wall. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_WALL: IAchievement = {\n    id: \"sacrifice:91/100\",\n    name: \"Sacrifice 100 Wall\",\n    description: \"You have sacrificed 100 Wall! Here, shake my hand!\",\n};\nexport const ITEM_WALL_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_WALL,\n    ACHIEVEMENT_BUY_100_WALL,\n    ACHIEVEMENT_SACRIFICE_1_WALL,\n    ACHIEVEMENT_SACRIFICE_100_WALL,\n];\nexport const ACHIEVEMENT_BUY_1_PUMICE: IAchievement = {\n    id: \"buy:92/1\",\n    name: \"Buy one Pumice\",\n    description: \"You have bought 1 Pumice. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_PUMICE: IAchievement = {\n    id: \"buy:92/100\",\n    name: \"Buy 100 Pumice\",\n    description: \"You have bought 100 Pumice! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_PUMICE: IAchievement = {\n    id: \"sacrifice:92/1\",\n    name: \"Sacrifice one Pumice\",\n    description: \"You have sacrificed 1 Pumice. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_PUMICE: IAchievement = {\n    id: \"sacrifice:92/100\",\n    name: \"Sacrifice 100 Pumice\",\n    description: \"You have sacrificed 100 Pumice! Here, shake my hand!\",\n};\nexport const ITEM_PUMICE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_PUMICE,\n    ACHIEVEMENT_BUY_100_PUMICE,\n    ACHIEVEMENT_SACRIFICE_1_PUMICE,\n    ACHIEVEMENT_SACRIFICE_100_PUMICE,\n];\nexport const ACHIEVEMENT_BUY_1_BARBECUE: IAchievement = {\n    id: \"buy:93/1\",\n    name: \"Buy one Barbecue\",\n    description: \"You have bought 1 Barbecue. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_BARBECUE: IAchievement = {\n    id: \"buy:93/100\",\n    name: \"Buy 100 Barbecue\",\n    description: \"You have bought 100 Barbecue! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_BARBECUE: IAchievement = {\n    id: \"sacrifice:93/1\",\n    name: \"Sacrifice one Barbecue\",\n    description: \"You have sacrificed 1 Barbecue. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_BARBECUE: IAchievement = {\n    id: \"sacrifice:93/100\",\n    name: \"Sacrifice 100 Barbecue\",\n    description: \"You have sacrificed 100 Barbecue! Here, shake my hand!\",\n};\nexport const ITEM_BARBECUE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_BARBECUE,\n    ACHIEVEMENT_BUY_100_BARBECUE,\n    ACHIEVEMENT_SACRIFICE_1_BARBECUE,\n    ACHIEVEMENT_SACRIFICE_100_BARBECUE,\n];\nexport const ACHIEVEMENT_BUY_1_FARM: IAchievement = {\n    id: \"buy:94/1\",\n    name: \"Buy one Farm\",\n    description: \"You have bought 1 Farm. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_FARM: IAchievement = {\n    id: \"buy:94/100\",\n    name: \"Buy 100 Farm\",\n    description: \"You have bought 100 Farm! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_FARM: IAchievement = {\n    id: \"sacrifice:94/1\",\n    name: \"Sacrifice one Farm\",\n    description: \"You have sacrificed 1 Farm. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_FARM: IAchievement = {\n    id: \"sacrifice:94/100\",\n    name: \"Sacrifice 100 Farm\",\n    description: \"You have sacrificed 100 Farm! Here, shake my hand!\",\n};\nexport const ITEM_FARM_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_FARM,\n    ACHIEVEMENT_BUY_100_FARM,\n    ACHIEVEMENT_SACRIFICE_1_FARM,\n    ACHIEVEMENT_SACRIFICE_100_FARM,\n];\nexport const ACHIEVEMENT_BUY_1_SHARDS: IAchievement = {\n    id: \"buy:95/1\",\n    name: \"Buy one Shards\",\n    description: \"You have bought 1 Shards. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_SHARDS: IAchievement = {\n    id: \"buy:95/100\",\n    name: \"Buy 100 Shards\",\n    description: \"You have bought 100 Shards! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_SHARDS: IAchievement = {\n    id: \"sacrifice:95/1\",\n    name: \"Sacrifice one Shards\",\n    description: \"You have sacrificed 1 Shards. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_SHARDS: IAchievement = {\n    id: \"sacrifice:95/100\",\n    name: \"Sacrifice 100 Shards\",\n    description: \"You have sacrificed 100 Shards! Here, shake my hand!\",\n};\nexport const ITEM_SHARDS_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_SHARDS,\n    ACHIEVEMENT_BUY_100_SHARDS,\n    ACHIEVEMENT_SACRIFICE_1_SHARDS,\n    ACHIEVEMENT_SACRIFICE_100_SHARDS,\n];\nexport const ACHIEVEMENT_BUY_1_MOLTEN_GLASS: IAchievement = {\n    id: \"buy:96/1\",\n    name: \"Buy one Molten Glass\",\n    description: \"You have bought 1 Molten Glass. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_MOLTEN_GLASS: IAchievement = {\n    id: \"buy:96/100\",\n    name: \"Buy 100 Molten Glass\",\n    description: \"You have bought 100 Molten Glass! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_MOLTEN_GLASS: IAchievement = {\n    id: \"sacrifice:96/1\",\n    name: \"Sacrifice one Molten Glass\",\n    description: \"You have sacrificed 1 Molten Glass. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_MOLTEN_GLASS: IAchievement = {\n    id: \"sacrifice:96/100\",\n    name: \"Sacrifice 100 Molten Glass\",\n    description: \"You have sacrificed 100 Molten Glass! Here, shake my hand!\",\n};\nexport const ITEM_MOLTEN_GLASS_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_MOLTEN_GLASS,\n    ACHIEVEMENT_BUY_100_MOLTEN_GLASS,\n    ACHIEVEMENT_SACRIFICE_1_MOLTEN_GLASS,\n    ACHIEVEMENT_SACRIFICE_100_MOLTEN_GLASS,\n];\nexport const ACHIEVEMENT_BUY_1_PRISM: IAchievement = {\n    id: \"buy:97/1\",\n    name: \"Buy one Prism\",\n    description: \"You have bought 1 Prism. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_PRISM: IAchievement = {\n    id: \"buy:97/100\",\n    name: \"Buy 100 Prism\",\n    description: \"You have bought 100 Prism! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_PRISM: IAchievement = {\n    id: \"sacrifice:97/1\",\n    name: \"Sacrifice one Prism\",\n    description: \"You have sacrificed 1 Prism. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_PRISM: IAchievement = {\n    id: \"sacrifice:97/100\",\n    name: \"Sacrifice 100 Prism\",\n    description: \"You have sacrificed 100 Prism! Here, shake my hand!\",\n};\nexport const ITEM_PRISM_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_PRISM,\n    ACHIEVEMENT_BUY_100_PRISM,\n    ACHIEVEMENT_SACRIFICE_1_PRISM,\n    ACHIEVEMENT_SACRIFICE_100_PRISM,\n];\nexport const ACHIEVEMENT_BUY_1_SPARKLE: IAchievement = {\n    id: \"buy:98/1\",\n    name: \"Buy one Sparkle\",\n    description: \"You have bought 1 Sparkle. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_SPARKLE: IAchievement = {\n    id: \"buy:98/100\",\n    name: \"Buy 100 Sparkle\",\n    description: \"You have bought 100 Sparkle! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_SPARKLE: IAchievement = {\n    id: \"sacrifice:98/1\",\n    name: \"Sacrifice one Sparkle\",\n    description: \"You have sacrificed 1 Sparkle. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_SPARKLE: IAchievement = {\n    id: \"sacrifice:98/100\",\n    name: \"Sacrifice 100 Sparkle\",\n    description: \"You have sacrificed 100 Sparkle! Here, shake my hand!\",\n};\nexport const ITEM_SPARKLE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_SPARKLE,\n    ACHIEVEMENT_BUY_100_SPARKLE,\n    ACHIEVEMENT_SACRIFICE_1_SPARKLE,\n    ACHIEVEMENT_SACRIFICE_100_SPARKLE,\n];\nexport const ACHIEVEMENT_BUY_1_DESERT: IAchievement = {\n    id: \"buy:99/1\",\n    name: \"Buy one Desert\",\n    description: \"You have bought 1 Desert. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_DESERT: IAchievement = {\n    id: \"buy:99/100\",\n    name: \"Buy 100 Desert\",\n    description: \"You have bought 100 Desert! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_DESERT: IAchievement = {\n    id: \"sacrifice:99/1\",\n    name: \"Sacrifice one Desert\",\n    description: \"You have sacrificed 1 Desert. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_DESERT: IAchievement = {\n    id: \"sacrifice:99/100\",\n    name: \"Sacrifice 100 Desert\",\n    description: \"You have sacrificed 100 Desert! Here, shake my hand!\",\n};\nexport const ITEM_DESERT_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_DESERT,\n    ACHIEVEMENT_BUY_100_DESERT,\n    ACHIEVEMENT_SACRIFICE_1_DESERT,\n    ACHIEVEMENT_SACRIFICE_100_DESERT,\n];\nexport const ACHIEVEMENT_BUY_1_OASIS: IAchievement = {\n    id: \"buy:100/1\",\n    name: \"Buy one Oasis\",\n    description: \"You have bought 1 Oasis. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_OASIS: IAchievement = {\n    id: \"buy:100/100\",\n    name: \"Buy 100 Oasis\",\n    description: \"You have bought 100 Oasis! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_OASIS: IAchievement = {\n    id: \"sacrifice:100/1\",\n    name: \"Sacrifice one Oasis\",\n    description: \"You have sacrificed 1 Oasis. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_OASIS: IAchievement = {\n    id: \"sacrifice:100/100\",\n    name: \"Sacrifice 100 Oasis\",\n    description: \"You have sacrificed 100 Oasis! Here, shake my hand!\",\n};\nexport const ITEM_OASIS_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_OASIS,\n    ACHIEVEMENT_BUY_100_OASIS,\n    ACHIEVEMENT_SACRIFICE_1_OASIS,\n    ACHIEVEMENT_SACRIFICE_100_OASIS,\n];\nexport const ACHIEVEMENT_BUY_1_MIRAGE: IAchievement = {\n    id: \"buy:101/1\",\n    name: \"Buy one Mirage\",\n    description: \"You have bought 1 Mirage. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_MIRAGE: IAchievement = {\n    id: \"buy:101/100\",\n    name: \"Buy 100 Mirage\",\n    description: \"You have bought 100 Mirage! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_MIRAGE: IAchievement = {\n    id: \"sacrifice:101/1\",\n    name: \"Sacrifice one Mirage\",\n    description: \"You have sacrificed 1 Mirage. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_MIRAGE: IAchievement = {\n    id: \"sacrifice:101/100\",\n    name: \"Sacrifice 100 Mirage\",\n    description: \"You have sacrificed 100 Mirage! Here, shake my hand!\",\n};\nexport const ITEM_MIRAGE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_MIRAGE,\n    ACHIEVEMENT_BUY_100_MIRAGE,\n    ACHIEVEMENT_SACRIFICE_1_MIRAGE,\n    ACHIEVEMENT_SACRIFICE_100_MIRAGE,\n];\nexport const ACHIEVEMENT_BUY_1_SAND_DUNE: IAchievement = {\n    id: \"buy:102/1\",\n    name: \"Buy one Sand Dune\",\n    description: \"You have bought 1 Sand Dune. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_SAND_DUNE: IAchievement = {\n    id: \"buy:102/100\",\n    name: \"Buy 100 Sand Dune\",\n    description: \"You have bought 100 Sand Dune! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_SAND_DUNE: IAchievement = {\n    id: \"sacrifice:102/1\",\n    name: \"Sacrifice one Sand Dune\",\n    description: \"You have sacrificed 1 Sand Dune. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_SAND_DUNE: IAchievement = {\n    id: \"sacrifice:102/100\",\n    name: \"Sacrifice 100 Sand Dune\",\n    description: \"You have sacrificed 100 Sand Dune! Here, shake my hand!\",\n};\nexport const ITEM_SAND_DUNE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_SAND_DUNE,\n    ACHIEVEMENT_BUY_100_SAND_DUNE,\n    ACHIEVEMENT_SACRIFICE_1_SAND_DUNE,\n    ACHIEVEMENT_SACRIFICE_100_SAND_DUNE,\n];\nexport const ACHIEVEMENT_BUY_1_DAM: IAchievement = {\n    id: \"buy:103/1\",\n    name: \"Buy one Dam\",\n    description: \"You have bought 1 Dam. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_DAM: IAchievement = {\n    id: \"buy:103/100\",\n    name: \"Buy 100 Dam\",\n    description: \"You have bought 100 Dam! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_DAM: IAchievement = {\n    id: \"sacrifice:103/1\",\n    name: \"Sacrifice one Dam\",\n    description: \"You have sacrificed 1 Dam. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_DAM: IAchievement = {\n    id: \"sacrifice:103/100\",\n    name: \"Sacrifice 100 Dam\",\n    description: \"You have sacrificed 100 Dam! Here, shake my hand!\",\n};\nexport const ITEM_DAM_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_DAM,\n    ACHIEVEMENT_BUY_100_DAM,\n    ACHIEVEMENT_SACRIFICE_1_DAM,\n    ACHIEVEMENT_SACRIFICE_100_DAM,\n];\nexport const ACHIEVEMENT_BUY_1_FIREWALL: IAchievement = {\n    id: \"buy:104/1\",\n    name: \"Buy one Firewall\",\n    description: \"You have bought 1 Firewall. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_FIREWALL: IAchievement = {\n    id: \"buy:104/100\",\n    name: \"Buy 100 Firewall\",\n    description: \"You have bought 100 Firewall! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_FIREWALL: IAchievement = {\n    id: \"sacrifice:104/1\",\n    name: \"Sacrifice one Firewall\",\n    description: \"You have sacrificed 1 Firewall. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_FIREWALL: IAchievement = {\n    id: \"sacrifice:104/100\",\n    name: \"Sacrifice 100 Firewall\",\n    description: \"You have sacrificed 100 Firewall! Here, shake my hand!\",\n};\nexport const ITEM_FIREWALL_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_FIREWALL,\n    ACHIEVEMENT_BUY_100_FIREWALL,\n    ACHIEVEMENT_SACRIFICE_1_FIREWALL,\n    ACHIEVEMENT_SACRIFICE_100_FIREWALL,\n];\nexport const ACHIEVEMENT_BUY_1_BARRICADE: IAchievement = {\n    id: \"buy:105/1\",\n    name: \"Buy one Barricade\",\n    description: \"You have bought 1 Barricade. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_BARRICADE: IAchievement = {\n    id: \"buy:105/100\",\n    name: \"Buy 100 Barricade\",\n    description: \"You have bought 100 Barricade! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_BARRICADE: IAchievement = {\n    id: \"sacrifice:105/1\",\n    name: \"Sacrifice one Barricade\",\n    description: \"You have sacrificed 1 Barricade. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_BARRICADE: IAchievement = {\n    id: \"sacrifice:105/100\",\n    name: \"Sacrifice 100 Barricade\",\n    description: \"You have sacrificed 100 Barricade! Here, shake my hand!\",\n};\nexport const ITEM_BARRICADE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_BARRICADE,\n    ACHIEVEMENT_BUY_100_BARRICADE,\n    ACHIEVEMENT_SACRIFICE_1_BARRICADE,\n    ACHIEVEMENT_SACRIFICE_100_BARRICADE,\n];\nexport const ACHIEVEMENT_BUY_1_PLATEAU: IAchievement = {\n    id: \"buy:106/1\",\n    name: \"Buy one Plateau\",\n    description: \"You have bought 1 Plateau. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_PLATEAU: IAchievement = {\n    id: \"buy:106/100\",\n    name: \"Buy 100 Plateau\",\n    description: \"You have bought 100 Plateau! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_PLATEAU: IAchievement = {\n    id: \"sacrifice:106/1\",\n    name: \"Sacrifice one Plateau\",\n    description: \"You have sacrificed 1 Plateau. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_PLATEAU: IAchievement = {\n    id: \"sacrifice:106/100\",\n    name: \"Sacrifice 100 Plateau\",\n    description: \"You have sacrificed 100 Plateau! Here, shake my hand!\",\n};\nexport const ITEM_PLATEAU_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_PLATEAU,\n    ACHIEVEMENT_BUY_100_PLATEAU,\n    ACHIEVEMENT_SACRIFICE_1_PLATEAU,\n    ACHIEVEMENT_SACRIFICE_100_PLATEAU,\n];\nexport const ACHIEVEMENT_BUY_1_POND: IAchievement = {\n    id: \"buy:107/1\",\n    name: \"Buy one Pond\",\n    description: \"You have bought 1 Pond. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_POND: IAchievement = {\n    id: \"buy:107/100\",\n    name: \"Buy 100 Pond\",\n    description: \"You have bought 100 Pond! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_POND: IAchievement = {\n    id: \"sacrifice:107/1\",\n    name: \"Sacrifice one Pond\",\n    description: \"You have sacrificed 1 Pond. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_POND: IAchievement = {\n    id: \"sacrifice:107/100\",\n    name: \"Sacrifice 100 Pond\",\n    description: \"You have sacrificed 100 Pond! Here, shake my hand!\",\n};\nexport const ITEM_POND_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_POND,\n    ACHIEVEMENT_BUY_100_POND,\n    ACHIEVEMENT_SACRIFICE_1_POND,\n    ACHIEVEMENT_SACRIFICE_100_POND,\n];\nexport const ACHIEVEMENT_BUY_1_AROMAS: IAchievement = {\n    id: \"buy:108/1\",\n    name: \"Buy one Aromas\",\n    description: \"You have bought 1 Aromas. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_AROMAS: IAchievement = {\n    id: \"buy:108/100\",\n    name: \"Buy 100 Aromas\",\n    description: \"You have bought 100 Aromas! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_AROMAS: IAchievement = {\n    id: \"sacrifice:108/1\",\n    name: \"Sacrifice one Aromas\",\n    description: \"You have sacrificed 1 Aromas. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_AROMAS: IAchievement = {\n    id: \"sacrifice:108/100\",\n    name: \"Sacrifice 100 Aromas\",\n    description: \"You have sacrificed 100 Aromas! Here, shake my hand!\",\n};\nexport const ITEM_AROMAS_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_AROMAS,\n    ACHIEVEMENT_BUY_100_AROMAS,\n    ACHIEVEMENT_SACRIFICE_1_AROMAS,\n    ACHIEVEMENT_SACRIFICE_100_AROMAS,\n];\nexport const ACHIEVEMENT_BUY_1_FLOWER: IAchievement = {\n    id: \"buy:109/1\",\n    name: \"Buy one Flower\",\n    description: \"You have bought 1 Flower. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_FLOWER: IAchievement = {\n    id: \"buy:109/100\",\n    name: \"Buy 100 Flower\",\n    description: \"You have bought 100 Flower! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_FLOWER: IAchievement = {\n    id: \"sacrifice:109/1\",\n    name: \"Sacrifice one Flower\",\n    description: \"You have sacrificed 1 Flower. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_FLOWER: IAchievement = {\n    id: \"sacrifice:109/100\",\n    name: \"Sacrifice 100 Flower\",\n    description: \"You have sacrificed 100 Flower! Here, shake my hand!\",\n};\nexport const ITEM_FLOWER_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_FLOWER,\n    ACHIEVEMENT_BUY_100_FLOWER,\n    ACHIEVEMENT_SACRIFICE_1_FLOWER,\n    ACHIEVEMENT_SACRIFICE_100_FLOWER,\n];\nexport const ACHIEVEMENT_BUY_1_SPORE: IAchievement = {\n    id: \"buy:110/1\",\n    name: \"Buy one Spore\",\n    description: \"You have bought 1 Spore. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_SPORE: IAchievement = {\n    id: \"buy:110/100\",\n    name: \"Buy 100 Spore\",\n    description: \"You have bought 100 Spore! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_SPORE: IAchievement = {\n    id: \"sacrifice:110/1\",\n    name: \"Sacrifice one Spore\",\n    description: \"You have sacrificed 1 Spore. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_SPORE: IAchievement = {\n    id: \"sacrifice:110/100\",\n    name: \"Sacrifice 100 Spore\",\n    description: \"You have sacrificed 100 Spore! Here, shake my hand!\",\n};\nexport const ITEM_SPORE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_SPORE,\n    ACHIEVEMENT_BUY_100_SPORE,\n    ACHIEVEMENT_SACRIFICE_1_SPORE,\n    ACHIEVEMENT_SACRIFICE_100_SPORE,\n];\nexport const ACHIEVEMENT_BUY_1_SPREAD: IAchievement = {\n    id: \"buy:111/1\",\n    name: \"Buy one Spread\",\n    description: \"You have bought 1 Spread. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_SPREAD: IAchievement = {\n    id: \"buy:111/100\",\n    name: \"Buy 100 Spread\",\n    description: \"You have bought 100 Spread! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_SPREAD: IAchievement = {\n    id: \"sacrifice:111/1\",\n    name: \"Sacrifice one Spread\",\n    description: \"You have sacrificed 1 Spread. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_SPREAD: IAchievement = {\n    id: \"sacrifice:111/100\",\n    name: \"Sacrifice 100 Spread\",\n    description: \"You have sacrificed 100 Spread! Here, shake my hand!\",\n};\nexport const ITEM_SPREAD_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_SPREAD,\n    ACHIEVEMENT_BUY_100_SPREAD,\n    ACHIEVEMENT_SACRIFICE_1_SPREAD,\n    ACHIEVEMENT_SACRIFICE_100_SPREAD,\n];\nexport const ACHIEVEMENT_BUY_1_FERTILE_LAND: IAchievement = {\n    id: \"buy:112/1\",\n    name: \"Buy one Fertile Land\",\n    description: \"You have bought 1 Fertile Land. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_FERTILE_LAND: IAchievement = {\n    id: \"buy:112/100\",\n    name: \"Buy 100 Fertile Land\",\n    description: \"You have bought 100 Fertile Land! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_FERTILE_LAND: IAchievement = {\n    id: \"sacrifice:112/1\",\n    name: \"Sacrifice one Fertile Land\",\n    description: \"You have sacrificed 1 Fertile Land. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_FERTILE_LAND: IAchievement = {\n    id: \"sacrifice:112/100\",\n    name: \"Sacrifice 100 Fertile Land\",\n    description: \"You have sacrificed 100 Fertile Land! Here, shake my hand!\",\n};\nexport const ITEM_FERTILE_LAND_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_FERTILE_LAND,\n    ACHIEVEMENT_BUY_100_FERTILE_LAND,\n    ACHIEVEMENT_SACRIFICE_1_FERTILE_LAND,\n    ACHIEVEMENT_SACRIFICE_100_FERTILE_LAND,\n];\nexport const ACHIEVEMENT_BUY_1_WETLAND: IAchievement = {\n    id: \"buy:113/1\",\n    name: \"Buy one Wetland\",\n    description: \"You have bought 1 Wetland. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_WETLAND: IAchievement = {\n    id: \"buy:113/100\",\n    name: \"Buy 100 Wetland\",\n    description: \"You have bought 100 Wetland! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_WETLAND: IAchievement = {\n    id: \"sacrifice:113/1\",\n    name: \"Sacrifice one Wetland\",\n    description: \"You have sacrificed 1 Wetland. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_WETLAND: IAchievement = {\n    id: \"sacrifice:113/100\",\n    name: \"Sacrifice 100 Wetland\",\n    description: \"You have sacrificed 100 Wetland! Here, shake my hand!\",\n};\nexport const ITEM_WETLAND_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_WETLAND,\n    ACHIEVEMENT_BUY_100_WETLAND,\n    ACHIEVEMENT_SACRIFICE_1_WETLAND,\n    ACHIEVEMENT_SACRIFICE_100_WETLAND,\n];\nexport const ACHIEVEMENT_BUY_1_PEAT: IAchievement = {\n    id: \"buy:114/1\",\n    name: \"Buy one Peat\",\n    description: \"You have bought 1 Peat. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_PEAT: IAchievement = {\n    id: \"buy:114/100\",\n    name: \"Buy 100 Peat\",\n    description: \"You have bought 100 Peat! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_PEAT: IAchievement = {\n    id: \"sacrifice:114/1\",\n    name: \"Sacrifice one Peat\",\n    description: \"You have sacrificed 1 Peat. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_PEAT: IAchievement = {\n    id: \"sacrifice:114/100\",\n    name: \"Sacrifice 100 Peat\",\n    description: \"You have sacrificed 100 Peat! Here, shake my hand!\",\n};\nexport const ITEM_PEAT_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_PEAT,\n    ACHIEVEMENT_BUY_100_PEAT,\n    ACHIEVEMENT_SACRIFICE_1_PEAT,\n    ACHIEVEMENT_SACRIFICE_100_PEAT,\n];\nexport const ACHIEVEMENT_BUY_1_REEDS: IAchievement = {\n    id: \"buy:115/1\",\n    name: \"Buy one Reeds\",\n    description: \"You have bought 1 Reeds. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_REEDS: IAchievement = {\n    id: \"buy:115/100\",\n    name: \"Buy 100 Reeds\",\n    description: \"You have bought 100 Reeds! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_REEDS: IAchievement = {\n    id: \"sacrifice:115/1\",\n    name: \"Sacrifice one Reeds\",\n    description: \"You have sacrificed 1 Reeds. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_REEDS: IAchievement = {\n    id: \"sacrifice:115/100\",\n    name: \"Sacrifice 100 Reeds\",\n    description: \"You have sacrificed 100 Reeds! Here, shake my hand!\",\n};\nexport const ITEM_REEDS_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_REEDS,\n    ACHIEVEMENT_BUY_100_REEDS,\n    ACHIEVEMENT_SACRIFICE_1_REEDS,\n    ACHIEVEMENT_SACRIFICE_100_REEDS,\n];\nexport const ACHIEVEMENT_BUY_1_VALLEY: IAchievement = {\n    id: \"buy:116/1\",\n    name: \"Buy one Valley\",\n    description: \"You have bought 1 Valley. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_VALLEY: IAchievement = {\n    id: \"buy:116/100\",\n    name: \"Buy 100 Valley\",\n    description: \"You have bought 100 Valley! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_VALLEY: IAchievement = {\n    id: \"sacrifice:116/1\",\n    name: \"Sacrifice one Valley\",\n    description: \"You have sacrificed 1 Valley. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_VALLEY: IAchievement = {\n    id: \"sacrifice:116/100\",\n    name: \"Sacrifice 100 Valley\",\n    description: \"You have sacrificed 100 Valley! Here, shake my hand!\",\n};\nexport const ITEM_VALLEY_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_VALLEY,\n    ACHIEVEMENT_BUY_100_VALLEY,\n    ACHIEVEMENT_SACRIFICE_1_VALLEY,\n    ACHIEVEMENT_SACRIFICE_100_VALLEY,\n];\nexport const ACHIEVEMENT_BUY_1_RIVER: IAchievement = {\n    id: \"buy:117/1\",\n    name: \"Buy one River\",\n    description: \"You have bought 1 River. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_RIVER: IAchievement = {\n    id: \"buy:117/100\",\n    name: \"Buy 100 River\",\n    description: \"You have bought 100 River! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_RIVER: IAchievement = {\n    id: \"sacrifice:117/1\",\n    name: \"Sacrifice one River\",\n    description: \"You have sacrificed 1 River. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_RIVER: IAchievement = {\n    id: \"sacrifice:117/100\",\n    name: \"Sacrifice 100 River\",\n    description: \"You have sacrificed 100 River! Here, shake my hand!\",\n};\nexport const ITEM_RIVER_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_RIVER,\n    ACHIEVEMENT_BUY_100_RIVER,\n    ACHIEVEMENT_SACRIFICE_1_RIVER,\n    ACHIEVEMENT_SACRIFICE_100_RIVER,\n];\nexport const ACHIEVEMENT_BUY_1_SCORCHED_EARTH: IAchievement = {\n    id: \"buy:118/1\",\n    name: \"Buy one Scorched Earth\",\n    description: \"You have bought 1 Scorched Earth. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_SCORCHED_EARTH: IAchievement = {\n    id: \"buy:118/100\",\n    name: \"Buy 100 Scorched Earth\",\n    description: \"You have bought 100 Scorched Earth! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_SCORCHED_EARTH: IAchievement = {\n    id: \"sacrifice:118/1\",\n    name: \"Sacrifice one Scorched Earth\",\n    description: \"You have sacrificed 1 Scorched Earth. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_SCORCHED_EARTH: IAchievement = {\n    id: \"sacrifice:118/100\",\n    name: \"Sacrifice 100 Scorched Earth\",\n    description: \"You have sacrificed 100 Scorched Earth! Here, shake my hand!\",\n};\nexport const ITEM_SCORCHED_EARTH_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_SCORCHED_EARTH,\n    ACHIEVEMENT_BUY_100_SCORCHED_EARTH,\n    ACHIEVEMENT_SACRIFICE_1_SCORCHED_EARTH,\n    ACHIEVEMENT_SACRIFICE_100_SCORCHED_EARTH,\n];\nexport const ACHIEVEMENT_BUY_1_DELTA: IAchievement = {\n    id: \"buy:119/1\",\n    name: \"Buy one Delta\",\n    description: \"You have bought 1 Delta. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_DELTA: IAchievement = {\n    id: \"buy:119/100\",\n    name: \"Buy 100 Delta\",\n    description: \"You have bought 100 Delta! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_DELTA: IAchievement = {\n    id: \"sacrifice:119/1\",\n    name: \"Sacrifice one Delta\",\n    description: \"You have sacrificed 1 Delta. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_DELTA: IAchievement = {\n    id: \"sacrifice:119/100\",\n    name: \"Sacrifice 100 Delta\",\n    description: \"You have sacrificed 100 Delta! Here, shake my hand!\",\n};\nexport const ITEM_DELTA_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_DELTA,\n    ACHIEVEMENT_BUY_100_DELTA,\n    ACHIEVEMENT_SACRIFICE_1_DELTA,\n    ACHIEVEMENT_SACRIFICE_100_DELTA,\n];\nexport const ACHIEVEMENT_BUY_1_ESTUARY: IAchievement = {\n    id: \"buy:120/1\",\n    name: \"Buy one Estuary\",\n    description: \"You have bought 1 Estuary. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_ESTUARY: IAchievement = {\n    id: \"buy:120/100\",\n    name: \"Buy 100 Estuary\",\n    description: \"You have bought 100 Estuary! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_ESTUARY: IAchievement = {\n    id: \"sacrifice:120/1\",\n    name: \"Sacrifice one Estuary\",\n    description: \"You have sacrificed 1 Estuary. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_ESTUARY: IAchievement = {\n    id: \"sacrifice:120/100\",\n    name: \"Sacrifice 100 Estuary\",\n    description: \"You have sacrificed 100 Estuary! Here, shake my hand!\",\n};\nexport const ITEM_ESTUARY_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_ESTUARY,\n    ACHIEVEMENT_BUY_100_ESTUARY,\n    ACHIEVEMENT_SACRIFICE_1_ESTUARY,\n    ACHIEVEMENT_SACRIFICE_100_ESTUARY,\n];\nexport const ACHIEVEMENT_BUY_1_FIRE_SWAMP: IAchievement = {\n    id: \"buy:121/1\",\n    name: \"Buy one Fire Swamp\",\n    description: \"You have bought 1 Fire Swamp. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_FIRE_SWAMP: IAchievement = {\n    id: \"buy:121/100\",\n    name: \"Buy 100 Fire Swamp\",\n    description: \"You have bought 100 Fire Swamp! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_FIRE_SWAMP: IAchievement = {\n    id: \"sacrifice:121/1\",\n    name: \"Sacrifice one Fire Swamp\",\n    description: \"You have sacrificed 1 Fire Swamp. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_FIRE_SWAMP: IAchievement = {\n    id: \"sacrifice:121/100\",\n    name: \"Sacrifice 100 Fire Swamp\",\n    description: \"You have sacrificed 100 Fire Swamp! Here, shake my hand!\",\n};\nexport const ITEM_FIRE_SWAMP_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_FIRE_SWAMP,\n    ACHIEVEMENT_BUY_100_FIRE_SWAMP,\n    ACHIEVEMENT_SACRIFICE_1_FIRE_SWAMP,\n    ACHIEVEMENT_SACRIFICE_100_FIRE_SWAMP,\n];\nexport const ACHIEVEMENT_BUY_1_RIVERBANK: IAchievement = {\n    id: \"buy:122/1\",\n    name: \"Buy one Riverbank\",\n    description: \"You have bought 1 Riverbank. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_RIVERBANK: IAchievement = {\n    id: \"buy:122/100\",\n    name: \"Buy 100 Riverbank\",\n    description: \"You have bought 100 Riverbank! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_RIVERBANK: IAchievement = {\n    id: \"sacrifice:122/1\",\n    name: \"Sacrifice one Riverbank\",\n    description: \"You have sacrificed 1 Riverbank. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_RIVERBANK: IAchievement = {\n    id: \"sacrifice:122/100\",\n    name: \"Sacrifice 100 Riverbank\",\n    description: \"You have sacrificed 100 Riverbank! Here, shake my hand!\",\n};\nexport const ITEM_RIVERBANK_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_RIVERBANK,\n    ACHIEVEMENT_BUY_100_RIVERBANK,\n    ACHIEVEMENT_SACRIFICE_1_RIVERBANK,\n    ACHIEVEMENT_SACRIFICE_100_RIVERBANK,\n];\nexport const ACHIEVEMENT_BUY_1_RAVINE: IAchievement = {\n    id: \"buy:123/1\",\n    name: \"Buy one Ravine\",\n    description: \"You have bought 1 Ravine. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_RAVINE: IAchievement = {\n    id: \"buy:123/100\",\n    name: \"Buy 100 Ravine\",\n    description: \"You have bought 100 Ravine! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_RAVINE: IAchievement = {\n    id: \"sacrifice:123/1\",\n    name: \"Sacrifice one Ravine\",\n    description: \"You have sacrificed 1 Ravine. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_RAVINE: IAchievement = {\n    id: \"sacrifice:123/100\",\n    name: \"Sacrifice 100 Ravine\",\n    description: \"You have sacrificed 100 Ravine! Here, shake my hand!\",\n};\nexport const ITEM_RAVINE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_RAVINE,\n    ACHIEVEMENT_BUY_100_RAVINE,\n    ACHIEVEMENT_SACRIFICE_1_RAVINE,\n    ACHIEVEMENT_SACRIFICE_100_RAVINE,\n];\nexport const ACHIEVEMENT_BUY_1_GORGE: IAchievement = {\n    id: \"buy:124/1\",\n    name: \"Buy one Gorge\",\n    description: \"You have bought 1 Gorge. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_GORGE: IAchievement = {\n    id: \"buy:124/100\",\n    name: \"Buy 100 Gorge\",\n    description: \"You have bought 100 Gorge! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_GORGE: IAchievement = {\n    id: \"sacrifice:124/1\",\n    name: \"Sacrifice one Gorge\",\n    description: \"You have sacrificed 1 Gorge. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_GORGE: IAchievement = {\n    id: \"sacrifice:124/100\",\n    name: \"Sacrifice 100 Gorge\",\n    description: \"You have sacrificed 100 Gorge! Here, shake my hand!\",\n};\nexport const ITEM_GORGE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_GORGE,\n    ACHIEVEMENT_BUY_100_GORGE,\n    ACHIEVEMENT_SACRIFICE_1_GORGE,\n    ACHIEVEMENT_SACRIFICE_100_GORGE,\n];\nexport const ACHIEVEMENT_BUY_1_CHARRED_RAVINE: IAchievement = {\n    id: \"buy:125/1\",\n    name: \"Buy one Charred Ravine\",\n    description: \"You have bought 1 Charred Ravine. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_CHARRED_RAVINE: IAchievement = {\n    id: \"buy:125/100\",\n    name: \"Buy 100 Charred Ravine\",\n    description: \"You have bought 100 Charred Ravine! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_CHARRED_RAVINE: IAchievement = {\n    id: \"sacrifice:125/1\",\n    name: \"Sacrifice one Charred Ravine\",\n    description: \"You have sacrificed 1 Charred Ravine. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_CHARRED_RAVINE: IAchievement = {\n    id: \"sacrifice:125/100\",\n    name: \"Sacrifice 100 Charred Ravine\",\n    description: \"You have sacrificed 100 Charred Ravine! Here, shake my hand!\",\n};\nexport const ITEM_CHARRED_RAVINE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_CHARRED_RAVINE,\n    ACHIEVEMENT_BUY_100_CHARRED_RAVINE,\n    ACHIEVEMENT_SACRIFICE_1_CHARRED_RAVINE,\n    ACHIEVEMENT_SACRIFICE_100_CHARRED_RAVINE,\n];\nexport const ACHIEVEMENT_BUY_1_ECHO: IAchievement = {\n    id: \"buy:126/1\",\n    name: \"Buy one Echo\",\n    description: \"You have bought 1 Echo. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_ECHO: IAchievement = {\n    id: \"buy:126/100\",\n    name: \"Buy 100 Echo\",\n    description: \"You have bought 100 Echo! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_ECHO: IAchievement = {\n    id: \"sacrifice:126/1\",\n    name: \"Sacrifice one Echo\",\n    description: \"You have sacrificed 1 Echo. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_ECHO: IAchievement = {\n    id: \"sacrifice:126/100\",\n    name: \"Sacrifice 100 Echo\",\n    description: \"You have sacrificed 100 Echo! Here, shake my hand!\",\n};\nexport const ITEM_ECHO_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_ECHO,\n    ACHIEVEMENT_BUY_100_ECHO,\n    ACHIEVEMENT_SACRIFICE_1_ECHO,\n    ACHIEVEMENT_SACRIFICE_100_ECHO,\n];\nexport const ACHIEVEMENT_BUY_1_CAVE: IAchievement = {\n    id: \"buy:127/1\",\n    name: \"Buy one Cave\",\n    description: \"You have bought 1 Cave. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_CAVE: IAchievement = {\n    id: \"buy:127/100\",\n    name: \"Buy 100 Cave\",\n    description: \"You have bought 100 Cave! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_CAVE: IAchievement = {\n    id: \"sacrifice:127/1\",\n    name: \"Sacrifice one Cave\",\n    description: \"You have sacrificed 1 Cave. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_CAVE: IAchievement = {\n    id: \"sacrifice:127/100\",\n    name: \"Sacrifice 100 Cave\",\n    description: \"You have sacrificed 100 Cave! Here, shake my hand!\",\n};\nexport const ITEM_CAVE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_CAVE,\n    ACHIEVEMENT_BUY_100_CAVE,\n    ACHIEVEMENT_SACRIFICE_1_CAVE,\n    ACHIEVEMENT_SACRIFICE_100_CAVE,\n];\nexport const ACHIEVEMENT_BUY_1_UNDERGROUND_LAKE: IAchievement = {\n    id: \"buy:128/1\",\n    name: \"Buy one Underground Lake\",\n    description: \"You have bought 1 Underground Lake. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_UNDERGROUND_LAKE: IAchievement = {\n    id: \"buy:128/100\",\n    name: \"Buy 100 Underground Lake\",\n    description: \"You have bought 100 Underground Lake! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_UNDERGROUND_LAKE: IAchievement = {\n    id: \"sacrifice:128/1\",\n    name: \"Sacrifice one Underground Lake\",\n    description: \"You have sacrificed 1 Underground Lake. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_UNDERGROUND_LAKE: IAchievement = {\n    id: \"sacrifice:128/100\",\n    name: \"Sacrifice 100 Underground Lake\",\n    description: \"You have sacrificed 100 Underground Lake! Here, shake my hand!\",\n};\nexport const ITEM_UNDERGROUND_LAKE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_UNDERGROUND_LAKE,\n    ACHIEVEMENT_BUY_100_UNDERGROUND_LAKE,\n    ACHIEVEMENT_SACRIFICE_1_UNDERGROUND_LAKE,\n    ACHIEVEMENT_SACRIFICE_100_UNDERGROUND_LAKE,\n];\nexport const ACHIEVEMENT_BUY_1_LAVA_CAVE: IAchievement = {\n    id: \"buy:129/1\",\n    name: \"Buy one Lava Cave\",\n    description: \"You have bought 1 Lava Cave. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_LAVA_CAVE: IAchievement = {\n    id: \"buy:129/100\",\n    name: \"Buy 100 Lava Cave\",\n    description: \"You have bought 100 Lava Cave! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_LAVA_CAVE: IAchievement = {\n    id: \"sacrifice:129/1\",\n    name: \"Sacrifice one Lava Cave\",\n    description: \"You have sacrificed 1 Lava Cave. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_LAVA_CAVE: IAchievement = {\n    id: \"sacrifice:129/100\",\n    name: \"Sacrifice 100 Lava Cave\",\n    description: \"You have sacrificed 100 Lava Cave! Here, shake my hand!\",\n};\nexport const ITEM_LAVA_CAVE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_LAVA_CAVE,\n    ACHIEVEMENT_BUY_100_LAVA_CAVE,\n    ACHIEVEMENT_SACRIFICE_1_LAVA_CAVE,\n    ACHIEVEMENT_SACRIFICE_100_LAVA_CAVE,\n];\nexport const ACHIEVEMENT_BUY_1_WHISPERING_CAVE: IAchievement = {\n    id: \"buy:130/1\",\n    name: \"Buy one Whispering Cave\",\n    description: \"You have bought 1 Whispering Cave. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_WHISPERING_CAVE: IAchievement = {\n    id: \"buy:130/100\",\n    name: \"Buy 100 Whispering Cave\",\n    description: \"You have bought 100 Whispering Cave! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_WHISPERING_CAVE: IAchievement = {\n    id: \"sacrifice:130/1\",\n    name: \"Sacrifice one Whispering Cave\",\n    description: \"You have sacrificed 1 Whispering Cave. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_WHISPERING_CAVE: IAchievement = {\n    id: \"sacrifice:130/100\",\n    name: \"Sacrifice 100 Whispering Cave\",\n    description: \"You have sacrificed 100 Whispering Cave! Here, shake my hand!\",\n};\nexport const ITEM_WHISPERING_CAVE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_WHISPERING_CAVE,\n    ACHIEVEMENT_BUY_100_WHISPERING_CAVE,\n    ACHIEVEMENT_SACRIFICE_1_WHISPERING_CAVE,\n    ACHIEVEMENT_SACRIFICE_100_WHISPERING_CAVE,\n];\nexport const ACHIEVEMENT_BUY_1_SUBTERRANEAN_POOL: IAchievement = {\n    id: \"buy:131/1\",\n    name: \"Buy one Subterranean Pool\",\n    description: \"You have bought 1 Subterranean Pool. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_SUBTERRANEAN_POOL: IAchievement = {\n    id: \"buy:131/100\",\n    name: \"Buy 100 Subterranean Pool\",\n    description: \"You have bought 100 Subterranean Pool! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_SUBTERRANEAN_POOL: IAchievement = {\n    id: \"sacrifice:131/1\",\n    name: \"Sacrifice one Subterranean Pool\",\n    description: \"You have sacrificed 1 Subterranean Pool. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_SUBTERRANEAN_POOL: IAchievement = {\n    id: \"sacrifice:131/100\",\n    name: \"Sacrifice 100 Subterranean Pool\",\n    description: \"You have sacrificed 100 Subterranean Pool! Here, shake my hand!\",\n};\nexport const ITEM_SUBTERRANEAN_POOL_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_SUBTERRANEAN_POOL,\n    ACHIEVEMENT_BUY_100_SUBTERRANEAN_POOL,\n    ACHIEVEMENT_SACRIFICE_1_SUBTERRANEAN_POOL,\n    ACHIEVEMENT_SACRIFICE_100_SUBTERRANEAN_POOL,\n];\nexport const ACHIEVEMENT_BUY_1_SPRING: IAchievement = {\n    id: \"buy:132/1\",\n    name: \"Buy one Spring\",\n    description: \"You have bought 1 Spring. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_SPRING: IAchievement = {\n    id: \"buy:132/100\",\n    name: \"Buy 100 Spring\",\n    description: \"You have bought 100 Spring! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_SPRING: IAchievement = {\n    id: \"sacrifice:132/1\",\n    name: \"Sacrifice one Spring\",\n    description: \"You have sacrificed 1 Spring. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_SPRING: IAchievement = {\n    id: \"sacrifice:132/100\",\n    name: \"Sacrifice 100 Spring\",\n    description: \"You have sacrificed 100 Spring! Here, shake my hand!\",\n};\nexport const ITEM_SPRING_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_SPRING,\n    ACHIEVEMENT_BUY_100_SPRING,\n    ACHIEVEMENT_SACRIFICE_1_SPRING,\n    ACHIEVEMENT_SACRIFICE_100_SPRING,\n];\nexport const ACHIEVEMENT_BUY_1_HOT_SPRING: IAchievement = {\n    id: \"buy:133/1\",\n    name: \"Buy one Hot Spring\",\n    description: \"You have bought 1 Hot Spring. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_HOT_SPRING: IAchievement = {\n    id: \"buy:133/100\",\n    name: \"Buy 100 Hot Spring\",\n    description: \"You have bought 100 Hot Spring! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_HOT_SPRING: IAchievement = {\n    id: \"sacrifice:133/1\",\n    name: \"Sacrifice one Hot Spring\",\n    description: \"You have sacrificed 1 Hot Spring. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_HOT_SPRING: IAchievement = {\n    id: \"sacrifice:133/100\",\n    name: \"Sacrifice 100 Hot Spring\",\n    description: \"You have sacrificed 100 Hot Spring! Here, shake my hand!\",\n};\nexport const ITEM_HOT_SPRING_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_HOT_SPRING,\n    ACHIEVEMENT_BUY_100_HOT_SPRING,\n    ACHIEVEMENT_SACRIFICE_1_HOT_SPRING,\n    ACHIEVEMENT_SACRIFICE_100_HOT_SPRING,\n];\nexport const ACHIEVEMENT_BUY_1_GROTTO: IAchievement = {\n    id: \"buy:134/1\",\n    name: \"Buy one Grotto\",\n    description: \"You have bought 1 Grotto. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_GROTTO: IAchievement = {\n    id: \"buy:134/100\",\n    name: \"Buy 100 Grotto\",\n    description: \"You have bought 100 Grotto! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_GROTTO: IAchievement = {\n    id: \"sacrifice:134/1\",\n    name: \"Sacrifice one Grotto\",\n    description: \"You have sacrificed 1 Grotto. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_GROTTO: IAchievement = {\n    id: \"sacrifice:134/100\",\n    name: \"Sacrifice 100 Grotto\",\n    description: \"You have sacrificed 100 Grotto! Here, shake my hand!\",\n};\nexport const ITEM_GROTTO_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_GROTTO,\n    ACHIEVEMENT_BUY_100_GROTTO,\n    ACHIEVEMENT_SACRIFICE_1_GROTTO,\n    ACHIEVEMENT_SACRIFICE_100_GROTTO,\n];\nexport const ACHIEVEMENT_BUY_1_FOUNTAIN: IAchievement = {\n    id: \"buy:135/1\",\n    name: \"Buy one Fountain\",\n    description: \"You have bought 1 Fountain. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_FOUNTAIN: IAchievement = {\n    id: \"buy:135/100\",\n    name: \"Buy 100 Fountain\",\n    description: \"You have bought 100 Fountain! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_FOUNTAIN: IAchievement = {\n    id: \"sacrifice:135/1\",\n    name: \"Sacrifice one Fountain\",\n    description: \"You have sacrificed 1 Fountain. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_FOUNTAIN: IAchievement = {\n    id: \"sacrifice:135/100\",\n    name: \"Sacrifice 100 Fountain\",\n    description: \"You have sacrificed 100 Fountain! Here, shake my hand!\",\n};\nexport const ITEM_FOUNTAIN_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_FOUNTAIN,\n    ACHIEVEMENT_BUY_100_FOUNTAIN,\n    ACHIEVEMENT_SACRIFICE_1_FOUNTAIN,\n    ACHIEVEMENT_SACRIFICE_100_FOUNTAIN,\n];\nexport const ACHIEVEMENT_BUY_1_STEAM_VENT: IAchievement = {\n    id: \"buy:136/1\",\n    name: \"Buy one Steam Vent\",\n    description: \"You have bought 1 Steam Vent. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_STEAM_VENT: IAchievement = {\n    id: \"buy:136/100\",\n    name: \"Buy 100 Steam Vent\",\n    description: \"You have bought 100 Steam Vent! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_STEAM_VENT: IAchievement = {\n    id: \"sacrifice:136/1\",\n    name: \"Sacrifice one Steam Vent\",\n    description: \"You have sacrificed 1 Steam Vent. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_STEAM_VENT: IAchievement = {\n    id: \"sacrifice:136/100\",\n    name: \"Sacrifice 100 Steam Vent\",\n    description: \"You have sacrificed 100 Steam Vent! Here, shake my hand!\",\n};\nexport const ITEM_STEAM_VENT_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_STEAM_VENT,\n    ACHIEVEMENT_BUY_100_STEAM_VENT,\n    ACHIEVEMENT_SACRIFICE_1_STEAM_VENT,\n    ACHIEVEMENT_SACRIFICE_100_STEAM_VENT,\n];\nexport const ACHIEVEMENT_BUY_1_COOL_BREEZE: IAchievement = {\n    id: \"buy:137/1\",\n    name: \"Buy one Cool Breeze\",\n    description: \"You have bought 1 Cool Breeze. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_COOL_BREEZE: IAchievement = {\n    id: \"buy:137/100\",\n    name: \"Buy 100 Cool Breeze\",\n    description: \"You have bought 100 Cool Breeze! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_COOL_BREEZE: IAchievement = {\n    id: \"sacrifice:137/1\",\n    name: \"Sacrifice one Cool Breeze\",\n    description: \"You have sacrificed 1 Cool Breeze. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_COOL_BREEZE: IAchievement = {\n    id: \"sacrifice:137/100\",\n    name: \"Sacrifice 100 Cool Breeze\",\n    description: \"You have sacrificed 100 Cool Breeze! Here, shake my hand!\",\n};\nexport const ITEM_COOL_BREEZE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_COOL_BREEZE,\n    ACHIEVEMENT_BUY_100_COOL_BREEZE,\n    ACHIEVEMENT_SACRIFICE_1_COOL_BREEZE,\n    ACHIEVEMENT_SACRIFICE_100_COOL_BREEZE,\n];\nexport const ACHIEVEMENT_BUY_1_MONUMENT: IAchievement = {\n    id: \"buy:138/1\",\n    name: \"Buy one Monument\",\n    description: \"You have bought 1 Monument. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_MONUMENT: IAchievement = {\n    id: \"buy:138/100\",\n    name: \"Buy 100 Monument\",\n    description: \"You have bought 100 Monument! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_MONUMENT: IAchievement = {\n    id: \"sacrifice:138/1\",\n    name: \"Sacrifice one Monument\",\n    description: \"You have sacrificed 1 Monument. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_MONUMENT: IAchievement = {\n    id: \"sacrifice:138/100\",\n    name: \"Sacrifice 100 Monument\",\n    description: \"You have sacrificed 100 Monument! Here, shake my hand!\",\n};\nexport const ITEM_MONUMENT_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_MONUMENT,\n    ACHIEVEMENT_BUY_100_MONUMENT,\n    ACHIEVEMENT_SACRIFICE_1_MONUMENT,\n    ACHIEVEMENT_SACRIFICE_100_MONUMENT,\n];\nexport const ACHIEVEMENT_BUY_1_WATERFALL: IAchievement = {\n    id: \"buy:139/1\",\n    name: \"Buy one Waterfall\",\n    description: \"You have bought 1 Waterfall. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_WATERFALL: IAchievement = {\n    id: \"buy:139/100\",\n    name: \"Buy 100 Waterfall\",\n    description: \"You have bought 100 Waterfall! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_WATERFALL: IAchievement = {\n    id: \"sacrifice:139/1\",\n    name: \"Sacrifice one Waterfall\",\n    description: \"You have sacrificed 1 Waterfall. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_WATERFALL: IAchievement = {\n    id: \"sacrifice:139/100\",\n    name: \"Sacrifice 100 Waterfall\",\n    description: \"You have sacrificed 100 Waterfall! Here, shake my hand!\",\n};\nexport const ITEM_WATERFALL_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_WATERFALL,\n    ACHIEVEMENT_BUY_100_WATERFALL,\n    ACHIEVEMENT_SACRIFICE_1_WATERFALL,\n    ACHIEVEMENT_SACRIFICE_100_WATERFALL,\n];\nexport const ACHIEVEMENT_BUY_1_ETERNAL_FLAME: IAchievement = {\n    id: \"buy:140/1\",\n    name: \"Buy one Eternal Flame\",\n    description: \"You have bought 1 Eternal Flame. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_ETERNAL_FLAME: IAchievement = {\n    id: \"buy:140/100\",\n    name: \"Buy 100 Eternal Flame\",\n    description: \"You have bought 100 Eternal Flame! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_ETERNAL_FLAME: IAchievement = {\n    id: \"sacrifice:140/1\",\n    name: \"Sacrifice one Eternal Flame\",\n    description: \"You have sacrificed 1 Eternal Flame. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_ETERNAL_FLAME: IAchievement = {\n    id: \"sacrifice:140/100\",\n    name: \"Sacrifice 100 Eternal Flame\",\n    description: \"You have sacrificed 100 Eternal Flame! Here, shake my hand!\",\n};\nexport const ITEM_ETERNAL_FLAME_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_ETERNAL_FLAME,\n    ACHIEVEMENT_BUY_100_ETERNAL_FLAME,\n    ACHIEVEMENT_SACRIFICE_1_ETERNAL_FLAME,\n    ACHIEVEMENT_SACRIFICE_100_ETERNAL_FLAME,\n];\nexport const ACHIEVEMENT_BUY_1_PILLAR_OF_WIND: IAchievement = {\n    id: \"buy:141/1\",\n    name: \"Buy one Pillar Of Wind\",\n    description: \"You have bought 1 Pillar Of Wind. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_PILLAR_OF_WIND: IAchievement = {\n    id: \"buy:141/100\",\n    name: \"Buy 100 Pillar Of Wind\",\n    description: \"You have bought 100 Pillar Of Wind! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_PILLAR_OF_WIND: IAchievement = {\n    id: \"sacrifice:141/1\",\n    name: \"Sacrifice one Pillar Of Wind\",\n    description: \"You have sacrificed 1 Pillar Of Wind. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_PILLAR_OF_WIND: IAchievement = {\n    id: \"sacrifice:141/100\",\n    name: \"Sacrifice 100 Pillar Of Wind\",\n    description: \"You have sacrificed 100 Pillar Of Wind! Here, shake my hand!\",\n};\nexport const ITEM_PILLAR_OF_WIND_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_PILLAR_OF_WIND,\n    ACHIEVEMENT_BUY_100_PILLAR_OF_WIND,\n    ACHIEVEMENT_SACRIFICE_1_PILLAR_OF_WIND,\n    ACHIEVEMENT_SACRIFICE_100_PILLAR_OF_WIND,\n];\nexport const ACHIEVEMENT_BUY_1_STREAM: IAchievement = {\n    id: \"buy:142/1\",\n    name: \"Buy one Stream\",\n    description: \"You have bought 1 Stream. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_STREAM: IAchievement = {\n    id: \"buy:142/100\",\n    name: \"Buy 100 Stream\",\n    description: \"You have bought 100 Stream! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_STREAM: IAchievement = {\n    id: \"sacrifice:142/1\",\n    name: \"Sacrifice one Stream\",\n    description: \"You have sacrificed 1 Stream. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_STREAM: IAchievement = {\n    id: \"sacrifice:142/100\",\n    name: \"Sacrifice 100 Stream\",\n    description: \"You have sacrificed 100 Stream! Here, shake my hand!\",\n};\nexport const ITEM_STREAM_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_STREAM,\n    ACHIEVEMENT_BUY_100_STREAM,\n    ACHIEVEMENT_SACRIFICE_1_STREAM,\n    ACHIEVEMENT_SACRIFICE_100_STREAM,\n];\nexport const ACHIEVEMENT_BUY_1_ZEPHYR: IAchievement = {\n    id: \"buy:143/1\",\n    name: \"Buy one Zephyr\",\n    description: \"You have bought 1 Zephyr. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_ZEPHYR: IAchievement = {\n    id: \"buy:143/100\",\n    name: \"Buy 100 Zephyr\",\n    description: \"You have bought 100 Zephyr! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_ZEPHYR: IAchievement = {\n    id: \"sacrifice:143/1\",\n    name: \"Sacrifice one Zephyr\",\n    description: \"You have sacrificed 1 Zephyr. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_ZEPHYR: IAchievement = {\n    id: \"sacrifice:143/100\",\n    name: \"Sacrifice 100 Zephyr\",\n    description: \"You have sacrificed 100 Zephyr! Here, shake my hand!\",\n};\nexport const ITEM_ZEPHYR_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_ZEPHYR,\n    ACHIEVEMENT_BUY_100_ZEPHYR,\n    ACHIEVEMENT_SACRIFICE_1_ZEPHYR,\n    ACHIEVEMENT_SACRIFICE_100_ZEPHYR,\n];\nexport const ACHIEVEMENT_BUY_1_CREEK: IAchievement = {\n    id: \"buy:144/1\",\n    name: \"Buy one Creek\",\n    description: \"You have bought 1 Creek. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_CREEK: IAchievement = {\n    id: \"buy:144/100\",\n    name: \"Buy 100 Creek\",\n    description: \"You have bought 100 Creek! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_CREEK: IAchievement = {\n    id: \"sacrifice:144/1\",\n    name: \"Sacrifice one Creek\",\n    description: \"You have sacrificed 1 Creek. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_CREEK: IAchievement = {\n    id: \"sacrifice:144/100\",\n    name: \"Sacrifice 100 Creek\",\n    description: \"You have sacrificed 100 Creek! Here, shake my hand!\",\n};\nexport const ITEM_CREEK_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_CREEK,\n    ACHIEVEMENT_BUY_100_CREEK,\n    ACHIEVEMENT_SACRIFICE_1_CREEK,\n    ACHIEVEMENT_SACRIFICE_100_CREEK,\n];\nexport const ACHIEVEMENT_BUY_1_BROOK: IAchievement = {\n    id: \"buy:145/1\",\n    name: \"Buy one Brook\",\n    description: \"You have bought 1 Brook. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_BROOK: IAchievement = {\n    id: \"buy:145/100\",\n    name: \"Buy 100 Brook\",\n    description: \"You have bought 100 Brook! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_BROOK: IAchievement = {\n    id: \"sacrifice:145/1\",\n    name: \"Sacrifice one Brook\",\n    description: \"You have sacrificed 1 Brook. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_BROOK: IAchievement = {\n    id: \"sacrifice:145/100\",\n    name: \"Sacrifice 100 Brook\",\n    description: \"You have sacrificed 100 Brook! Here, shake my hand!\",\n};\nexport const ITEM_BROOK_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_BROOK,\n    ACHIEVEMENT_BUY_100_BROOK,\n    ACHIEVEMENT_SACRIFICE_1_BROOK,\n    ACHIEVEMENT_SACRIFICE_100_BROOK,\n];\nexport const ACHIEVEMENT_BUY_1_WHISPER: IAchievement = {\n    id: \"buy:146/1\",\n    name: \"Buy one Whisper\",\n    description: \"You have bought 1 Whisper. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_WHISPER: IAchievement = {\n    id: \"buy:146/100\",\n    name: \"Buy 100 Whisper\",\n    description: \"You have bought 100 Whisper! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_WHISPER: IAchievement = {\n    id: \"sacrifice:146/1\",\n    name: \"Sacrifice one Whisper\",\n    description: \"You have sacrificed 1 Whisper. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_WHISPER: IAchievement = {\n    id: \"sacrifice:146/100\",\n    name: \"Sacrifice 100 Whisper\",\n    description: \"You have sacrificed 100 Whisper! Here, shake my hand!\",\n};\nexport const ITEM_WHISPER_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_WHISPER,\n    ACHIEVEMENT_BUY_100_WHISPER,\n    ACHIEVEMENT_SACRIFICE_1_WHISPER,\n    ACHIEVEMENT_SACRIFICE_100_WHISPER,\n];\nexport const ACHIEVEMENT_BUY_1_RIVULET: IAchievement = {\n    id: \"buy:147/1\",\n    name: \"Buy one Rivulet\",\n    description: \"You have bought 1 Rivulet. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_RIVULET: IAchievement = {\n    id: \"buy:147/100\",\n    name: \"Buy 100 Rivulet\",\n    description: \"You have bought 100 Rivulet! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_RIVULET: IAchievement = {\n    id: \"sacrifice:147/1\",\n    name: \"Sacrifice one Rivulet\",\n    description: \"You have sacrificed 1 Rivulet. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_RIVULET: IAchievement = {\n    id: \"sacrifice:147/100\",\n    name: \"Sacrifice 100 Rivulet\",\n    description: \"You have sacrificed 100 Rivulet! Here, shake my hand!\",\n};\nexport const ITEM_RIVULET_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_RIVULET,\n    ACHIEVEMENT_BUY_100_RIVULET,\n    ACHIEVEMENT_SACRIFICE_1_RIVULET,\n    ACHIEVEMENT_SACRIFICE_100_RIVULET,\n];\nexport const ACHIEVEMENT_BUY_1_TRIBUTARY: IAchievement = {\n    id: \"buy:148/1\",\n    name: \"Buy one Tributary\",\n    description: \"You have bought 1 Tributary. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_TRIBUTARY: IAchievement = {\n    id: \"buy:148/100\",\n    name: \"Buy 100 Tributary\",\n    description: \"You have bought 100 Tributary! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_TRIBUTARY: IAchievement = {\n    id: \"sacrifice:148/1\",\n    name: \"Sacrifice one Tributary\",\n    description: \"You have sacrificed 1 Tributary. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_TRIBUTARY: IAchievement = {\n    id: \"sacrifice:148/100\",\n    name: \"Sacrifice 100 Tributary\",\n    description: \"You have sacrificed 100 Tributary! Here, shake my hand!\",\n};\nexport const ITEM_TRIBUTARY_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_TRIBUTARY,\n    ACHIEVEMENT_BUY_100_TRIBUTARY,\n    ACHIEVEMENT_SACRIFICE_1_TRIBUTARY,\n    ACHIEVEMENT_SACRIFICE_100_TRIBUTARY,\n];\nexport const ACHIEVEMENT_BUY_1_MURMUR: IAchievement = {\n    id: \"buy:149/1\",\n    name: \"Buy one Murmur\",\n    description: \"You have bought 1 Murmur. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_MURMUR: IAchievement = {\n    id: \"buy:149/100\",\n    name: \"Buy 100 Murmur\",\n    description: \"You have bought 100 Murmur! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_MURMUR: IAchievement = {\n    id: \"sacrifice:149/1\",\n    name: \"Sacrifice one Murmur\",\n    description: \"You have sacrificed 1 Murmur. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_MURMUR: IAchievement = {\n    id: \"sacrifice:149/100\",\n    name: \"Sacrifice 100 Murmur\",\n    description: \"You have sacrificed 100 Murmur! Here, shake my hand!\",\n};\nexport const ITEM_MURMUR_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_MURMUR,\n    ACHIEVEMENT_BUY_100_MURMUR,\n    ACHIEVEMENT_SACRIFICE_1_MURMUR,\n    ACHIEVEMENT_SACRIFICE_100_MURMUR,\n];\nexport const ACHIEVEMENT_BUY_1_WATERSHED: IAchievement = {\n    id: \"buy:150/1\",\n    name: \"Buy one Watershed\",\n    description: \"You have bought 1 Watershed. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_WATERSHED: IAchievement = {\n    id: \"buy:150/100\",\n    name: \"Buy 100 Watershed\",\n    description: \"You have bought 100 Watershed! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_WATERSHED: IAchievement = {\n    id: \"sacrifice:150/1\",\n    name: \"Sacrifice one Watershed\",\n    description: \"You have sacrificed 1 Watershed. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_WATERSHED: IAchievement = {\n    id: \"sacrifice:150/100\",\n    name: \"Sacrifice 100 Watershed\",\n    description: \"You have sacrificed 100 Watershed! Here, shake my hand!\",\n};\nexport const ITEM_WATERSHED_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_WATERSHED,\n    ACHIEVEMENT_BUY_100_WATERSHED,\n    ACHIEVEMENT_SACRIFICE_1_WATERSHED,\n    ACHIEVEMENT_SACRIFICE_100_WATERSHED,\n];\nexport const ACHIEVEMENT_BUY_1_AQUIFER: IAchievement = {\n    id: \"buy:151/1\",\n    name: \"Buy one Aquifer\",\n    description: \"You have bought 1 Aquifer. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_AQUIFER: IAchievement = {\n    id: \"buy:151/100\",\n    name: \"Buy 100 Aquifer\",\n    description: \"You have bought 100 Aquifer! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_AQUIFER: IAchievement = {\n    id: \"sacrifice:151/1\",\n    name: \"Sacrifice one Aquifer\",\n    description: \"You have sacrificed 1 Aquifer. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_AQUIFER: IAchievement = {\n    id: \"sacrifice:151/100\",\n    name: \"Sacrifice 100 Aquifer\",\n    description: \"You have sacrificed 100 Aquifer! Here, shake my hand!\",\n};\nexport const ITEM_AQUIFER_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_AQUIFER,\n    ACHIEVEMENT_BUY_100_AQUIFER,\n    ACHIEVEMENT_SACRIFICE_1_AQUIFER,\n    ACHIEVEMENT_SACRIFICE_100_AQUIFER,\n];\nexport const ACHIEVEMENT_BUY_1_PARCHED_EARTH: IAchievement = {\n    id: \"buy:152/1\",\n    name: \"Buy one Parched Earth\",\n    description: \"You have bought 1 Parched Earth. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_PARCHED_EARTH: IAchievement = {\n    id: \"buy:152/100\",\n    name: \"Buy 100 Parched Earth\",\n    description: \"You have bought 100 Parched Earth! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_PARCHED_EARTH: IAchievement = {\n    id: \"sacrifice:152/1\",\n    name: \"Sacrifice one Parched Earth\",\n    description: \"You have sacrificed 1 Parched Earth. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_PARCHED_EARTH: IAchievement = {\n    id: \"sacrifice:152/100\",\n    name: \"Sacrifice 100 Parched Earth\",\n    description: \"You have sacrificed 100 Parched Earth! Here, shake my hand!\",\n};\nexport const ITEM_PARCHED_EARTH_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_PARCHED_EARTH,\n    ACHIEVEMENT_BUY_100_PARCHED_EARTH,\n    ACHIEVEMENT_SACRIFICE_1_PARCHED_EARTH,\n    ACHIEVEMENT_SACRIFICE_100_PARCHED_EARTH,\n];\nexport const ACHIEVEMENT_BUY_1_FRESH_BREEZE: IAchievement = {\n    id: \"buy:153/1\",\n    name: \"Buy one Fresh Breeze\",\n    description: \"You have bought 1 Fresh Breeze. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_FRESH_BREEZE: IAchievement = {\n    id: \"buy:153/100\",\n    name: \"Buy 100 Fresh Breeze\",\n    description: \"You have bought 100 Fresh Breeze! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_FRESH_BREEZE: IAchievement = {\n    id: \"sacrifice:153/1\",\n    name: \"Sacrifice one Fresh Breeze\",\n    description: \"You have sacrificed 1 Fresh Breeze. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_FRESH_BREEZE: IAchievement = {\n    id: \"sacrifice:153/100\",\n    name: \"Sacrifice 100 Fresh Breeze\",\n    description: \"You have sacrificed 100 Fresh Breeze! Here, shake my hand!\",\n};\nexport const ITEM_FRESH_BREEZE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_FRESH_BREEZE,\n    ACHIEVEMENT_BUY_100_FRESH_BREEZE,\n    ACHIEVEMENT_SACRIFICE_1_FRESH_BREEZE,\n    ACHIEVEMENT_SACRIFICE_100_FRESH_BREEZE,\n];\nexport const ACHIEVEMENT_BUY_1_GROUNDWATER: IAchievement = {\n    id: \"buy:154/1\",\n    name: \"Buy one Groundwater\",\n    description: \"You have bought 1 Groundwater. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_GROUNDWATER: IAchievement = {\n    id: \"buy:154/100\",\n    name: \"Buy 100 Groundwater\",\n    description: \"You have bought 100 Groundwater! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_GROUNDWATER: IAchievement = {\n    id: \"sacrifice:154/1\",\n    name: \"Sacrifice one Groundwater\",\n    description: \"You have sacrificed 1 Groundwater. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_GROUNDWATER: IAchievement = {\n    id: \"sacrifice:154/100\",\n    name: \"Sacrifice 100 Groundwater\",\n    description: \"You have sacrificed 100 Groundwater! Here, shake my hand!\",\n};\nexport const ITEM_GROUNDWATER_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_GROUNDWATER,\n    ACHIEVEMENT_BUY_100_GROUNDWATER,\n    ACHIEVEMENT_SACRIFICE_1_GROUNDWATER,\n    ACHIEVEMENT_SACRIFICE_100_GROUNDWATER,\n];\nexport const ACHIEVEMENT_BUY_1_RESERVOIR: IAchievement = {\n    id: \"buy:155/1\",\n    name: \"Buy one Reservoir\",\n    description: \"You have bought 1 Reservoir. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_RESERVOIR: IAchievement = {\n    id: \"buy:155/100\",\n    name: \"Buy 100 Reservoir\",\n    description: \"You have bought 100 Reservoir! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_RESERVOIR: IAchievement = {\n    id: \"sacrifice:155/1\",\n    name: \"Sacrifice one Reservoir\",\n    description: \"You have sacrificed 1 Reservoir. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_RESERVOIR: IAchievement = {\n    id: \"sacrifice:155/100\",\n    name: \"Sacrifice 100 Reservoir\",\n    description: \"You have sacrificed 100 Reservoir! Here, shake my hand!\",\n};\nexport const ITEM_RESERVOIR_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_RESERVOIR,\n    ACHIEVEMENT_BUY_100_RESERVOIR,\n    ACHIEVEMENT_SACRIFICE_1_RESERVOIR,\n    ACHIEVEMENT_SACRIFICE_100_RESERVOIR,\n];\nexport const ACHIEVEMENT_BUY_1_GEOTHERMAL_SPRING: IAchievement = {\n    id: \"buy:156/1\",\n    name: \"Buy one Geothermal Spring\",\n    description: \"You have bought 1 Geothermal Spring. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_GEOTHERMAL_SPRING: IAchievement = {\n    id: \"buy:156/100\",\n    name: \"Buy 100 Geothermal Spring\",\n    description: \"You have bought 100 Geothermal Spring! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_GEOTHERMAL_SPRING: IAchievement = {\n    id: \"sacrifice:156/1\",\n    name: \"Sacrifice one Geothermal Spring\",\n    description: \"You have sacrificed 1 Geothermal Spring. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_GEOTHERMAL_SPRING: IAchievement = {\n    id: \"sacrifice:156/100\",\n    name: \"Sacrifice 100 Geothermal Spring\",\n    description: \"You have sacrificed 100 Geothermal Spring! Here, shake my hand!\",\n};\nexport const ITEM_GEOTHERMAL_SPRING_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_GEOTHERMAL_SPRING,\n    ACHIEVEMENT_BUY_100_GEOTHERMAL_SPRING,\n    ACHIEVEMENT_SACRIFICE_1_GEOTHERMAL_SPRING,\n    ACHIEVEMENT_SACRIFICE_100_GEOTHERMAL_SPRING,\n];\nexport const ACHIEVEMENT_BUY_1_ARTESIAN_WELL: IAchievement = {\n    id: \"buy:157/1\",\n    name: \"Buy one Artesian Well\",\n    description: \"You have bought 1 Artesian Well. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_ARTESIAN_WELL: IAchievement = {\n    id: \"buy:157/100\",\n    name: \"Buy 100 Artesian Well\",\n    description: \"You have bought 100 Artesian Well! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_ARTESIAN_WELL: IAchievement = {\n    id: \"sacrifice:157/1\",\n    name: \"Sacrifice one Artesian Well\",\n    description: \"You have sacrificed 1 Artesian Well. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_ARTESIAN_WELL: IAchievement = {\n    id: \"sacrifice:157/100\",\n    name: \"Sacrifice 100 Artesian Well\",\n    description: \"You have sacrificed 100 Artesian Well! Here, shake my hand!\",\n};\nexport const ITEM_ARTESIAN_WELL_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_ARTESIAN_WELL,\n    ACHIEVEMENT_BUY_100_ARTESIAN_WELL,\n    ACHIEVEMENT_SACRIFICE_1_ARTESIAN_WELL,\n    ACHIEVEMENT_SACRIFICE_100_ARTESIAN_WELL,\n];\nexport const ACHIEVEMENT_BUY_1_BASIN: IAchievement = {\n    id: \"buy:158/1\",\n    name: \"Buy one Basin\",\n    description: \"You have bought 1 Basin. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_BASIN: IAchievement = {\n    id: \"buy:158/100\",\n    name: \"Buy 100 Basin\",\n    description: \"You have bought 100 Basin! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_BASIN: IAchievement = {\n    id: \"sacrifice:158/1\",\n    name: \"Sacrifice one Basin\",\n    description: \"You have sacrificed 1 Basin. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_BASIN: IAchievement = {\n    id: \"sacrifice:158/100\",\n    name: \"Sacrifice 100 Basin\",\n    description: \"You have sacrificed 100 Basin! Here, shake my hand!\",\n};\nexport const ITEM_BASIN_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_BASIN,\n    ACHIEVEMENT_BUY_100_BASIN,\n    ACHIEVEMENT_SACRIFICE_1_BASIN,\n    ACHIEVEMENT_SACRIFICE_100_BASIN,\n];\nexport const ACHIEVEMENT_BUY_1_LAKE: IAchievement = {\n    id: \"buy:159/1\",\n    name: \"Buy one Lake\",\n    description: \"You have bought 1 Lake. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_LAKE: IAchievement = {\n    id: \"buy:159/100\",\n    name: \"Buy 100 Lake\",\n    description: \"You have bought 100 Lake! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_LAKE: IAchievement = {\n    id: \"sacrifice:159/1\",\n    name: \"Sacrifice one Lake\",\n    description: \"You have sacrificed 1 Lake. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_LAKE: IAchievement = {\n    id: \"sacrifice:159/100\",\n    name: \"Sacrifice 100 Lake\",\n    description: \"You have sacrificed 100 Lake! Here, shake my hand!\",\n};\nexport const ITEM_LAKE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_LAKE,\n    ACHIEVEMENT_BUY_100_LAKE,\n    ACHIEVEMENT_SACRIFICE_1_LAKE,\n    ACHIEVEMENT_SACRIFICE_100_LAKE,\n];\nexport const ACHIEVEMENT_BUY_1_DRY_BASIN: IAchievement = {\n    id: \"buy:160/1\",\n    name: \"Buy one Dry Basin\",\n    description: \"You have bought 1 Dry Basin. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_DRY_BASIN: IAchievement = {\n    id: \"buy:160/100\",\n    name: \"Buy 100 Dry Basin\",\n    description: \"You have bought 100 Dry Basin! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_DRY_BASIN: IAchievement = {\n    id: \"sacrifice:160/1\",\n    name: \"Sacrifice one Dry Basin\",\n    description: \"You have sacrificed 1 Dry Basin. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_DRY_BASIN: IAchievement = {\n    id: \"sacrifice:160/100\",\n    name: \"Sacrifice 100 Dry Basin\",\n    description: \"You have sacrificed 100 Dry Basin! Here, shake my hand!\",\n};\nexport const ITEM_DRY_BASIN_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_DRY_BASIN,\n    ACHIEVEMENT_BUY_100_DRY_BASIN,\n    ACHIEVEMENT_SACRIFICE_1_DRY_BASIN,\n    ACHIEVEMENT_SACRIFICE_100_DRY_BASIN,\n];\nexport const ACHIEVEMENT_BUY_1_DEPRESSION: IAchievement = {\n    id: \"buy:161/1\",\n    name: \"Buy one Depression\",\n    description: \"You have bought 1 Depression. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_DEPRESSION: IAchievement = {\n    id: \"buy:161/100\",\n    name: \"Buy 100 Depression\",\n    description: \"You have bought 100 Depression! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_DEPRESSION: IAchievement = {\n    id: \"sacrifice:161/1\",\n    name: \"Sacrifice one Depression\",\n    description: \"You have sacrificed 1 Depression. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_DEPRESSION: IAchievement = {\n    id: \"sacrifice:161/100\",\n    name: \"Sacrifice 100 Depression\",\n    description: \"You have sacrificed 100 Depression! Here, shake my hand!\",\n};\nexport const ITEM_DEPRESSION_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_DEPRESSION,\n    ACHIEVEMENT_BUY_100_DEPRESSION,\n    ACHIEVEMENT_SACRIFICE_1_DEPRESSION,\n    ACHIEVEMENT_SACRIFICE_100_DEPRESSION,\n];\nexport const ACHIEVEMENT_BUY_1_ISLAND: IAchievement = {\n    id: \"buy:162/1\",\n    name: \"Buy one Island\",\n    description: \"You have bought 1 Island. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_ISLAND: IAchievement = {\n    id: \"buy:162/100\",\n    name: \"Buy 100 Island\",\n    description: \"You have bought 100 Island! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_ISLAND: IAchievement = {\n    id: \"sacrifice:162/1\",\n    name: \"Sacrifice one Island\",\n    description: \"You have sacrificed 1 Island. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_ISLAND: IAchievement = {\n    id: \"sacrifice:162/100\",\n    name: \"Sacrifice 100 Island\",\n    description: \"You have sacrificed 100 Island! Here, shake my hand!\",\n};\nexport const ITEM_ISLAND_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_ISLAND,\n    ACHIEVEMENT_BUY_100_ISLAND,\n    ACHIEVEMENT_SACRIFICE_1_ISLAND,\n    ACHIEVEMENT_SACRIFICE_100_ISLAND,\n];\nexport const ACHIEVEMENT_BUY_1_LAGOON: IAchievement = {\n    id: \"buy:163/1\",\n    name: \"Buy one Lagoon\",\n    description: \"You have bought 1 Lagoon. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_LAGOON: IAchievement = {\n    id: \"buy:163/100\",\n    name: \"Buy 100 Lagoon\",\n    description: \"You have bought 100 Lagoon! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_LAGOON: IAchievement = {\n    id: \"sacrifice:163/1\",\n    name: \"Sacrifice one Lagoon\",\n    description: \"You have sacrificed 1 Lagoon. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_LAGOON: IAchievement = {\n    id: \"sacrifice:163/100\",\n    name: \"Sacrifice 100 Lagoon\",\n    description: \"You have sacrificed 100 Lagoon! Here, shake my hand!\",\n};\nexport const ITEM_LAGOON_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_LAGOON,\n    ACHIEVEMENT_BUY_100_LAGOON,\n    ACHIEVEMENT_SACRIFICE_1_LAGOON,\n    ACHIEVEMENT_SACRIFICE_100_LAGOON,\n];\nexport const ACHIEVEMENT_BUY_1_WAVE: IAchievement = {\n    id: \"buy:164/1\",\n    name: \"Buy one Wave\",\n    description: \"You have bought 1 Wave. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_WAVE: IAchievement = {\n    id: \"buy:164/100\",\n    name: \"Buy 100 Wave\",\n    description: \"You have bought 100 Wave! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_WAVE: IAchievement = {\n    id: \"sacrifice:164/1\",\n    name: \"Sacrifice one Wave\",\n    description: \"You have sacrificed 1 Wave. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_WAVE: IAchievement = {\n    id: \"sacrifice:164/100\",\n    name: \"Sacrifice 100 Wave\",\n    description: \"You have sacrificed 100 Wave! Here, shake my hand!\",\n};\nexport const ITEM_WAVE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_WAVE,\n    ACHIEVEMENT_BUY_100_WAVE,\n    ACHIEVEMENT_SACRIFICE_1_WAVE,\n    ACHIEVEMENT_SACRIFICE_100_WAVE,\n];\nexport const ACHIEVEMENT_BUY_1_REEF: IAchievement = {\n    id: \"buy:165/1\",\n    name: \"Buy one Reef\",\n    description: \"You have bought 1 Reef. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_REEF: IAchievement = {\n    id: \"buy:165/100\",\n    name: \"Buy 100 Reef\",\n    description: \"You have bought 100 Reef! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_REEF: IAchievement = {\n    id: \"sacrifice:165/1\",\n    name: \"Sacrifice one Reef\",\n    description: \"You have sacrificed 1 Reef. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_REEF: IAchievement = {\n    id: \"sacrifice:165/100\",\n    name: \"Sacrifice 100 Reef\",\n    description: \"You have sacrificed 100 Reef! Here, shake my hand!\",\n};\nexport const ITEM_REEF_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_REEF,\n    ACHIEVEMENT_BUY_100_REEF,\n    ACHIEVEMENT_SACRIFICE_1_REEF,\n    ACHIEVEMENT_SACRIFICE_100_REEF,\n];\nexport const ACHIEVEMENT_BUY_1_CORAL: IAchievement = {\n    id: \"buy:166/1\",\n    name: \"Buy one Coral\",\n    description: \"You have bought 1 Coral. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_CORAL: IAchievement = {\n    id: \"buy:166/100\",\n    name: \"Buy 100 Coral\",\n    description: \"You have bought 100 Coral! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_CORAL: IAchievement = {\n    id: \"sacrifice:166/1\",\n    name: \"Sacrifice one Coral\",\n    description: \"You have sacrificed 1 Coral. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_CORAL: IAchievement = {\n    id: \"sacrifice:166/100\",\n    name: \"Sacrifice 100 Coral\",\n    description: \"You have sacrificed 100 Coral! Here, shake my hand!\",\n};\nexport const ITEM_CORAL_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_CORAL,\n    ACHIEVEMENT_BUY_100_CORAL,\n    ACHIEVEMENT_SACRIFICE_1_CORAL,\n    ACHIEVEMENT_SACRIFICE_100_CORAL,\n];\nexport const ACHIEVEMENT_BUY_1_WHIRL: IAchievement = {\n    id: \"buy:167/1\",\n    name: \"Buy one Whirl\",\n    description: \"You have bought 1 Whirl. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_WHIRL: IAchievement = {\n    id: \"buy:167/100\",\n    name: \"Buy 100 Whirl\",\n    description: \"You have bought 100 Whirl! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_WHIRL: IAchievement = {\n    id: \"sacrifice:167/1\",\n    name: \"Sacrifice one Whirl\",\n    description: \"You have sacrificed 1 Whirl. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_WHIRL: IAchievement = {\n    id: \"sacrifice:167/100\",\n    name: \"Sacrifice 100 Whirl\",\n    description: \"You have sacrificed 100 Whirl! Here, shake my hand!\",\n};\nexport const ITEM_WHIRL_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_WHIRL,\n    ACHIEVEMENT_BUY_100_WHIRL,\n    ACHIEVEMENT_SACRIFICE_1_WHIRL,\n    ACHIEVEMENT_SACRIFICE_100_WHIRL,\n];\nexport const ACHIEVEMENT_BUY_1_LIMESTONE: IAchievement = {\n    id: \"buy:168/1\",\n    name: \"Buy one Limestone\",\n    description: \"You have bought 1 Limestone. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_LIMESTONE: IAchievement = {\n    id: \"buy:168/100\",\n    name: \"Buy 100 Limestone\",\n    description: \"You have bought 100 Limestone! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_LIMESTONE: IAchievement = {\n    id: \"sacrifice:168/1\",\n    name: \"Sacrifice one Limestone\",\n    description: \"You have sacrificed 1 Limestone. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_LIMESTONE: IAchievement = {\n    id: \"sacrifice:168/100\",\n    name: \"Sacrifice 100 Limestone\",\n    description: \"You have sacrificed 100 Limestone! Here, shake my hand!\",\n};\nexport const ITEM_LIMESTONE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_LIMESTONE,\n    ACHIEVEMENT_BUY_100_LIMESTONE,\n    ACHIEVEMENT_SACRIFICE_1_LIMESTONE,\n    ACHIEVEMENT_SACRIFICE_100_LIMESTONE,\n];\nexport const ACHIEVEMENT_BUY_1_KARST: IAchievement = {\n    id: \"buy:169/1\",\n    name: \"Buy one Karst\",\n    description: \"You have bought 1 Karst. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_KARST: IAchievement = {\n    id: \"buy:169/100\",\n    name: \"Buy 100 Karst\",\n    description: \"You have bought 100 Karst! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_KARST: IAchievement = {\n    id: \"sacrifice:169/1\",\n    name: \"Sacrifice one Karst\",\n    description: \"You have sacrificed 1 Karst. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_KARST: IAchievement = {\n    id: \"sacrifice:169/100\",\n    name: \"Sacrifice 100 Karst\",\n    description: \"You have sacrificed 100 Karst! Here, shake my hand!\",\n};\nexport const ITEM_KARST_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_KARST,\n    ACHIEVEMENT_BUY_100_KARST,\n    ACHIEVEMENT_SACRIFICE_1_KARST,\n    ACHIEVEMENT_SACRIFICE_100_KARST,\n];\nexport const ACHIEVEMENT_BUY_1_QUICKLIME: IAchievement = {\n    id: \"buy:170/1\",\n    name: \"Buy one Quicklime\",\n    description: \"You have bought 1 Quicklime. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_QUICKLIME: IAchievement = {\n    id: \"buy:170/100\",\n    name: \"Buy 100 Quicklime\",\n    description: \"You have bought 100 Quicklime! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_QUICKLIME: IAchievement = {\n    id: \"sacrifice:170/1\",\n    name: \"Sacrifice one Quicklime\",\n    description: \"You have sacrificed 1 Quicklime. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_QUICKLIME: IAchievement = {\n    id: \"sacrifice:170/100\",\n    name: \"Sacrifice 100 Quicklime\",\n    description: \"You have sacrificed 100 Quicklime! Here, shake my hand!\",\n};\nexport const ITEM_QUICKLIME_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_QUICKLIME,\n    ACHIEVEMENT_BUY_100_QUICKLIME,\n    ACHIEVEMENT_SACRIFICE_1_QUICKLIME,\n    ACHIEVEMENT_SACRIFICE_100_QUICKLIME,\n];\nexport const ACHIEVEMENT_BUY_1_BLOWHOLE: IAchievement = {\n    id: \"buy:171/1\",\n    name: \"Buy one Blowhole\",\n    description: \"You have bought 1 Blowhole. It's not bad for a start.\",\n};\nexport const ACHIEVEMENT_BUY_100_BLOWHOLE: IAchievement = {\n    id: \"buy:171/100\",\n    name: \"Buy 100 Blowhole\",\n    description: \"You have bought 100 Blowhole! That's something!\",\n};\nexport const ACHIEVEMENT_SACRIFICE_1_BLOWHOLE: IAchievement = {\n    id: \"sacrifice:171/1\",\n    name: \"Sacrifice one Blowhole\",\n    description: \"You have sacrificed 1 Blowhole. At least you've done something.\",\n};\nexport const ACHIEVEMENT_SACRIFICE_100_BLOWHOLE: IAchievement = {\n    id: \"sacrifice:171/100\",\n    name: \"Sacrifice 100 Blowhole\",\n    description: \"You have sacrificed 100 Blowhole! Here, shake my hand!\",\n};\nexport const ITEM_BLOWHOLE_ACHIEVEMENTS = [\n    ACHIEVEMENT_BUY_1_BLOWHOLE,\n    ACHIEVEMENT_BUY_100_BLOWHOLE,\n    ACHIEVEMENT_SACRIFICE_1_BLOWHOLE,\n    ACHIEVEMENT_SACRIFICE_100_BLOWHOLE,\n];\n\nexport const ACHIEVEMENT_CRAFT_1_MAKE_SWARM: IAchievement = {\n    id: \"craft:0/1\",\n    name: \"Craft 'Make Swarm' once\",\n    description: \"You have combined Bee and Bee to craft Swarm. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_SWARM: IAchievement = {\n    id: \"craft:0/100\",\n    name: \"Craft 'Make Swarm' 100 times\",\n    description: \"You have made such efforts, to combine Bee and Bee to craft Swarm 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_SWARM_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_SWARM,\n    ACHIEVEMENT_CRAFT_100_MAKE_SWARM,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_HYDRA: IAchievement = {\n    id: \"craft:1/1\",\n    name: \"Craft 'Make Hydra' once\",\n    description: \"You have combined Giraffe and Giraffe to craft Hydra. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_HYDRA: IAchievement = {\n    id: \"craft:1/100\",\n    name: \"Craft 'Make Hydra' 100 times\",\n    description: \"You have made such efforts, to combine Giraffe and Giraffe to craft Hydra 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_HYDRA_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_HYDRA,\n    ACHIEVEMENT_CRAFT_100_MAKE_HYDRA,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_MONKEYBRANCH: IAchievement = {\n    id: \"craft:2/1\",\n    name: \"Craft 'Make Monkeybranch' once\",\n    description: \"You have combined Monkey and Hydra to craft Monkey Branch. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_MONKEYBRANCH: IAchievement = {\n    id: \"craft:2/100\",\n    name: \"Craft 'Make Monkeybranch' 100 times\",\n    description: \"You have made such efforts, to combine Monkey and Hydra to craft Monkey Branch 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_MONKEYBRANCH_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_MONKEYBRANCH,\n    ACHIEVEMENT_CRAFT_100_MAKE_MONKEYBRANCH,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_BRIDGE: IAchievement = {\n    id: \"craft:3/1\",\n    name: \"Craft 'Make Bridge' once\",\n    description: \"You have combined Monkey Branch and Monkey Branch to craft Bridge. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_BRIDGE: IAchievement = {\n    id: \"craft:3/100\",\n    name: \"Craft 'Make Bridge' 100 times\",\n    description: \"You have made such efforts, to combine Monkey Branch and Monkey Branch to craft Bridge 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_BRIDGE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_BRIDGE,\n    ACHIEVEMENT_CRAFT_100_MAKE_BRIDGE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_GOLDENGATE: IAchievement = {\n    id: \"craft:4/1\",\n    name: \"Craft 'Make Goldengate' once\",\n    description: \"You have combined Coin and Bridge to craft Golden Gate. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_GOLDENGATE: IAchievement = {\n    id: \"craft:4/100\",\n    name: \"Craft 'Make Goldengate' 100 times\",\n    description: \"You have made such efforts, to combine Coin and Bridge to craft Golden Gate 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_GOLDENGATE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_GOLDENGATE,\n    ACHIEVEMENT_CRAFT_100_MAKE_GOLDENGATE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_CARDANO: IAchievement = {\n    id: \"craft:5/1\",\n    name: \"Craft 'Make Cardano' once\",\n    description: \"You have combined Blockchain and Peer Review to craft Cardano. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_CARDANO: IAchievement = {\n    id: \"craft:5/100\",\n    name: \"Craft 'Make Cardano' 100 times\",\n    description: \"You have made such efforts, to combine Blockchain and Peer Review to craft Cardano 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_CARDANO_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_CARDANO,\n    ACHIEVEMENT_CRAFT_100_MAKE_CARDANO,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_BEER: IAchievement = {\n    id: \"craft:6/1\",\n    name: \"Craft 'Make Beer' once\",\n    description: \"You have combined Bee and Bear to craft Beer. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_BEER: IAchievement = {\n    id: \"craft:6/100\",\n    name: \"Craft 'Make Beer' 100 times\",\n    description: \"You have made such efforts, to combine Bee and Bear to craft Beer 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_BEER_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_BEER,\n    ACHIEVEMENT_CRAFT_100_MAKE_BEER,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_LOCK: IAchievement = {\n    id: \"craft:7/1\",\n    name: \"Craft 'Make Lock' once\",\n    description: \"You have combined Silver and Silver to craft Lock. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_LOCK: IAchievement = {\n    id: \"craft:7/100\",\n    name: \"Craft 'Make Lock' 100 times\",\n    description: \"You have made such efforts, to combine Silver and Silver to craft Lock 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_LOCK_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_LOCK,\n    ACHIEVEMENT_CRAFT_100_MAKE_LOCK,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_SUPERMARMALADE: IAchievement = {\n    id: \"craft:8/1\",\n    name: \"Craft 'Make Supermarmalade' once\",\n    description: \"You have combined Marmalade and Marmalade to craft Super Marmalade. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_SUPERMARMALADE: IAchievement = {\n    id: \"craft:8/100\",\n    name: \"Craft 'Make Supermarmalade' 100 times\",\n    description: \"You have made such efforts, to combine Marmalade and Marmalade to craft Super Marmalade 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_SUPERMARMALADE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_SUPERMARMALADE,\n    ACHIEVEMENT_CRAFT_100_MAKE_SUPERMARMALADE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_HYPERMARMALADE: IAchievement = {\n    id: \"craft:9/1\",\n    name: \"Craft 'Make Hypermarmalade' once\",\n    description: \"You have combined Super Marmalade and Super Marmalade to craft Hyper Marmalade. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_HYPERMARMALADE: IAchievement = {\n    id: \"craft:9/100\",\n    name: \"Craft 'Make Hypermarmalade' 100 times\",\n    description: \"You have made such efforts, to combine Super Marmalade and Super Marmalade to craft Hyper Marmalade 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_HYPERMARMALADE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_HYPERMARMALADE,\n    ACHIEVEMENT_CRAFT_100_MAKE_HYPERMARMALADE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_STEAM: IAchievement = {\n    id: \"craft:10/1\",\n    name: \"Craft 'Make Steam' once\",\n    description: \"You have combined Water and Fire to craft Steam. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_STEAM: IAchievement = {\n    id: \"craft:10/100\",\n    name: \"Craft 'Make Steam' 100 times\",\n    description: \"You have made such efforts, to combine Water and Fire to craft Steam 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_STEAM_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_STEAM,\n    ACHIEVEMENT_CRAFT_100_MAKE_STEAM,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_MUD: IAchievement = {\n    id: \"craft:11/1\",\n    name: \"Craft 'Make Mud' once\",\n    description: \"You have combined Water and Earth to craft Mud. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_MUD: IAchievement = {\n    id: \"craft:11/100\",\n    name: \"Craft 'Make Mud' 100 times\",\n    description: \"You have made such efforts, to combine Water and Earth to craft Mud 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_MUD_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_MUD,\n    ACHIEVEMENT_CRAFT_100_MAKE_MUD,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_LAVA: IAchievement = {\n    id: \"craft:12/1\",\n    name: \"Craft 'Make Lava' once\",\n    description: \"You have combined Fire and Earth to craft Lava. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_LAVA: IAchievement = {\n    id: \"craft:12/100\",\n    name: \"Craft 'Make Lava' 100 times\",\n    description: \"You have made such efforts, to combine Fire and Earth to craft Lava 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_LAVA_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_LAVA,\n    ACHIEVEMENT_CRAFT_100_MAKE_LAVA,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_DUST: IAchievement = {\n    id: \"craft:13/1\",\n    name: \"Craft 'Make Dust' once\",\n    description: \"You have combined Wind and Earth to craft Dust. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_DUST: IAchievement = {\n    id: \"craft:13/100\",\n    name: \"Craft 'Make Dust' 100 times\",\n    description: \"You have made such efforts, to combine Wind and Earth to craft Dust 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_DUST_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_DUST,\n    ACHIEVEMENT_CRAFT_100_MAKE_DUST,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_RAIN: IAchievement = {\n    id: \"craft:14/1\",\n    name: \"Craft 'Make Rain' once\",\n    description: \"You have combined Water and Wind to craft Rain. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_RAIN: IAchievement = {\n    id: \"craft:14/100\",\n    name: \"Craft 'Make Rain' 100 times\",\n    description: \"You have made such efforts, to combine Water and Wind to craft Rain 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_RAIN_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_RAIN,\n    ACHIEVEMENT_CRAFT_100_MAKE_RAIN,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_SMOKE: IAchievement = {\n    id: \"craft:15/1\",\n    name: \"Craft 'Make Smoke' once\",\n    description: \"You have combined Fire and Wind to craft Smoke. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_SMOKE: IAchievement = {\n    id: \"craft:15/100\",\n    name: \"Craft 'Make Smoke' 100 times\",\n    description: \"You have made such efforts, to combine Fire and Wind to craft Smoke 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_SMOKE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_SMOKE,\n    ACHIEVEMENT_CRAFT_100_MAKE_SMOKE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_GEYSER: IAchievement = {\n    id: \"craft:16/1\",\n    name: \"Craft 'Make Geyser' once\",\n    description: \"You have combined Steam and Earth to craft Geyser. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_GEYSER: IAchievement = {\n    id: \"craft:16/100\",\n    name: \"Craft 'Make Geyser' 100 times\",\n    description: \"You have made such efforts, to combine Steam and Earth to craft Geyser 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_GEYSER_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_GEYSER,\n    ACHIEVEMENT_CRAFT_100_MAKE_GEYSER,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_CLAY: IAchievement = {\n    id: \"craft:17/1\",\n    name: \"Craft 'Make Clay' once\",\n    description: \"You have combined Mud and Fire to craft Clay. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_CLAY: IAchievement = {\n    id: \"craft:17/100\",\n    name: \"Craft 'Make Clay' 100 times\",\n    description: \"You have made such efforts, to combine Mud and Fire to craft Clay 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_CLAY_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_CLAY,\n    ACHIEVEMENT_CRAFT_100_MAKE_CLAY,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_SAND: IAchievement = {\n    id: \"craft:18/1\",\n    name: \"Craft 'Make Sand' once\",\n    description: \"You have combined Mud and Wind to craft Sand. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_SAND: IAchievement = {\n    id: \"craft:18/100\",\n    name: \"Craft 'Make Sand' 100 times\",\n    description: \"You have made such efforts, to combine Mud and Wind to craft Sand 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_SAND_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_SAND,\n    ACHIEVEMENT_CRAFT_100_MAKE_SAND,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_PLANT: IAchievement = {\n    id: \"craft:19/1\",\n    name: \"Craft 'Make Plant' once\",\n    description: \"You have combined Rain and Earth to craft Plant. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_PLANT: IAchievement = {\n    id: \"craft:19/100\",\n    name: \"Craft 'Make Plant' 100 times\",\n    description: \"You have made such efforts, to combine Rain and Earth to craft Plant 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_PLANT_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_PLANT,\n    ACHIEVEMENT_CRAFT_100_MAKE_PLANT,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_RAINBOW: IAchievement = {\n    id: \"craft:20/1\",\n    name: \"Craft 'Make Rainbow' once\",\n    description: \"You have combined Rain and Fire to craft Rainbow. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_RAINBOW: IAchievement = {\n    id: \"craft:20/100\",\n    name: \"Craft 'Make Rainbow' 100 times\",\n    description: \"You have made such efforts, to combine Rain and Fire to craft Rainbow 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_RAINBOW_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_RAINBOW,\n    ACHIEVEMENT_CRAFT_100_MAKE_RAINBOW,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_STORM: IAchievement = {\n    id: \"craft:21/1\",\n    name: \"Craft 'Make Storm' once\",\n    description: \"You have combined Rain and Wind to craft Storm. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_STORM: IAchievement = {\n    id: \"craft:21/100\",\n    name: \"Craft 'Make Storm' 100 times\",\n    description: \"You have made such efforts, to combine Rain and Wind to craft Storm 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_STORM_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_STORM,\n    ACHIEVEMENT_CRAFT_100_MAKE_STORM,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_OBSIDIAN: IAchievement = {\n    id: \"craft:22/1\",\n    name: \"Craft 'Make Obsidian' once\",\n    description: \"You have combined Lava and Water to craft Obsidian. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_OBSIDIAN: IAchievement = {\n    id: \"craft:22/100\",\n    name: \"Craft 'Make Obsidian' 100 times\",\n    description: \"You have made such efforts, to combine Lava and Water to craft Obsidian 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_OBSIDIAN_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_OBSIDIAN,\n    ACHIEVEMENT_CRAFT_100_MAKE_OBSIDIAN,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_ASH: IAchievement = {\n    id: \"craft:23/1\",\n    name: \"Craft 'Make Ash' once\",\n    description: \"You have combined Lava and Wind to craft Ash. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_ASH: IAchievement = {\n    id: \"craft:23/100\",\n    name: \"Craft 'Make Ash' 100 times\",\n    description: \"You have made such efforts, to combine Lava and Wind to craft Ash 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_ASH_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_ASH,\n    ACHIEVEMENT_CRAFT_100_MAKE_ASH,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_VOLCANO: IAchievement = {\n    id: \"craft:24/1\",\n    name: \"Craft 'Make Volcano' once\",\n    description: \"You have combined Lava and Earth to craft Volcano. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_VOLCANO: IAchievement = {\n    id: \"craft:24/100\",\n    name: \"Craft 'Make Volcano' 100 times\",\n    description: \"You have made such efforts, to combine Lava and Earth to craft Volcano 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_VOLCANO_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_VOLCANO,\n    ACHIEVEMENT_CRAFT_100_MAKE_VOLCANO,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_SANDSTORM: IAchievement = {\n    id: \"craft:25/1\",\n    name: \"Craft 'Make Sandstorm' once\",\n    description: \"You have combined Dust and Wind to craft Sandstorm. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_SANDSTORM: IAchievement = {\n    id: \"craft:25/100\",\n    name: \"Craft 'Make Sandstorm' 100 times\",\n    description: \"You have made such efforts, to combine Dust and Wind to craft Sandstorm 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_SANDSTORM_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_SANDSTORM,\n    ACHIEVEMENT_CRAFT_100_MAKE_SANDSTORM,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_CLOUD: IAchievement = {\n    id: \"craft:26/1\",\n    name: \"Craft 'Make Cloud' once\",\n    description: \"You have combined Smoke and Water to craft Cloud. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_CLOUD: IAchievement = {\n    id: \"craft:26/100\",\n    name: \"Craft 'Make Cloud' 100 times\",\n    description: \"You have made such efforts, to combine Smoke and Water to craft Cloud 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_CLOUD_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_CLOUD,\n    ACHIEVEMENT_CRAFT_100_MAKE_CLOUD,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_FOG: IAchievement = {\n    id: \"craft:27/1\",\n    name: \"Craft 'Make Fog' once\",\n    description: \"You have combined Smoke and Wind to craft Fog. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_FOG: IAchievement = {\n    id: \"craft:27/100\",\n    name: \"Craft 'Make Fog' 100 times\",\n    description: \"You have made such efforts, to combine Smoke and Wind to craft Fog 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_FOG_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_FOG,\n    ACHIEVEMENT_CRAFT_100_MAKE_FOG,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_TREE: IAchievement = {\n    id: \"craft:28/1\",\n    name: \"Craft 'Make Tree' once\",\n    description: \"You have combined Plant and Water to craft Tree. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_TREE: IAchievement = {\n    id: \"craft:28/100\",\n    name: \"Craft 'Make Tree' 100 times\",\n    description: \"You have made such efforts, to combine Plant and Water to craft Tree 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_TREE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_TREE,\n    ACHIEVEMENT_CRAFT_100_MAKE_TREE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_FOREST: IAchievement = {\n    id: \"craft:29/1\",\n    name: \"Craft 'Make Forest' once\",\n    description: \"You have combined Plant and Earth to craft Forest. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_FOREST: IAchievement = {\n    id: \"craft:29/100\",\n    name: \"Craft 'Make Forest' 100 times\",\n    description: \"You have made such efforts, to combine Plant and Earth to craft Forest 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_FOREST_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_FOREST,\n    ACHIEVEMENT_CRAFT_100_MAKE_FOREST,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_SEEDS: IAchievement = {\n    id: \"craft:30/1\",\n    name: \"Craft 'Make Seeds' once\",\n    description: \"You have combined Plant and Wind to craft Seeds. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_SEEDS: IAchievement = {\n    id: \"craft:30/100\",\n    name: \"Craft 'Make Seeds' 100 times\",\n    description: \"You have made such efforts, to combine Plant and Wind to craft Seeds 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_SEEDS_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_SEEDS,\n    ACHIEVEMENT_CRAFT_100_MAKE_SEEDS,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_POTTERY: IAchievement = {\n    id: \"craft:31/1\",\n    name: \"Craft 'Make Pottery' once\",\n    description: \"You have combined Clay and Fire to craft Pottery. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_POTTERY: IAchievement = {\n    id: \"craft:31/100\",\n    name: \"Craft 'Make Pottery' 100 times\",\n    description: \"You have made such efforts, to combine Clay and Fire to craft Pottery 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_POTTERY_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_POTTERY,\n    ACHIEVEMENT_CRAFT_100_MAKE_POTTERY,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_BRICK: IAchievement = {\n    id: \"craft:32/1\",\n    name: \"Craft 'Make Brick' once\",\n    description: \"You have combined Clay and Earth to craft Brick. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_BRICK: IAchievement = {\n    id: \"craft:32/100\",\n    name: \"Craft 'Make Brick' 100 times\",\n    description: \"You have made such efforts, to combine Clay and Earth to craft Brick 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_BRICK_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_BRICK,\n    ACHIEVEMENT_CRAFT_100_MAKE_BRICK,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_QUICKSAND: IAchievement = {\n    id: \"craft:33/1\",\n    name: \"Craft 'Make Quicksand' once\",\n    description: \"You have combined Sand and Water to craft Quicksand. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_QUICKSAND: IAchievement = {\n    id: \"craft:33/100\",\n    name: \"Craft 'Make Quicksand' 100 times\",\n    description: \"You have made such efforts, to combine Sand and Water to craft Quicksand 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_QUICKSAND_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_QUICKSAND,\n    ACHIEVEMENT_CRAFT_100_MAKE_QUICKSAND,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_GLASS: IAchievement = {\n    id: \"craft:34/1\",\n    name: \"Craft 'Make Glass' once\",\n    description: \"You have combined Sand and Fire to craft Glass. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_GLASS: IAchievement = {\n    id: \"craft:34/100\",\n    name: \"Craft 'Make Glass' 100 times\",\n    description: \"You have made such efforts, to combine Sand and Fire to craft Glass 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_GLASS_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_GLASS,\n    ACHIEVEMENT_CRAFT_100_MAKE_GLASS,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_DUNE: IAchievement = {\n    id: \"craft:35/1\",\n    name: \"Craft 'Make Dune' once\",\n    description: \"You have combined Sand and Wind to craft Dune. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_DUNE: IAchievement = {\n    id: \"craft:35/100\",\n    name: \"Craft 'Make Dune' 100 times\",\n    description: \"You have made such efforts, to combine Sand and Wind to craft Dune 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_DUNE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_DUNE,\n    ACHIEVEMENT_CRAFT_100_MAKE_DUNE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_CHARCOAL: IAchievement = {\n    id: \"craft:36/1\",\n    name: \"Craft 'Make Charcoal' once\",\n    description: \"You have combined Tree and Fire to craft Charcoal. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_CHARCOAL: IAchievement = {\n    id: \"craft:36/100\",\n    name: \"Craft 'Make Charcoal' 100 times\",\n    description: \"You have made such efforts, to combine Tree and Fire to craft Charcoal 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_CHARCOAL_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_CHARCOAL,\n    ACHIEVEMENT_CRAFT_100_MAKE_CHARCOAL,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_LEAVES: IAchievement = {\n    id: \"craft:37/1\",\n    name: \"Craft 'Make Leaves' once\",\n    description: \"You have combined Tree and Wind to craft Leaves. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_LEAVES: IAchievement = {\n    id: \"craft:37/100\",\n    name: \"Craft 'Make Leaves' 100 times\",\n    description: \"You have made such efforts, to combine Tree and Wind to craft Leaves 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_LEAVES_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_LEAVES,\n    ACHIEVEMENT_CRAFT_100_MAKE_LEAVES,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_WILDFIRE: IAchievement = {\n    id: \"craft:38/1\",\n    name: \"Craft 'Make Wildfire' once\",\n    description: \"You have combined Forest and Fire to craft Wildfire. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_WILDFIRE: IAchievement = {\n    id: \"craft:38/100\",\n    name: \"Craft 'Make Wildfire' 100 times\",\n    description: \"You have made such efforts, to combine Forest and Fire to craft Wildfire 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_WILDFIRE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_WILDFIRE,\n    ACHIEVEMENT_CRAFT_100_MAKE_WILDFIRE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_JUNGLE: IAchievement = {\n    id: \"craft:39/1\",\n    name: \"Craft 'Make Jungle' once\",\n    description: \"You have combined Forest and Earth to craft Jungle. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_JUNGLE: IAchievement = {\n    id: \"craft:39/100\",\n    name: \"Craft 'Make Jungle' 100 times\",\n    description: \"You have made such efforts, to combine Forest and Earth to craft Jungle 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_JUNGLE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_JUNGLE,\n    ACHIEVEMENT_CRAFT_100_MAKE_JUNGLE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_FROSTED_GLASS: IAchievement = {\n    id: \"craft:40/1\",\n    name: \"Craft 'Make Frosted Glass' once\",\n    description: \"You have combined Glass and Water to craft Frosted Glass. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_FROSTED_GLASS: IAchievement = {\n    id: \"craft:40/100\",\n    name: \"Craft 'Make Frosted Glass' 100 times\",\n    description: \"You have made such efforts, to combine Glass and Water to craft Frosted Glass 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_FROSTED_GLASS_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_FROSTED_GLASS,\n    ACHIEVEMENT_CRAFT_100_MAKE_FROSTED_GLASS,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_CRYSTAL: IAchievement = {\n    id: \"craft:41/1\",\n    name: \"Craft 'Make Crystal' once\",\n    description: \"You have combined Glass and Earth to craft Crystal. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_CRYSTAL: IAchievement = {\n    id: \"craft:41/100\",\n    name: \"Craft 'Make Crystal' 100 times\",\n    description: \"You have made such efforts, to combine Glass and Earth to craft Crystal 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_CRYSTAL_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_CRYSTAL,\n    ACHIEVEMENT_CRAFT_100_MAKE_CRYSTAL,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_MAGMA: IAchievement = {\n    id: \"craft:42/1\",\n    name: \"Craft 'Make Magma' once\",\n    description: \"You have combined Obsidian and Fire to craft Magma. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_MAGMA: IAchievement = {\n    id: \"craft:42/100\",\n    name: \"Craft 'Make Magma' 100 times\",\n    description: \"You have made such efforts, to combine Obsidian and Fire to craft Magma 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_MAGMA_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_MAGMA,\n    ACHIEVEMENT_CRAFT_100_MAKE_MAGMA,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_ROCK: IAchievement = {\n    id: \"craft:43/1\",\n    name: \"Craft 'Make Rock' once\",\n    description: \"You have combined Obsidian and Earth to craft Rock. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_ROCK: IAchievement = {\n    id: \"craft:43/100\",\n    name: \"Craft 'Make Rock' 100 times\",\n    description: \"You have made such efforts, to combine Obsidian and Earth to craft Rock 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_ROCK_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_ROCK,\n    ACHIEVEMENT_CRAFT_100_MAKE_ROCK,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_SHARD: IAchievement = {\n    id: \"craft:44/1\",\n    name: \"Craft 'Make Shard' once\",\n    description: \"You have combined Obsidian and Wind to craft Shard. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_SHARD: IAchievement = {\n    id: \"craft:44/100\",\n    name: \"Craft 'Make Shard' 100 times\",\n    description: \"You have made such efforts, to combine Obsidian and Wind to craft Shard 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_SHARD_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_SHARD,\n    ACHIEVEMENT_CRAFT_100_MAKE_SHARD,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_PEBBLE: IAchievement = {\n    id: \"craft:45/1\",\n    name: \"Craft 'Make Pebble' once\",\n    description: \"You have combined Rock and Water to craft Pebble. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_PEBBLE: IAchievement = {\n    id: \"craft:45/100\",\n    name: \"Craft 'Make Pebble' 100 times\",\n    description: \"You have made such efforts, to combine Rock and Water to craft Pebble 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_PEBBLE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_PEBBLE,\n    ACHIEVEMENT_CRAFT_100_MAKE_PEBBLE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_MOUNTAIN: IAchievement = {\n    id: \"craft:46/1\",\n    name: \"Craft 'Make Mountain' once\",\n    description: \"You have combined Rock and Earth to craft Mountain. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_MOUNTAIN: IAchievement = {\n    id: \"craft:46/100\",\n    name: \"Craft 'Make Mountain' 100 times\",\n    description: \"You have made such efforts, to combine Rock and Earth to craft Mountain 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_MOUNTAIN_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_MOUNTAIN,\n    ACHIEVEMENT_CRAFT_100_MAKE_MOUNTAIN,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_FERTILIZER: IAchievement = {\n    id: \"craft:47/1\",\n    name: \"Craft 'Make Fertilizer' once\",\n    description: \"You have combined Ash and Earth to craft Fertilizer. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_FERTILIZER: IAchievement = {\n    id: \"craft:47/100\",\n    name: \"Craft 'Make Fertilizer' 100 times\",\n    description: \"You have made such efforts, to combine Ash and Earth to craft Fertilizer 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_FERTILIZER_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_FERTILIZER,\n    ACHIEVEMENT_CRAFT_100_MAKE_FERTILIZER,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_SOOT: IAchievement = {\n    id: \"craft:48/1\",\n    name: \"Craft 'Make Soot' once\",\n    description: \"You have combined Ash and Wind to craft Soot. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_SOOT: IAchievement = {\n    id: \"craft:48/100\",\n    name: \"Craft 'Make Soot' 100 times\",\n    description: \"You have made such efforts, to combine Ash and Wind to craft Soot 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_SOOT_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_SOOT,\n    ACHIEVEMENT_CRAFT_100_MAKE_SOOT,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_LIGHTNING: IAchievement = {\n    id: \"craft:49/1\",\n    name: \"Craft 'Make Lightning' once\",\n    description: \"You have combined Cloud and Fire to craft Lightning. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_LIGHTNING: IAchievement = {\n    id: \"craft:49/100\",\n    name: \"Craft 'Make Lightning' 100 times\",\n    description: \"You have made such efforts, to combine Cloud and Fire to craft Lightning 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_LIGHTNING_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_LIGHTNING,\n    ACHIEVEMENT_CRAFT_100_MAKE_LIGHTNING,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_MIST: IAchievement = {\n    id: \"craft:50/1\",\n    name: \"Craft 'Make Mist' once\",\n    description: \"You have combined Fog and Earth to craft Mist. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_MIST: IAchievement = {\n    id: \"craft:50/100\",\n    name: \"Craft 'Make Mist' 100 times\",\n    description: \"You have made such efforts, to combine Fog and Earth to craft Mist 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_MIST_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_MIST,\n    ACHIEVEMENT_CRAFT_100_MAKE_MIST,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_HAZE: IAchievement = {\n    id: \"craft:51/1\",\n    name: \"Craft 'Make Haze' once\",\n    description: \"You have combined Fog and Wind to craft Haze. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_HAZE: IAchievement = {\n    id: \"craft:51/100\",\n    name: \"Craft 'Make Haze' 100 times\",\n    description: \"You have made such efforts, to combine Fog and Wind to craft Haze 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_HAZE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_HAZE,\n    ACHIEVEMENT_CRAFT_100_MAKE_HAZE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_FLOOD: IAchievement = {\n    id: \"craft:52/1\",\n    name: \"Craft 'Make Flood' once\",\n    description: \"You have combined Storm and Water to craft Flood. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_FLOOD: IAchievement = {\n    id: \"craft:52/100\",\n    name: \"Craft 'Make Flood' 100 times\",\n    description: \"You have made such efforts, to combine Storm and Water to craft Flood 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_FLOOD_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_FLOOD,\n    ACHIEVEMENT_CRAFT_100_MAKE_FLOOD,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_LANDSLIDE: IAchievement = {\n    id: \"craft:53/1\",\n    name: \"Craft 'Make Landslide' once\",\n    description: \"You have combined Storm and Earth to craft Landslide. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_LANDSLIDE: IAchievement = {\n    id: \"craft:53/100\",\n    name: \"Craft 'Make Landslide' 100 times\",\n    description: \"You have made such efforts, to combine Storm and Earth to craft Landslide 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_LANDSLIDE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_LANDSLIDE,\n    ACHIEVEMENT_CRAFT_100_MAKE_LANDSLIDE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_THUNDER: IAchievement = {\n    id: \"craft:54/1\",\n    name: \"Craft 'Make Thunder' once\",\n    description: \"You have combined Storm and Fire to craft Thunder. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_THUNDER: IAchievement = {\n    id: \"craft:54/100\",\n    name: \"Craft 'Make Thunder' 100 times\",\n    description: \"You have made such efforts, to combine Storm and Fire to craft Thunder 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_THUNDER_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_THUNDER,\n    ACHIEVEMENT_CRAFT_100_MAKE_THUNDER,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_TORNADO: IAchievement = {\n    id: \"craft:55/1\",\n    name: \"Craft 'Make Tornado' once\",\n    description: \"You have combined Storm and Wind to craft Tornado. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_TORNADO: IAchievement = {\n    id: \"craft:55/100\",\n    name: \"Craft 'Make Tornado' 100 times\",\n    description: \"You have made such efforts, to combine Storm and Wind to craft Tornado 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_TORNADO_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_TORNADO,\n    ACHIEVEMENT_CRAFT_100_MAKE_TORNADO,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_GARDEN: IAchievement = {\n    id: \"craft:56/1\",\n    name: \"Craft 'Make Garden' once\",\n    description: \"You have combined Earth and Plant to craft Garden. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_GARDEN: IAchievement = {\n    id: \"craft:56/100\",\n    name: \"Craft 'Make Garden' 100 times\",\n    description: \"You have made such efforts, to combine Earth and Plant to craft Garden 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_GARDEN_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_GARDEN,\n    ACHIEVEMENT_CRAFT_100_MAKE_GARDEN,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_EMBER: IAchievement = {\n    id: \"craft:57/1\",\n    name: \"Craft 'Make Ember' once\",\n    description: \"You have combined Fire and Ash to craft Ember. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_EMBER: IAchievement = {\n    id: \"craft:57/100\",\n    name: \"Craft 'Make Ember' 100 times\",\n    description: \"You have made such efforts, to combine Fire and Ash to craft Ember 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_EMBER_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_EMBER,\n    ACHIEVEMENT_CRAFT_100_MAKE_EMBER,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_KILN: IAchievement = {\n    id: \"craft:58/1\",\n    name: \"Craft 'Make Kiln' once\",\n    description: \"You have combined Fire and Pottery to craft Kiln. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_KILN: IAchievement = {\n    id: \"craft:58/100\",\n    name: \"Craft 'Make Kiln' 100 times\",\n    description: \"You have made such efforts, to combine Fire and Pottery to craft Kiln 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_KILN_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_KILN,\n    ACHIEVEMENT_CRAFT_100_MAKE_KILN,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_POLLINATION: IAchievement = {\n    id: \"craft:59/1\",\n    name: \"Craft 'Make Pollination' once\",\n    description: \"You have combined Wind and Plant to craft Pollination. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_POLLINATION: IAchievement = {\n    id: \"craft:59/100\",\n    name: \"Craft 'Make Pollination' 100 times\",\n    description: \"You have made such efforts, to combine Wind and Plant to craft Pollination 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_POLLINATION_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_POLLINATION,\n    ACHIEVEMENT_CRAFT_100_MAKE_POLLINATION,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_SINKHOLE: IAchievement = {\n    id: \"craft:60/1\",\n    name: \"Craft 'Make Sinkhole' once\",\n    description: \"You have combined Earth and Quicksand to craft Sinkhole. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_SINKHOLE: IAchievement = {\n    id: \"craft:60/100\",\n    name: \"Craft 'Make Sinkhole' 100 times\",\n    description: \"You have made such efforts, to combine Earth and Quicksand to craft Sinkhole 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_SINKHOLE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_SINKHOLE,\n    ACHIEVEMENT_CRAFT_100_MAKE_SINKHOLE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_BEACH: IAchievement = {\n    id: \"craft:61/1\",\n    name: \"Craft 'Make Beach' once\",\n    description: \"You have combined Water and Sand to craft Beach. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_BEACH: IAchievement = {\n    id: \"craft:61/100\",\n    name: \"Craft 'Make Beach' 100 times\",\n    description: \"You have made such efforts, to combine Water and Sand to craft Beach 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_BEACH_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_BEACH,\n    ACHIEVEMENT_CRAFT_100_MAKE_BEACH,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_WETSTONE: IAchievement = {\n    id: \"craft:62/1\",\n    name: \"Craft 'Make Wetstone' once\",\n    description: \"You have combined Water and Obsidian to craft Wetstone. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_WETSTONE: IAchievement = {\n    id: \"craft:62/100\",\n    name: \"Craft 'Make Wetstone' 100 times\",\n    description: \"You have made such efforts, to combine Water and Obsidian to craft Wetstone 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_WETSTONE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_WETSTONE,\n    ACHIEVEMENT_CRAFT_100_MAKE_WETSTONE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_EROSION: IAchievement = {\n    id: \"craft:63/1\",\n    name: \"Craft 'Make Erosion' once\",\n    description: \"You have combined Wind and Rock to craft Erosion. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_EROSION: IAchievement = {\n    id: \"craft:63/100\",\n    name: \"Craft 'Make Erosion' 100 times\",\n    description: \"You have made such efforts, to combine Wind and Rock to craft Erosion 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_EROSION_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_EROSION,\n    ACHIEVEMENT_CRAFT_100_MAKE_EROSION,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_BASALT: IAchievement = {\n    id: \"craft:64/1\",\n    name: \"Craft 'Make Basalt' once\",\n    description: \"You have combined Water and Lava to craft Basalt. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_BASALT: IAchievement = {\n    id: \"craft:64/100\",\n    name: \"Craft 'Make Basalt' 100 times\",\n    description: \"You have made such efforts, to combine Water and Lava to craft Basalt 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_BASALT_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_BASALT,\n    ACHIEVEMENT_CRAFT_100_MAKE_BASALT,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_MAGMA_CHAMBER: IAchievement = {\n    id: \"craft:65/1\",\n    name: \"Craft 'Make Magma Chamber' once\",\n    description: \"You have combined Earth and Lava to craft Magma Chamber. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_MAGMA_CHAMBER: IAchievement = {\n    id: \"craft:65/100\",\n    name: \"Craft 'Make Magma Chamber' 100 times\",\n    description: \"You have made such efforts, to combine Earth and Lava to craft Magma Chamber 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_MAGMA_CHAMBER_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_MAGMA_CHAMBER,\n    ACHIEVEMENT_CRAFT_100_MAKE_MAGMA_CHAMBER,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_BREEZE: IAchievement = {\n    id: \"craft:66/1\",\n    name: \"Craft 'Make Breeze' once\",\n    description: \"You have combined Wind and Dust to craft Breeze. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_BREEZE: IAchievement = {\n    id: \"craft:66/100\",\n    name: \"Craft 'Make Breeze' 100 times\",\n    description: \"You have made such efforts, to combine Wind and Dust to craft Breeze 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_BREEZE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_BREEZE,\n    ACHIEVEMENT_CRAFT_100_MAKE_BREEZE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_WARM_BREEZE: IAchievement = {\n    id: \"craft:67/1\",\n    name: \"Craft 'Make Warm Breeze' once\",\n    description: \"You have combined Fire and Breeze to craft Warm Breeze. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_WARM_BREEZE: IAchievement = {\n    id: \"craft:67/100\",\n    name: \"Craft 'Make Warm Breeze' 100 times\",\n    description: \"You have made such efforts, to combine Fire and Breeze to craft Warm Breeze 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_WARM_BREEZE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_WARM_BREEZE,\n    ACHIEVEMENT_CRAFT_100_MAKE_WARM_BREEZE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_SOIL: IAchievement = {\n    id: \"craft:68/1\",\n    name: \"Craft 'Make Soil' once\",\n    description: \"You have combined Earth and Plant to craft Soil. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_SOIL: IAchievement = {\n    id: \"craft:68/100\",\n    name: \"Craft 'Make Soil' 100 times\",\n    description: \"You have made such efforts, to combine Earth and Plant to craft Soil 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_SOIL_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_SOIL,\n    ACHIEVEMENT_CRAFT_100_MAKE_SOIL,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_CANYON: IAchievement = {\n    id: \"craft:69/1\",\n    name: \"Craft 'Make Canyon' once\",\n    description: \"You have combined Water and Erosion to craft Canyon. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_CANYON: IAchievement = {\n    id: \"craft:69/100\",\n    name: \"Craft 'Make Canyon' 100 times\",\n    description: \"You have made such efforts, to combine Water and Erosion to craft Canyon 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_CANYON_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_CANYON,\n    ACHIEVEMENT_CRAFT_100_MAKE_CANYON,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_WINDMILL: IAchievement = {\n    id: \"craft:70/1\",\n    name: \"Craft 'Make Windmill' once\",\n    description: \"You have combined Wind and Plant to craft Windmill. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_WINDMILL: IAchievement = {\n    id: \"craft:70/100\",\n    name: \"Craft 'Make Windmill' 100 times\",\n    description: \"You have made such efforts, to combine Wind and Plant to craft Windmill 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_WINDMILL_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_WINDMILL,\n    ACHIEVEMENT_CRAFT_100_MAKE_WINDMILL,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_ADOBE: IAchievement = {\n    id: \"craft:71/1\",\n    name: \"Craft 'Make Adobe' once\",\n    description: \"You have combined Earth and Clay to craft Adobe. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_ADOBE: IAchievement = {\n    id: \"craft:71/100\",\n    name: \"Craft 'Make Adobe' 100 times\",\n    description: \"You have made such efforts, to combine Earth and Clay to craft Adobe 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_ADOBE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_ADOBE,\n    ACHIEVEMENT_CRAFT_100_MAKE_ADOBE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_WALL: IAchievement = {\n    id: \"craft:72/1\",\n    name: \"Craft 'Make Wall' once\",\n    description: \"You have combined Earth and Brick to craft Wall. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_WALL: IAchievement = {\n    id: \"craft:72/100\",\n    name: \"Craft 'Make Wall' 100 times\",\n    description: \"You have made such efforts, to combine Earth and Brick to craft Wall 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_WALL_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_WALL,\n    ACHIEVEMENT_CRAFT_100_MAKE_WALL,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_PUMICE: IAchievement = {\n    id: \"craft:73/1\",\n    name: \"Craft 'Make Pumice' once\",\n    description: \"You have combined Water and Ash to craft Pumice. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_PUMICE: IAchievement = {\n    id: \"craft:73/100\",\n    name: \"Craft 'Make Pumice' 100 times\",\n    description: \"You have made such efforts, to combine Water and Ash to craft Pumice 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_PUMICE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_PUMICE,\n    ACHIEVEMENT_CRAFT_100_MAKE_PUMICE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_BARBECUE: IAchievement = {\n    id: \"craft:74/1\",\n    name: \"Craft 'Make Barbecue' once\",\n    description: \"You have combined Fire and Charcoal to craft Barbecue. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_BARBECUE: IAchievement = {\n    id: \"craft:74/100\",\n    name: \"Craft 'Make Barbecue' 100 times\",\n    description: \"You have made such efforts, to combine Fire and Charcoal to craft Barbecue 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_BARBECUE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_BARBECUE,\n    ACHIEVEMENT_CRAFT_100_MAKE_BARBECUE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_FARM: IAchievement = {\n    id: \"craft:75/1\",\n    name: \"Craft 'Make Farm' once\",\n    description: \"You have combined Earth and Seeds to craft Farm. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_FARM: IAchievement = {\n    id: \"craft:75/100\",\n    name: \"Craft 'Make Farm' 100 times\",\n    description: \"You have made such efforts, to combine Earth and Seeds to craft Farm 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_FARM_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_FARM,\n    ACHIEVEMENT_CRAFT_100_MAKE_FARM,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_SHARDS: IAchievement = {\n    id: \"craft:76/1\",\n    name: \"Craft 'Make Shards' once\",\n    description: \"You have combined Wind and Obsidian to craft Shards. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_SHARDS: IAchievement = {\n    id: \"craft:76/100\",\n    name: \"Craft 'Make Shards' 100 times\",\n    description: \"You have made such efforts, to combine Wind and Obsidian to craft Shards 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_SHARDS_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_SHARDS,\n    ACHIEVEMENT_CRAFT_100_MAKE_SHARDS,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_MOLTEN_GLASS: IAchievement = {\n    id: \"craft:77/1\",\n    name: \"Craft 'Make Molten Glass' once\",\n    description: \"You have combined Fire and Crystal to craft Molten Glass. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_MOLTEN_GLASS: IAchievement = {\n    id: \"craft:77/100\",\n    name: \"Craft 'Make Molten Glass' 100 times\",\n    description: \"You have made such efforts, to combine Fire and Crystal to craft Molten Glass 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_MOLTEN_GLASS_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_MOLTEN_GLASS,\n    ACHIEVEMENT_CRAFT_100_MAKE_MOLTEN_GLASS,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_PRISM: IAchievement = {\n    id: \"craft:78/1\",\n    name: \"Craft 'Make Prism' once\",\n    description: \"You have combined Water and Crystal to craft Prism. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_PRISM: IAchievement = {\n    id: \"craft:78/100\",\n    name: \"Craft 'Make Prism' 100 times\",\n    description: \"You have made such efforts, to combine Water and Crystal to craft Prism 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_PRISM_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_PRISM,\n    ACHIEVEMENT_CRAFT_100_MAKE_PRISM,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_SPARKLE: IAchievement = {\n    id: \"craft:79/1\",\n    name: \"Craft 'Make Sparkle' once\",\n    description: \"You have combined Wind and Crystal to craft Sparkle. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_SPARKLE: IAchievement = {\n    id: \"craft:79/100\",\n    name: \"Craft 'Make Sparkle' 100 times\",\n    description: \"You have made such efforts, to combine Wind and Crystal to craft Sparkle 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_SPARKLE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_SPARKLE,\n    ACHIEVEMENT_CRAFT_100_MAKE_SPARKLE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_DESERT: IAchievement = {\n    id: \"craft:80/1\",\n    name: \"Craft 'Make Desert' once\",\n    description: \"You have combined Earth and Beach to craft Desert. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_DESERT: IAchievement = {\n    id: \"craft:80/100\",\n    name: \"Craft 'Make Desert' 100 times\",\n    description: \"You have made such efforts, to combine Earth and Beach to craft Desert 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_DESERT_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_DESERT,\n    ACHIEVEMENT_CRAFT_100_MAKE_DESERT,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_OASIS: IAchievement = {\n    id: \"craft:81/1\",\n    name: \"Craft 'Make Oasis' once\",\n    description: \"You have combined Water and Desert to craft Oasis. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_OASIS: IAchievement = {\n    id: \"craft:81/100\",\n    name: \"Craft 'Make Oasis' 100 times\",\n    description: \"You have made such efforts, to combine Water and Desert to craft Oasis 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_OASIS_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_OASIS,\n    ACHIEVEMENT_CRAFT_100_MAKE_OASIS,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_MIRAGE: IAchievement = {\n    id: \"craft:82/1\",\n    name: \"Craft 'Make Mirage' once\",\n    description: \"You have combined Fire and Desert to craft Mirage. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_MIRAGE: IAchievement = {\n    id: \"craft:82/100\",\n    name: \"Craft 'Make Mirage' 100 times\",\n    description: \"You have made such efforts, to combine Fire and Desert to craft Mirage 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_MIRAGE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_MIRAGE,\n    ACHIEVEMENT_CRAFT_100_MAKE_MIRAGE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_SAND_DUNE: IAchievement = {\n    id: \"craft:83/1\",\n    name: \"Craft 'Make Sand Dune' once\",\n    description: \"You have combined Wind and Desert to craft Sand Dune. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_SAND_DUNE: IAchievement = {\n    id: \"craft:83/100\",\n    name: \"Craft 'Make Sand Dune' 100 times\",\n    description: \"You have made such efforts, to combine Wind and Desert to craft Sand Dune 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_SAND_DUNE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_SAND_DUNE,\n    ACHIEVEMENT_CRAFT_100_MAKE_SAND_DUNE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_DAM: IAchievement = {\n    id: \"craft:84/1\",\n    name: \"Craft 'Make Dam' once\",\n    description: \"You have combined Water and Wall to craft Dam. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_DAM: IAchievement = {\n    id: \"craft:84/100\",\n    name: \"Craft 'Make Dam' 100 times\",\n    description: \"You have made such efforts, to combine Water and Wall to craft Dam 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_DAM_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_DAM,\n    ACHIEVEMENT_CRAFT_100_MAKE_DAM,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_FIREWALL: IAchievement = {\n    id: \"craft:85/1\",\n    name: \"Craft 'Make Firewall' once\",\n    description: \"You have combined Fire and Wall to craft Firewall. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_FIREWALL: IAchievement = {\n    id: \"craft:85/100\",\n    name: \"Craft 'Make Firewall' 100 times\",\n    description: \"You have made such efforts, to combine Fire and Wall to craft Firewall 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_FIREWALL_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_FIREWALL,\n    ACHIEVEMENT_CRAFT_100_MAKE_FIREWALL,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_BARRICADE: IAchievement = {\n    id: \"craft:86/1\",\n    name: \"Craft 'Make Barricade' once\",\n    description: \"You have combined Wind and Wall to craft Barricade. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_BARRICADE: IAchievement = {\n    id: \"craft:86/100\",\n    name: \"Craft 'Make Barricade' 100 times\",\n    description: \"You have made such efforts, to combine Wind and Wall to craft Barricade 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_BARRICADE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_BARRICADE,\n    ACHIEVEMENT_CRAFT_100_MAKE_BARRICADE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_PLATEAU: IAchievement = {\n    id: \"craft:87/1\",\n    name: \"Craft 'Make Plateau' once\",\n    description: \"You have combined Earth and Canyon to craft Plateau. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_PLATEAU: IAchievement = {\n    id: \"craft:87/100\",\n    name: \"Craft 'Make Plateau' 100 times\",\n    description: \"You have made such efforts, to combine Earth and Canyon to craft Plateau 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_PLATEAU_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_PLATEAU,\n    ACHIEVEMENT_CRAFT_100_MAKE_PLATEAU,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_POND: IAchievement = {\n    id: \"craft:88/1\",\n    name: \"Craft 'Make Pond' once\",\n    description: \"You have combined Water and Garden to craft Pond. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_POND: IAchievement = {\n    id: \"craft:88/100\",\n    name: \"Craft 'Make Pond' 100 times\",\n    description: \"You have made such efforts, to combine Water and Garden to craft Pond 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_POND_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_POND,\n    ACHIEVEMENT_CRAFT_100_MAKE_POND,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_AROMAS: IAchievement = {\n    id: \"craft:89/1\",\n    name: \"Craft 'Make Aromas' once\",\n    description: \"You have combined Wind and Garden to craft Aromas. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_AROMAS: IAchievement = {\n    id: \"craft:89/100\",\n    name: \"Craft 'Make Aromas' 100 times\",\n    description: \"You have made such efforts, to combine Wind and Garden to craft Aromas 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_AROMAS_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_AROMAS,\n    ACHIEVEMENT_CRAFT_100_MAKE_AROMAS,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_FLOWER: IAchievement = {\n    id: \"craft:90/1\",\n    name: \"Craft 'Make Flower' once\",\n    description: \"You have combined Water and Pollination to craft Flower. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_FLOWER: IAchievement = {\n    id: \"craft:90/100\",\n    name: \"Craft 'Make Flower' 100 times\",\n    description: \"You have made such efforts, to combine Water and Pollination to craft Flower 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_FLOWER_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_FLOWER,\n    ACHIEVEMENT_CRAFT_100_MAKE_FLOWER,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_SPORE: IAchievement = {\n    id: \"craft:91/1\",\n    name: \"Craft 'Make Spore' once\",\n    description: \"You have combined Fire and Pollination to craft Spore. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_SPORE: IAchievement = {\n    id: \"craft:91/100\",\n    name: \"Craft 'Make Spore' 100 times\",\n    description: \"You have made such efforts, to combine Fire and Pollination to craft Spore 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_SPORE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_SPORE,\n    ACHIEVEMENT_CRAFT_100_MAKE_SPORE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_SPREAD: IAchievement = {\n    id: \"craft:92/1\",\n    name: \"Craft 'Make Spread' once\",\n    description: \"You have combined Wind and Pollination to craft Spread. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_SPREAD: IAchievement = {\n    id: \"craft:92/100\",\n    name: \"Craft 'Make Spread' 100 times\",\n    description: \"You have made such efforts, to combine Wind and Pollination to craft Spread 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_SPREAD_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_SPREAD,\n    ACHIEVEMENT_CRAFT_100_MAKE_SPREAD,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_FERTILE_LAND: IAchievement = {\n    id: \"craft:93/1\",\n    name: \"Craft 'Make Fertile Land' once\",\n    description: \"You have combined Earth and Soil to craft Fertile Land. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_FERTILE_LAND: IAchievement = {\n    id: \"craft:93/100\",\n    name: \"Craft 'Make Fertile Land' 100 times\",\n    description: \"You have made such efforts, to combine Earth and Soil to craft Fertile Land 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_FERTILE_LAND_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_FERTILE_LAND,\n    ACHIEVEMENT_CRAFT_100_MAKE_FERTILE_LAND,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_WETLAND: IAchievement = {\n    id: \"craft:94/1\",\n    name: \"Craft 'Make Wetland' once\",\n    description: \"You have combined Water and Fertile Land to craft Wetland. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_WETLAND: IAchievement = {\n    id: \"craft:94/100\",\n    name: \"Craft 'Make Wetland' 100 times\",\n    description: \"You have made such efforts, to combine Water and Fertile Land to craft Wetland 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_WETLAND_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_WETLAND,\n    ACHIEVEMENT_CRAFT_100_MAKE_WETLAND,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_PEAT: IAchievement = {\n    id: \"craft:95/1\",\n    name: \"Craft 'Make Peat' once\",\n    description: \"You have combined Fire and Wetland to craft Peat. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_PEAT: IAchievement = {\n    id: \"craft:95/100\",\n    name: \"Craft 'Make Peat' 100 times\",\n    description: \"You have made such efforts, to combine Fire and Wetland to craft Peat 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_PEAT_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_PEAT,\n    ACHIEVEMENT_CRAFT_100_MAKE_PEAT,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_REEDS: IAchievement = {\n    id: \"craft:96/1\",\n    name: \"Craft 'Make Reeds' once\",\n    description: \"You have combined Wind and Wetland to craft Reeds. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_REEDS: IAchievement = {\n    id: \"craft:96/100\",\n    name: \"Craft 'Make Reeds' 100 times\",\n    description: \"You have made such efforts, to combine Wind and Wetland to craft Reeds 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_REEDS_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_REEDS,\n    ACHIEVEMENT_CRAFT_100_MAKE_REEDS,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_VALLEY: IAchievement = {\n    id: \"craft:97/1\",\n    name: \"Craft 'Make Valley' once\",\n    description: \"You have combined Earth and Canyon to craft Valley. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_VALLEY: IAchievement = {\n    id: \"craft:97/100\",\n    name: \"Craft 'Make Valley' 100 times\",\n    description: \"You have made such efforts, to combine Earth and Canyon to craft Valley 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_VALLEY_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_VALLEY,\n    ACHIEVEMENT_CRAFT_100_MAKE_VALLEY,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_RIVER: IAchievement = {\n    id: \"craft:98/1\",\n    name: \"Craft 'Make River' once\",\n    description: \"You have combined Water and Valley to craft River. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_RIVER: IAchievement = {\n    id: \"craft:98/100\",\n    name: \"Craft 'Make River' 100 times\",\n    description: \"You have made such efforts, to combine Water and Valley to craft River 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_RIVER_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_RIVER,\n    ACHIEVEMENT_CRAFT_100_MAKE_RIVER,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_SCORCHED_EARTH: IAchievement = {\n    id: \"craft:99/1\",\n    name: \"Craft 'Make Scorched Earth' once\",\n    description: \"You have combined Fire and Valley to craft Scorched Earth. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_SCORCHED_EARTH: IAchievement = {\n    id: \"craft:99/100\",\n    name: \"Craft 'Make Scorched Earth' 100 times\",\n    description: \"You have made such efforts, to combine Fire and Valley to craft Scorched Earth 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_SCORCHED_EARTH_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_SCORCHED_EARTH,\n    ACHIEVEMENT_CRAFT_100_MAKE_SCORCHED_EARTH,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_DELTA: IAchievement = {\n    id: \"craft:100/1\",\n    name: \"Craft 'Make Delta' once\",\n    description: \"You have combined Earth and River to craft Delta. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_DELTA: IAchievement = {\n    id: \"craft:100/100\",\n    name: \"Craft 'Make Delta' 100 times\",\n    description: \"You have made such efforts, to combine Earth and River to craft Delta 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_DELTA_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_DELTA,\n    ACHIEVEMENT_CRAFT_100_MAKE_DELTA,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_ESTUARY: IAchievement = {\n    id: \"craft:101/1\",\n    name: \"Craft 'Make Estuary' once\",\n    description: \"You have combined Water and Delta to craft Estuary. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_ESTUARY: IAchievement = {\n    id: \"craft:101/100\",\n    name: \"Craft 'Make Estuary' 100 times\",\n    description: \"You have made such efforts, to combine Water and Delta to craft Estuary 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_ESTUARY_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_ESTUARY,\n    ACHIEVEMENT_CRAFT_100_MAKE_ESTUARY,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_FIRE_SWAMP: IAchievement = {\n    id: \"craft:102/1\",\n    name: \"Craft 'Make Fire Swamp' once\",\n    description: \"You have combined Fire and Delta to craft Fire Swamp. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_FIRE_SWAMP: IAchievement = {\n    id: \"craft:102/100\",\n    name: \"Craft 'Make Fire Swamp' 100 times\",\n    description: \"You have made such efforts, to combine Fire and Delta to craft Fire Swamp 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_FIRE_SWAMP_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_FIRE_SWAMP,\n    ACHIEVEMENT_CRAFT_100_MAKE_FIRE_SWAMP,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_RIVERBANK: IAchievement = {\n    id: \"craft:103/1\",\n    name: \"Craft 'Make Riverbank' once\",\n    description: \"You have combined Wind and Delta to craft Riverbank. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_RIVERBANK: IAchievement = {\n    id: \"craft:103/100\",\n    name: \"Craft 'Make Riverbank' 100 times\",\n    description: \"You have made such efforts, to combine Wind and Delta to craft Riverbank 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_RIVERBANK_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_RIVERBANK,\n    ACHIEVEMENT_CRAFT_100_MAKE_RIVERBANK,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_RAVINE: IAchievement = {\n    id: \"craft:104/1\",\n    name: \"Craft 'Make Ravine' once\",\n    description: \"You have combined Earth and Erosion to craft Ravine. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_RAVINE: IAchievement = {\n    id: \"craft:104/100\",\n    name: \"Craft 'Make Ravine' 100 times\",\n    description: \"You have made such efforts, to combine Earth and Erosion to craft Ravine 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_RAVINE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_RAVINE,\n    ACHIEVEMENT_CRAFT_100_MAKE_RAVINE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_GORGE: IAchievement = {\n    id: \"craft:105/1\",\n    name: \"Craft 'Make Gorge' once\",\n    description: \"You have combined Water and Ravine to craft Gorge. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_GORGE: IAchievement = {\n    id: \"craft:105/100\",\n    name: \"Craft 'Make Gorge' 100 times\",\n    description: \"You have made such efforts, to combine Water and Ravine to craft Gorge 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_GORGE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_GORGE,\n    ACHIEVEMENT_CRAFT_100_MAKE_GORGE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_CHARRED_RAVINE: IAchievement = {\n    id: \"craft:106/1\",\n    name: \"Craft 'Make Charred Ravine' once\",\n    description: \"You have combined Fire and Ravine to craft Charred Ravine. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_CHARRED_RAVINE: IAchievement = {\n    id: \"craft:106/100\",\n    name: \"Craft 'Make Charred Ravine' 100 times\",\n    description: \"You have made such efforts, to combine Fire and Ravine to craft Charred Ravine 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_CHARRED_RAVINE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_CHARRED_RAVINE,\n    ACHIEVEMENT_CRAFT_100_MAKE_CHARRED_RAVINE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_ECHO: IAchievement = {\n    id: \"craft:107/1\",\n    name: \"Craft 'Make Echo' once\",\n    description: \"You have combined Wind and Ravine to craft Echo. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_ECHO: IAchievement = {\n    id: \"craft:107/100\",\n    name: \"Craft 'Make Echo' 100 times\",\n    description: \"You have made such efforts, to combine Wind and Ravine to craft Echo 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_ECHO_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_ECHO,\n    ACHIEVEMENT_CRAFT_100_MAKE_ECHO,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_CAVE: IAchievement = {\n    id: \"craft:108/1\",\n    name: \"Craft 'Make Cave' once\",\n    description: \"You have combined Earth and Echo to craft Cave. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_CAVE: IAchievement = {\n    id: \"craft:108/100\",\n    name: \"Craft 'Make Cave' 100 times\",\n    description: \"You have made such efforts, to combine Earth and Echo to craft Cave 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_CAVE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_CAVE,\n    ACHIEVEMENT_CRAFT_100_MAKE_CAVE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_UNDERGROUND_LAKE: IAchievement = {\n    id: \"craft:109/1\",\n    name: \"Craft 'Make Underground Lake' once\",\n    description: \"You have combined Water and Cave to craft Underground Lake. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_UNDERGROUND_LAKE: IAchievement = {\n    id: \"craft:109/100\",\n    name: \"Craft 'Make Underground Lake' 100 times\",\n    description: \"You have made such efforts, to combine Water and Cave to craft Underground Lake 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_UNDERGROUND_LAKE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_UNDERGROUND_LAKE,\n    ACHIEVEMENT_CRAFT_100_MAKE_UNDERGROUND_LAKE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_LAVA_CAVE: IAchievement = {\n    id: \"craft:110/1\",\n    name: \"Craft 'Make Lava Cave' once\",\n    description: \"You have combined Fire and Cave to craft Lava Cave. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_LAVA_CAVE: IAchievement = {\n    id: \"craft:110/100\",\n    name: \"Craft 'Make Lava Cave' 100 times\",\n    description: \"You have made such efforts, to combine Fire and Cave to craft Lava Cave 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_LAVA_CAVE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_LAVA_CAVE,\n    ACHIEVEMENT_CRAFT_100_MAKE_LAVA_CAVE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_WHISPERING_CAVE: IAchievement = {\n    id: \"craft:111/1\",\n    name: \"Craft 'Make Whispering Cave' once\",\n    description: \"You have combined Wind and Cave to craft Whispering Cave. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_WHISPERING_CAVE: IAchievement = {\n    id: \"craft:111/100\",\n    name: \"Craft 'Make Whispering Cave' 100 times\",\n    description: \"You have made such efforts, to combine Wind and Cave to craft Whispering Cave 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_WHISPERING_CAVE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_WHISPERING_CAVE,\n    ACHIEVEMENT_CRAFT_100_MAKE_WHISPERING_CAVE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_SUBTERRANEAN_POOL: IAchievement = {\n    id: \"craft:112/1\",\n    name: \"Craft 'Make Subterranean Pool' once\",\n    description: \"You have combined Earth and Underground Lake to craft Subterranean Pool. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_SUBTERRANEAN_POOL: IAchievement = {\n    id: \"craft:112/100\",\n    name: \"Craft 'Make Subterranean Pool' 100 times\",\n    description: \"You have made such efforts, to combine Earth and Underground Lake to craft Subterranean Pool 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_SUBTERRANEAN_POOL_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_SUBTERRANEAN_POOL,\n    ACHIEVEMENT_CRAFT_100_MAKE_SUBTERRANEAN_POOL,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_SPRING: IAchievement = {\n    id: \"craft:113/1\",\n    name: \"Craft 'Make Spring' once\",\n    description: \"You have combined Water and Subterranean Pool to craft Spring. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_SPRING: IAchievement = {\n    id: \"craft:113/100\",\n    name: \"Craft 'Make Spring' 100 times\",\n    description: \"You have made such efforts, to combine Water and Subterranean Pool to craft Spring 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_SPRING_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_SPRING,\n    ACHIEVEMENT_CRAFT_100_MAKE_SPRING,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_HOT_SPRING: IAchievement = {\n    id: \"craft:114/1\",\n    name: \"Craft 'Make Hot Spring' once\",\n    description: \"You have combined Fire and Subterranean Pool to craft Hot Spring. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_HOT_SPRING: IAchievement = {\n    id: \"craft:114/100\",\n    name: \"Craft 'Make Hot Spring' 100 times\",\n    description: \"You have made such efforts, to combine Fire and Subterranean Pool to craft Hot Spring 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_HOT_SPRING_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_HOT_SPRING,\n    ACHIEVEMENT_CRAFT_100_MAKE_HOT_SPRING,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_GROTTO: IAchievement = {\n    id: \"craft:115/1\",\n    name: \"Craft 'Make Grotto' once\",\n    description: \"You have combined Wind and Subterranean Pool to craft Grotto. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_GROTTO: IAchievement = {\n    id: \"craft:115/100\",\n    name: \"Craft 'Make Grotto' 100 times\",\n    description: \"You have made such efforts, to combine Wind and Subterranean Pool to craft Grotto 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_GROTTO_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_GROTTO,\n    ACHIEVEMENT_CRAFT_100_MAKE_GROTTO,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_FOUNTAIN: IAchievement = {\n    id: \"craft:116/1\",\n    name: \"Craft 'Make Fountain' once\",\n    description: \"You have combined Water and Spring to craft Fountain. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_FOUNTAIN: IAchievement = {\n    id: \"craft:116/100\",\n    name: \"Craft 'Make Fountain' 100 times\",\n    description: \"You have made such efforts, to combine Water and Spring to craft Fountain 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_FOUNTAIN_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_FOUNTAIN,\n    ACHIEVEMENT_CRAFT_100_MAKE_FOUNTAIN,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_STEAM_VENT: IAchievement = {\n    id: \"craft:117/1\",\n    name: \"Craft 'Make Steam Vent' once\",\n    description: \"You have combined Fire and Spring to craft Steam Vent. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_STEAM_VENT: IAchievement = {\n    id: \"craft:117/100\",\n    name: \"Craft 'Make Steam Vent' 100 times\",\n    description: \"You have made such efforts, to combine Fire and Spring to craft Steam Vent 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_STEAM_VENT_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_STEAM_VENT,\n    ACHIEVEMENT_CRAFT_100_MAKE_STEAM_VENT,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_COOL_BREEZE: IAchievement = {\n    id: \"craft:118/1\",\n    name: \"Craft 'Make Cool Breeze' once\",\n    description: \"You have combined Wind and Spring to craft Cool Breeze. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_COOL_BREEZE: IAchievement = {\n    id: \"craft:118/100\",\n    name: \"Craft 'Make Cool Breeze' 100 times\",\n    description: \"You have made such efforts, to combine Wind and Spring to craft Cool Breeze 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_COOL_BREEZE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_COOL_BREEZE,\n    ACHIEVEMENT_CRAFT_100_MAKE_COOL_BREEZE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_MONUMENT: IAchievement = {\n    id: \"craft:119/1\",\n    name: \"Craft 'Make Monument' once\",\n    description: \"You have combined Earth and Fountain to craft Monument. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_MONUMENT: IAchievement = {\n    id: \"craft:119/100\",\n    name: \"Craft 'Make Monument' 100 times\",\n    description: \"You have made such efforts, to combine Earth and Fountain to craft Monument 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_MONUMENT_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_MONUMENT,\n    ACHIEVEMENT_CRAFT_100_MAKE_MONUMENT,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_WATERFALL: IAchievement = {\n    id: \"craft:120/1\",\n    name: \"Craft 'Make Waterfall' once\",\n    description: \"You have combined Water and Monument to craft Waterfall. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_WATERFALL: IAchievement = {\n    id: \"craft:120/100\",\n    name: \"Craft 'Make Waterfall' 100 times\",\n    description: \"You have made such efforts, to combine Water and Monument to craft Waterfall 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_WATERFALL_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_WATERFALL,\n    ACHIEVEMENT_CRAFT_100_MAKE_WATERFALL,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_ETERNAL_FLAME: IAchievement = {\n    id: \"craft:121/1\",\n    name: \"Craft 'Make Eternal Flame' once\",\n    description: \"You have combined Fire and Monument to craft Eternal Flame. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_ETERNAL_FLAME: IAchievement = {\n    id: \"craft:121/100\",\n    name: \"Craft 'Make Eternal Flame' 100 times\",\n    description: \"You have made such efforts, to combine Fire and Monument to craft Eternal Flame 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_ETERNAL_FLAME_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_ETERNAL_FLAME,\n    ACHIEVEMENT_CRAFT_100_MAKE_ETERNAL_FLAME,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_PILLAR_OF_WIND: IAchievement = {\n    id: \"craft:122/1\",\n    name: \"Craft 'Make Pillar Of Wind' once\",\n    description: \"You have combined Wind and Monument to craft Pillar Of Wind. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_PILLAR_OF_WIND: IAchievement = {\n    id: \"craft:122/100\",\n    name: \"Craft 'Make Pillar Of Wind' 100 times\",\n    description: \"You have made such efforts, to combine Wind and Monument to craft Pillar Of Wind 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_PILLAR_OF_WIND_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_PILLAR_OF_WIND,\n    ACHIEVEMENT_CRAFT_100_MAKE_PILLAR_OF_WIND,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_STREAM: IAchievement = {\n    id: \"craft:123/1\",\n    name: \"Craft 'Make Stream' once\",\n    description: \"You have combined Water and River to craft Stream. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_STREAM: IAchievement = {\n    id: \"craft:123/100\",\n    name: \"Craft 'Make Stream' 100 times\",\n    description: \"You have made such efforts, to combine Water and River to craft Stream 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_STREAM_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_STREAM,\n    ACHIEVEMENT_CRAFT_100_MAKE_STREAM,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_ZEPHYR: IAchievement = {\n    id: \"craft:124/1\",\n    name: \"Craft 'Make Zephyr' once\",\n    description: \"You have combined Wind and River to craft Zephyr. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_ZEPHYR: IAchievement = {\n    id: \"craft:124/100\",\n    name: \"Craft 'Make Zephyr' 100 times\",\n    description: \"You have made such efforts, to combine Wind and River to craft Zephyr 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_ZEPHYR_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_ZEPHYR,\n    ACHIEVEMENT_CRAFT_100_MAKE_ZEPHYR,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_CREEK: IAchievement = {\n    id: \"craft:125/1\",\n    name: \"Craft 'Make Creek' once\",\n    description: \"You have combined Earth and Stream to craft Creek. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_CREEK: IAchievement = {\n    id: \"craft:125/100\",\n    name: \"Craft 'Make Creek' 100 times\",\n    description: \"You have made such efforts, to combine Earth and Stream to craft Creek 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_CREEK_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_CREEK,\n    ACHIEVEMENT_CRAFT_100_MAKE_CREEK,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_BROOK: IAchievement = {\n    id: \"craft:126/1\",\n    name: \"Craft 'Make Brook' once\",\n    description: \"You have combined Water and Creek to craft Brook. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_BROOK: IAchievement = {\n    id: \"craft:126/100\",\n    name: \"Craft 'Make Brook' 100 times\",\n    description: \"You have made such efforts, to combine Water and Creek to craft Brook 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_BROOK_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_BROOK,\n    ACHIEVEMENT_CRAFT_100_MAKE_BROOK,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_WHISPER: IAchievement = {\n    id: \"craft:127/1\",\n    name: \"Craft 'Make Whisper' once\",\n    description: \"You have combined Wind and Creek to craft Whisper. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_WHISPER: IAchievement = {\n    id: \"craft:127/100\",\n    name: \"Craft 'Make Whisper' 100 times\",\n    description: \"You have made such efforts, to combine Wind and Creek to craft Whisper 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_WHISPER_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_WHISPER,\n    ACHIEVEMENT_CRAFT_100_MAKE_WHISPER,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_RIVULET: IAchievement = {\n    id: \"craft:128/1\",\n    name: \"Craft 'Make Rivulet' once\",\n    description: \"You have combined Earth and Brook to craft Rivulet. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_RIVULET: IAchievement = {\n    id: \"craft:128/100\",\n    name: \"Craft 'Make Rivulet' 100 times\",\n    description: \"You have made such efforts, to combine Earth and Brook to craft Rivulet 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_RIVULET_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_RIVULET,\n    ACHIEVEMENT_CRAFT_100_MAKE_RIVULET,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_TRIBUTARY: IAchievement = {\n    id: \"craft:129/1\",\n    name: \"Craft 'Make Tributary' once\",\n    description: \"You have combined Water and Rivulet to craft Tributary. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_TRIBUTARY: IAchievement = {\n    id: \"craft:129/100\",\n    name: \"Craft 'Make Tributary' 100 times\",\n    description: \"You have made such efforts, to combine Water and Rivulet to craft Tributary 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_TRIBUTARY_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_TRIBUTARY,\n    ACHIEVEMENT_CRAFT_100_MAKE_TRIBUTARY,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_MURMUR: IAchievement = {\n    id: \"craft:130/1\",\n    name: \"Craft 'Make Murmur' once\",\n    description: \"You have combined Wind and Rivulet to craft Murmur. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_MURMUR: IAchievement = {\n    id: \"craft:130/100\",\n    name: \"Craft 'Make Murmur' 100 times\",\n    description: \"You have made such efforts, to combine Wind and Rivulet to craft Murmur 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_MURMUR_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_MURMUR,\n    ACHIEVEMENT_CRAFT_100_MAKE_MURMUR,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_WATERSHED: IAchievement = {\n    id: \"craft:131/1\",\n    name: \"Craft 'Make Watershed' once\",\n    description: \"You have combined Earth and Tributary to craft Watershed. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_WATERSHED: IAchievement = {\n    id: \"craft:131/100\",\n    name: \"Craft 'Make Watershed' 100 times\",\n    description: \"You have made such efforts, to combine Earth and Tributary to craft Watershed 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_WATERSHED_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_WATERSHED,\n    ACHIEVEMENT_CRAFT_100_MAKE_WATERSHED,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_AQUIFER: IAchievement = {\n    id: \"craft:132/1\",\n    name: \"Craft 'Make Aquifer' once\",\n    description: \"You have combined Water and Watershed to craft Aquifer. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_AQUIFER: IAchievement = {\n    id: \"craft:132/100\",\n    name: \"Craft 'Make Aquifer' 100 times\",\n    description: \"You have made such efforts, to combine Water and Watershed to craft Aquifer 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_AQUIFER_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_AQUIFER,\n    ACHIEVEMENT_CRAFT_100_MAKE_AQUIFER,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_PARCHED_EARTH: IAchievement = {\n    id: \"craft:133/1\",\n    name: \"Craft 'Make Parched Earth' once\",\n    description: \"You have combined Fire and Watershed to craft Parched Earth. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_PARCHED_EARTH: IAchievement = {\n    id: \"craft:133/100\",\n    name: \"Craft 'Make Parched Earth' 100 times\",\n    description: \"You have made such efforts, to combine Fire and Watershed to craft Parched Earth 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_PARCHED_EARTH_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_PARCHED_EARTH,\n    ACHIEVEMENT_CRAFT_100_MAKE_PARCHED_EARTH,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_FRESH_BREEZE: IAchievement = {\n    id: \"craft:134/1\",\n    name: \"Craft 'Make Fresh Breeze' once\",\n    description: \"You have combined Wind and Watershed to craft Fresh Breeze. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_FRESH_BREEZE: IAchievement = {\n    id: \"craft:134/100\",\n    name: \"Craft 'Make Fresh Breeze' 100 times\",\n    description: \"You have made such efforts, to combine Wind and Watershed to craft Fresh Breeze 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_FRESH_BREEZE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_FRESH_BREEZE,\n    ACHIEVEMENT_CRAFT_100_MAKE_FRESH_BREEZE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_GROUNDWATER: IAchievement = {\n    id: \"craft:135/1\",\n    name: \"Craft 'Make Groundwater' once\",\n    description: \"You have combined Earth and Aquifer to craft Groundwater. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_GROUNDWATER: IAchievement = {\n    id: \"craft:135/100\",\n    name: \"Craft 'Make Groundwater' 100 times\",\n    description: \"You have made such efforts, to combine Earth and Aquifer to craft Groundwater 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_GROUNDWATER_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_GROUNDWATER,\n    ACHIEVEMENT_CRAFT_100_MAKE_GROUNDWATER,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_RESERVOIR: IAchievement = {\n    id: \"craft:136/1\",\n    name: \"Craft 'Make Reservoir' once\",\n    description: \"You have combined Water and Groundwater to craft Reservoir. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_RESERVOIR: IAchievement = {\n    id: \"craft:136/100\",\n    name: \"Craft 'Make Reservoir' 100 times\",\n    description: \"You have made such efforts, to combine Water and Groundwater to craft Reservoir 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_RESERVOIR_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_RESERVOIR,\n    ACHIEVEMENT_CRAFT_100_MAKE_RESERVOIR,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_GEOTHERMAL_SPRING: IAchievement = {\n    id: \"craft:137/1\",\n    name: \"Craft 'Make Geothermal Spring' once\",\n    description: \"You have combined Fire and Groundwater to craft Geothermal Spring. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_GEOTHERMAL_SPRING: IAchievement = {\n    id: \"craft:137/100\",\n    name: \"Craft 'Make Geothermal Spring' 100 times\",\n    description: \"You have made such efforts, to combine Fire and Groundwater to craft Geothermal Spring 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_GEOTHERMAL_SPRING_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_GEOTHERMAL_SPRING,\n    ACHIEVEMENT_CRAFT_100_MAKE_GEOTHERMAL_SPRING,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_ARTESIAN_WELL: IAchievement = {\n    id: \"craft:138/1\",\n    name: \"Craft 'Make Artesian Well' once\",\n    description: \"You have combined Wind and Groundwater to craft Artesian Well. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_ARTESIAN_WELL: IAchievement = {\n    id: \"craft:138/100\",\n    name: \"Craft 'Make Artesian Well' 100 times\",\n    description: \"You have made such efforts, to combine Wind and Groundwater to craft Artesian Well 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_ARTESIAN_WELL_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_ARTESIAN_WELL,\n    ACHIEVEMENT_CRAFT_100_MAKE_ARTESIAN_WELL,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_BASIN: IAchievement = {\n    id: \"craft:139/1\",\n    name: \"Craft 'Make Basin' once\",\n    description: \"You have combined Earth and Reservoir to craft Basin. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_BASIN: IAchievement = {\n    id: \"craft:139/100\",\n    name: \"Craft 'Make Basin' 100 times\",\n    description: \"You have made such efforts, to combine Earth and Reservoir to craft Basin 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_BASIN_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_BASIN,\n    ACHIEVEMENT_CRAFT_100_MAKE_BASIN,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_LAKE: IAchievement = {\n    id: \"craft:140/1\",\n    name: \"Craft 'Make Lake' once\",\n    description: \"You have combined Water and Basin to craft Lake. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_LAKE: IAchievement = {\n    id: \"craft:140/100\",\n    name: \"Craft 'Make Lake' 100 times\",\n    description: \"You have made such efforts, to combine Water and Basin to craft Lake 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_LAKE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_LAKE,\n    ACHIEVEMENT_CRAFT_100_MAKE_LAKE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_DRY_BASIN: IAchievement = {\n    id: \"craft:141/1\",\n    name: \"Craft 'Make Dry Basin' once\",\n    description: \"You have combined Fire and Basin to craft Dry Basin. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_DRY_BASIN: IAchievement = {\n    id: \"craft:141/100\",\n    name: \"Craft 'Make Dry Basin' 100 times\",\n    description: \"You have made such efforts, to combine Fire and Basin to craft Dry Basin 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_DRY_BASIN_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_DRY_BASIN,\n    ACHIEVEMENT_CRAFT_100_MAKE_DRY_BASIN,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_DEPRESSION: IAchievement = {\n    id: \"craft:142/1\",\n    name: \"Craft 'Make Depression' once\",\n    description: \"You have combined Wind and Basin to craft Depression. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_DEPRESSION: IAchievement = {\n    id: \"craft:142/100\",\n    name: \"Craft 'Make Depression' 100 times\",\n    description: \"You have made such efforts, to combine Wind and Basin to craft Depression 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_DEPRESSION_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_DEPRESSION,\n    ACHIEVEMENT_CRAFT_100_MAKE_DEPRESSION,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_ISLAND: IAchievement = {\n    id: \"craft:143/1\",\n    name: \"Craft 'Make Island' once\",\n    description: \"You have combined Earth and Lake to craft Island. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_ISLAND: IAchievement = {\n    id: \"craft:143/100\",\n    name: \"Craft 'Make Island' 100 times\",\n    description: \"You have made such efforts, to combine Earth and Lake to craft Island 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_ISLAND_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_ISLAND,\n    ACHIEVEMENT_CRAFT_100_MAKE_ISLAND,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_LAGOON: IAchievement = {\n    id: \"craft:144/1\",\n    name: \"Craft 'Make Lagoon' once\",\n    description: \"You have combined Water and Lake to craft Lagoon. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_LAGOON: IAchievement = {\n    id: \"craft:144/100\",\n    name: \"Craft 'Make Lagoon' 100 times\",\n    description: \"You have made such efforts, to combine Water and Lake to craft Lagoon 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_LAGOON_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_LAGOON,\n    ACHIEVEMENT_CRAFT_100_MAKE_LAGOON,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_WAVE: IAchievement = {\n    id: \"craft:145/1\",\n    name: \"Craft 'Make Wave' once\",\n    description: \"You have combined Wind and Lake to craft Wave. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_WAVE: IAchievement = {\n    id: \"craft:145/100\",\n    name: \"Craft 'Make Wave' 100 times\",\n    description: \"You have made such efforts, to combine Wind and Lake to craft Wave 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_WAVE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_WAVE,\n    ACHIEVEMENT_CRAFT_100_MAKE_WAVE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_REEF: IAchievement = {\n    id: \"craft:146/1\",\n    name: \"Craft 'Make Reef' once\",\n    description: \"You have combined Earth and Lagoon to craft Reef. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_REEF: IAchievement = {\n    id: \"craft:146/100\",\n    name: \"Craft 'Make Reef' 100 times\",\n    description: \"You have made such efforts, to combine Earth and Lagoon to craft Reef 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_REEF_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_REEF,\n    ACHIEVEMENT_CRAFT_100_MAKE_REEF,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_CORAL: IAchievement = {\n    id: \"craft:147/1\",\n    name: \"Craft 'Make Coral' once\",\n    description: \"You have combined Water and Reef to craft Coral. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_CORAL: IAchievement = {\n    id: \"craft:147/100\",\n    name: \"Craft 'Make Coral' 100 times\",\n    description: \"You have made such efforts, to combine Water and Reef to craft Coral 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_CORAL_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_CORAL,\n    ACHIEVEMENT_CRAFT_100_MAKE_CORAL,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_WHIRL: IAchievement = {\n    id: \"craft:148/1\",\n    name: \"Craft 'Make Whirl' once\",\n    description: \"You have combined Wind and Reef to craft Whirl. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_WHIRL: IAchievement = {\n    id: \"craft:148/100\",\n    name: \"Craft 'Make Whirl' 100 times\",\n    description: \"You have made such efforts, to combine Wind and Reef to craft Whirl 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_WHIRL_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_WHIRL,\n    ACHIEVEMENT_CRAFT_100_MAKE_WHIRL,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_LIMESTONE: IAchievement = {\n    id: \"craft:149/1\",\n    name: \"Craft 'Make Limestone' once\",\n    description: \"You have combined Earth and Coral to craft Limestone. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_LIMESTONE: IAchievement = {\n    id: \"craft:149/100\",\n    name: \"Craft 'Make Limestone' 100 times\",\n    description: \"You have made such efforts, to combine Earth and Coral to craft Limestone 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_LIMESTONE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_LIMESTONE,\n    ACHIEVEMENT_CRAFT_100_MAKE_LIMESTONE,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_KARST: IAchievement = {\n    id: \"craft:150/1\",\n    name: \"Craft 'Make Karst' once\",\n    description: \"You have combined Water and Limestone to craft Karst. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_KARST: IAchievement = {\n    id: \"craft:150/100\",\n    name: \"Craft 'Make Karst' 100 times\",\n    description: \"You have made such efforts, to combine Water and Limestone to craft Karst 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_KARST_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_KARST,\n    ACHIEVEMENT_CRAFT_100_MAKE_KARST,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_QUICKLIME: IAchievement = {\n    id: \"craft:151/1\",\n    name: \"Craft 'Make Quicklime' once\",\n    description: \"You have combined Fire and Limestone to craft Quicklime. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_QUICKLIME: IAchievement = {\n    id: \"craft:151/100\",\n    name: \"Craft 'Make Quicklime' 100 times\",\n    description: \"You have made such efforts, to combine Fire and Limestone to craft Quicklime 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_QUICKLIME_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_QUICKLIME,\n    ACHIEVEMENT_CRAFT_100_MAKE_QUICKLIME,\n];\nexport const ACHIEVEMENT_CRAFT_1_MAKE_BLOWHOLE: IAchievement = {\n    id: \"craft:152/1\",\n    name: \"Craft 'Make Blowhole' once\",\n    description: \"You have combined Wind and Karst to craft Blowhole. Genius.\",\n};\nexport const ACHIEVEMENT_CRAFT_100_MAKE_BLOWHOLE: IAchievement = {\n    id: \"craft:152/100\",\n    name: \"Craft 'Make Blowhole' 100 times\",\n    description: \"You have made such efforts, to combine Wind and Karst to craft Blowhole 100 times. You are a true master.\",\n};\nexport const RECIPE_MAKE_BLOWHOLE_ACHIEVEMENTS = [\n    ACHIEVEMENT_CRAFT_1_MAKE_BLOWHOLE,\n    ACHIEVEMENT_CRAFT_100_MAKE_BLOWHOLE,\n];\n\nexport const ALL_ACHIEVEMENTS = [\n    ...ITEM_MONKEY_ACHIEVEMENTS,\n    ...ITEM_GIRAFFE_ACHIEVEMENTS,\n    ...ITEM_BEE_ACHIEVEMENTS,\n    ...ITEM_COIN_ACHIEVEMENTS,\n    ...ITEM_SWARM_ACHIEVEMENTS,\n    ...ITEM_HYDRA_ACHIEVEMENTS,\n    ...ITEM_MONKEY_BRANCH_ACHIEVEMENTS,\n    ...ITEM_BRIDGE_ACHIEVEMENTS,\n    ...ITEM_GOLDEN_GATE_ACHIEVEMENTS,\n    ...ITEM_GOLD_ACHIEVEMENTS,\n    ...ITEM_SILVER_ACHIEVEMENTS,\n    ...ITEM_RHODIUM_ACHIEVEMENTS,\n    ...ITEM_HIVE_ACHIEVEMENTS,\n    ...ITEM_TRANSACTION_ACHIEVEMENTS,\n    ...ITEM_BLOCK_ACHIEVEMENTS,\n    ...ITEM_BLOCKCHAIN_ACHIEVEMENTS,\n    ...ITEM_POLKADOT_ACHIEVEMENTS,\n    ...ITEM_PEER_REVIEW_ACHIEVEMENTS,\n    ...ITEM_CARDANO_ACHIEVEMENTS,\n    ...ITEM_BEAR_ACHIEVEMENTS,\n    ...ITEM_BEER_ACHIEVEMENTS,\n    ...ITEM_LOCK_ACHIEVEMENTS,\n    ...ITEM_MARMALADE_ACHIEVEMENTS,\n    ...ITEM_SUPER_MARMALADE_ACHIEVEMENTS,\n    ...ITEM_HYPER_MARMALADE_ACHIEVEMENTS,\n    ...ITEM_WATER_ACHIEVEMENTS,\n    ...ITEM_FIRE_ACHIEVEMENTS,\n    ...ITEM_STEAM_ACHIEVEMENTS,\n    ...ITEM_EARTH_ACHIEVEMENTS,\n    ...ITEM_MUD_ACHIEVEMENTS,\n    ...ITEM_LAVA_ACHIEVEMENTS,\n    ...ITEM_WIND_ACHIEVEMENTS,\n    ...ITEM_DUST_ACHIEVEMENTS,\n    ...ITEM_RAIN_ACHIEVEMENTS,\n    ...ITEM_SMOKE_ACHIEVEMENTS,\n    ...ITEM_GEYSER_ACHIEVEMENTS,\n    ...ITEM_CLAY_ACHIEVEMENTS,\n    ...ITEM_SAND_ACHIEVEMENTS,\n    ...ITEM_PLANT_ACHIEVEMENTS,\n    ...ITEM_RAINBOW_ACHIEVEMENTS,\n    ...ITEM_STORM_ACHIEVEMENTS,\n    ...ITEM_OBSIDIAN_ACHIEVEMENTS,\n    ...ITEM_ASH_ACHIEVEMENTS,\n    ...ITEM_VOLCANO_ACHIEVEMENTS,\n    ...ITEM_SANDSTORM_ACHIEVEMENTS,\n    ...ITEM_CLOUD_ACHIEVEMENTS,\n    ...ITEM_FOG_ACHIEVEMENTS,\n    ...ITEM_TREE_ACHIEVEMENTS,\n    ...ITEM_FOREST_ACHIEVEMENTS,\n    ...ITEM_SEEDS_ACHIEVEMENTS,\n    ...ITEM_POTTERY_ACHIEVEMENTS,\n    ...ITEM_BRICK_ACHIEVEMENTS,\n    ...ITEM_QUICKSAND_ACHIEVEMENTS,\n    ...ITEM_GLASS_ACHIEVEMENTS,\n    ...ITEM_DUNE_ACHIEVEMENTS,\n    ...ITEM_CHARCOAL_ACHIEVEMENTS,\n    ...ITEM_LEAVES_ACHIEVEMENTS,\n    ...ITEM_WILDFIRE_ACHIEVEMENTS,\n    ...ITEM_JUNGLE_ACHIEVEMENTS,\n    ...ITEM_FROSTED_GLASS_ACHIEVEMENTS,\n    ...ITEM_CRYSTAL_ACHIEVEMENTS,\n    ...ITEM_MAGMA_ACHIEVEMENTS,\n    ...ITEM_ROCK_ACHIEVEMENTS,\n    ...ITEM_SHARD_ACHIEVEMENTS,\n    ...ITEM_PEBBLE_ACHIEVEMENTS,\n    ...ITEM_MOUNTAIN_ACHIEVEMENTS,\n    ...ITEM_FERTILIZER_ACHIEVEMENTS,\n    ...ITEM_SOOT_ACHIEVEMENTS,\n    ...ITEM_LIGHTNING_ACHIEVEMENTS,\n    ...ITEM_MIST_ACHIEVEMENTS,\n    ...ITEM_HAZE_ACHIEVEMENTS,\n    ...ITEM_FLOOD_ACHIEVEMENTS,\n    ...ITEM_LANDSLIDE_ACHIEVEMENTS,\n    ...ITEM_THUNDER_ACHIEVEMENTS,\n    ...ITEM_TORNADO_ACHIEVEMENTS,\n    ...ITEM_GARDEN_ACHIEVEMENTS,\n    ...ITEM_EMBER_ACHIEVEMENTS,\n    ...ITEM_KILN_ACHIEVEMENTS,\n    ...ITEM_POLLINATION_ACHIEVEMENTS,\n    ...ITEM_SINKHOLE_ACHIEVEMENTS,\n    ...ITEM_BEACH_ACHIEVEMENTS,\n    ...ITEM_WETSTONE_ACHIEVEMENTS,\n    ...ITEM_EROSION_ACHIEVEMENTS,\n    ...ITEM_BASALT_ACHIEVEMENTS,\n    ...ITEM_MAGMA_CHAMBER_ACHIEVEMENTS,\n    ...ITEM_BREEZE_ACHIEVEMENTS,\n    ...ITEM_WARM_BREEZE_ACHIEVEMENTS,\n    ...ITEM_SOIL_ACHIEVEMENTS,\n    ...ITEM_CANYON_ACHIEVEMENTS,\n    ...ITEM_WINDMILL_ACHIEVEMENTS,\n    ...ITEM_ADOBE_ACHIEVEMENTS,\n    ...ITEM_WALL_ACHIEVEMENTS,\n    ...ITEM_PUMICE_ACHIEVEMENTS,\n    ...ITEM_BARBECUE_ACHIEVEMENTS,\n    ...ITEM_FARM_ACHIEVEMENTS,\n    ...ITEM_SHARDS_ACHIEVEMENTS,\n    ...ITEM_MOLTEN_GLASS_ACHIEVEMENTS,\n    ...ITEM_PRISM_ACHIEVEMENTS,\n    ...ITEM_SPARKLE_ACHIEVEMENTS,\n    ...ITEM_DESERT_ACHIEVEMENTS,\n    ...ITEM_OASIS_ACHIEVEMENTS,\n    ...ITEM_MIRAGE_ACHIEVEMENTS,\n    ...ITEM_SAND_DUNE_ACHIEVEMENTS,\n    ...ITEM_DAM_ACHIEVEMENTS,\n    ...ITEM_FIREWALL_ACHIEVEMENTS,\n    ...ITEM_BARRICADE_ACHIEVEMENTS,\n    ...ITEM_PLATEAU_ACHIEVEMENTS,\n    ...ITEM_POND_ACHIEVEMENTS,\n    ...ITEM_AROMAS_ACHIEVEMENTS,\n    ...ITEM_FLOWER_ACHIEVEMENTS,\n    ...ITEM_SPORE_ACHIEVEMENTS,\n    ...ITEM_SPREAD_ACHIEVEMENTS,\n    ...ITEM_FERTILE_LAND_ACHIEVEMENTS,\n    ...ITEM_WETLAND_ACHIEVEMENTS,\n    ...ITEM_PEAT_ACHIEVEMENTS,\n    ...ITEM_REEDS_ACHIEVEMENTS,\n    ...ITEM_VALLEY_ACHIEVEMENTS,\n    ...ITEM_RIVER_ACHIEVEMENTS,\n    ...ITEM_SCORCHED_EARTH_ACHIEVEMENTS,\n    ...ITEM_DELTA_ACHIEVEMENTS,\n    ...ITEM_ESTUARY_ACHIEVEMENTS,\n    ...ITEM_FIRE_SWAMP_ACHIEVEMENTS,\n    ...ITEM_RIVERBANK_ACHIEVEMENTS,\n    ...ITEM_RAVINE_ACHIEVEMENTS,\n    ...ITEM_GORGE_ACHIEVEMENTS,\n    ...ITEM_CHARRED_RAVINE_ACHIEVEMENTS,\n    ...ITEM_ECHO_ACHIEVEMENTS,\n    ...ITEM_CAVE_ACHIEVEMENTS,\n    ...ITEM_UNDERGROUND_LAKE_ACHIEVEMENTS,\n    ...ITEM_LAVA_CAVE_ACHIEVEMENTS,\n    ...ITEM_WHISPERING_CAVE_ACHIEVEMENTS,\n    ...ITEM_SUBTERRANEAN_POOL_ACHIEVEMENTS,\n    ...ITEM_SPRING_ACHIEVEMENTS,\n    ...ITEM_HOT_SPRING_ACHIEVEMENTS,\n    ...ITEM_GROTTO_ACHIEVEMENTS,\n    ...ITEM_FOUNTAIN_ACHIEVEMENTS,\n    ...ITEM_STEAM_VENT_ACHIEVEMENTS,\n    ...ITEM_COOL_BREEZE_ACHIEVEMENTS,\n    ...ITEM_MONUMENT_ACHIEVEMENTS,\n    ...ITEM_WATERFALL_ACHIEVEMENTS,\n    ...ITEM_ETERNAL_FLAME_ACHIEVEMENTS,\n    ...ITEM_PILLAR_OF_WIND_ACHIEVEMENTS,\n    ...ITEM_STREAM_ACHIEVEMENTS,\n    ...ITEM_ZEPHYR_ACHIEVEMENTS,\n    ...ITEM_CREEK_ACHIEVEMENTS,\n    ...ITEM_BROOK_ACHIEVEMENTS,\n    ...ITEM_WHISPER_ACHIEVEMENTS,\n    ...ITEM_RIVULET_ACHIEVEMENTS,\n    ...ITEM_TRIBUTARY_ACHIEVEMENTS,\n    ...ITEM_MURMUR_ACHIEVEMENTS,\n    ...ITEM_WATERSHED_ACHIEVEMENTS,\n    ...ITEM_AQUIFER_ACHIEVEMENTS,\n    ...ITEM_PARCHED_EARTH_ACHIEVEMENTS,\n    ...ITEM_FRESH_BREEZE_ACHIEVEMENTS,\n    ...ITEM_GROUNDWATER_ACHIEVEMENTS,\n    ...ITEM_RESERVOIR_ACHIEVEMENTS,\n    ...ITEM_GEOTHERMAL_SPRING_ACHIEVEMENTS,\n    ...ITEM_ARTESIAN_WELL_ACHIEVEMENTS,\n    ...ITEM_BASIN_ACHIEVEMENTS,\n    ...ITEM_LAKE_ACHIEVEMENTS,\n    ...ITEM_DRY_BASIN_ACHIEVEMENTS,\n    ...ITEM_DEPRESSION_ACHIEVEMENTS,\n    ...ITEM_ISLAND_ACHIEVEMENTS,\n    ...ITEM_LAGOON_ACHIEVEMENTS,\n    ...ITEM_WAVE_ACHIEVEMENTS,\n    ...ITEM_REEF_ACHIEVEMENTS,\n    ...ITEM_CORAL_ACHIEVEMENTS,\n    ...ITEM_WHIRL_ACHIEVEMENTS,\n    ...ITEM_LIMESTONE_ACHIEVEMENTS,\n    ...ITEM_KARST_ACHIEVEMENTS,\n    ...ITEM_QUICKLIME_ACHIEVEMENTS,\n    ...ITEM_BLOWHOLE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_SWARM_ACHIEVEMENTS,\n    ...RECIPE_MAKE_HYDRA_ACHIEVEMENTS,\n    ...RECIPE_MAKE_MONKEYBRANCH_ACHIEVEMENTS,\n    ...RECIPE_MAKE_BRIDGE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_GOLDENGATE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_CARDANO_ACHIEVEMENTS,\n    ...RECIPE_MAKE_BEER_ACHIEVEMENTS,\n    ...RECIPE_MAKE_LOCK_ACHIEVEMENTS,\n    ...RECIPE_MAKE_SUPERMARMALADE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_HYPERMARMALADE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_STEAM_ACHIEVEMENTS,\n    ...RECIPE_MAKE_MUD_ACHIEVEMENTS,\n    ...RECIPE_MAKE_LAVA_ACHIEVEMENTS,\n    ...RECIPE_MAKE_DUST_ACHIEVEMENTS,\n    ...RECIPE_MAKE_RAIN_ACHIEVEMENTS,\n    ...RECIPE_MAKE_SMOKE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_GEYSER_ACHIEVEMENTS,\n    ...RECIPE_MAKE_CLAY_ACHIEVEMENTS,\n    ...RECIPE_MAKE_SAND_ACHIEVEMENTS,\n    ...RECIPE_MAKE_PLANT_ACHIEVEMENTS,\n    ...RECIPE_MAKE_RAINBOW_ACHIEVEMENTS,\n    ...RECIPE_MAKE_STORM_ACHIEVEMENTS,\n    ...RECIPE_MAKE_OBSIDIAN_ACHIEVEMENTS,\n    ...RECIPE_MAKE_ASH_ACHIEVEMENTS,\n    ...RECIPE_MAKE_VOLCANO_ACHIEVEMENTS,\n    ...RECIPE_MAKE_SANDSTORM_ACHIEVEMENTS,\n    ...RECIPE_MAKE_CLOUD_ACHIEVEMENTS,\n    ...RECIPE_MAKE_FOG_ACHIEVEMENTS,\n    ...RECIPE_MAKE_TREE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_FOREST_ACHIEVEMENTS,\n    ...RECIPE_MAKE_SEEDS_ACHIEVEMENTS,\n    ...RECIPE_MAKE_POTTERY_ACHIEVEMENTS,\n    ...RECIPE_MAKE_BRICK_ACHIEVEMENTS,\n    ...RECIPE_MAKE_QUICKSAND_ACHIEVEMENTS,\n    ...RECIPE_MAKE_GLASS_ACHIEVEMENTS,\n    ...RECIPE_MAKE_DUNE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_CHARCOAL_ACHIEVEMENTS,\n    ...RECIPE_MAKE_LEAVES_ACHIEVEMENTS,\n    ...RECIPE_MAKE_WILDFIRE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_JUNGLE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_FROSTED_GLASS_ACHIEVEMENTS,\n    ...RECIPE_MAKE_CRYSTAL_ACHIEVEMENTS,\n    ...RECIPE_MAKE_MAGMA_ACHIEVEMENTS,\n    ...RECIPE_MAKE_ROCK_ACHIEVEMENTS,\n    ...RECIPE_MAKE_SHARD_ACHIEVEMENTS,\n    ...RECIPE_MAKE_PEBBLE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_MOUNTAIN_ACHIEVEMENTS,\n    ...RECIPE_MAKE_FERTILIZER_ACHIEVEMENTS,\n    ...RECIPE_MAKE_SOOT_ACHIEVEMENTS,\n    ...RECIPE_MAKE_LIGHTNING_ACHIEVEMENTS,\n    ...RECIPE_MAKE_MIST_ACHIEVEMENTS,\n    ...RECIPE_MAKE_HAZE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_FLOOD_ACHIEVEMENTS,\n    ...RECIPE_MAKE_LANDSLIDE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_THUNDER_ACHIEVEMENTS,\n    ...RECIPE_MAKE_TORNADO_ACHIEVEMENTS,\n    ...RECIPE_MAKE_GARDEN_ACHIEVEMENTS,\n    ...RECIPE_MAKE_EMBER_ACHIEVEMENTS,\n    ...RECIPE_MAKE_KILN_ACHIEVEMENTS,\n    ...RECIPE_MAKE_POLLINATION_ACHIEVEMENTS,\n    ...RECIPE_MAKE_SINKHOLE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_BEACH_ACHIEVEMENTS,\n    ...RECIPE_MAKE_WETSTONE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_EROSION_ACHIEVEMENTS,\n    ...RECIPE_MAKE_BASALT_ACHIEVEMENTS,\n    ...RECIPE_MAKE_MAGMA_CHAMBER_ACHIEVEMENTS,\n    ...RECIPE_MAKE_BREEZE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_WARM_BREEZE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_SOIL_ACHIEVEMENTS,\n    ...RECIPE_MAKE_CANYON_ACHIEVEMENTS,\n    ...RECIPE_MAKE_WINDMILL_ACHIEVEMENTS,\n    ...RECIPE_MAKE_ADOBE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_WALL_ACHIEVEMENTS,\n    ...RECIPE_MAKE_PUMICE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_BARBECUE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_FARM_ACHIEVEMENTS,\n    ...RECIPE_MAKE_SHARDS_ACHIEVEMENTS,\n    ...RECIPE_MAKE_MOLTEN_GLASS_ACHIEVEMENTS,\n    ...RECIPE_MAKE_PRISM_ACHIEVEMENTS,\n    ...RECIPE_MAKE_SPARKLE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_DESERT_ACHIEVEMENTS,\n    ...RECIPE_MAKE_OASIS_ACHIEVEMENTS,\n    ...RECIPE_MAKE_MIRAGE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_SAND_DUNE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_DAM_ACHIEVEMENTS,\n    ...RECIPE_MAKE_FIREWALL_ACHIEVEMENTS,\n    ...RECIPE_MAKE_BARRICADE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_PLATEAU_ACHIEVEMENTS,\n    ...RECIPE_MAKE_POND_ACHIEVEMENTS,\n    ...RECIPE_MAKE_AROMAS_ACHIEVEMENTS,\n    ...RECIPE_MAKE_FLOWER_ACHIEVEMENTS,\n    ...RECIPE_MAKE_SPORE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_SPREAD_ACHIEVEMENTS,\n    ...RECIPE_MAKE_FERTILE_LAND_ACHIEVEMENTS,\n    ...RECIPE_MAKE_WETLAND_ACHIEVEMENTS,\n    ...RECIPE_MAKE_PEAT_ACHIEVEMENTS,\n    ...RECIPE_MAKE_REEDS_ACHIEVEMENTS,\n    ...RECIPE_MAKE_VALLEY_ACHIEVEMENTS,\n    ...RECIPE_MAKE_RIVER_ACHIEVEMENTS,\n    ...RECIPE_MAKE_SCORCHED_EARTH_ACHIEVEMENTS,\n    ...RECIPE_MAKE_DELTA_ACHIEVEMENTS,\n    ...RECIPE_MAKE_ESTUARY_ACHIEVEMENTS,\n    ...RECIPE_MAKE_FIRE_SWAMP_ACHIEVEMENTS,\n    ...RECIPE_MAKE_RIVERBANK_ACHIEVEMENTS,\n    ...RECIPE_MAKE_RAVINE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_GORGE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_CHARRED_RAVINE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_ECHO_ACHIEVEMENTS,\n    ...RECIPE_MAKE_CAVE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_UNDERGROUND_LAKE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_LAVA_CAVE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_WHISPERING_CAVE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_SUBTERRANEAN_POOL_ACHIEVEMENTS,\n    ...RECIPE_MAKE_SPRING_ACHIEVEMENTS,\n    ...RECIPE_MAKE_HOT_SPRING_ACHIEVEMENTS,\n    ...RECIPE_MAKE_GROTTO_ACHIEVEMENTS,\n    ...RECIPE_MAKE_FOUNTAIN_ACHIEVEMENTS,\n    ...RECIPE_MAKE_STEAM_VENT_ACHIEVEMENTS,\n    ...RECIPE_MAKE_COOL_BREEZE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_MONUMENT_ACHIEVEMENTS,\n    ...RECIPE_MAKE_WATERFALL_ACHIEVEMENTS,\n    ...RECIPE_MAKE_ETERNAL_FLAME_ACHIEVEMENTS,\n    ...RECIPE_MAKE_PILLAR_OF_WIND_ACHIEVEMENTS,\n    ...RECIPE_MAKE_STREAM_ACHIEVEMENTS,\n    ...RECIPE_MAKE_ZEPHYR_ACHIEVEMENTS,\n    ...RECIPE_MAKE_CREEK_ACHIEVEMENTS,\n    ...RECIPE_MAKE_BROOK_ACHIEVEMENTS,\n    ...RECIPE_MAKE_WHISPER_ACHIEVEMENTS,\n    ...RECIPE_MAKE_RIVULET_ACHIEVEMENTS,\n    ...RECIPE_MAKE_TRIBUTARY_ACHIEVEMENTS,\n    ...RECIPE_MAKE_MURMUR_ACHIEVEMENTS,\n    ...RECIPE_MAKE_WATERSHED_ACHIEVEMENTS,\n    ...RECIPE_MAKE_AQUIFER_ACHIEVEMENTS,\n    ...RECIPE_MAKE_PARCHED_EARTH_ACHIEVEMENTS,\n    ...RECIPE_MAKE_FRESH_BREEZE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_GROUNDWATER_ACHIEVEMENTS,\n    ...RECIPE_MAKE_RESERVOIR_ACHIEVEMENTS,\n    ...RECIPE_MAKE_GEOTHERMAL_SPRING_ACHIEVEMENTS,\n    ...RECIPE_MAKE_ARTESIAN_WELL_ACHIEVEMENTS,\n    ...RECIPE_MAKE_BASIN_ACHIEVEMENTS,\n    ...RECIPE_MAKE_LAKE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_DRY_BASIN_ACHIEVEMENTS,\n    ...RECIPE_MAKE_DEPRESSION_ACHIEVEMENTS,\n    ...RECIPE_MAKE_ISLAND_ACHIEVEMENTS,\n    ...RECIPE_MAKE_LAGOON_ACHIEVEMENTS,\n    ...RECIPE_MAKE_WAVE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_REEF_ACHIEVEMENTS,\n    ...RECIPE_MAKE_CORAL_ACHIEVEMENTS,\n    ...RECIPE_MAKE_WHIRL_ACHIEVEMENTS,\n    ...RECIPE_MAKE_LIMESTONE_ACHIEVEMENTS,\n    ...RECIPE_MAKE_KARST_ACHIEVEMENTS,\n    ...RECIPE_MAKE_QUICKLIME_ACHIEVEMENTS,\n    ...RECIPE_MAKE_BLOWHOLE_ACHIEVEMENTS,\n];",
      "contentHash": "293027d91024c118ca8866efaea745b05c75138f907ed020556fd23ce686bde6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/model/src/items.ts",
      "content": "import { IItem } from './IItem';\nimport { IRecipe } from './IRecipe';\nimport { IGameContent } from './IGameContent';\n\nimport ITEM_MONKEY_CONTRACT_ABI from \"../../../contracts.v1/interfaces/monkey.interface.json\";\nimport ITEM_GIRAFFE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/giraffe.interface.json\";\nimport ITEM_BEE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/bee.interface.json\";\nimport ITEM_COIN_CONTRACT_ABI from \"../../../contracts.v1/interfaces/coin.interface.json\";\nimport ITEM_SWARM_CONTRACT_ABI from \"../../../contracts.v1/interfaces/swarm.interface.json\";\nimport ITEM_HYDRA_CONTRACT_ABI from \"../../../contracts.v1/interfaces/hydra.interface.json\";\nimport ITEM_MONKEY_BRANCH_CONTRACT_ABI from \"../../../contracts.v1/interfaces/monkey_branch.interface.json\";\nimport ITEM_BRIDGE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/bridge.interface.json\";\nimport ITEM_GOLDEN_GATE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/golden_gate.interface.json\";\nimport ITEM_GOLD_CONTRACT_ABI from \"../../../contracts.v1/interfaces/gold.interface.json\";\nimport ITEM_SILVER_CONTRACT_ABI from \"../../../contracts.v1/interfaces/silver.interface.json\";\nimport ITEM_RHODIUM_CONTRACT_ABI from \"../../../contracts.v1/interfaces/rhodium.interface.json\";\nimport ITEM_HIVE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/hive.interface.json\";\nimport ITEM_TRANSACTION_CONTRACT_ABI from \"../../../contracts.v1/interfaces/transaction.interface.json\";\nimport ITEM_BLOCK_CONTRACT_ABI from \"../../../contracts.v1/interfaces/block.interface.json\";\nimport ITEM_BLOCKCHAIN_CONTRACT_ABI from \"../../../contracts.v1/interfaces/blockchain.interface.json\";\nimport ITEM_POLKADOT_CONTRACT_ABI from \"../../../contracts.v1/interfaces/polkadot.interface.json\";\nimport ITEM_PEER_REVIEW_CONTRACT_ABI from \"../../../contracts.v1/interfaces/peer_review.interface.json\";\nimport ITEM_CARDANO_CONTRACT_ABI from \"../../../contracts.v1/interfaces/cardano.interface.json\";\nimport ITEM_BEAR_CONTRACT_ABI from \"../../../contracts.v1/interfaces/bear.interface.json\";\nimport ITEM_BEER_CONTRACT_ABI from \"../../../contracts.v1/interfaces/beer.interface.json\";\nimport ITEM_LOCK_CONTRACT_ABI from \"../../../contracts.v1/interfaces/lock.interface.json\";\nimport ITEM_MARMALADE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/marmalade.interface.json\";\nimport ITEM_SUPER_MARMALADE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/super_marmalade.interface.json\";\nimport ITEM_HYPER_MARMALADE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/hyper_marmalade.interface.json\";\nimport ITEM_WATER_CONTRACT_ABI from \"../../../contracts.v1/interfaces/water.interface.json\";\nimport ITEM_FIRE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/fire.interface.json\";\nimport ITEM_STEAM_CONTRACT_ABI from \"../../../contracts.v1/interfaces/steam.interface.json\";\nimport ITEM_EARTH_CONTRACT_ABI from \"../../../contracts.v1/interfaces/earth.interface.json\";\nimport ITEM_MUD_CONTRACT_ABI from \"../../../contracts.v1/interfaces/mud.interface.json\";\nimport ITEM_LAVA_CONTRACT_ABI from \"../../../contracts.v1/interfaces/lava.interface.json\";\nimport ITEM_WIND_CONTRACT_ABI from \"../../../contracts.v1/interfaces/wind.interface.json\";\nimport ITEM_DUST_CONTRACT_ABI from \"../../../contracts.v1/interfaces/dust.interface.json\";\nimport ITEM_RAIN_CONTRACT_ABI from \"../../../contracts.v1/interfaces/rain.interface.json\";\nimport ITEM_SMOKE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/smoke.interface.json\";\nimport ITEM_GEYSER_CONTRACT_ABI from \"../../../contracts.v1/interfaces/geyser.interface.json\";\nimport ITEM_CLAY_CONTRACT_ABI from \"../../../contracts.v1/interfaces/clay.interface.json\";\nimport ITEM_SAND_CONTRACT_ABI from \"../../../contracts.v1/interfaces/sand.interface.json\";\nimport ITEM_PLANT_CONTRACT_ABI from \"../../../contracts.v1/interfaces/plant.interface.json\";\nimport ITEM_RAINBOW_CONTRACT_ABI from \"../../../contracts.v1/interfaces/rainbow.interface.json\";\nimport ITEM_STORM_CONTRACT_ABI from \"../../../contracts.v1/interfaces/storm.interface.json\";\nimport ITEM_OBSIDIAN_CONTRACT_ABI from \"../../../contracts.v1/interfaces/obsidian.interface.json\";\nimport ITEM_ASH_CONTRACT_ABI from \"../../../contracts.v1/interfaces/ash.interface.json\";\nimport ITEM_VOLCANO_CONTRACT_ABI from \"../../../contracts.v1/interfaces/volcano.interface.json\";\nimport ITEM_SANDSTORM_CONTRACT_ABI from \"../../../contracts.v1/interfaces/sandstorm.interface.json\";\nimport ITEM_CLOUD_CONTRACT_ABI from \"../../../contracts.v1/interfaces/cloud.interface.json\";\nimport ITEM_FOG_CONTRACT_ABI from \"../../../contracts.v1/interfaces/fog.interface.json\";\nimport ITEM_TREE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/tree.interface.json\";\nimport ITEM_FOREST_CONTRACT_ABI from \"../../../contracts.v1/interfaces/forest.interface.json\";\nimport ITEM_SEEDS_CONTRACT_ABI from \"../../../contracts.v1/interfaces/seeds.interface.json\";\nimport ITEM_POTTERY_CONTRACT_ABI from \"../../../contracts.v1/interfaces/pottery.interface.json\";\nimport ITEM_BRICK_CONTRACT_ABI from \"../../../contracts.v1/interfaces/brick.interface.json\";\nimport ITEM_QUICKSAND_CONTRACT_ABI from \"../../../contracts.v1/interfaces/quicksand.interface.json\";\nimport ITEM_GLASS_CONTRACT_ABI from \"../../../contracts.v1/interfaces/glass.interface.json\";\nimport ITEM_DUNE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/dune.interface.json\";\nimport ITEM_CHARCOAL_CONTRACT_ABI from \"../../../contracts.v1/interfaces/charcoal.interface.json\";\nimport ITEM_LEAVES_CONTRACT_ABI from \"../../../contracts.v1/interfaces/leaves.interface.json\";\nimport ITEM_WILDFIRE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/wildfire.interface.json\";\nimport ITEM_JUNGLE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/jungle.interface.json\";\nimport ITEM_FROSTED_GLASS_CONTRACT_ABI from \"../../../contracts.v1/interfaces/frosted_glass.interface.json\";\nimport ITEM_CRYSTAL_CONTRACT_ABI from \"../../../contracts.v1/interfaces/crystal.interface.json\";\nimport ITEM_MAGMA_CONTRACT_ABI from \"../../../contracts.v1/interfaces/magma.interface.json\";\nimport ITEM_ROCK_CONTRACT_ABI from \"../../../contracts.v1/interfaces/rock.interface.json\";\nimport ITEM_SHARD_CONTRACT_ABI from \"../../../contracts.v1/interfaces/shard.interface.json\";\nimport ITEM_PEBBLE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/pebble.interface.json\";\nimport ITEM_MOUNTAIN_CONTRACT_ABI from \"../../../contracts.v1/interfaces/mountain.interface.json\";\nimport ITEM_FERTILIZER_CONTRACT_ABI from \"../../../contracts.v1/interfaces/fertilizer.interface.json\";\nimport ITEM_SOOT_CONTRACT_ABI from \"../../../contracts.v1/interfaces/soot.interface.json\";\nimport ITEM_LIGHTNING_CONTRACT_ABI from \"../../../contracts.v1/interfaces/lightning.interface.json\";\nimport ITEM_MIST_CONTRACT_ABI from \"../../../contracts.v1/interfaces/mist.interface.json\";\nimport ITEM_HAZE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/haze.interface.json\";\nimport ITEM_FLOOD_CONTRACT_ABI from \"../../../contracts.v1/interfaces/flood.interface.json\";\nimport ITEM_LANDSLIDE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/landslide.interface.json\";\nimport ITEM_THUNDER_CONTRACT_ABI from \"../../../contracts.v1/interfaces/thunder.interface.json\";\nimport ITEM_TORNADO_CONTRACT_ABI from \"../../../contracts.v1/interfaces/tornado.interface.json\";\nimport ITEM_GARDEN_CONTRACT_ABI from \"../../../contracts.v1/interfaces/garden.interface.json\";\nimport ITEM_EMBER_CONTRACT_ABI from \"../../../contracts.v1/interfaces/ember.interface.json\";\nimport ITEM_KILN_CONTRACT_ABI from \"../../../contracts.v1/interfaces/kiln.interface.json\";\nimport ITEM_POLLINATION_CONTRACT_ABI from \"../../../contracts.v1/interfaces/pollination.interface.json\";\nimport ITEM_SINKHOLE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/sinkhole.interface.json\";\nimport ITEM_BEACH_CONTRACT_ABI from \"../../../contracts.v1/interfaces/beach.interface.json\";\nimport ITEM_WETSTONE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/wetstone.interface.json\";\nimport ITEM_EROSION_CONTRACT_ABI from \"../../../contracts.v1/interfaces/erosion.interface.json\";\nimport ITEM_BASALT_CONTRACT_ABI from \"../../../contracts.v1/interfaces/basalt.interface.json\";\nimport ITEM_MAGMA_CHAMBER_CONTRACT_ABI from \"../../../contracts.v1/interfaces/magma_chamber.interface.json\";\nimport ITEM_BREEZE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/breeze.interface.json\";\nimport ITEM_WARM_BREEZE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/warm_breeze.interface.json\";\nimport ITEM_SOIL_CONTRACT_ABI from \"../../../contracts.v1/interfaces/soil.interface.json\";\nimport ITEM_CANYON_CONTRACT_ABI from \"../../../contracts.v1/interfaces/canyon.interface.json\";\nimport ITEM_WINDMILL_CONTRACT_ABI from \"../../../contracts.v1/interfaces/windmill.interface.json\";\nimport ITEM_ADOBE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/adobe.interface.json\";\nimport ITEM_WALL_CONTRACT_ABI from \"../../../contracts.v1/interfaces/wall.interface.json\";\nimport ITEM_PUMICE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/pumice.interface.json\";\nimport ITEM_BARBECUE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/barbecue.interface.json\";\nimport ITEM_FARM_CONTRACT_ABI from \"../../../contracts.v1/interfaces/farm.interface.json\";\nimport ITEM_SHARDS_CONTRACT_ABI from \"../../../contracts.v1/interfaces/shards.interface.json\";\nimport ITEM_MOLTEN_GLASS_CONTRACT_ABI from \"../../../contracts.v1/interfaces/molten_glass.interface.json\";\nimport ITEM_PRISM_CONTRACT_ABI from \"../../../contracts.v1/interfaces/prism.interface.json\";\nimport ITEM_SPARKLE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/sparkle.interface.json\";\nimport ITEM_DESERT_CONTRACT_ABI from \"../../../contracts.v1/interfaces/desert.interface.json\";\nimport ITEM_OASIS_CONTRACT_ABI from \"../../../contracts.v1/interfaces/oasis.interface.json\";\nimport ITEM_MIRAGE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/mirage.interface.json\";\nimport ITEM_SAND_DUNE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/sand_dune.interface.json\";\nimport ITEM_DAM_CONTRACT_ABI from \"../../../contracts.v1/interfaces/dam.interface.json\";\nimport ITEM_FIREWALL_CONTRACT_ABI from \"../../../contracts.v1/interfaces/firewall.interface.json\";\nimport ITEM_BARRICADE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/barricade.interface.json\";\nimport ITEM_PLATEAU_CONTRACT_ABI from \"../../../contracts.v1/interfaces/plateau.interface.json\";\nimport ITEM_POND_CONTRACT_ABI from \"../../../contracts.v1/interfaces/pond.interface.json\";\nimport ITEM_AROMAS_CONTRACT_ABI from \"../../../contracts.v1/interfaces/aromas.interface.json\";\nimport ITEM_FLOWER_CONTRACT_ABI from \"../../../contracts.v1/interfaces/flower.interface.json\";\nimport ITEM_SPORE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/spore.interface.json\";\nimport ITEM_SPREAD_CONTRACT_ABI from \"../../../contracts.v1/interfaces/spread.interface.json\";\nimport ITEM_FERTILE_LAND_CONTRACT_ABI from \"../../../contracts.v1/interfaces/fertile_land.interface.json\";\nimport ITEM_WETLAND_CONTRACT_ABI from \"../../../contracts.v1/interfaces/wetland.interface.json\";\nimport ITEM_PEAT_CONTRACT_ABI from \"../../../contracts.v1/interfaces/peat.interface.json\";\nimport ITEM_REEDS_CONTRACT_ABI from \"../../../contracts.v1/interfaces/reeds.interface.json\";\nimport ITEM_VALLEY_CONTRACT_ABI from \"../../../contracts.v1/interfaces/valley.interface.json\";\nimport ITEM_RIVER_CONTRACT_ABI from \"../../../contracts.v1/interfaces/river.interface.json\";\nimport ITEM_SCORCHED_EARTH_CONTRACT_ABI from \"../../../contracts.v1/interfaces/scorched_earth.interface.json\";\nimport ITEM_DELTA_CONTRACT_ABI from \"../../../contracts.v1/interfaces/delta.interface.json\";\nimport ITEM_ESTUARY_CONTRACT_ABI from \"../../../contracts.v1/interfaces/estuary.interface.json\";\nimport ITEM_FIRE_SWAMP_CONTRACT_ABI from \"../../../contracts.v1/interfaces/fire_swamp.interface.json\";\nimport ITEM_RIVERBANK_CONTRACT_ABI from \"../../../contracts.v1/interfaces/riverbank.interface.json\";\nimport ITEM_RAVINE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/ravine.interface.json\";\nimport ITEM_GORGE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/gorge.interface.json\";\nimport ITEM_CHARRED_RAVINE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/charred_ravine.interface.json\";\nimport ITEM_ECHO_CONTRACT_ABI from \"../../../contracts.v1/interfaces/echo.interface.json\";\nimport ITEM_CAVE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/cave.interface.json\";\nimport ITEM_UNDERGROUND_LAKE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/underground_lake.interface.json\";\nimport ITEM_LAVA_CAVE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/lava_cave.interface.json\";\nimport ITEM_WHISPERING_CAVE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/whispering_cave.interface.json\";\nimport ITEM_SUBTERRANEAN_POOL_CONTRACT_ABI from \"../../../contracts.v1/interfaces/subterranean_pool.interface.json\";\nimport ITEM_SPRING_CONTRACT_ABI from \"../../../contracts.v1/interfaces/spring.interface.json\";\nimport ITEM_HOT_SPRING_CONTRACT_ABI from \"../../../contracts.v1/interfaces/hot_spring.interface.json\";\nimport ITEM_GROTTO_CONTRACT_ABI from \"../../../contracts.v1/interfaces/grotto.interface.json\";\nimport ITEM_FOUNTAIN_CONTRACT_ABI from \"../../../contracts.v1/interfaces/fountain.interface.json\";\nimport ITEM_STEAM_VENT_CONTRACT_ABI from \"../../../contracts.v1/interfaces/steam_vent.interface.json\";\nimport ITEM_COOL_BREEZE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/cool_breeze.interface.json\";\nimport ITEM_MONUMENT_CONTRACT_ABI from \"../../../contracts.v1/interfaces/monument.interface.json\";\nimport ITEM_WATERFALL_CONTRACT_ABI from \"../../../contracts.v1/interfaces/waterfall.interface.json\";\nimport ITEM_ETERNAL_FLAME_CONTRACT_ABI from \"../../../contracts.v1/interfaces/eternal_flame.interface.json\";\nimport ITEM_PILLAR_OF_WIND_CONTRACT_ABI from \"../../../contracts.v1/interfaces/pillar_of_wind.interface.json\";\nimport ITEM_STREAM_CONTRACT_ABI from \"../../../contracts.v1/interfaces/stream.interface.json\";\nimport ITEM_ZEPHYR_CONTRACT_ABI from \"../../../contracts.v1/interfaces/zephyr.interface.json\";\nimport ITEM_CREEK_CONTRACT_ABI from \"../../../contracts.v1/interfaces/creek.interface.json\";\nimport ITEM_BROOK_CONTRACT_ABI from \"../../../contracts.v1/interfaces/brook.interface.json\";\nimport ITEM_WHISPER_CONTRACT_ABI from \"../../../contracts.v1/interfaces/whisper.interface.json\";\nimport ITEM_RIVULET_CONTRACT_ABI from \"../../../contracts.v1/interfaces/rivulet.interface.json\";\nimport ITEM_TRIBUTARY_CONTRACT_ABI from \"../../../contracts.v1/interfaces/tributary.interface.json\";\nimport ITEM_MURMUR_CONTRACT_ABI from \"../../../contracts.v1/interfaces/murmur.interface.json\";\nimport ITEM_WATERSHED_CONTRACT_ABI from \"../../../contracts.v1/interfaces/watershed.interface.json\";\nimport ITEM_AQUIFER_CONTRACT_ABI from \"../../../contracts.v1/interfaces/aquifer.interface.json\";\nimport ITEM_PARCHED_EARTH_CONTRACT_ABI from \"../../../contracts.v1/interfaces/parched_earth.interface.json\";\nimport ITEM_FRESH_BREEZE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/fresh_breeze.interface.json\";\nimport ITEM_GROUNDWATER_CONTRACT_ABI from \"../../../contracts.v1/interfaces/groundwater.interface.json\";\nimport ITEM_RESERVOIR_CONTRACT_ABI from \"../../../contracts.v1/interfaces/reservoir.interface.json\";\nimport ITEM_GEOTHERMAL_SPRING_CONTRACT_ABI from \"../../../contracts.v1/interfaces/geothermal_spring.interface.json\";\nimport ITEM_ARTESIAN_WELL_CONTRACT_ABI from \"../../../contracts.v1/interfaces/artesian_well.interface.json\";\nimport ITEM_BASIN_CONTRACT_ABI from \"../../../contracts.v1/interfaces/basin.interface.json\";\nimport ITEM_LAKE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/lake.interface.json\";\nimport ITEM_DRY_BASIN_CONTRACT_ABI from \"../../../contracts.v1/interfaces/dry_basin.interface.json\";\nimport ITEM_DEPRESSION_CONTRACT_ABI from \"../../../contracts.v1/interfaces/depression.interface.json\";\nimport ITEM_ISLAND_CONTRACT_ABI from \"../../../contracts.v1/interfaces/island.interface.json\";\nimport ITEM_LAGOON_CONTRACT_ABI from \"../../../contracts.v1/interfaces/lagoon.interface.json\";\nimport ITEM_WAVE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/wave.interface.json\";\nimport ITEM_REEF_CONTRACT_ABI from \"../../../contracts.v1/interfaces/reef.interface.json\";\nimport ITEM_CORAL_CONTRACT_ABI from \"../../../contracts.v1/interfaces/coral.interface.json\";\nimport ITEM_WHIRL_CONTRACT_ABI from \"../../../contracts.v1/interfaces/whirl.interface.json\";\nimport ITEM_LIMESTONE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/limestone.interface.json\";\nimport ITEM_KARST_CONTRACT_ABI from \"../../../contracts.v1/interfaces/karst.interface.json\";\nimport ITEM_QUICKLIME_CONTRACT_ABI from \"../../../contracts.v1/interfaces/quicklime.interface.json\";\nimport ITEM_BLOWHOLE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/blowhole.interface.json\";\n\nimport GAME_UNIFIERS_CONTRACT_ABI from \"../../../contracts.v1/interfaces/unifiers.interface.json\";\nimport GAME_ELEMENTY_CONTRACT_ABI from \"../../../contracts.v1/interfaces/elementy.interface.json\";\n\nexport const ITEM_MONKEY: IItem = {\n    id: 0,\n    name: 'Monkey',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_MONKEY_CONTRACT_ABI,\n};\nexport const ITEM_GIRAFFE: IItem = {\n    id: 1,\n    name: 'Giraffe',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_GIRAFFE_CONTRACT_ABI,\n};\nexport const ITEM_BEE: IItem = {\n    id: 2,\n    name: 'Bee',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_BEE_CONTRACT_ABI,\n};\nexport const ITEM_COIN: IItem = {\n    id: 3,\n    name: 'Coin',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_COIN_CONTRACT_ABI,\n};\nexport const ITEM_SWARM: IItem = {\n    id: 4,\n    name: 'Swarm',\n    description: 'We need a description here',\n    tier: 2,\n    contractAbi: ITEM_SWARM_CONTRACT_ABI,\n};\nexport const ITEM_HYDRA: IItem = {\n    id: 5,\n    name: 'Hydra',\n    description: 'We need a description here',\n    tier: 2,\n    contractAbi: ITEM_HYDRA_CONTRACT_ABI,\n};\nexport const ITEM_MONKEY_BRANCH: IItem = {\n    id: 6,\n    name: 'Monkey Branch',\n    description: 'We need a description here',\n    tier: 2,\n    contractAbi: ITEM_MONKEY_BRANCH_CONTRACT_ABI,\n};\nexport const ITEM_BRIDGE: IItem = {\n    id: 7,\n    name: 'Bridge',\n    description: 'We need a description here',\n    tier: 2,\n    contractAbi: ITEM_BRIDGE_CONTRACT_ABI,\n};\nexport const ITEM_GOLDEN_GATE: IItem = {\n    id: 8,\n    name: 'Golden Gate',\n    description: 'We need a description here',\n    tier: 2,\n    contractAbi: ITEM_GOLDEN_GATE_CONTRACT_ABI,\n};\nexport const ITEM_GOLD: IItem = {\n    id: 9,\n    name: 'Gold',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_GOLD_CONTRACT_ABI,\n};\nexport const ITEM_SILVER: IItem = {\n    id: 10,\n    name: 'Silver',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SILVER_CONTRACT_ABI,\n};\nexport const ITEM_RHODIUM: IItem = {\n    id: 11,\n    name: 'Rhodium',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_RHODIUM_CONTRACT_ABI,\n};\nexport const ITEM_HIVE: IItem = {\n    id: 12,\n    name: 'Hive',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_HIVE_CONTRACT_ABI,\n};\nexport const ITEM_TRANSACTION: IItem = {\n    id: 13,\n    name: 'Transaction',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_TRANSACTION_CONTRACT_ABI,\n};\nexport const ITEM_BLOCK: IItem = {\n    id: 14,\n    name: 'Block',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_BLOCK_CONTRACT_ABI,\n};\nexport const ITEM_BLOCKCHAIN: IItem = {\n    id: 15,\n    name: 'Blockchain',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_BLOCKCHAIN_CONTRACT_ABI,\n};\nexport const ITEM_POLKADOT: IItem = {\n    id: 16,\n    name: 'Polkadot',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_POLKADOT_CONTRACT_ABI,\n};\nexport const ITEM_PEER_REVIEW: IItem = {\n    id: 17,\n    name: 'Peer Review',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_PEER_REVIEW_CONTRACT_ABI,\n};\nexport const ITEM_CARDANO: IItem = {\n    id: 18,\n    name: 'Cardano',\n    description: 'We need a description here',\n    tier: 2,\n    contractAbi: ITEM_CARDANO_CONTRACT_ABI,\n};\nexport const ITEM_BEAR: IItem = {\n    id: 19,\n    name: 'Bear',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_BEAR_CONTRACT_ABI,\n};\nexport const ITEM_BEER: IItem = {\n    id: 20,\n    name: 'Beer',\n    description: 'We need a description here',\n    tier: 2,\n    contractAbi: ITEM_BEER_CONTRACT_ABI,\n};\nexport const ITEM_LOCK: IItem = {\n    id: 21,\n    name: 'Lock',\n    description: 'We need a description here',\n    tier: 2,\n    contractAbi: ITEM_LOCK_CONTRACT_ABI,\n};\nexport const ITEM_MARMALADE: IItem = {\n    id: 22,\n    name: 'Marmalade',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_MARMALADE_CONTRACT_ABI,\n};\nexport const ITEM_SUPER_MARMALADE: IItem = {\n    id: 23,\n    name: 'Super Marmalade',\n    description: 'We need a description here',\n    tier: 2,\n    contractAbi: ITEM_SUPER_MARMALADE_CONTRACT_ABI,\n};\nexport const ITEM_HYPER_MARMALADE: IItem = {\n    id: 24,\n    name: 'Hyper Marmalade',\n    description: 'We need a description here',\n    tier: 2,\n    contractAbi: ITEM_HYPER_MARMALADE_CONTRACT_ABI,\n};\nexport const ITEM_WATER: IItem = {\n    id: 25,\n    name: 'Water',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_WATER_CONTRACT_ABI,\n};\nexport const ITEM_FIRE: IItem = {\n    id: 26,\n    name: 'Fire',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_FIRE_CONTRACT_ABI,\n};\nexport const ITEM_STEAM: IItem = {\n    id: 27,\n    name: 'Steam',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_STEAM_CONTRACT_ABI,\n};\nexport const ITEM_EARTH: IItem = {\n    id: 28,\n    name: 'Earth',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_EARTH_CONTRACT_ABI,\n};\nexport const ITEM_MUD: IItem = {\n    id: 29,\n    name: 'Mud',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_MUD_CONTRACT_ABI,\n};\nexport const ITEM_LAVA: IItem = {\n    id: 30,\n    name: 'Lava',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_LAVA_CONTRACT_ABI,\n};\nexport const ITEM_WIND: IItem = {\n    id: 31,\n    name: 'Wind',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_WIND_CONTRACT_ABI,\n};\nexport const ITEM_DUST: IItem = {\n    id: 32,\n    name: 'Dust',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_DUST_CONTRACT_ABI,\n};\nexport const ITEM_RAIN: IItem = {\n    id: 33,\n    name: 'Rain',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_RAIN_CONTRACT_ABI,\n};\nexport const ITEM_SMOKE: IItem = {\n    id: 34,\n    name: 'Smoke',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SMOKE_CONTRACT_ABI,\n};\nexport const ITEM_GEYSER: IItem = {\n    id: 35,\n    name: 'Geyser',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_GEYSER_CONTRACT_ABI,\n};\nexport const ITEM_CLAY: IItem = {\n    id: 36,\n    name: 'Clay',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_CLAY_CONTRACT_ABI,\n};\nexport const ITEM_SAND: IItem = {\n    id: 37,\n    name: 'Sand',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SAND_CONTRACT_ABI,\n};\nexport const ITEM_PLANT: IItem = {\n    id: 38,\n    name: 'Plant',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_PLANT_CONTRACT_ABI,\n};\nexport const ITEM_RAINBOW: IItem = {\n    id: 39,\n    name: 'Rainbow',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_RAINBOW_CONTRACT_ABI,\n};\nexport const ITEM_STORM: IItem = {\n    id: 40,\n    name: 'Storm',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_STORM_CONTRACT_ABI,\n};\nexport const ITEM_OBSIDIAN: IItem = {\n    id: 41,\n    name: 'Obsidian',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_OBSIDIAN_CONTRACT_ABI,\n};\nexport const ITEM_ASH: IItem = {\n    id: 42,\n    name: 'Ash',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_ASH_CONTRACT_ABI,\n};\nexport const ITEM_VOLCANO: IItem = {\n    id: 43,\n    name: 'Volcano',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_VOLCANO_CONTRACT_ABI,\n};\nexport const ITEM_SANDSTORM: IItem = {\n    id: 44,\n    name: 'Sandstorm',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SANDSTORM_CONTRACT_ABI,\n};\nexport const ITEM_CLOUD: IItem = {\n    id: 45,\n    name: 'Cloud',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_CLOUD_CONTRACT_ABI,\n};\nexport const ITEM_FOG: IItem = {\n    id: 46,\n    name: 'Fog',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_FOG_CONTRACT_ABI,\n};\nexport const ITEM_TREE: IItem = {\n    id: 47,\n    name: 'Tree',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_TREE_CONTRACT_ABI,\n};\nexport const ITEM_FOREST: IItem = {\n    id: 48,\n    name: 'Forest',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_FOREST_CONTRACT_ABI,\n};\nexport const ITEM_SEEDS: IItem = {\n    id: 49,\n    name: 'Seeds',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SEEDS_CONTRACT_ABI,\n};\nexport const ITEM_POTTERY: IItem = {\n    id: 50,\n    name: 'Pottery',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_POTTERY_CONTRACT_ABI,\n};\nexport const ITEM_BRICK: IItem = {\n    id: 51,\n    name: 'Brick',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_BRICK_CONTRACT_ABI,\n};\nexport const ITEM_QUICKSAND: IItem = {\n    id: 52,\n    name: 'Quicksand',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_QUICKSAND_CONTRACT_ABI,\n};\nexport const ITEM_GLASS: IItem = {\n    id: 53,\n    name: 'Glass',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_GLASS_CONTRACT_ABI,\n};\nexport const ITEM_DUNE: IItem = {\n    id: 54,\n    name: 'Dune',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_DUNE_CONTRACT_ABI,\n};\nexport const ITEM_CHARCOAL: IItem = {\n    id: 55,\n    name: 'Charcoal',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_CHARCOAL_CONTRACT_ABI,\n};\nexport const ITEM_LEAVES: IItem = {\n    id: 56,\n    name: 'Leaves',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_LEAVES_CONTRACT_ABI,\n};\nexport const ITEM_WILDFIRE: IItem = {\n    id: 57,\n    name: 'Wildfire',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_WILDFIRE_CONTRACT_ABI,\n};\nexport const ITEM_JUNGLE: IItem = {\n    id: 58,\n    name: 'Jungle',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_JUNGLE_CONTRACT_ABI,\n};\nexport const ITEM_FROSTED_GLASS: IItem = {\n    id: 59,\n    name: 'Frosted Glass',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_FROSTED_GLASS_CONTRACT_ABI,\n};\nexport const ITEM_CRYSTAL: IItem = {\n    id: 60,\n    name: 'Crystal',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_CRYSTAL_CONTRACT_ABI,\n};\nexport const ITEM_MAGMA: IItem = {\n    id: 61,\n    name: 'Magma',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_MAGMA_CONTRACT_ABI,\n};\nexport const ITEM_ROCK: IItem = {\n    id: 62,\n    name: 'Rock',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_ROCK_CONTRACT_ABI,\n};\nexport const ITEM_SHARD: IItem = {\n    id: 63,\n    name: 'Shard',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SHARD_CONTRACT_ABI,\n};\nexport const ITEM_PEBBLE: IItem = {\n    id: 64,\n    name: 'Pebble',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_PEBBLE_CONTRACT_ABI,\n};\nexport const ITEM_MOUNTAIN: IItem = {\n    id: 65,\n    name: 'Mountain',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_MOUNTAIN_CONTRACT_ABI,\n};\nexport const ITEM_FERTILIZER: IItem = {\n    id: 66,\n    name: 'Fertilizer',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_FERTILIZER_CONTRACT_ABI,\n};\nexport const ITEM_SOOT: IItem = {\n    id: 67,\n    name: 'Soot',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SOOT_CONTRACT_ABI,\n};\nexport const ITEM_LIGHTNING: IItem = {\n    id: 68,\n    name: 'Lightning',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_LIGHTNING_CONTRACT_ABI,\n};\nexport const ITEM_MIST: IItem = {\n    id: 69,\n    name: 'Mist',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_MIST_CONTRACT_ABI,\n};\nexport const ITEM_HAZE: IItem = {\n    id: 70,\n    name: 'Haze',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_HAZE_CONTRACT_ABI,\n};\nexport const ITEM_FLOOD: IItem = {\n    id: 71,\n    name: 'Flood',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_FLOOD_CONTRACT_ABI,\n};\nexport const ITEM_LANDSLIDE: IItem = {\n    id: 72,\n    name: 'Landslide',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_LANDSLIDE_CONTRACT_ABI,\n};\nexport const ITEM_THUNDER: IItem = {\n    id: 73,\n    name: 'Thunder',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_THUNDER_CONTRACT_ABI,\n};\nexport const ITEM_TORNADO: IItem = {\n    id: 74,\n    name: 'Tornado',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_TORNADO_CONTRACT_ABI,\n};\nexport const ITEM_GARDEN: IItem = {\n    id: 75,\n    name: 'Garden',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_GARDEN_CONTRACT_ABI,\n};\nexport const ITEM_EMBER: IItem = {\n    id: 76,\n    name: 'Ember',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_EMBER_CONTRACT_ABI,\n};\nexport const ITEM_KILN: IItem = {\n    id: 77,\n    name: 'Kiln',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_KILN_CONTRACT_ABI,\n};\nexport const ITEM_POLLINATION: IItem = {\n    id: 78,\n    name: 'Pollination',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_POLLINATION_CONTRACT_ABI,\n};\nexport const ITEM_SINKHOLE: IItem = {\n    id: 79,\n    name: 'Sinkhole',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SINKHOLE_CONTRACT_ABI,\n};\nexport const ITEM_BEACH: IItem = {\n    id: 80,\n    name: 'Beach',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_BEACH_CONTRACT_ABI,\n};\nexport const ITEM_WETSTONE: IItem = {\n    id: 81,\n    name: 'Wetstone',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_WETSTONE_CONTRACT_ABI,\n};\nexport const ITEM_EROSION: IItem = {\n    id: 82,\n    name: 'Erosion',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_EROSION_CONTRACT_ABI,\n};\nexport const ITEM_BASALT: IItem = {\n    id: 83,\n    name: 'Basalt',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_BASALT_CONTRACT_ABI,\n};\nexport const ITEM_MAGMA_CHAMBER: IItem = {\n    id: 84,\n    name: 'Magma Chamber',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_MAGMA_CHAMBER_CONTRACT_ABI,\n};\nexport const ITEM_BREEZE: IItem = {\n    id: 85,\n    name: 'Breeze',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_BREEZE_CONTRACT_ABI,\n};\nexport const ITEM_WARM_BREEZE: IItem = {\n    id: 86,\n    name: 'Warm Breeze',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_WARM_BREEZE_CONTRACT_ABI,\n};\nexport const ITEM_SOIL: IItem = {\n    id: 87,\n    name: 'Soil',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SOIL_CONTRACT_ABI,\n};\nexport const ITEM_CANYON: IItem = {\n    id: 88,\n    name: 'Canyon',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_CANYON_CONTRACT_ABI,\n};\nexport const ITEM_WINDMILL: IItem = {\n    id: 89,\n    name: 'Windmill',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_WINDMILL_CONTRACT_ABI,\n};\nexport const ITEM_ADOBE: IItem = {\n    id: 90,\n    name: 'Adobe',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_ADOBE_CONTRACT_ABI,\n};\nexport const ITEM_WALL: IItem = {\n    id: 91,\n    name: 'Wall',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_WALL_CONTRACT_ABI,\n};\nexport const ITEM_PUMICE: IItem = {\n    id: 92,\n    name: 'Pumice',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_PUMICE_CONTRACT_ABI,\n};\nexport const ITEM_BARBECUE: IItem = {\n    id: 93,\n    name: 'Barbecue',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_BARBECUE_CONTRACT_ABI,\n};\nexport const ITEM_FARM: IItem = {\n    id: 94,\n    name: 'Farm',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_FARM_CONTRACT_ABI,\n};\nexport const ITEM_SHARDS: IItem = {\n    id: 95,\n    name: 'Shards',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SHARDS_CONTRACT_ABI,\n};\nexport const ITEM_MOLTEN_GLASS: IItem = {\n    id: 96,\n    name: 'Molten Glass',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_MOLTEN_GLASS_CONTRACT_ABI,\n};\nexport const ITEM_PRISM: IItem = {\n    id: 97,\n    name: 'Prism',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_PRISM_CONTRACT_ABI,\n};\nexport const ITEM_SPARKLE: IItem = {\n    id: 98,\n    name: 'Sparkle',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SPARKLE_CONTRACT_ABI,\n};\nexport const ITEM_DESERT: IItem = {\n    id: 99,\n    name: 'Desert',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_DESERT_CONTRACT_ABI,\n};\nexport const ITEM_OASIS: IItem = {\n    id: 100,\n    name: 'Oasis',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_OASIS_CONTRACT_ABI,\n};\nexport const ITEM_MIRAGE: IItem = {\n    id: 101,\n    name: 'Mirage',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_MIRAGE_CONTRACT_ABI,\n};\nexport const ITEM_SAND_DUNE: IItem = {\n    id: 102,\n    name: 'Sand Dune',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SAND_DUNE_CONTRACT_ABI,\n};\nexport const ITEM_DAM: IItem = {\n    id: 103,\n    name: 'Dam',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_DAM_CONTRACT_ABI,\n};\nexport const ITEM_FIREWALL: IItem = {\n    id: 104,\n    name: 'Firewall',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_FIREWALL_CONTRACT_ABI,\n};\nexport const ITEM_BARRICADE: IItem = {\n    id: 105,\n    name: 'Barricade',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_BARRICADE_CONTRACT_ABI,\n};\nexport const ITEM_PLATEAU: IItem = {\n    id: 106,\n    name: 'Plateau',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_PLATEAU_CONTRACT_ABI,\n};\nexport const ITEM_POND: IItem = {\n    id: 107,\n    name: 'Pond',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_POND_CONTRACT_ABI,\n};\nexport const ITEM_AROMAS: IItem = {\n    id: 108,\n    name: 'Aromas',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_AROMAS_CONTRACT_ABI,\n};\nexport const ITEM_FLOWER: IItem = {\n    id: 109,\n    name: 'Flower',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_FLOWER_CONTRACT_ABI,\n};\nexport const ITEM_SPORE: IItem = {\n    id: 110,\n    name: 'Spore',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SPORE_CONTRACT_ABI,\n};\nexport const ITEM_SPREAD: IItem = {\n    id: 111,\n    name: 'Spread',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SPREAD_CONTRACT_ABI,\n};\nexport const ITEM_FERTILE_LAND: IItem = {\n    id: 112,\n    name: 'Fertile Land',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_FERTILE_LAND_CONTRACT_ABI,\n};\nexport const ITEM_WETLAND: IItem = {\n    id: 113,\n    name: 'Wetland',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_WETLAND_CONTRACT_ABI,\n};\nexport const ITEM_PEAT: IItem = {\n    id: 114,\n    name: 'Peat',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_PEAT_CONTRACT_ABI,\n};\nexport const ITEM_REEDS: IItem = {\n    id: 115,\n    name: 'Reeds',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_REEDS_CONTRACT_ABI,\n};\nexport const ITEM_VALLEY: IItem = {\n    id: 116,\n    name: 'Valley',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_VALLEY_CONTRACT_ABI,\n};\nexport const ITEM_RIVER: IItem = {\n    id: 117,\n    name: 'River',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_RIVER_CONTRACT_ABI,\n};\nexport const ITEM_SCORCHED_EARTH: IItem = {\n    id: 118,\n    name: 'Scorched Earth',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SCORCHED_EARTH_CONTRACT_ABI,\n};\nexport const ITEM_DELTA: IItem = {\n    id: 119,\n    name: 'Delta',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_DELTA_CONTRACT_ABI,\n};\nexport const ITEM_ESTUARY: IItem = {\n    id: 120,\n    name: 'Estuary',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_ESTUARY_CONTRACT_ABI,\n};\nexport const ITEM_FIRE_SWAMP: IItem = {\n    id: 121,\n    name: 'Fire Swamp',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_FIRE_SWAMP_CONTRACT_ABI,\n};\nexport const ITEM_RIVERBANK: IItem = {\n    id: 122,\n    name: 'Riverbank',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_RIVERBANK_CONTRACT_ABI,\n};\nexport const ITEM_RAVINE: IItem = {\n    id: 123,\n    name: 'Ravine',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_RAVINE_CONTRACT_ABI,\n};\nexport const ITEM_GORGE: IItem = {\n    id: 124,\n    name: 'Gorge',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_GORGE_CONTRACT_ABI,\n};\nexport const ITEM_CHARRED_RAVINE: IItem = {\n    id: 125,\n    name: 'Charred Ravine',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_CHARRED_RAVINE_CONTRACT_ABI,\n};\nexport const ITEM_ECHO: IItem = {\n    id: 126,\n    name: 'Echo',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_ECHO_CONTRACT_ABI,\n};\nexport const ITEM_CAVE: IItem = {\n    id: 127,\n    name: 'Cave',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_CAVE_CONTRACT_ABI,\n};\nexport const ITEM_UNDERGROUND_LAKE: IItem = {\n    id: 128,\n    name: 'Underground Lake',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_UNDERGROUND_LAKE_CONTRACT_ABI,\n};\nexport const ITEM_LAVA_CAVE: IItem = {\n    id: 129,\n    name: 'Lava Cave',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_LAVA_CAVE_CONTRACT_ABI,\n};\nexport const ITEM_WHISPERING_CAVE: IItem = {\n    id: 130,\n    name: 'Whispering Cave',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_WHISPERING_CAVE_CONTRACT_ABI,\n};\nexport const ITEM_SUBTERRANEAN_POOL: IItem = {\n    id: 131,\n    name: 'Subterranean Pool',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SUBTERRANEAN_POOL_CONTRACT_ABI,\n};\nexport const ITEM_SPRING: IItem = {\n    id: 132,\n    name: 'Spring',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SPRING_CONTRACT_ABI,\n};\nexport const ITEM_HOT_SPRING: IItem = {\n    id: 133,\n    name: 'Hot Spring',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_HOT_SPRING_CONTRACT_ABI,\n};\nexport const ITEM_GROTTO: IItem = {\n    id: 134,\n    name: 'Grotto',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_GROTTO_CONTRACT_ABI,\n};\nexport const ITEM_FOUNTAIN: IItem = {\n    id: 135,\n    name: 'Fountain',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_FOUNTAIN_CONTRACT_ABI,\n};\nexport const ITEM_STEAM_VENT: IItem = {\n    id: 136,\n    name: 'Steam Vent',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_STEAM_VENT_CONTRACT_ABI,\n};\nexport const ITEM_COOL_BREEZE: IItem = {\n    id: 137,\n    name: 'Cool Breeze',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_COOL_BREEZE_CONTRACT_ABI,\n};\nexport const ITEM_MONUMENT: IItem = {\n    id: 138,\n    name: 'Monument',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_MONUMENT_CONTRACT_ABI,\n};\nexport const ITEM_WATERFALL: IItem = {\n    id: 139,\n    name: 'Waterfall',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_WATERFALL_CONTRACT_ABI,\n};\nexport const ITEM_ETERNAL_FLAME: IItem = {\n    id: 140,\n    name: 'Eternal Flame',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_ETERNAL_FLAME_CONTRACT_ABI,\n};\nexport const ITEM_PILLAR_OF_WIND: IItem = {\n    id: 141,\n    name: 'Pillar Of Wind',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_PILLAR_OF_WIND_CONTRACT_ABI,\n};\nexport const ITEM_STREAM: IItem = {\n    id: 142,\n    name: 'Stream',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_STREAM_CONTRACT_ABI,\n};\nexport const ITEM_ZEPHYR: IItem = {\n    id: 143,\n    name: 'Zephyr',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_ZEPHYR_CONTRACT_ABI,\n};\nexport const ITEM_CREEK: IItem = {\n    id: 144,\n    name: 'Creek',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_CREEK_CONTRACT_ABI,\n};\nexport const ITEM_BROOK: IItem = {\n    id: 145,\n    name: 'Brook',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_BROOK_CONTRACT_ABI,\n};\nexport const ITEM_WHISPER: IItem = {\n    id: 146,\n    name: 'Whisper',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_WHISPER_CONTRACT_ABI,\n};\nexport const ITEM_RIVULET: IItem = {\n    id: 147,\n    name: 'Rivulet',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_RIVULET_CONTRACT_ABI,\n};\nexport const ITEM_TRIBUTARY: IItem = {\n    id: 148,\n    name: 'Tributary',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_TRIBUTARY_CONTRACT_ABI,\n};\nexport const ITEM_MURMUR: IItem = {\n    id: 149,\n    name: 'Murmur',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_MURMUR_CONTRACT_ABI,\n};\nexport const ITEM_WATERSHED: IItem = {\n    id: 150,\n    name: 'Watershed',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_WATERSHED_CONTRACT_ABI,\n};\nexport const ITEM_AQUIFER: IItem = {\n    id: 151,\n    name: 'Aquifer',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_AQUIFER_CONTRACT_ABI,\n};\nexport const ITEM_PARCHED_EARTH: IItem = {\n    id: 152,\n    name: 'Parched Earth',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_PARCHED_EARTH_CONTRACT_ABI,\n};\nexport const ITEM_FRESH_BREEZE: IItem = {\n    id: 153,\n    name: 'Fresh Breeze',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_FRESH_BREEZE_CONTRACT_ABI,\n};\nexport const ITEM_GROUNDWATER: IItem = {\n    id: 154,\n    name: 'Groundwater',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_GROUNDWATER_CONTRACT_ABI,\n};\nexport const ITEM_RESERVOIR: IItem = {\n    id: 155,\n    name: 'Reservoir',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_RESERVOIR_CONTRACT_ABI,\n};\nexport const ITEM_GEOTHERMAL_SPRING: IItem = {\n    id: 156,\n    name: 'Geothermal Spring',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_GEOTHERMAL_SPRING_CONTRACT_ABI,\n};\nexport const ITEM_ARTESIAN_WELL: IItem = {\n    id: 157,\n    name: 'Artesian Well',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_ARTESIAN_WELL_CONTRACT_ABI,\n};\nexport const ITEM_BASIN: IItem = {\n    id: 158,\n    name: 'Basin',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_BASIN_CONTRACT_ABI,\n};\nexport const ITEM_LAKE: IItem = {\n    id: 159,\n    name: 'Lake',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_LAKE_CONTRACT_ABI,\n};\nexport const ITEM_DRY_BASIN: IItem = {\n    id: 160,\n    name: 'Dry Basin',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_DRY_BASIN_CONTRACT_ABI,\n};\nexport const ITEM_DEPRESSION: IItem = {\n    id: 161,\n    name: 'Depression',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_DEPRESSION_CONTRACT_ABI,\n};\nexport const ITEM_ISLAND: IItem = {\n    id: 162,\n    name: 'Island',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_ISLAND_CONTRACT_ABI,\n};\nexport const ITEM_LAGOON: IItem = {\n    id: 163,\n    name: 'Lagoon',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_LAGOON_CONTRACT_ABI,\n};\nexport const ITEM_WAVE: IItem = {\n    id: 164,\n    name: 'Wave',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_WAVE_CONTRACT_ABI,\n};\nexport const ITEM_REEF: IItem = {\n    id: 165,\n    name: 'Reef',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_REEF_CONTRACT_ABI,\n};\nexport const ITEM_CORAL: IItem = {\n    id: 166,\n    name: 'Coral',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_CORAL_CONTRACT_ABI,\n};\nexport const ITEM_WHIRL: IItem = {\n    id: 167,\n    name: 'Whirl',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_WHIRL_CONTRACT_ABI,\n};\nexport const ITEM_LIMESTONE: IItem = {\n    id: 168,\n    name: 'Limestone',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_LIMESTONE_CONTRACT_ABI,\n};\nexport const ITEM_KARST: IItem = {\n    id: 169,\n    name: 'Karst',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_KARST_CONTRACT_ABI,\n};\nexport const ITEM_QUICKLIME: IItem = {\n    id: 170,\n    name: 'Quicklime',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_QUICKLIME_CONTRACT_ABI,\n};\nexport const ITEM_BLOWHOLE: IItem = {\n    id: 171,\n    name: 'Blowhole',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_BLOWHOLE_CONTRACT_ABI,\n};\n\nexport const ALL_ITEMS: IItem[] = [\n    ITEM_MONKEY,\n    ITEM_GIRAFFE,\n    ITEM_BEE,\n    ITEM_COIN,\n    ITEM_SWARM,\n    ITEM_HYDRA,\n    ITEM_MONKEY_BRANCH,\n    ITEM_BRIDGE,\n    ITEM_GOLDEN_GATE,\n    ITEM_GOLD,\n    ITEM_SILVER,\n    ITEM_RHODIUM,\n    ITEM_HIVE,\n    ITEM_TRANSACTION,\n    ITEM_BLOCK,\n    ITEM_BLOCKCHAIN,\n    ITEM_POLKADOT,\n    ITEM_PEER_REVIEW,\n    ITEM_CARDANO,\n    ITEM_BEAR,\n    ITEM_BEER,\n    ITEM_LOCK,\n    ITEM_MARMALADE,\n    ITEM_SUPER_MARMALADE,\n    ITEM_HYPER_MARMALADE,\n    ITEM_WATER,\n    ITEM_FIRE,\n    ITEM_STEAM,\n    ITEM_EARTH,\n    ITEM_MUD,\n    ITEM_LAVA,\n    ITEM_WIND,\n    ITEM_DUST,\n    ITEM_RAIN,\n    ITEM_SMOKE,\n    ITEM_GEYSER,\n    ITEM_CLAY,\n    ITEM_SAND,\n    ITEM_PLANT,\n    ITEM_RAINBOW,\n    ITEM_STORM,\n    ITEM_OBSIDIAN,\n    ITEM_ASH,\n    ITEM_VOLCANO,\n    ITEM_SANDSTORM,\n    ITEM_CLOUD,\n    ITEM_FOG,\n    ITEM_TREE,\n    ITEM_FOREST,\n    ITEM_SEEDS,\n    ITEM_POTTERY,\n    ITEM_BRICK,\n    ITEM_QUICKSAND,\n    ITEM_GLASS,\n    ITEM_DUNE,\n    ITEM_CHARCOAL,\n    ITEM_LEAVES,\n    ITEM_WILDFIRE,\n    ITEM_JUNGLE,\n    ITEM_FROSTED_GLASS,\n    ITEM_CRYSTAL,\n    ITEM_MAGMA,\n    ITEM_ROCK,\n    ITEM_SHARD,\n    ITEM_PEBBLE,\n    ITEM_MOUNTAIN,\n    ITEM_FERTILIZER,\n    ITEM_SOOT,\n    ITEM_LIGHTNING,\n    ITEM_MIST,\n    ITEM_HAZE,\n    ITEM_FLOOD,\n    ITEM_LANDSLIDE,\n    ITEM_THUNDER,\n    ITEM_TORNADO,\n    ITEM_GARDEN,\n    ITEM_EMBER,\n    ITEM_KILN,\n    ITEM_POLLINATION,\n    ITEM_SINKHOLE,\n    ITEM_BEACH,\n    ITEM_WETSTONE,\n    ITEM_EROSION,\n    ITEM_BASALT,\n    ITEM_MAGMA_CHAMBER,\n    ITEM_BREEZE,\n    ITEM_WARM_BREEZE,\n    ITEM_SOIL,\n    ITEM_CANYON,\n    ITEM_WINDMILL,\n    ITEM_ADOBE,\n    ITEM_WALL,\n    ITEM_PUMICE,\n    ITEM_BARBECUE,\n    ITEM_FARM,\n    ITEM_SHARDS,\n    ITEM_MOLTEN_GLASS,\n    ITEM_PRISM,\n    ITEM_SPARKLE,\n    ITEM_DESERT,\n    ITEM_OASIS,\n    ITEM_MIRAGE,\n    ITEM_SAND_DUNE,\n    ITEM_DAM,\n    ITEM_FIREWALL,\n    ITEM_BARRICADE,\n    ITEM_PLATEAU,\n    ITEM_POND,\n    ITEM_AROMAS,\n    ITEM_FLOWER,\n    ITEM_SPORE,\n    ITEM_SPREAD,\n    ITEM_FERTILE_LAND,\n    ITEM_WETLAND,\n    ITEM_PEAT,\n    ITEM_REEDS,\n    ITEM_VALLEY,\n    ITEM_RIVER,\n    ITEM_SCORCHED_EARTH,\n    ITEM_DELTA,\n    ITEM_ESTUARY,\n    ITEM_FIRE_SWAMP,\n    ITEM_RIVERBANK,\n    ITEM_RAVINE,\n    ITEM_GORGE,\n    ITEM_CHARRED_RAVINE,\n    ITEM_ECHO,\n    ITEM_CAVE,\n    ITEM_UNDERGROUND_LAKE,\n    ITEM_LAVA_CAVE,\n    ITEM_WHISPERING_CAVE,\n    ITEM_SUBTERRANEAN_POOL,\n    ITEM_SPRING,\n    ITEM_HOT_SPRING,\n    ITEM_GROTTO,\n    ITEM_FOUNTAIN,\n    ITEM_STEAM_VENT,\n    ITEM_COOL_BREEZE,\n    ITEM_MONUMENT,\n    ITEM_WATERFALL,\n    ITEM_ETERNAL_FLAME,\n    ITEM_PILLAR_OF_WIND,\n    ITEM_STREAM,\n    ITEM_ZEPHYR,\n    ITEM_CREEK,\n    ITEM_BROOK,\n    ITEM_WHISPER,\n    ITEM_RIVULET,\n    ITEM_TRIBUTARY,\n    ITEM_MURMUR,\n    ITEM_WATERSHED,\n    ITEM_AQUIFER,\n    ITEM_PARCHED_EARTH,\n    ITEM_FRESH_BREEZE,\n    ITEM_GROUNDWATER,\n    ITEM_RESERVOIR,\n    ITEM_GEOTHERMAL_SPRING,\n    ITEM_ARTESIAN_WELL,\n    ITEM_BASIN,\n    ITEM_LAKE,\n    ITEM_DRY_BASIN,\n    ITEM_DEPRESSION,\n    ITEM_ISLAND,\n    ITEM_LAGOON,\n    ITEM_WAVE,\n    ITEM_REEF,\n    ITEM_CORAL,\n    ITEM_WHIRL,\n    ITEM_LIMESTONE,\n    ITEM_KARST,\n    ITEM_QUICKLIME,\n    ITEM_BLOWHOLE,\n];\n\nexport const RECIPE_MAKE_SWARM: IRecipe = {\n    id: 0,\n    a: ITEM_BEE,\n    b: ITEM_BEE,\n    result: ITEM_SWARM,\n};\nexport const RECIPE_MAKE_HYDRA: IRecipe = {\n    id: 1,\n    a: ITEM_GIRAFFE,\n    b: ITEM_GIRAFFE,\n    result: ITEM_HYDRA,\n};\nexport const RECIPE_MAKE_MONKEYBRANCH: IRecipe = {\n    id: 2,\n    a: ITEM_MONKEY,\n    b: ITEM_HYDRA,\n    result: ITEM_MONKEY_BRANCH,\n};\nexport const RECIPE_MAKE_BRIDGE: IRecipe = {\n    id: 3,\n    a: ITEM_MONKEY_BRANCH,\n    b: ITEM_MONKEY_BRANCH,\n    result: ITEM_BRIDGE,\n};\nexport const RECIPE_MAKE_GOLDENGATE: IRecipe = {\n    id: 4,\n    a: ITEM_COIN,\n    b: ITEM_BRIDGE,\n    result: ITEM_GOLDEN_GATE,\n};\nexport const RECIPE_MAKE_CARDANO: IRecipe = {\n    id: 5,\n    a: ITEM_BLOCKCHAIN,\n    b: ITEM_PEER_REVIEW,\n    result: ITEM_CARDANO,\n};\nexport const RECIPE_MAKE_BEER: IRecipe = {\n    id: 6,\n    a: ITEM_BEE,\n    b: ITEM_BEAR,\n    result: ITEM_BEER,\n};\nexport const RECIPE_MAKE_LOCK: IRecipe = {\n    id: 7,\n    a: ITEM_SILVER,\n    b: ITEM_SILVER,\n    result: ITEM_LOCK,\n};\nexport const RECIPE_MAKE_SUPERMARMALADE: IRecipe = {\n    id: 8,\n    a: ITEM_MARMALADE,\n    b: ITEM_MARMALADE,\n    result: ITEM_SUPER_MARMALADE,\n};\nexport const RECIPE_MAKE_HYPERMARMALADE: IRecipe = {\n    id: 9,\n    a: ITEM_SUPER_MARMALADE,\n    b: ITEM_SUPER_MARMALADE,\n    result: ITEM_HYPER_MARMALADE,\n};\nexport const RECIPE_MAKE_STEAM: IRecipe = {\n    id: 10,\n    a: ITEM_WATER,\n    b: ITEM_FIRE,\n    result: ITEM_STEAM,\n};\nexport const RECIPE_MAKE_MUD: IRecipe = {\n    id: 11,\n    a: ITEM_WATER,\n    b: ITEM_EARTH,\n    result: ITEM_MUD,\n};\nexport const RECIPE_MAKE_LAVA: IRecipe = {\n    id: 12,\n    a: ITEM_FIRE,\n    b: ITEM_EARTH,\n    result: ITEM_LAVA,\n};\nexport const RECIPE_MAKE_DUST: IRecipe = {\n    id: 13,\n    a: ITEM_WIND,\n    b: ITEM_EARTH,\n    result: ITEM_DUST,\n};\nexport const RECIPE_MAKE_RAIN: IRecipe = {\n    id: 14,\n    a: ITEM_WATER,\n    b: ITEM_WIND,\n    result: ITEM_RAIN,\n};\nexport const RECIPE_MAKE_SMOKE: IRecipe = {\n    id: 15,\n    a: ITEM_FIRE,\n    b: ITEM_WIND,\n    result: ITEM_SMOKE,\n};\nexport const RECIPE_MAKE_GEYSER: IRecipe = {\n    id: 16,\n    a: ITEM_STEAM,\n    b: ITEM_EARTH,\n    result: ITEM_GEYSER,\n};\nexport const RECIPE_MAKE_CLAY: IRecipe = {\n    id: 17,\n    a: ITEM_MUD,\n    b: ITEM_FIRE,\n    result: ITEM_CLAY,\n};\nexport const RECIPE_MAKE_SAND: IRecipe = {\n    id: 18,\n    a: ITEM_MUD,\n    b: ITEM_WIND,\n    result: ITEM_SAND,\n};\nexport const RECIPE_MAKE_PLANT: IRecipe = {\n    id: 19,\n    a: ITEM_RAIN,\n    b: ITEM_EARTH,\n    result: ITEM_PLANT,\n};\nexport const RECIPE_MAKE_RAINBOW: IRecipe = {\n    id: 20,\n    a: ITEM_RAIN,\n    b: ITEM_FIRE,\n    result: ITEM_RAINBOW,\n};\nexport const RECIPE_MAKE_STORM: IRecipe = {\n    id: 21,\n    a: ITEM_RAIN,\n    b: ITEM_WIND,\n    result: ITEM_STORM,\n};\nexport const RECIPE_MAKE_OBSIDIAN: IRecipe = {\n    id: 22,\n    a: ITEM_LAVA,\n    b: ITEM_WATER,\n    result: ITEM_OBSIDIAN,\n};\nexport const RECIPE_MAKE_ASH: IRecipe = {\n    id: 23,\n    a: ITEM_LAVA,\n    b: ITEM_WIND,\n    result: ITEM_ASH,\n};\nexport const RECIPE_MAKE_VOLCANO: IRecipe = {\n    id: 24,\n    a: ITEM_LAVA,\n    b: ITEM_EARTH,\n    result: ITEM_VOLCANO,\n};\nexport const RECIPE_MAKE_SANDSTORM: IRecipe = {\n    id: 25,\n    a: ITEM_DUST,\n    b: ITEM_WIND,\n    result: ITEM_SANDSTORM,\n};\nexport const RECIPE_MAKE_CLOUD: IRecipe = {\n    id: 26,\n    a: ITEM_SMOKE,\n    b: ITEM_WATER,\n    result: ITEM_CLOUD,\n};\nexport const RECIPE_MAKE_FOG: IRecipe = {\n    id: 27,\n    a: ITEM_SMOKE,\n    b: ITEM_WIND,\n    result: ITEM_FOG,\n};\nexport const RECIPE_MAKE_TREE: IRecipe = {\n    id: 28,\n    a: ITEM_PLANT,\n    b: ITEM_WATER,\n    result: ITEM_TREE,\n};\nexport const RECIPE_MAKE_FOREST: IRecipe = {\n    id: 29,\n    a: ITEM_PLANT,\n    b: ITEM_EARTH,\n    result: ITEM_FOREST,\n};\nexport const RECIPE_MAKE_SEEDS: IRecipe = {\n    id: 30,\n    a: ITEM_PLANT,\n    b: ITEM_WIND,\n    result: ITEM_SEEDS,\n};\nexport const RECIPE_MAKE_POTTERY: IRecipe = {\n    id: 31,\n    a: ITEM_CLAY,\n    b: ITEM_FIRE,\n    result: ITEM_POTTERY,\n};\nexport const RECIPE_MAKE_BRICK: IRecipe = {\n    id: 32,\n    a: ITEM_CLAY,\n    b: ITEM_EARTH,\n    result: ITEM_BRICK,\n};\nexport const RECIPE_MAKE_QUICKSAND: IRecipe = {\n    id: 33,\n    a: ITEM_SAND,\n    b: ITEM_WATER,\n    result: ITEM_QUICKSAND,\n};\nexport const RECIPE_MAKE_GLASS: IRecipe = {\n    id: 34,\n    a: ITEM_SAND,\n    b: ITEM_FIRE,\n    result: ITEM_GLASS,\n};\nexport const RECIPE_MAKE_DUNE: IRecipe = {\n    id: 35,\n    a: ITEM_SAND,\n    b: ITEM_WIND,\n    result: ITEM_DUNE,\n};\nexport const RECIPE_MAKE_CHARCOAL: IRecipe = {\n    id: 36,\n    a: ITEM_TREE,\n    b: ITEM_FIRE,\n    result: ITEM_CHARCOAL,\n};\nexport const RECIPE_MAKE_LEAVES: IRecipe = {\n    id: 37,\n    a: ITEM_TREE,\n    b: ITEM_WIND,\n    result: ITEM_LEAVES,\n};\nexport const RECIPE_MAKE_WILDFIRE: IRecipe = {\n    id: 38,\n    a: ITEM_FOREST,\n    b: ITEM_FIRE,\n    result: ITEM_WILDFIRE,\n};\nexport const RECIPE_MAKE_JUNGLE: IRecipe = {\n    id: 39,\n    a: ITEM_FOREST,\n    b: ITEM_EARTH,\n    result: ITEM_JUNGLE,\n};\nexport const RECIPE_MAKE_FROSTED_GLASS: IRecipe = {\n    id: 40,\n    a: ITEM_GLASS,\n    b: ITEM_WATER,\n    result: ITEM_FROSTED_GLASS,\n};\nexport const RECIPE_MAKE_CRYSTAL: IRecipe = {\n    id: 41,\n    a: ITEM_GLASS,\n    b: ITEM_EARTH,\n    result: ITEM_CRYSTAL,\n};\nexport const RECIPE_MAKE_MAGMA: IRecipe = {\n    id: 42,\n    a: ITEM_OBSIDIAN,\n    b: ITEM_FIRE,\n    result: ITEM_MAGMA,\n};\nexport const RECIPE_MAKE_ROCK: IRecipe = {\n    id: 43,\n    a: ITEM_OBSIDIAN,\n    b: ITEM_EARTH,\n    result: ITEM_ROCK,\n};\nexport const RECIPE_MAKE_SHARD: IRecipe = {\n    id: 44,\n    a: ITEM_OBSIDIAN,\n    b: ITEM_WIND,\n    result: ITEM_SHARD,\n};\nexport const RECIPE_MAKE_PEBBLE: IRecipe = {\n    id: 45,\n    a: ITEM_ROCK,\n    b: ITEM_WATER,\n    result: ITEM_PEBBLE,\n};\nexport const RECIPE_MAKE_MOUNTAIN: IRecipe = {\n    id: 46,\n    a: ITEM_ROCK,\n    b: ITEM_EARTH,\n    result: ITEM_MOUNTAIN,\n};\nexport const RECIPE_MAKE_FERTILIZER: IRecipe = {\n    id: 47,\n    a: ITEM_ASH,\n    b: ITEM_EARTH,\n    result: ITEM_FERTILIZER,\n};\nexport const RECIPE_MAKE_SOOT: IRecipe = {\n    id: 48,\n    a: ITEM_ASH,\n    b: ITEM_WIND,\n    result: ITEM_SOOT,\n};\nexport const RECIPE_MAKE_LIGHTNING: IRecipe = {\n    id: 49,\n    a: ITEM_CLOUD,\n    b: ITEM_FIRE,\n    result: ITEM_LIGHTNING,\n};\nexport const RECIPE_MAKE_MIST: IRecipe = {\n    id: 50,\n    a: ITEM_FOG,\n    b: ITEM_EARTH,\n    result: ITEM_MIST,\n};\nexport const RECIPE_MAKE_HAZE: IRecipe = {\n    id: 51,\n    a: ITEM_FOG,\n    b: ITEM_WIND,\n    result: ITEM_HAZE,\n};\nexport const RECIPE_MAKE_FLOOD: IRecipe = {\n    id: 52,\n    a: ITEM_STORM,\n    b: ITEM_WATER,\n    result: ITEM_FLOOD,\n};\nexport const RECIPE_MAKE_LANDSLIDE: IRecipe = {\n    id: 53,\n    a: ITEM_STORM,\n    b: ITEM_EARTH,\n    result: ITEM_LANDSLIDE,\n};\nexport const RECIPE_MAKE_THUNDER: IRecipe = {\n    id: 54,\n    a: ITEM_STORM,\n    b: ITEM_FIRE,\n    result: ITEM_THUNDER,\n};\nexport const RECIPE_MAKE_TORNADO: IRecipe = {\n    id: 55,\n    a: ITEM_STORM,\n    b: ITEM_WIND,\n    result: ITEM_TORNADO,\n};\nexport const RECIPE_MAKE_GARDEN: IRecipe = {\n    id: 56,\n    a: ITEM_EARTH,\n    b: ITEM_PLANT,\n    result: ITEM_GARDEN,\n};\nexport const RECIPE_MAKE_EMBER: IRecipe = {\n    id: 57,\n    a: ITEM_FIRE,\n    b: ITEM_ASH,\n    result: ITEM_EMBER,\n};\nexport const RECIPE_MAKE_KILN: IRecipe = {\n    id: 58,\n    a: ITEM_FIRE,\n    b: ITEM_POTTERY,\n    result: ITEM_KILN,\n};\nexport const RECIPE_MAKE_POLLINATION: IRecipe = {\n    id: 59,\n    a: ITEM_WIND,\n    b: ITEM_PLANT,\n    result: ITEM_POLLINATION,\n};\nexport const RECIPE_MAKE_SINKHOLE: IRecipe = {\n    id: 60,\n    a: ITEM_EARTH,\n    b: ITEM_QUICKSAND,\n    result: ITEM_SINKHOLE,\n};\nexport const RECIPE_MAKE_BEACH: IRecipe = {\n    id: 61,\n    a: ITEM_WATER,\n    b: ITEM_SAND,\n    result: ITEM_BEACH,\n};\nexport const RECIPE_MAKE_WETSTONE: IRecipe = {\n    id: 62,\n    a: ITEM_WATER,\n    b: ITEM_OBSIDIAN,\n    result: ITEM_WETSTONE,\n};\nexport const RECIPE_MAKE_EROSION: IRecipe = {\n    id: 63,\n    a: ITEM_WIND,\n    b: ITEM_ROCK,\n    result: ITEM_EROSION,\n};\nexport const RECIPE_MAKE_BASALT: IRecipe = {\n    id: 64,\n    a: ITEM_WATER,\n    b: ITEM_LAVA,\n    result: ITEM_BASALT,\n};\nexport const RECIPE_MAKE_MAGMA_CHAMBER: IRecipe = {\n    id: 65,\n    a: ITEM_EARTH,\n    b: ITEM_LAVA,\n    result: ITEM_MAGMA_CHAMBER,\n};\nexport const RECIPE_MAKE_BREEZE: IRecipe = {\n    id: 66,\n    a: ITEM_WIND,\n    b: ITEM_DUST,\n    result: ITEM_BREEZE,\n};\nexport const RECIPE_MAKE_WARM_BREEZE: IRecipe = {\n    id: 67,\n    a: ITEM_FIRE,\n    b: ITEM_BREEZE,\n    result: ITEM_WARM_BREEZE,\n};\nexport const RECIPE_MAKE_SOIL: IRecipe = {\n    id: 68,\n    a: ITEM_EARTH,\n    b: ITEM_PLANT,\n    result: ITEM_SOIL,\n};\nexport const RECIPE_MAKE_CANYON: IRecipe = {\n    id: 69,\n    a: ITEM_WATER,\n    b: ITEM_EROSION,\n    result: ITEM_CANYON,\n};\nexport const RECIPE_MAKE_WINDMILL: IRecipe = {\n    id: 70,\n    a: ITEM_WIND,\n    b: ITEM_PLANT,\n    result: ITEM_WINDMILL,\n};\nexport const RECIPE_MAKE_ADOBE: IRecipe = {\n    id: 71,\n    a: ITEM_EARTH,\n    b: ITEM_CLAY,\n    result: ITEM_ADOBE,\n};\nexport const RECIPE_MAKE_WALL: IRecipe = {\n    id: 72,\n    a: ITEM_EARTH,\n    b: ITEM_BRICK,\n    result: ITEM_WALL,\n};\nexport const RECIPE_MAKE_PUMICE: IRecipe = {\n    id: 73,\n    a: ITEM_WATER,\n    b: ITEM_ASH,\n    result: ITEM_PUMICE,\n};\nexport const RECIPE_MAKE_BARBECUE: IRecipe = {\n    id: 74,\n    a: ITEM_FIRE,\n    b: ITEM_CHARCOAL,\n    result: ITEM_BARBECUE,\n};\nexport const RECIPE_MAKE_FARM: IRecipe = {\n    id: 75,\n    a: ITEM_EARTH,\n    b: ITEM_SEEDS,\n    result: ITEM_FARM,\n};\nexport const RECIPE_MAKE_SHARDS: IRecipe = {\n    id: 76,\n    a: ITEM_WIND,\n    b: ITEM_OBSIDIAN,\n    result: ITEM_SHARDS,\n};\nexport const RECIPE_MAKE_MOLTEN_GLASS: IRecipe = {\n    id: 77,\n    a: ITEM_FIRE,\n    b: ITEM_CRYSTAL,\n    result: ITEM_MOLTEN_GLASS,\n};\nexport const RECIPE_MAKE_PRISM: IRecipe = {\n    id: 78,\n    a: ITEM_WATER,\n    b: ITEM_CRYSTAL,\n    result: ITEM_PRISM,\n};\nexport const RECIPE_MAKE_SPARKLE: IRecipe = {\n    id: 79,\n    a: ITEM_WIND,\n    b: ITEM_CRYSTAL,\n    result: ITEM_SPARKLE,\n};\nexport const RECIPE_MAKE_DESERT: IRecipe = {\n    id: 80,\n    a: ITEM_EARTH,\n    b: ITEM_BEACH,\n    result: ITEM_DESERT,\n};\nexport const RECIPE_MAKE_OASIS: IRecipe = {\n    id: 81,\n    a: ITEM_WATER,\n    b: ITEM_DESERT,\n    result: ITEM_OASIS,\n};\nexport const RECIPE_MAKE_MIRAGE: IRecipe = {\n    id: 82,\n    a: ITEM_FIRE,\n    b: ITEM_DESERT,\n    result: ITEM_MIRAGE,\n};\nexport const RECIPE_MAKE_SAND_DUNE: IRecipe = {\n    id: 83,\n    a: ITEM_WIND,\n    b: ITEM_DESERT,\n    result: ITEM_SAND_DUNE,\n};\nexport const RECIPE_MAKE_DAM: IRecipe = {\n    id: 84,\n    a: ITEM_WATER,\n    b: ITEM_WALL,\n    result: ITEM_DAM,\n};\nexport const RECIPE_MAKE_FIREWALL: IRecipe = {\n    id: 85,\n    a: ITEM_FIRE,\n    b: ITEM_WALL,\n    result: ITEM_FIREWALL,\n};\nexport const RECIPE_MAKE_BARRICADE: IRecipe = {\n    id: 86,\n    a: ITEM_WIND,\n    b: ITEM_WALL,\n    result: ITEM_BARRICADE,\n};\nexport const RECIPE_MAKE_PLATEAU: IRecipe = {\n    id: 87,\n    a: ITEM_EARTH,\n    b: ITEM_CANYON,\n    result: ITEM_PLATEAU,\n};\nexport const RECIPE_MAKE_POND: IRecipe = {\n    id: 88,\n    a: ITEM_WATER,\n    b: ITEM_GARDEN,\n    result: ITEM_POND,\n};\nexport const RECIPE_MAKE_AROMAS: IRecipe = {\n    id: 89,\n    a: ITEM_WIND,\n    b: ITEM_GARDEN,\n    result: ITEM_AROMAS,\n};\nexport const RECIPE_MAKE_FLOWER: IRecipe = {\n    id: 90,\n    a: ITEM_WATER,\n    b: ITEM_POLLINATION,\n    result: ITEM_FLOWER,\n};\nexport const RECIPE_MAKE_SPORE: IRecipe = {\n    id: 91,\n    a: ITEM_FIRE,\n    b: ITEM_POLLINATION,\n    result: ITEM_SPORE,\n};\nexport const RECIPE_MAKE_SPREAD: IRecipe = {\n    id: 92,\n    a: ITEM_WIND,\n    b: ITEM_POLLINATION,\n    result: ITEM_SPREAD,\n};\nexport const RECIPE_MAKE_FERTILE_LAND: IRecipe = {\n    id: 93,\n    a: ITEM_EARTH,\n    b: ITEM_SOIL,\n    result: ITEM_FERTILE_LAND,\n};\nexport const RECIPE_MAKE_WETLAND: IRecipe = {\n    id: 94,\n    a: ITEM_WATER,\n    b: ITEM_FERTILE_LAND,\n    result: ITEM_WETLAND,\n};\nexport const RECIPE_MAKE_PEAT: IRecipe = {\n    id: 95,\n    a: ITEM_FIRE,\n    b: ITEM_WETLAND,\n    result: ITEM_PEAT,\n};\nexport const RECIPE_MAKE_REEDS: IRecipe = {\n    id: 96,\n    a: ITEM_WIND,\n    b: ITEM_WETLAND,\n    result: ITEM_REEDS,\n};\nexport const RECIPE_MAKE_VALLEY: IRecipe = {\n    id: 97,\n    a: ITEM_EARTH,\n    b: ITEM_CANYON,\n    result: ITEM_VALLEY,\n};\nexport const RECIPE_MAKE_RIVER: IRecipe = {\n    id: 98,\n    a: ITEM_WATER,\n    b: ITEM_VALLEY,\n    result: ITEM_RIVER,\n};\nexport const RECIPE_MAKE_SCORCHED_EARTH: IRecipe = {\n    id: 99,\n    a: ITEM_FIRE,\n    b: ITEM_VALLEY,\n    result: ITEM_SCORCHED_EARTH,\n};\nexport const RECIPE_MAKE_DELTA: IRecipe = {\n    id: 100,\n    a: ITEM_EARTH,\n    b: ITEM_RIVER,\n    result: ITEM_DELTA,\n};\nexport const RECIPE_MAKE_ESTUARY: IRecipe = {\n    id: 101,\n    a: ITEM_WATER,\n    b: ITEM_DELTA,\n    result: ITEM_ESTUARY,\n};\nexport const RECIPE_MAKE_FIRE_SWAMP: IRecipe = {\n    id: 102,\n    a: ITEM_FIRE,\n    b: ITEM_DELTA,\n    result: ITEM_FIRE_SWAMP,\n};\nexport const RECIPE_MAKE_RIVERBANK: IRecipe = {\n    id: 103,\n    a: ITEM_WIND,\n    b: ITEM_DELTA,\n    result: ITEM_RIVERBANK,\n};\nexport const RECIPE_MAKE_RAVINE: IRecipe = {\n    id: 104,\n    a: ITEM_EARTH,\n    b: ITEM_EROSION,\n    result: ITEM_RAVINE,\n};\nexport const RECIPE_MAKE_GORGE: IRecipe = {\n    id: 105,\n    a: ITEM_WATER,\n    b: ITEM_RAVINE,\n    result: ITEM_GORGE,\n};\nexport const RECIPE_MAKE_CHARRED_RAVINE: IRecipe = {\n    id: 106,\n    a: ITEM_FIRE,\n    b: ITEM_RAVINE,\n    result: ITEM_CHARRED_RAVINE,\n};\nexport const RECIPE_MAKE_ECHO: IRecipe = {\n    id: 107,\n    a: ITEM_WIND,\n    b: ITEM_RAVINE,\n    result: ITEM_ECHO,\n};\nexport const RECIPE_MAKE_CAVE: IRecipe = {\n    id: 108,\n    a: ITEM_EARTH,\n    b: ITEM_ECHO,\n    result: ITEM_CAVE,\n};\nexport const RECIPE_MAKE_UNDERGROUND_LAKE: IRecipe = {\n    id: 109,\n    a: ITEM_WATER,\n    b: ITEM_CAVE,\n    result: ITEM_UNDERGROUND_LAKE,\n};\nexport const RECIPE_MAKE_LAVA_CAVE: IRecipe = {\n    id: 110,\n    a: ITEM_FIRE,\n    b: ITEM_CAVE,\n    result: ITEM_LAVA_CAVE,\n};\nexport const RECIPE_MAKE_WHISPERING_CAVE: IRecipe = {\n    id: 111,\n    a: ITEM_WIND,\n    b: ITEM_CAVE,\n    result: ITEM_WHISPERING_CAVE,\n};\nexport const RECIPE_MAKE_SUBTERRANEAN_POOL: IRecipe = {\n    id: 112,\n    a: ITEM_EARTH,\n    b: ITEM_UNDERGROUND_LAKE,\n    result: ITEM_SUBTERRANEAN_POOL,\n};\nexport const RECIPE_MAKE_SPRING: IRecipe = {\n    id: 113,\n    a: ITEM_WATER,\n    b: ITEM_SUBTERRANEAN_POOL,\n    result: ITEM_SPRING,\n};\nexport const RECIPE_MAKE_HOT_SPRING: IRecipe = {\n    id: 114,\n    a: ITEM_FIRE,\n    b: ITEM_SUBTERRANEAN_POOL,\n    result: ITEM_HOT_SPRING,\n};\nexport const RECIPE_MAKE_GROTTO: IRecipe = {\n    id: 115,\n    a: ITEM_WIND,\n    b: ITEM_SUBTERRANEAN_POOL,\n    result: ITEM_GROTTO,\n};\nexport const RECIPE_MAKE_FOUNTAIN: IRecipe = {\n    id: 116,\n    a: ITEM_WATER,\n    b: ITEM_SPRING,\n    result: ITEM_FOUNTAIN,\n};\nexport const RECIPE_MAKE_STEAM_VENT: IRecipe = {\n    id: 117,\n    a: ITEM_FIRE,\n    b: ITEM_SPRING,\n    result: ITEM_STEAM_VENT,\n};\nexport const RECIPE_MAKE_COOL_BREEZE: IRecipe = {\n    id: 118,\n    a: ITEM_WIND,\n    b: ITEM_SPRING,\n    result: ITEM_COOL_BREEZE,\n};\nexport const RECIPE_MAKE_MONUMENT: IRecipe = {\n    id: 119,\n    a: ITEM_EARTH,\n    b: ITEM_FOUNTAIN,\n    result: ITEM_MONUMENT,\n};\nexport const RECIPE_MAKE_WATERFALL: IRecipe = {\n    id: 120,\n    a: ITEM_WATER,\n    b: ITEM_MONUMENT,\n    result: ITEM_WATERFALL,\n};\nexport const RECIPE_MAKE_ETERNAL_FLAME: IRecipe = {\n    id: 121,\n    a: ITEM_FIRE,\n    b: ITEM_MONUMENT,\n    result: ITEM_ETERNAL_FLAME,\n};\nexport const RECIPE_MAKE_PILLAR_OF_WIND: IRecipe = {\n    id: 122,\n    a: ITEM_WIND,\n    b: ITEM_MONUMENT,\n    result: ITEM_PILLAR_OF_WIND,\n};\nexport const RECIPE_MAKE_STREAM: IRecipe = {\n    id: 123,\n    a: ITEM_WATER,\n    b: ITEM_RIVER,\n    result: ITEM_STREAM,\n};\nexport const RECIPE_MAKE_ZEPHYR: IRecipe = {\n    id: 124,\n    a: ITEM_WIND,\n    b: ITEM_RIVER,\n    result: ITEM_ZEPHYR,\n};\nexport const RECIPE_MAKE_CREEK: IRecipe = {\n    id: 125,\n    a: ITEM_EARTH,\n    b: ITEM_STREAM,\n    result: ITEM_CREEK,\n};\nexport const RECIPE_MAKE_BROOK: IRecipe = {\n    id: 126,\n    a: ITEM_WATER,\n    b: ITEM_CREEK,\n    result: ITEM_BROOK,\n};\nexport const RECIPE_MAKE_WHISPER: IRecipe = {\n    id: 127,\n    a: ITEM_WIND,\n    b: ITEM_CREEK,\n    result: ITEM_WHISPER,\n};\nexport const RECIPE_MAKE_RIVULET: IRecipe = {\n    id: 128,\n    a: ITEM_EARTH,\n    b: ITEM_BROOK,\n    result: ITEM_RIVULET,\n};\nexport const RECIPE_MAKE_TRIBUTARY: IRecipe = {\n    id: 129,\n    a: ITEM_WATER,\n    b: ITEM_RIVULET,\n    result: ITEM_TRIBUTARY,\n};\nexport const RECIPE_MAKE_MURMUR: IRecipe = {\n    id: 130,\n    a: ITEM_WIND,\n    b: ITEM_RIVULET,\n    result: ITEM_MURMUR,\n};\nexport const RECIPE_MAKE_WATERSHED: IRecipe = {\n    id: 131,\n    a: ITEM_EARTH,\n    b: ITEM_TRIBUTARY,\n    result: ITEM_WATERSHED,\n};\nexport const RECIPE_MAKE_AQUIFER: IRecipe = {\n    id: 132,\n    a: ITEM_WATER,\n    b: ITEM_WATERSHED,\n    result: ITEM_AQUIFER,\n};\nexport const RECIPE_MAKE_PARCHED_EARTH: IRecipe = {\n    id: 133,\n    a: ITEM_FIRE,\n    b: ITEM_WATERSHED,\n    result: ITEM_PARCHED_EARTH,\n};\nexport const RECIPE_MAKE_FRESH_BREEZE: IRecipe = {\n    id: 134,\n    a: ITEM_WIND,\n    b: ITEM_WATERSHED,\n    result: ITEM_FRESH_BREEZE,\n};\nexport const RECIPE_MAKE_GROUNDWATER: IRecipe = {\n    id: 135,\n    a: ITEM_EARTH,\n    b: ITEM_AQUIFER,\n    result: ITEM_GROUNDWATER,\n};\nexport const RECIPE_MAKE_RESERVOIR: IRecipe = {\n    id: 136,\n    a: ITEM_WATER,\n    b: ITEM_GROUNDWATER,\n    result: ITEM_RESERVOIR,\n};\nexport const RECIPE_MAKE_GEOTHERMAL_SPRING: IRecipe = {\n    id: 137,\n    a: ITEM_FIRE,\n    b: ITEM_GROUNDWATER,\n    result: ITEM_GEOTHERMAL_SPRING,\n};\nexport const RECIPE_MAKE_ARTESIAN_WELL: IRecipe = {\n    id: 138,\n    a: ITEM_WIND,\n    b: ITEM_GROUNDWATER,\n    result: ITEM_ARTESIAN_WELL,\n};\nexport const RECIPE_MAKE_BASIN: IRecipe = {\n    id: 139,\n    a: ITEM_EARTH,\n    b: ITEM_RESERVOIR,\n    result: ITEM_BASIN,\n};\nexport const RECIPE_MAKE_LAKE: IRecipe = {\n    id: 140,\n    a: ITEM_WATER,\n    b: ITEM_BASIN,\n    result: ITEM_LAKE,\n};\nexport const RECIPE_MAKE_DRY_BASIN: IRecipe = {\n    id: 141,\n    a: ITEM_FIRE,\n    b: ITEM_BASIN,\n    result: ITEM_DRY_BASIN,\n};\nexport const RECIPE_MAKE_DEPRESSION: IRecipe = {\n    id: 142,\n    a: ITEM_WIND,\n    b: ITEM_BASIN,\n    result: ITEM_DEPRESSION,\n};\nexport const RECIPE_MAKE_ISLAND: IRecipe = {\n    id: 143,\n    a: ITEM_EARTH,\n    b: ITEM_LAKE,\n    result: ITEM_ISLAND,\n};\nexport const RECIPE_MAKE_LAGOON: IRecipe = {\n    id: 144,\n    a: ITEM_WATER,\n    b: ITEM_LAKE,\n    result: ITEM_LAGOON,\n};\nexport const RECIPE_MAKE_WAVE: IRecipe = {\n    id: 145,\n    a: ITEM_WIND,\n    b: ITEM_LAKE,\n    result: ITEM_WAVE,\n};\nexport const RECIPE_MAKE_REEF: IRecipe = {\n    id: 146,\n    a: ITEM_EARTH,\n    b: ITEM_LAGOON,\n    result: ITEM_REEF,\n};\nexport const RECIPE_MAKE_CORAL: IRecipe = {\n    id: 147,\n    a: ITEM_WATER,\n    b: ITEM_REEF,\n    result: ITEM_CORAL,\n};\nexport const RECIPE_MAKE_WHIRL: IRecipe = {\n    id: 148,\n    a: ITEM_WIND,\n    b: ITEM_REEF,\n    result: ITEM_WHIRL,\n};\nexport const RECIPE_MAKE_LIMESTONE: IRecipe = {\n    id: 149,\n    a: ITEM_EARTH,\n    b: ITEM_CORAL,\n    result: ITEM_LIMESTONE,\n};\nexport const RECIPE_MAKE_KARST: IRecipe = {\n    id: 150,\n    a: ITEM_WATER,\n    b: ITEM_LIMESTONE,\n    result: ITEM_KARST,\n};\nexport const RECIPE_MAKE_QUICKLIME: IRecipe = {\n    id: 151,\n    a: ITEM_FIRE,\n    b: ITEM_LIMESTONE,\n    result: ITEM_QUICKLIME,\n};\nexport const RECIPE_MAKE_BLOWHOLE: IRecipe = {\n    id: 152,\n    a: ITEM_WIND,\n    b: ITEM_KARST,\n    result: ITEM_BLOWHOLE,\n};\n\nexport const ALL_RECIPES: IRecipe[] = [\n    RECIPE_MAKE_SWARM,\n    RECIPE_MAKE_HYDRA,\n    RECIPE_MAKE_MONKEYBRANCH,\n    RECIPE_MAKE_BRIDGE,\n    RECIPE_MAKE_GOLDENGATE,\n    RECIPE_MAKE_CARDANO,\n    RECIPE_MAKE_BEER,\n    RECIPE_MAKE_LOCK,\n    RECIPE_MAKE_SUPERMARMALADE,\n    RECIPE_MAKE_HYPERMARMALADE,\n    RECIPE_MAKE_STEAM,\n    RECIPE_MAKE_MUD,\n    RECIPE_MAKE_LAVA,\n    RECIPE_MAKE_DUST,\n    RECIPE_MAKE_RAIN,\n    RECIPE_MAKE_SMOKE,\n    RECIPE_MAKE_GEYSER,\n    RECIPE_MAKE_CLAY,\n    RECIPE_MAKE_SAND,\n    RECIPE_MAKE_PLANT,\n    RECIPE_MAKE_RAINBOW,\n    RECIPE_MAKE_STORM,\n    RECIPE_MAKE_OBSIDIAN,\n    RECIPE_MAKE_ASH,\n    RECIPE_MAKE_VOLCANO,\n    RECIPE_MAKE_SANDSTORM,\n    RECIPE_MAKE_CLOUD,\n    RECIPE_MAKE_FOG,\n    RECIPE_MAKE_TREE,\n    RECIPE_MAKE_FOREST,\n    RECIPE_MAKE_SEEDS,\n    RECIPE_MAKE_POTTERY,\n    RECIPE_MAKE_BRICK,\n    RECIPE_MAKE_QUICKSAND,\n    RECIPE_MAKE_GLASS,\n    RECIPE_MAKE_DUNE,\n    RECIPE_MAKE_CHARCOAL,\n    RECIPE_MAKE_LEAVES,\n    RECIPE_MAKE_WILDFIRE,\n    RECIPE_MAKE_JUNGLE,\n    RECIPE_MAKE_FROSTED_GLASS,\n    RECIPE_MAKE_CRYSTAL,\n    RECIPE_MAKE_MAGMA,\n    RECIPE_MAKE_ROCK,\n    RECIPE_MAKE_SHARD,\n    RECIPE_MAKE_PEBBLE,\n    RECIPE_MAKE_MOUNTAIN,\n    RECIPE_MAKE_FERTILIZER,\n    RECIPE_MAKE_SOOT,\n    RECIPE_MAKE_LIGHTNING,\n    RECIPE_MAKE_MIST,\n    RECIPE_MAKE_HAZE,\n    RECIPE_MAKE_FLOOD,\n    RECIPE_MAKE_LANDSLIDE,\n    RECIPE_MAKE_THUNDER,\n    RECIPE_MAKE_TORNADO,\n    RECIPE_MAKE_GARDEN,\n    RECIPE_MAKE_EMBER,\n    RECIPE_MAKE_KILN,\n    RECIPE_MAKE_POLLINATION,\n    RECIPE_MAKE_SINKHOLE,\n    RECIPE_MAKE_BEACH,\n    RECIPE_MAKE_WETSTONE,\n    RECIPE_MAKE_EROSION,\n    RECIPE_MAKE_BASALT,\n    RECIPE_MAKE_MAGMA_CHAMBER,\n    RECIPE_MAKE_BREEZE,\n    RECIPE_MAKE_WARM_BREEZE,\n    RECIPE_MAKE_SOIL,\n    RECIPE_MAKE_CANYON,\n    RECIPE_MAKE_WINDMILL,\n    RECIPE_MAKE_ADOBE,\n    RECIPE_MAKE_WALL,\n    RECIPE_MAKE_PUMICE,\n    RECIPE_MAKE_BARBECUE,\n    RECIPE_MAKE_FARM,\n    RECIPE_MAKE_SHARDS,\n    RECIPE_MAKE_MOLTEN_GLASS,\n    RECIPE_MAKE_PRISM,\n    RECIPE_MAKE_SPARKLE,\n    RECIPE_MAKE_DESERT,\n    RECIPE_MAKE_OASIS,\n    RECIPE_MAKE_MIRAGE,\n    RECIPE_MAKE_SAND_DUNE,\n    RECIPE_MAKE_DAM,\n    RECIPE_MAKE_FIREWALL,\n    RECIPE_MAKE_BARRICADE,\n    RECIPE_MAKE_PLATEAU,\n    RECIPE_MAKE_POND,\n    RECIPE_MAKE_AROMAS,\n    RECIPE_MAKE_FLOWER,\n    RECIPE_MAKE_SPORE,\n    RECIPE_MAKE_SPREAD,\n    RECIPE_MAKE_FERTILE_LAND,\n    RECIPE_MAKE_WETLAND,\n    RECIPE_MAKE_PEAT,\n    RECIPE_MAKE_REEDS,\n    RECIPE_MAKE_VALLEY,\n    RECIPE_MAKE_RIVER,\n    RECIPE_MAKE_SCORCHED_EARTH,\n    RECIPE_MAKE_DELTA,\n    RECIPE_MAKE_ESTUARY,\n    RECIPE_MAKE_FIRE_SWAMP,\n    RECIPE_MAKE_RIVERBANK,\n    RECIPE_MAKE_RAVINE,\n    RECIPE_MAKE_GORGE,\n    RECIPE_MAKE_CHARRED_RAVINE,\n    RECIPE_MAKE_ECHO,\n    RECIPE_MAKE_CAVE,\n    RECIPE_MAKE_UNDERGROUND_LAKE,\n    RECIPE_MAKE_LAVA_CAVE,\n    RECIPE_MAKE_WHISPERING_CAVE,\n    RECIPE_MAKE_SUBTERRANEAN_POOL,\n    RECIPE_MAKE_SPRING,\n    RECIPE_MAKE_HOT_SPRING,\n    RECIPE_MAKE_GROTTO,\n    RECIPE_MAKE_FOUNTAIN,\n    RECIPE_MAKE_STEAM_VENT,\n    RECIPE_MAKE_COOL_BREEZE,\n    RECIPE_MAKE_MONUMENT,\n    RECIPE_MAKE_WATERFALL,\n    RECIPE_MAKE_ETERNAL_FLAME,\n    RECIPE_MAKE_PILLAR_OF_WIND,\n    RECIPE_MAKE_STREAM,\n    RECIPE_MAKE_ZEPHYR,\n    RECIPE_MAKE_CREEK,\n    RECIPE_MAKE_BROOK,\n    RECIPE_MAKE_WHISPER,\n    RECIPE_MAKE_RIVULET,\n    RECIPE_MAKE_TRIBUTARY,\n    RECIPE_MAKE_MURMUR,\n    RECIPE_MAKE_WATERSHED,\n    RECIPE_MAKE_AQUIFER,\n    RECIPE_MAKE_PARCHED_EARTH,\n    RECIPE_MAKE_FRESH_BREEZE,\n    RECIPE_MAKE_GROUNDWATER,\n    RECIPE_MAKE_RESERVOIR,\n    RECIPE_MAKE_GEOTHERMAL_SPRING,\n    RECIPE_MAKE_ARTESIAN_WELL,\n    RECIPE_MAKE_BASIN,\n    RECIPE_MAKE_LAKE,\n    RECIPE_MAKE_DRY_BASIN,\n    RECIPE_MAKE_DEPRESSION,\n    RECIPE_MAKE_ISLAND,\n    RECIPE_MAKE_LAGOON,\n    RECIPE_MAKE_WAVE,\n    RECIPE_MAKE_REEF,\n    RECIPE_MAKE_CORAL,\n    RECIPE_MAKE_WHIRL,\n    RECIPE_MAKE_LIMESTONE,\n    RECIPE_MAKE_KARST,\n    RECIPE_MAKE_QUICKLIME,\n    RECIPE_MAKE_BLOWHOLE,\n];\n\nexport const GAME_UNIFIERS_ITEMS: Array<IItem> = [\n    ITEM_MONKEY,\n    ITEM_GIRAFFE,\n    ITEM_BEE,\n    ITEM_COIN,\n    ITEM_SWARM,\n    ITEM_HYDRA,\n    ITEM_MONKEY_BRANCH,\n    ITEM_BRIDGE,\n    ITEM_GOLDEN_GATE,\n    ITEM_GOLD,\n    ITEM_SILVER,\n    ITEM_RHODIUM,\n    ITEM_HIVE,\n    ITEM_TRANSACTION,\n    ITEM_BLOCK,\n    ITEM_BLOCKCHAIN,\n    ITEM_POLKADOT,\n    ITEM_PEER_REVIEW,\n    ITEM_CARDANO,\n    ITEM_BEAR,\n    ITEM_BEER,\n    ITEM_LOCK,\n    ITEM_MARMALADE,\n    ITEM_SUPER_MARMALADE,\n    ITEM_HYPER_MARMALADE,\n];\nexport const GAME_UNIFIERS_RECIPES: Array<IRecipe> = [\n    RECIPE_MAKE_SWARM,\n    RECIPE_MAKE_HYDRA,\n    RECIPE_MAKE_MONKEYBRANCH,\n    RECIPE_MAKE_BRIDGE,\n    RECIPE_MAKE_GOLDENGATE,\n    RECIPE_MAKE_CARDANO,\n    RECIPE_MAKE_BEER,\n    RECIPE_MAKE_LOCK,\n    RECIPE_MAKE_SUPERMARMALADE,\n    RECIPE_MAKE_HYPERMARMALADE,\n];\nexport const GAME_UNIFIERS: IGameContent = {\n    name: \"Unifiers\",\n    description: \"A game created with the help of the Unifiers group\",\n    items: GAME_UNIFIERS_ITEMS,\n    recipes: GAME_UNIFIERS_RECIPES,\n    contractAbi: GAME_UNIFIERS_CONTRACT_ABI,\n};\nexport const GAME_ELEMENTY_ITEMS: Array<IItem> = [\n    ITEM_WATER,\n    ITEM_FIRE,\n    ITEM_STEAM,\n    ITEM_EARTH,\n    ITEM_MUD,\n    ITEM_LAVA,\n    ITEM_WIND,\n    ITEM_DUST,\n    ITEM_RAIN,\n    ITEM_SMOKE,\n    ITEM_GEYSER,\n    ITEM_CLAY,\n    ITEM_SAND,\n    ITEM_PLANT,\n    ITEM_RAINBOW,\n    ITEM_STORM,\n    ITEM_OBSIDIAN,\n    ITEM_ASH,\n    ITEM_VOLCANO,\n    ITEM_SANDSTORM,\n    ITEM_CLOUD,\n    ITEM_FOG,\n    ITEM_TREE,\n    ITEM_FOREST,\n    ITEM_SEEDS,\n    ITEM_POTTERY,\n    ITEM_BRICK,\n    ITEM_QUICKSAND,\n    ITEM_GLASS,\n    ITEM_DUNE,\n    ITEM_CHARCOAL,\n    ITEM_LEAVES,\n    ITEM_WILDFIRE,\n    ITEM_JUNGLE,\n    ITEM_FROSTED_GLASS,\n    ITEM_CRYSTAL,\n    ITEM_MAGMA,\n    ITEM_ROCK,\n    ITEM_SHARD,\n    ITEM_PEBBLE,\n    ITEM_MOUNTAIN,\n    ITEM_FERTILIZER,\n    ITEM_SOOT,\n    ITEM_LIGHTNING,\n    ITEM_MIST,\n    ITEM_HAZE,\n    ITEM_FLOOD,\n    ITEM_LANDSLIDE,\n    ITEM_THUNDER,\n    ITEM_TORNADO,\n    ITEM_GARDEN,\n    ITEM_EMBER,\n    ITEM_KILN,\n    ITEM_POLLINATION,\n    ITEM_SINKHOLE,\n    ITEM_BEACH,\n    ITEM_WETSTONE,\n    ITEM_EROSION,\n    ITEM_BASALT,\n    ITEM_MAGMA_CHAMBER,\n    ITEM_BREEZE,\n    ITEM_WARM_BREEZE,\n    ITEM_SOIL,\n    ITEM_CANYON,\n    ITEM_WINDMILL,\n    ITEM_ADOBE,\n    ITEM_WALL,\n    ITEM_PUMICE,\n    ITEM_BARBECUE,\n    ITEM_FARM,\n    ITEM_SHARDS,\n    ITEM_MOLTEN_GLASS,\n    ITEM_PRISM,\n    ITEM_SPARKLE,\n    ITEM_DESERT,\n    ITEM_OASIS,\n    ITEM_MIRAGE,\n    ITEM_SAND_DUNE,\n    ITEM_DAM,\n    ITEM_FIREWALL,\n    ITEM_BARRICADE,\n    ITEM_PLATEAU,\n    ITEM_POND,\n    ITEM_AROMAS,\n    ITEM_FLOWER,\n    ITEM_SPORE,\n    ITEM_SPREAD,\n    ITEM_FERTILE_LAND,\n    ITEM_WETLAND,\n    ITEM_PEAT,\n    ITEM_REEDS,\n    ITEM_VALLEY,\n    ITEM_RIVER,\n    ITEM_SCORCHED_EARTH,\n    ITEM_DELTA,\n    ITEM_ESTUARY,\n    ITEM_FIRE_SWAMP,\n    ITEM_RIVERBANK,\n    ITEM_RAVINE,\n    ITEM_GORGE,\n    ITEM_CHARRED_RAVINE,\n    ITEM_ECHO,\n    ITEM_CAVE,\n    ITEM_UNDERGROUND_LAKE,\n    ITEM_LAVA_CAVE,\n    ITEM_WHISPERING_CAVE,\n    ITEM_SUBTERRANEAN_POOL,\n    ITEM_SPRING,\n    ITEM_HOT_SPRING,\n    ITEM_GROTTO,\n    ITEM_FOUNTAIN,\n    ITEM_STEAM_VENT,\n    ITEM_COOL_BREEZE,\n    ITEM_MONUMENT,\n    ITEM_WATERFALL,\n    ITEM_ETERNAL_FLAME,\n    ITEM_PILLAR_OF_WIND,\n    ITEM_STREAM,\n    ITEM_ZEPHYR,\n    ITEM_CREEK,\n    ITEM_BROOK,\n    ITEM_WHISPER,\n    ITEM_RIVULET,\n    ITEM_TRIBUTARY,\n    ITEM_MURMUR,\n    ITEM_WATERSHED,\n    ITEM_AQUIFER,\n    ITEM_PARCHED_EARTH,\n    ITEM_FRESH_BREEZE,\n    ITEM_GROUNDWATER,\n    ITEM_RESERVOIR,\n    ITEM_GEOTHERMAL_SPRING,\n    ITEM_ARTESIAN_WELL,\n    ITEM_BASIN,\n    ITEM_LAKE,\n    ITEM_DRY_BASIN,\n    ITEM_DEPRESSION,\n    ITEM_ISLAND,\n    ITEM_LAGOON,\n    ITEM_WAVE,\n    ITEM_REEF,\n    ITEM_CORAL,\n    ITEM_WHIRL,\n    ITEM_LIMESTONE,\n    ITEM_KARST,\n    ITEM_QUICKLIME,\n    ITEM_BLOWHOLE,\n];\nexport const GAME_ELEMENTY_RECIPES: Array<IRecipe> = [\n    RECIPE_MAKE_STEAM,\n    RECIPE_MAKE_MUD,\n    RECIPE_MAKE_LAVA,\n    RECIPE_MAKE_DUST,\n    RECIPE_MAKE_RAIN,\n    RECIPE_MAKE_SMOKE,\n    RECIPE_MAKE_GEYSER,\n    RECIPE_MAKE_CLAY,\n    RECIPE_MAKE_SAND,\n    RECIPE_MAKE_PLANT,\n    RECIPE_MAKE_RAINBOW,\n    RECIPE_MAKE_STORM,\n    RECIPE_MAKE_OBSIDIAN,\n    RECIPE_MAKE_ASH,\n    RECIPE_MAKE_VOLCANO,\n    RECIPE_MAKE_SANDSTORM,\n    RECIPE_MAKE_CLOUD,\n    RECIPE_MAKE_FOG,\n    RECIPE_MAKE_TREE,\n    RECIPE_MAKE_FOREST,\n    RECIPE_MAKE_SEEDS,\n    RECIPE_MAKE_POTTERY,\n    RECIPE_MAKE_BRICK,\n    RECIPE_MAKE_QUICKSAND,\n    RECIPE_MAKE_GLASS,\n    RECIPE_MAKE_DUNE,\n    RECIPE_MAKE_CHARCOAL,\n    RECIPE_MAKE_LEAVES,\n    RECIPE_MAKE_WILDFIRE,\n    RECIPE_MAKE_JUNGLE,\n    RECIPE_MAKE_FROSTED_GLASS,\n    RECIPE_MAKE_CRYSTAL,\n    RECIPE_MAKE_MAGMA,\n    RECIPE_MAKE_ROCK,\n    RECIPE_MAKE_SHARD,\n    RECIPE_MAKE_PEBBLE,\n    RECIPE_MAKE_MOUNTAIN,\n    RECIPE_MAKE_FERTILIZER,\n    RECIPE_MAKE_SOOT,\n    RECIPE_MAKE_LIGHTNING,\n    RECIPE_MAKE_MIST,\n    RECIPE_MAKE_HAZE,\n    RECIPE_MAKE_FLOOD,\n    RECIPE_MAKE_LANDSLIDE,\n    RECIPE_MAKE_THUNDER,\n    RECIPE_MAKE_TORNADO,\n    RECIPE_MAKE_GARDEN,\n    RECIPE_MAKE_EMBER,\n    RECIPE_MAKE_KILN,\n    RECIPE_MAKE_POLLINATION,\n    RECIPE_MAKE_SINKHOLE,\n    RECIPE_MAKE_BEACH,\n    RECIPE_MAKE_WETSTONE,\n    RECIPE_MAKE_EROSION,\n    RECIPE_MAKE_BASALT,\n    RECIPE_MAKE_MAGMA_CHAMBER,\n    RECIPE_MAKE_BREEZE,\n    RECIPE_MAKE_WARM_BREEZE,\n    RECIPE_MAKE_SOIL,\n    RECIPE_MAKE_CANYON,\n    RECIPE_MAKE_WINDMILL,\n    RECIPE_MAKE_ADOBE,\n    RECIPE_MAKE_WALL,\n    RECIPE_MAKE_PUMICE,\n    RECIPE_MAKE_BARBECUE,\n    RECIPE_MAKE_FARM,\n    RECIPE_MAKE_SHARDS,\n    RECIPE_MAKE_MOLTEN_GLASS,\n    RECIPE_MAKE_PRISM,\n    RECIPE_MAKE_SPARKLE,\n    RECIPE_MAKE_DESERT,\n    RECIPE_MAKE_OASIS,\n    RECIPE_MAKE_MIRAGE,\n    RECIPE_MAKE_SAND_DUNE,\n    RECIPE_MAKE_DAM,\n    RECIPE_MAKE_FIREWALL,\n    RECIPE_MAKE_BARRICADE,\n    RECIPE_MAKE_PLATEAU,\n    RECIPE_MAKE_POND,\n    RECIPE_MAKE_AROMAS,\n    RECIPE_MAKE_FLOWER,\n    RECIPE_MAKE_SPORE,\n    RECIPE_MAKE_SPREAD,\n    RECIPE_MAKE_FERTILE_LAND,\n    RECIPE_MAKE_WETLAND,\n    RECIPE_MAKE_PEAT,\n    RECIPE_MAKE_REEDS,\n    RECIPE_MAKE_VALLEY,\n    RECIPE_MAKE_RIVER,\n    RECIPE_MAKE_SCORCHED_EARTH,\n    RECIPE_MAKE_DELTA,\n    RECIPE_MAKE_ESTUARY,\n    RECIPE_MAKE_FIRE_SWAMP,\n    RECIPE_MAKE_RIVERBANK,\n    RECIPE_MAKE_RAVINE,\n    RECIPE_MAKE_GORGE,\n    RECIPE_MAKE_CHARRED_RAVINE,\n    RECIPE_MAKE_ECHO,\n    RECIPE_MAKE_CAVE,\n    RECIPE_MAKE_UNDERGROUND_LAKE,\n    RECIPE_MAKE_LAVA_CAVE,\n    RECIPE_MAKE_WHISPERING_CAVE,\n    RECIPE_MAKE_SUBTERRANEAN_POOL,\n    RECIPE_MAKE_SPRING,\n    RECIPE_MAKE_HOT_SPRING,\n    RECIPE_MAKE_GROTTO,\n    RECIPE_MAKE_FOUNTAIN,\n    RECIPE_MAKE_STEAM_VENT,\n    RECIPE_MAKE_COOL_BREEZE,\n    RECIPE_MAKE_MONUMENT,\n    RECIPE_MAKE_WATERFALL,\n    RECIPE_MAKE_ETERNAL_FLAME,\n    RECIPE_MAKE_PILLAR_OF_WIND,\n    RECIPE_MAKE_STREAM,\n    RECIPE_MAKE_ZEPHYR,\n    RECIPE_MAKE_CREEK,\n    RECIPE_MAKE_BROOK,\n    RECIPE_MAKE_WHISPER,\n    RECIPE_MAKE_RIVULET,\n    RECIPE_MAKE_TRIBUTARY,\n    RECIPE_MAKE_MURMUR,\n    RECIPE_MAKE_WATERSHED,\n    RECIPE_MAKE_AQUIFER,\n    RECIPE_MAKE_PARCHED_EARTH,\n    RECIPE_MAKE_FRESH_BREEZE,\n    RECIPE_MAKE_GROUNDWATER,\n    RECIPE_MAKE_RESERVOIR,\n    RECIPE_MAKE_GEOTHERMAL_SPRING,\n    RECIPE_MAKE_ARTESIAN_WELL,\n    RECIPE_MAKE_BASIN,\n    RECIPE_MAKE_LAKE,\n    RECIPE_MAKE_DRY_BASIN,\n    RECIPE_MAKE_DEPRESSION,\n    RECIPE_MAKE_ISLAND,\n    RECIPE_MAKE_LAGOON,\n    RECIPE_MAKE_WAVE,\n    RECIPE_MAKE_REEF,\n    RECIPE_MAKE_CORAL,\n    RECIPE_MAKE_WHIRL,\n    RECIPE_MAKE_LIMESTONE,\n    RECIPE_MAKE_KARST,\n    RECIPE_MAKE_QUICKLIME,\n    RECIPE_MAKE_BLOWHOLE,\n];\nexport const GAME_ELEMENTY: IGameContent = {\n    name: \"Elementy\",\n    description: \"A game in which you combine elements to create new ones.\",\n    items: GAME_ELEMENTY_ITEMS,\n    recipes: GAME_ELEMENTY_RECIPES,\n    contractAbi: GAME_ELEMENTY_CONTRACT_ABI,\n};\nexport const ALL_GAMES: Array<IGameContent> = [\n    GAME_UNIFIERS,\n    GAME_ELEMENTY,\n];",
      "contentHash": "7c5bf0cae0d3bb8fbd1336f260fd159568d6e1f92af2f57410e0c8bb070413af",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IAdobeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Adobe' */\nexport interface IAdobeContract extends IElementContract {\n}",
      "contentHash": "0c6d59bd7d60049dbc6c07f3a6031ce75840a89209347ac181f875eb18e578b1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IAquiferContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Aquifer' */\nexport interface IAquiferContract extends IElementContract {\n}",
      "contentHash": "8622bc73813c1826336521be557ccb6f640e2a89e570444770a8b98059e7d2f5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IAromasContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Aromas' */\nexport interface IAromasContract extends IElementContract {\n}",
      "contentHash": "302668e7396138e70d3051c711d17b2bd18126d5d2fd14ee7d087e257ee17f3d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IArtesianWellContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'ArtesianWell' */\nexport interface IArtesianWellContract extends IElementContract {\n}",
      "contentHash": "7dcfb6dcf37eb9c66d05dad3cf1281c093626ec3b64cc2ec13c0a27095d70aec",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IAshContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Ash' */\nexport interface IAshContract extends IElementContract {\n}",
      "contentHash": "3433149198e9d5e5bf1cb2781cb49dbe5092f2ec8bd76260563e1acdeb3c24f6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBarbecueContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Barbecue' */\nexport interface IBarbecueContract extends IElementContract {\n}",
      "contentHash": "897e90bd5101f3117a759753da45230be6daebdf565369da3c95f8d3e4c44edc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBarricadeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Barricade' */\nexport interface IBarricadeContract extends IElementContract {\n}",
      "contentHash": "bbff65d37252d045de653a745318fbd6366399f38a99e3da6d987a0fa41f5b5f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBasaltContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Basalt' */\nexport interface IBasaltContract extends IElementContract {\n}",
      "contentHash": "b39130fdb93237fad2b477b9afb0bf703c595a73d034888b7b6ad1ecd6ceca17",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBasinContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Basin' */\nexport interface IBasinContract extends IElementContract {\n}",
      "contentHash": "b594b0d6a313c52e546b829944fc80d3a2fa2d2d53ff6d77ed6420caa8ad85dc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBeachContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Beach' */\nexport interface IBeachContract extends IElementContract {\n}",
      "contentHash": "eb3f340619b568af4e7562e1112e508902c09ec86c8e4f59a67de6c1688864ab",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBearContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Bear' */\nexport interface IBearContract extends IElementContract {\n}",
      "contentHash": "dbc7dce70d8590a162d8f1b061e33b71f7c3da8ee38e2d9be07d32bb87aff29b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBeeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Bee' */\nexport interface IBeeContract extends IElementContract {\n}",
      "contentHash": "e599bf6fbde7ef15a9e9e60771f8088870672b688a2944ee801634b35c40e814",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBeerContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Beer' */\nexport interface IBeerContract extends IElementContract {\n}",
      "contentHash": "c82126140d3e69e303de5acc77108515296d835e4c250b36e709c2977b8a725f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBlockchainContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Blockchain' */\nexport interface IBlockchainContract extends IElementContract {\n}",
      "contentHash": "04b54c84c1d47da99b9987c6c473c1134e694863bdfb49c27b3be53965730a15",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBlockContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Block' */\nexport interface IBlockContract extends IElementContract {\n}",
      "contentHash": "ed053882f8170fc6132db1e82e19bb6970896f8c09384ed9d87f81c7f814b8dd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBlowholeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Blowhole' */\nexport interface IBlowholeContract extends IElementContract {\n}",
      "contentHash": "29b8fed151d6e7f7c9f60891ffdd69b5282032c3a1223e03726fb64f6753fd6d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBreezeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Breeze' */\nexport interface IBreezeContract extends IElementContract {\n}",
      "contentHash": "b265ceb7f5fd52c0e51e8472db3489d5bdea10eafabda6f7aa848b28b9eb4e60",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBrickContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Brick' */\nexport interface IBrickContract extends IElementContract {\n}",
      "contentHash": "df2663cdb74842efde0c42b045641f81b9989cdce77a71f900bb051e12625a82",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBridgeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Bridge' */\nexport interface IBridgeContract extends IElementContract {\n}",
      "contentHash": "1933ae9c360f56d6ed47adad7d6fcfac7ba9de44cddf546d1458e412b201df1f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBrookContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Brook' */\nexport interface IBrookContract extends IElementContract {\n}",
      "contentHash": "508a8b1af028ca94c37ee741d1b0e123a459ac6fd9d066a991e0ed1327359153",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ICanyonContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Canyon' */\nexport interface ICanyonContract extends IElementContract {\n}",
      "contentHash": "6389896787495ce4740b703c8e9efcc60319ece93105f5858cbf2988e9f50378",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ICardanoContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Cardano' */\nexport interface ICardanoContract extends IElementContract {\n}",
      "contentHash": "23176866b2c544cd25b2bb81a57a2b568027aece572378d50f1921fb48b24673",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ICaveContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Cave' */\nexport interface ICaveContract extends IElementContract {\n}",
      "contentHash": "ee4d4fe3fc36c84b770bc3c6a5155c7cfdc78dc02c2d5abc0915c43c3d377675",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ICharcoalContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Charcoal' */\nexport interface ICharcoalContract extends IElementContract {\n}",
      "contentHash": "72c31bc81d3ad8ea4dbdf1a0ca23b564c337d6aa0843db7fb6784900b413bf42",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ICharredRavineContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'CharredRavine' */\nexport interface ICharredRavineContract extends IElementContract {\n}",
      "contentHash": "953f3c228152b6cd0cf305a8309bbec4e51e4307903e21a1aff4a6b1036d57f1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IClayContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Clay' */\nexport interface IClayContract extends IElementContract {\n}",
      "contentHash": "4f90e6dd7c87ac5b51190f8fb04061d5ab6c7970e3007ccbe101db74ebac08a2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ICloudContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Cloud' */\nexport interface ICloudContract extends IElementContract {\n}",
      "contentHash": "af66552fa8bfef050d65c77f76aaff57f69cee834b3b597c570012897a761771",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ICoinContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Coin' */\nexport interface ICoinContract extends IElementContract {\n}",
      "contentHash": "40857b349a34d90f452862672364e20be00e652d3fcaa81c4912d027bee3106f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ICoolBreezeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'CoolBreeze' */\nexport interface ICoolBreezeContract extends IElementContract {\n}",
      "contentHash": "86cd63e6ee06522916320603752123ada1478dcc781454406c8f2183ec60c13c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ICoralContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Coral' */\nexport interface ICoralContract extends IElementContract {\n}",
      "contentHash": "fcfbd8e2c3405be6e4713e3e5680493c410945718bf542cfd66fa16f93832f49",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ICreekContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Creek' */\nexport interface ICreekContract extends IElementContract {\n}",
      "contentHash": "4987021ebf8bf10350e858e988607cadd4b17be63e51b02064d180b82d10a54a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ICrystalContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Crystal' */\nexport interface ICrystalContract extends IElementContract {\n}",
      "contentHash": "63e237b2123d859b622ebfcea3fe8b9c85913f31324ebf6dad4d5b1554af39d6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IDamContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Dam' */\nexport interface IDamContract extends IElementContract {\n}",
      "contentHash": "390412ffabb3ce45528dc21bf9fc670317bca6e8254513b1075ace96d0981852",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IDeltaContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Delta' */\nexport interface IDeltaContract extends IElementContract {\n}",
      "contentHash": "d0b8fcd3ff31082addb2371601584e08966ad2f5cb1702b456b1781261b882e4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IDepressionContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Depression' */\nexport interface IDepressionContract extends IElementContract {\n}",
      "contentHash": "60cc6534be92d0a9378b43bd626ca96d510fd9dd4c5702fcbce8a7a207208abe",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IDesertContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Desert' */\nexport interface IDesertContract extends IElementContract {\n}",
      "contentHash": "77723dc1ea20a37d4332c4589520de2653bcef8e855373c62d744b047cbb059c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IDryBasinContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'DryBasin' */\nexport interface IDryBasinContract extends IElementContract {\n}",
      "contentHash": "12c4a42da10796af09d97b1614b62ac88d8af3c382aa58c5ea955bc29627c62c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IDuneContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Dune' */\nexport interface IDuneContract extends IElementContract {\n}",
      "contentHash": "ecce00680bdff51ad05c6a3ca187b208503d8fd9b92fa37cd60d28abf427de63",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IDustContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Dust' */\nexport interface IDustContract extends IElementContract {\n}",
      "contentHash": "143f8ed6f427e30c54798bd29e7e08325cf863a2671ede6c443c0ecd56241905",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IEarthContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Earth' */\nexport interface IEarthContract extends IElementContract {\n}",
      "contentHash": "ab79b56dbe0d4682f3b1f1c261db56d28a93fa7a405f5f31ec17b7cffa4ab1f7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IEchoContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Echo' */\nexport interface IEchoContract extends IElementContract {\n}",
      "contentHash": "a225549d944b4d42cb62afcf3136bc0e56cfa94bdeeb2bae15aae15b0aa3e8eb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IEmberContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Ember' */\nexport interface IEmberContract extends IElementContract {\n}",
      "contentHash": "59f2034a5fcca34aa8550b46c86ff69c974830eb752b13b90d55800b119d3448",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IErosionContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Erosion' */\nexport interface IErosionContract extends IElementContract {\n}",
      "contentHash": "ac7cc131b736b521e90c21c1c8c941485712e3fa438681d3c980d2e198c79e78",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IEstuaryContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Estuary' */\nexport interface IEstuaryContract extends IElementContract {\n}",
      "contentHash": "c163ee261ceb277d7c608f87e158e30415fd856502e4243f6dc37171cd0d2cad",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IEternalFlameContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'EternalFlame' */\nexport interface IEternalFlameContract extends IElementContract {\n}",
      "contentHash": "96b48e78495aeaa52b18a5cc717c562c26ca81fae6d9e3ffc51fb2ad5bd775bd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IFarmContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Farm' */\nexport interface IFarmContract extends IElementContract {\n}",
      "contentHash": "e27fd255e4d79e255df12ed1dfe6f4364ce2708ba3717daf1665ae60c0a62021",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IFertileLandContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'FertileLand' */\nexport interface IFertileLandContract extends IElementContract {\n}",
      "contentHash": "3cc75072068d6e1bf5eeb26548776663b51a39fbc10eef44ae422c81176d1461",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IFertilizerContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Fertilizer' */\nexport interface IFertilizerContract extends IElementContract {\n}",
      "contentHash": "c03a378f5c23d7dea1426d0413b2bb92353e45d0fcb29b25d5215b4533f27dc6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IFireContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Fire' */\nexport interface IFireContract extends IElementContract {\n}",
      "contentHash": "040ef5a70fbce7053578d9f1159292ce1668947a8ff2de32a2b9428a21748b4b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IFireSwampContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'FireSwamp' */\nexport interface IFireSwampContract extends IElementContract {\n}",
      "contentHash": "22c41620b9902c3c7b36ef2c9109bddfeea980a3d7c48d80c07475daa3bb6db7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IFirewallContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Firewall' */\nexport interface IFirewallContract extends IElementContract {\n}",
      "contentHash": "0bc46a8d50ac75a2ad775aaad0e3c8a3d63b804020dca0d3fc465174f7f23000",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IFloodContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Flood' */\nexport interface IFloodContract extends IElementContract {\n}",
      "contentHash": "ca0961231fa0c83f07598a4de9c5a21b977d81c451bd2c8b243729cfc29f6b98",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IFlowerContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Flower' */\nexport interface IFlowerContract extends IElementContract {\n}",
      "contentHash": "320d6a76cc53432635b42b51c5bfbe8027a5a4dd9bac9c3efe90a939121d3fd5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IFogContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Fog' */\nexport interface IFogContract extends IElementContract {\n}",
      "contentHash": "6e79af634726c736b309e95bac2aacecad60ac5390e6cac83049eb5bdcd08c43",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IForestContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Forest' */\nexport interface IForestContract extends IElementContract {\n}",
      "contentHash": "b4b87384b76b65611902cd3f35b6b372889b0f68483eaff4d68467143843072b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IFountainContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Fountain' */\nexport interface IFountainContract extends IElementContract {\n}",
      "contentHash": "6f8a94c310ec0fa877f7bdece7e6ce02f01889b98746c0d142c18e939ba12630",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IFreshBreezeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'FreshBreeze' */\nexport interface IFreshBreezeContract extends IElementContract {\n}",
      "contentHash": "81f487f955dc731554f16a3ed2594a8fdbc49545382dd2ff136936f3302c0a39",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IFrostedGlassContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'FrostedGlass' */\nexport interface IFrostedGlassContract extends IElementContract {\n}",
      "contentHash": "3c3eace5295191912edff766c86fcb1ab2d9cbc7b1356cb5623b567ecce97166",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IGardenContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Garden' */\nexport interface IGardenContract extends IElementContract {\n}",
      "contentHash": "fcd353ea0448e5d18520eaf244ff11b1cdc2f80beb3c29199eaf0785ee5e9036",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IGeothermalSpringContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'GeothermalSpring' */\nexport interface IGeothermalSpringContract extends IElementContract {\n}",
      "contentHash": "0f56f83f3ca9ed735901868e048548db049abf2a4fe59332f813597212b07468",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IGeyserContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Geyser' */\nexport interface IGeyserContract extends IElementContract {\n}",
      "contentHash": "377d93fe51442dadddac78f155652b718f087c6705e16942b98bec4b8c568e05",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IGiraffeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Giraffe' */\nexport interface IGiraffeContract extends IElementContract {\n}",
      "contentHash": "b0f132f7ec57e8b1a27e253388da29a87729a955b200b3c83729ee2b3f5f1c97",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IGlassContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Glass' */\nexport interface IGlassContract extends IElementContract {\n}",
      "contentHash": "e812ed2cfc2c83c46626ed7cd624a93ad70856ba773218aead5053a398c24359",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IGoldContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Gold' */\nexport interface IGoldContract extends IElementContract {\n}",
      "contentHash": "0a6a7d8b7d8cb1c99cf77533d3d8d3aa4c2df967a9b1ecd398c8bc0a8cc7211e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IGoldenGateContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'GoldenGate' */\nexport interface IGoldenGateContract extends IElementContract {\n}",
      "contentHash": "4a8b2b8ebda9af7326a8060db985e25a7e7c70618a5f0e9c5cd9896a634d3cb0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IGorgeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Gorge' */\nexport interface IGorgeContract extends IElementContract {\n}",
      "contentHash": "c1782160a581e2b3e08d47741efec4b9f8bf749711859b486bda1a6ce0c80311",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IGrottoContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Grotto' */\nexport interface IGrottoContract extends IElementContract {\n}",
      "contentHash": "f07bc2c3791d6b3be21abc6b2f2292724e5c01980407b2b43a562e6f669382ff",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IGroundwaterContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Groundwater' */\nexport interface IGroundwaterContract extends IElementContract {\n}",
      "contentHash": "d54e3a7fb338e9b89bd158f124b43ab42bfcea30916e97844705e0e45f94c249",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IHazeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Haze' */\nexport interface IHazeContract extends IElementContract {\n}",
      "contentHash": "8bbcb1b8eee93a4642c96ecba45d3072b2dd059b1b2a9f7a84fa3604ef8322b1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IHiveContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Hive' */\nexport interface IHiveContract extends IElementContract {\n}",
      "contentHash": "08012832365dfcce94d28349d84b262d7c6defcee4e8794c955954fdf3f9f995",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IHotSpringContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'HotSpring' */\nexport interface IHotSpringContract extends IElementContract {\n}",
      "contentHash": "cd0d60b8c2cb930e78f7ce1849902cc83c015400d45d625cf57af7325ce84c45",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IHydraContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Hydra' */\nexport interface IHydraContract extends IElementContract {\n}",
      "contentHash": "f85c3b6aee34bd315923d09ba262c6f3f257c271b416d6ba2677eccd50266175",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IHyperMarmaladeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'HyperMarmalade' */\nexport interface IHyperMarmaladeContract extends IElementContract {\n}",
      "contentHash": "c5f7a11fb98aa73dc04dbb7e0fbf3fbde0f22051db780788ffe59bf23ccf3a97",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IIslandContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Island' */\nexport interface IIslandContract extends IElementContract {\n}",
      "contentHash": "290b832a24bc3c80b2edcff4a5b5195d115a8f96f9944be0adda1746bbf4f6e8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IJungleContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Jungle' */\nexport interface IJungleContract extends IElementContract {\n}",
      "contentHash": "2495b411b28f8f5ea3f93d21837126684cda0f1c30cf130311dc434e9d5098ac",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IKarstContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Karst' */\nexport interface IKarstContract extends IElementContract {\n}",
      "contentHash": "45cb6826519794eaffca1d1011a6d07b786ae7403a489b0c0dd66ac60bb85746",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IKilnContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Kiln' */\nexport interface IKilnContract extends IElementContract {\n}",
      "contentHash": "1774f6cb4260d5ab4e2b397d7d276900440ddccf00352954545d38ab79122cad",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ILagoonContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Lagoon' */\nexport interface ILagoonContract extends IElementContract {\n}",
      "contentHash": "26c0851c8679c18227e18674bacac147e0e58320e038b00dda565e22a881e5ad",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ILakeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Lake' */\nexport interface ILakeContract extends IElementContract {\n}",
      "contentHash": "c3f78e5f14a5d5ad840f18b6314cb4548ab8d352dc2808a3734230080a9597bc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ILandslideContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Landslide' */\nexport interface ILandslideContract extends IElementContract {\n}",
      "contentHash": "63ea99ab83447cae67e179bc8ca6721b83e5a6d6f55e367d88f348234a574ad3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ILavaCaveContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'LavaCave' */\nexport interface ILavaCaveContract extends IElementContract {\n}",
      "contentHash": "0f0899fc02bafdcbfc32924e66fa282b9837b915a95cc309e2b35b8671f29e39",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ILavaContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Lava' */\nexport interface ILavaContract extends IElementContract {\n}",
      "contentHash": "45a3bc8a3354770a748c80c68370d658eb92809e340e4ab5d2fb0272bd7af77e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ILeavesContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Leaves' */\nexport interface ILeavesContract extends IElementContract {\n}",
      "contentHash": "ec133b3e9d4f81d9ac5b6d99cd03ed475ff5cd8c70c525c50de2795267dd4b94",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ILightningContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Lightning' */\nexport interface ILightningContract extends IElementContract {\n}",
      "contentHash": "a18f28018780b2dcfd83e92fc4097d424f4242f651737ad6494611ca4f23f38b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ILimestoneContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Limestone' */\nexport interface ILimestoneContract extends IElementContract {\n}",
      "contentHash": "5f53400ad9d3123b8227159fdd1f367a21f31ceddd914ecf6b1b8424e3ee9f42",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ILockContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Lock' */\nexport interface ILockContract extends IElementContract {\n}",
      "contentHash": "5abbfe49063e89c4a18b0dee309fa6df2195942bc44aa293118326a2635e6be9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IMagmaChamberContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'MagmaChamber' */\nexport interface IMagmaChamberContract extends IElementContract {\n}",
      "contentHash": "b395dbb908f2305ce5c69268a4593d229975320308b5e4c1e64e804f42697d90",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IMagmaContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Magma' */\nexport interface IMagmaContract extends IElementContract {\n}",
      "contentHash": "095eb2a56f38ffeccc5585567e10c1b7b22611bad94675da5868019df9a16172",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IMarmaladeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Marmalade' */\nexport interface IMarmaladeContract extends IElementContract {\n}",
      "contentHash": "b2a62c8f54e74767f5e19b10f3c62427d6e817f3fb9514b5fe775329eec3fc9a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IMirageContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Mirage' */\nexport interface IMirageContract extends IElementContract {\n}",
      "contentHash": "b4fe7769bac3f271e74d5c73bee733975e3c0eb3b434b0842a50db90e873476d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IMistContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Mist' */\nexport interface IMistContract extends IElementContract {\n}",
      "contentHash": "c998458f762ac0e7578a6e707bbec4a179d60167d7d318547a9bc85e130f2496",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IMoltenGlassContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'MoltenGlass' */\nexport interface IMoltenGlassContract extends IElementContract {\n}",
      "contentHash": "511c418074bb4edd6a76d85d7592d1e06da1caf5fc5458c7ca2ac31e84cedf63",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IMonkeyBranchContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'MonkeyBranch' */\nexport interface IMonkeyBranchContract extends IElementContract {\n}",
      "contentHash": "3e89ed2ce9c367c8a78ed90b65baca703207d8f60495a354d6d7910af2562cef",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IMonkeyContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Monkey' */\nexport interface IMonkeyContract extends IElementContract {\n}",
      "contentHash": "baaa2ad1dfc9777ef7d05b76d2e17ab4f547235452a982b095d295df3e471574",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IMonumentContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Monument' */\nexport interface IMonumentContract extends IElementContract {\n}",
      "contentHash": "1d4889f46aa336109e6eafa61ab2644eec53ef79ad680c11d07c2ba1331311ed",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IMountainContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Mountain' */\nexport interface IMountainContract extends IElementContract {\n}",
      "contentHash": "bce207d8c97faaae90d5b6fafab232a317ba5ef18ae8fc9796c1d9cb91acdeb3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IMudContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Mud' */\nexport interface IMudContract extends IElementContract {\n}",
      "contentHash": "9df02fabcb723222856838b7fc30ba793e56b24e2c3e7f503f29bb084ce1bafb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IMurmurContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Murmur' */\nexport interface IMurmurContract extends IElementContract {\n}",
      "contentHash": "232597e534044f5d046447d49a8f678b0df107c9a1f2c21dd3a86d1251437ec6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/index.ts",
      "content": "export * from './IGameContract';\nexport * from './IMonkeyContract';\nexport * from './IGiraffeContract';\nexport * from './IBeeContract';\nexport * from './ICoinContract';\nexport * from './ISwarmContract';\nexport * from './IHydraContract';\nexport * from './IMonkeyBranchContract';\nexport * from './IBridgeContract';\nexport * from './IGoldenGateContract';\nexport * from './IGoldContract';\nexport * from './ISilverContract';\nexport * from './IRhodiumContract';\nexport * from './IHiveContract';\nexport * from './ITransactionContract';\nexport * from './IBlockContract';\nexport * from './IBlockchainContract';\nexport * from './IPolkadotContract';\nexport * from './IPeerReviewContract';\nexport * from './ICardanoContract';\nexport * from './IBearContract';\nexport * from './IBeerContract';\nexport * from './ILockContract';\nexport * from './IMarmaladeContract';\nexport * from './ISuperMarmaladeContract';\nexport * from './IHyperMarmaladeContract';\nexport * from './IWaterContract';\nexport * from './IFireContract';\nexport * from './ISteamContract';\nexport * from './IEarthContract';\nexport * from './IMudContract';\nexport * from './ILavaContract';\nexport * from './IWindContract';\nexport * from './IDustContract';\nexport * from './IRainContract';\nexport * from './ISmokeContract';\nexport * from './IGeyserContract';\nexport * from './IClayContract';\nexport * from './ISandContract';\nexport * from './IPlantContract';\nexport * from './IRainbowContract';\nexport * from './IStormContract';\nexport * from './IObsidianContract';\nexport * from './IAshContract';\nexport * from './IVolcanoContract';\nexport * from './ISandstormContract';\nexport * from './ICloudContract';\nexport * from './IFogContract';\nexport * from './ITreeContract';\nexport * from './IForestContract';\nexport * from './ISeedsContract';\nexport * from './IPotteryContract';\nexport * from './IBrickContract';\nexport * from './IQuicksandContract';\nexport * from './IGlassContract';\nexport * from './IDuneContract';\nexport * from './ICharcoalContract';\nexport * from './ILeavesContract';\nexport * from './IWildfireContract';\nexport * from './IJungleContract';\nexport * from './IFrostedGlassContract';\nexport * from './ICrystalContract';\nexport * from './IMagmaContract';\nexport * from './IRockContract';\nexport * from './IShardContract';\nexport * from './IPebbleContract';\nexport * from './IMountainContract';\nexport * from './IFertilizerContract';\nexport * from './ISootContract';\nexport * from './ILightningContract';\nexport * from './IMistContract';\nexport * from './IHazeContract';\nexport * from './IFloodContract';\nexport * from './ILandslideContract';\nexport * from './IThunderContract';\nexport * from './ITornadoContract';\nexport * from './IGardenContract';\nexport * from './IEmberContract';\nexport * from './IKilnContract';\nexport * from './IPollinationContract';\nexport * from './ISinkholeContract';\nexport * from './IBeachContract';\nexport * from './IWetstoneContract';\nexport * from './IErosionContract';\nexport * from './IBasaltContract';\nexport * from './IMagmaChamberContract';\nexport * from './IBreezeContract';\nexport * from './IWarmBreezeContract';\nexport * from './ISoilContract';\nexport * from './ICanyonContract';\nexport * from './IWindmillContract';\nexport * from './IAdobeContract';\nexport * from './IWallContract';\nexport * from './IPumiceContract';\nexport * from './IBarbecueContract';\nexport * from './IFarmContract';\nexport * from './IShardsContract';\nexport * from './IMoltenGlassContract';\nexport * from './IPrismContract';\nexport * from './ISparkleContract';\nexport * from './IDesertContract';\nexport * from './IOasisContract';\nexport * from './IMirageContract';\nexport * from './ISandDuneContract';\nexport * from './IDamContract';\nexport * from './IFirewallContract';\nexport * from './IBarricadeContract';\nexport * from './IPlateauContract';\nexport * from './IPondContract';\nexport * from './IAromasContract';\nexport * from './IFlowerContract';\nexport * from './ISporeContract';\nexport * from './ISpreadContract';\nexport * from './IFertileLandContract';\nexport * from './IWetlandContract';\nexport * from './IPeatContract';\nexport * from './IReedsContract';\nexport * from './IValleyContract';\nexport * from './IRiverContract';\nexport * from './IScorchedEarthContract';\nexport * from './IDeltaContract';\nexport * from './IEstuaryContract';\nexport * from './IFireSwampContract';\nexport * from './IRiverbankContract';\nexport * from './IRavineContract';\nexport * from './IGorgeContract';\nexport * from './ICharredRavineContract';\nexport * from './IEchoContract';\nexport * from './ICaveContract';\nexport * from './IUndergroundLakeContract';\nexport * from './ILavaCaveContract';\nexport * from './IWhisperingCaveContract';\nexport * from './ISubterraneanPoolContract';\nexport * from './ISpringContract';\nexport * from './IHotSpringContract';\nexport * from './IGrottoContract';\nexport * from './IFountainContract';\nexport * from './ISteamVentContract';\nexport * from './ICoolBreezeContract';\nexport * from './IMonumentContract';\nexport * from './IWaterfallContract';\nexport * from './IEternalFlameContract';\nexport * from './IPillarOfWindContract';\nexport * from './IStreamContract';\nexport * from './IZephyrContract';\nexport * from './ICreekContract';\nexport * from './IBrookContract';\nexport * from './IWhisperContract';\nexport * from './IRivuletContract';\nexport * from './ITributaryContract';\nexport * from './IMurmurContract';\nexport * from './IWatershedContract';\nexport * from './IAquiferContract';\nexport * from './IParchedEarthContract';\nexport * from './IFreshBreezeContract';\nexport * from './IGroundwaterContract';\nexport * from './IReservoirContract';\nexport * from './IGeothermalSpringContract';\nexport * from './IArtesianWellContract';\nexport * from './IBasinContract';\nexport * from './ILakeContract';\nexport * from './IDryBasinContract';\nexport * from './IDepressionContract';\nexport * from './IIslandContract';\nexport * from './ILagoonContract';\nexport * from './IWaveContract';\nexport * from './IReefContract';\nexport * from './ICoralContract';\nexport * from './IWhirlContract';\nexport * from './ILimestoneContract';\nexport * from './IKarstContract';\nexport * from './IQuicklimeContract';\nexport * from './IBlowholeContract';\n",
      "contentHash": "14cd8d3ac216445feec66f27b39b491cfbde6be3310c946c186dc92cce259cf1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IOasisContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Oasis' */\nexport interface IOasisContract extends IElementContract {\n}",
      "contentHash": "b194049646b3a0e32f6e34dd6cf109b048c6b94ce32e1fd12924486210b9e43a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IObsidianContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Obsidian' */\nexport interface IObsidianContract extends IElementContract {\n}",
      "contentHash": "f7bd8d7438726cd788988f292c3aac82b7ba2c9ebfdc69c129534157d4adc645",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IParchedEarthContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'ParchedEarth' */\nexport interface IParchedEarthContract extends IElementContract {\n}",
      "contentHash": "6385ec5d84235a95c8f6ab0d570993eb3ed6287007c6fc5d231d227dad436156",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IPeatContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Peat' */\nexport interface IPeatContract extends IElementContract {\n}",
      "contentHash": "c3ff8a9aef06ae19b5ea16f418a965a34b73f61874468b279db489dbc5ee5040",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IPebbleContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Pebble' */\nexport interface IPebbleContract extends IElementContract {\n}",
      "contentHash": "d9380ed16ea16c7e63c8a485b0d8a119cea7cfd65aa98a8f1be9cfaf4baa5029",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IPeerReviewContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'PeerReview' */\nexport interface IPeerReviewContract extends IElementContract {\n}",
      "contentHash": "d0b75c0d4acf3414796ac9f63c83ad19390310ba518b18ca4623e4a2d023f611",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IPillarOfWindContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'PillarOfWind' */\nexport interface IPillarOfWindContract extends IElementContract {\n}",
      "contentHash": "d1cd07fea82ab48e1b9e587bc0f3c3d528cc1ab413c6436bc57cffe092626d36",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IPlantContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Plant' */\nexport interface IPlantContract extends IElementContract {\n}",
      "contentHash": "62e03b173c01866211c88f00e4b3514690d42707feb6d5582390cfcb6262ee2d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IPlateauContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Plateau' */\nexport interface IPlateauContract extends IElementContract {\n}",
      "contentHash": "55c3d79c6097a366bccdb80adc4f98ccf3686dc13e11504b43a8de665c835dd8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IPolkadotContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Polkadot' */\nexport interface IPolkadotContract extends IElementContract {\n}",
      "contentHash": "d59f6fab4c68fbe345e172ab165d1e662ff49bc067f14cb8af4e612aea946881",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IPollinationContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Pollination' */\nexport interface IPollinationContract extends IElementContract {\n}",
      "contentHash": "2187691dd0e5fc75286af718191588987f74e40248494eeef97d7e7a8e70bd61",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IPondContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Pond' */\nexport interface IPondContract extends IElementContract {\n}",
      "contentHash": "e5d7c421126254f5ae5cbac7888e11c8f40567995b5ea2848484312c3222e250",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IPotteryContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Pottery' */\nexport interface IPotteryContract extends IElementContract {\n}",
      "contentHash": "9fe6db27ab183e473ac59da1564347b8200ff51e2579b0b6753c8799a760c16b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IPrismContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Prism' */\nexport interface IPrismContract extends IElementContract {\n}",
      "contentHash": "24b8b54aa32a1f873b06e81efffa16691cc72a0fd25a22506b65fc99ed489f64",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IPumiceContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Pumice' */\nexport interface IPumiceContract extends IElementContract {\n}",
      "contentHash": "257163668d0886aaf279f338c3bc0d60c7351e96b62b8195aeaaf38b0875ab05",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IQuicklimeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Quicklime' */\nexport interface IQuicklimeContract extends IElementContract {\n}",
      "contentHash": "65a757ea992f6d77ce817227b893d7460ba5665311e6afe980bf68704c905638",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IQuicksandContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Quicksand' */\nexport interface IQuicksandContract extends IElementContract {\n}",
      "contentHash": "c6b1f766a297ff5c12785d6f8da5a079de076eaa99ff509f1d46b42ab3e07542",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IRainbowContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Rainbow' */\nexport interface IRainbowContract extends IElementContract {\n}",
      "contentHash": "1d82e606ad38161c8255555ec12e089749da774d2dab4038da10c13e6e6f399c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IRainContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Rain' */\nexport interface IRainContract extends IElementContract {\n}",
      "contentHash": "e0b0df056b0bae8c568a683283ab9928f441ae6b6271f813aaeca6fc22d07e99",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IRavineContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Ravine' */\nexport interface IRavineContract extends IElementContract {\n}",
      "contentHash": "5fcd60b43785b89e58810764070bfdeefa62bbd4eabef22791c68b55f0a5a1d2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IReedsContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Reeds' */\nexport interface IReedsContract extends IElementContract {\n}",
      "contentHash": "5851eadf84cd2daed9e949de4f0fc8cddb8cca4339e6cfd797a4fd56b080a59d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IReefContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Reef' */\nexport interface IReefContract extends IElementContract {\n}",
      "contentHash": "4e92152c1105247ca79b63a2ff2d5d5ddca7eddfbbbb2bba5261487f91405b81",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IReservoirContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Reservoir' */\nexport interface IReservoirContract extends IElementContract {\n}",
      "contentHash": "13642dd8d7b1c75ce6513647bd3bab9775bee82619567b01b5abc47932d2f141",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IRhodiumContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Rhodium' */\nexport interface IRhodiumContract extends IElementContract {\n}",
      "contentHash": "8e688b8436c36043bde57972c959199126d54b5ce53065e51d59b1ddce69d833",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IRiverbankContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Riverbank' */\nexport interface IRiverbankContract extends IElementContract {\n}",
      "contentHash": "03d4b2bd4b3cec4159ca29fc35d62e3efd26bc2313cbe2d7552187d18c439047",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IRiverContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'River' */\nexport interface IRiverContract extends IElementContract {\n}",
      "contentHash": "129a1b4e8ac952643f09c75a9924202609ae43b8aeebf5dfe47c594ec613476d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IRivuletContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Rivulet' */\nexport interface IRivuletContract extends IElementContract {\n}",
      "contentHash": "af9f045997f56acc0542ea724a96745121ab6a3085641149c5200db7d9afca0c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IRockContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Rock' */\nexport interface IRockContract extends IElementContract {\n}",
      "contentHash": "d708520f5e745c4026cb42e58d7b4f33d5cee14d0a18b470f0fbfae65f108992",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISandContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Sand' */\nexport interface ISandContract extends IElementContract {\n}",
      "contentHash": "3627deb075a4d19b3a1f7cf053023041a349507d5c2a105da9ccc43663521266",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISandDuneContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'SandDune' */\nexport interface ISandDuneContract extends IElementContract {\n}",
      "contentHash": "e5bf98e6e474eb84436ad63abc299c1f47842376dd75a7f9798e5e0fb3bb7dc4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISandstormContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Sandstorm' */\nexport interface ISandstormContract extends IElementContract {\n}",
      "contentHash": "f205d7dd45e52749a823fe3c82c97d684772682481bc88b63a57455d23a3ed6d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IScorchedEarthContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'ScorchedEarth' */\nexport interface IScorchedEarthContract extends IElementContract {\n}",
      "contentHash": "f71f93b096b3e6b1598061f5b1268e10396bd4d8335c66c12bbc9c1daf3204d9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISeedsContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Seeds' */\nexport interface ISeedsContract extends IElementContract {\n}",
      "contentHash": "817f4ecd20e39a7f464a27a28459e112000436b1f20ff073baf4dbaea163f302",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IShardContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Shard' */\nexport interface IShardContract extends IElementContract {\n}",
      "contentHash": "004804f9c28944e437be99c9528f4586a748d476e1667573565bd24ea62345be",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IShardsContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Shards' */\nexport interface IShardsContract extends IElementContract {\n}",
      "contentHash": "b298ad35f67f398179f2fc62fe2558648940a38fd3d8d6098272c6a0bc3c9f9d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISilverContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Silver' */\nexport interface ISilverContract extends IElementContract {\n}",
      "contentHash": "d62ce35a00728f18e5a0693b180acfc5f86490d01c5a394bf15d677be51780b4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISinkholeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Sinkhole' */\nexport interface ISinkholeContract extends IElementContract {\n}",
      "contentHash": "5ad53b7182d532749b8b43c10b2011e95518e7eb2259679a0e3eba6d581954cb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISmokeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Smoke' */\nexport interface ISmokeContract extends IElementContract {\n}",
      "contentHash": "ee1c824c5d5ddfce4a1745b2b11a729092a753abab5996746787714de4860b91",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISoilContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Soil' */\nexport interface ISoilContract extends IElementContract {\n}",
      "contentHash": "641e7a460eacf4fd3d09f465010c471953246e952474b8fff9a7d5152bb45ca6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISootContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Soot' */\nexport interface ISootContract extends IElementContract {\n}",
      "contentHash": "714aa5a181c84c602458e2fe834d957e7cc5d6abacff965c181d65b757de62ec",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISparkleContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Sparkle' */\nexport interface ISparkleContract extends IElementContract {\n}",
      "contentHash": "88885fc3e14acdf44cc2a406b17ddf575424aff06130f264824475d5d83d3066",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISporeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Spore' */\nexport interface ISporeContract extends IElementContract {\n}",
      "contentHash": "bb81f348b681226fd5088e8e3276c11aaa92372d588e3b67f94a9adca0081091",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISpreadContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Spread' */\nexport interface ISpreadContract extends IElementContract {\n}",
      "contentHash": "5407bb28b7f5f91204f29db61db33238956baf9f01a98245578053f871ea5102",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISpringContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Spring' */\nexport interface ISpringContract extends IElementContract {\n}",
      "contentHash": "48b4815ec2a43dc10306a0ada480564aef78ded978c77cfe4e2f4fe47e894490",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISteamContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Steam' */\nexport interface ISteamContract extends IElementContract {\n}",
      "contentHash": "af72b196861e596d7c3c03073536beb62dfbc67b63fa4f0d3a842b39aeedb21f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISteamVentContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'SteamVent' */\nexport interface ISteamVentContract extends IElementContract {\n}",
      "contentHash": "6cd2a86c079bab2c0632d81dd15a27da03119b1012fd754851088995850fb9b1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IStormContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Storm' */\nexport interface IStormContract extends IElementContract {\n}",
      "contentHash": "c3033e1a701c3335848257599b9b6e0476719d1892599662061ef7a17bb7d020",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IStreamContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Stream' */\nexport interface IStreamContract extends IElementContract {\n}",
      "contentHash": "6558b970e82eb9252f62c811973d0f82f762431506eacb0285a7cee1986a06fa",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISubterraneanPoolContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'SubterraneanPool' */\nexport interface ISubterraneanPoolContract extends IElementContract {\n}",
      "contentHash": "c0071bb70b8c7bf5845ca9fec204bd3f426bb903ca95c6ab3c36b4ff9119ba42",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISuperMarmaladeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'SuperMarmalade' */\nexport interface ISuperMarmaladeContract extends IElementContract {\n}",
      "contentHash": "66a3b3529321223ab59de2801d7a39350680af4d45938486105887b390c5f77c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISwarmContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'SWARM' */\nexport interface ISwarmContract extends IElementContract {\n}",
      "contentHash": "9d2fa8eb888255c648fd9f8a409e3ceff1530082a2a17ae267af954f286dbfee",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IThunderContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Thunder' */\nexport interface IThunderContract extends IElementContract {\n}",
      "contentHash": "8de31f704dbbdb36824cd8629ced5507ac86672c586855bf5ea6773a758c5b97",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ITornadoContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Tornado' */\nexport interface ITornadoContract extends IElementContract {\n}",
      "contentHash": "4f3adb9919c3c64dd0724ea1faa1fbd04cb8ac2bc4e52e1f4da20eac9bb7acf5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ITransactionContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Transaction' */\nexport interface ITransactionContract extends IElementContract {\n}",
      "contentHash": "89f93a898dc4d37458bfe21b94c5748b59b8a68700fc9ca61f94818700429afe",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ITreeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Tree' */\nexport interface ITreeContract extends IElementContract {\n}",
      "contentHash": "ef4e5a185f0d568032ca72a675c341c58feb15b65d6bf6a391802a6a7fb74fcd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ITributaryContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Tributary' */\nexport interface ITributaryContract extends IElementContract {\n}",
      "contentHash": "664aa29a9ea2a6aaa21f089fb2cdf17dc68c11fc86ac7af8bf5adb0608a38449",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IUndergroundLakeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'UndergroundLake' */\nexport interface IUndergroundLakeContract extends IElementContract {\n}",
      "contentHash": "27eddc70ea16a5639bfdbaddff26eed4d433d493c5c50e0dabb5aa07a37e276c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IValleyContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Valley' */\nexport interface IValleyContract extends IElementContract {\n}",
      "contentHash": "18688ad5668606f2ab759c0bb7e4925bc8261c1bca56c36405da4b443d4eaac8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IVolcanoContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Volcano' */\nexport interface IVolcanoContract extends IElementContract {\n}",
      "contentHash": "1f3cb34d51de88c740687c4a17ba8015878f236850da821186f857e4fff00344",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IWallContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Wall' */\nexport interface IWallContract extends IElementContract {\n}",
      "contentHash": "63006d1f0537a6f29f725f867d9a89e1377c168795b5100d1cdc2fb825f89a51",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IWarmBreezeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'WarmBreeze' */\nexport interface IWarmBreezeContract extends IElementContract {\n}",
      "contentHash": "3a090df71bc2f28a143487e4f94743f1fe2519d616ad6ab7fcb8c94e327e0f72",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IWaterContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Water' */\nexport interface IWaterContract extends IElementContract {\n}",
      "contentHash": "b8e0c9e303e12976dede5d7fb5578ccc5c6391c6dfe082ec9d72f8749907f72b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IWaterfallContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Waterfall' */\nexport interface IWaterfallContract extends IElementContract {\n}",
      "contentHash": "3567f8639241447f58f87dc2f9b6ea13fd823a32ff9b74514225e773b69707e3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IWatershedContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Watershed' */\nexport interface IWatershedContract extends IElementContract {\n}",
      "contentHash": "a00b7b01f2739538567350d021c991e02c122dd2e96bdd21e036610f074b298d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IWaveContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Wave' */\nexport interface IWaveContract extends IElementContract {\n}",
      "contentHash": "b828dc0babdbf8dc655903a86d056fc3181f73c5cca1f1cd58e9da1450509a6f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IWetlandContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Wetland' */\nexport interface IWetlandContract extends IElementContract {\n}",
      "contentHash": "760cbf34c6858847ebda2df99601768a0fbb96453e8e1381b10243ea86795132",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IWetstoneContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Wetstone' */\nexport interface IWetstoneContract extends IElementContract {\n}",
      "contentHash": "672938cd71d4aa4a52d6f76710be8799d4396df4cc6fa5240c87607443fa4fdd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IWhirlContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Whirl' */\nexport interface IWhirlContract extends IElementContract {\n}",
      "contentHash": "f9119d53f317577cd6bb1810831e89740803de36b317e5591c45138977dd0f7a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IWhisperContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Whisper' */\nexport interface IWhisperContract extends IElementContract {\n}",
      "contentHash": "a771b8f5e716c5e57f920a864db1e240d48f764de3e9711b97d6240e8960739a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IWhisperingCaveContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'WhisperingCave' */\nexport interface IWhisperingCaveContract extends IElementContract {\n}",
      "contentHash": "5bc0c72f5112aaad44173c8276edcfbb0407563edec19773e320533fcdf03005",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IWildfireContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Wildfire' */\nexport interface IWildfireContract extends IElementContract {\n}",
      "contentHash": "b8cf7486b7a77a254157284417ed9578009e5cba4a5dcddd0068008e1b27a8ac",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IWindContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Wind' */\nexport interface IWindContract extends IElementContract {\n}",
      "contentHash": "ea61d47764032edf12a318502541f5bd2519911c5a8294a32babd83786253538",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IWindmillContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Windmill' */\nexport interface IWindmillContract extends IElementContract {\n}",
      "contentHash": "a7f063396e4b55861da6710688b54a6dc01d73513c5d7fa6ac62bb5db763ca54",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IZephyrContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Zephyr' */\nexport interface IZephyrContract extends IElementContract {\n}",
      "contentHash": "e9447be30237bb8f2610045dbac02985bbc7ef96f4fb52091d9732f1668ac2c2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/elementy.singleplayer.game.ts",
      "content": "import { GAME_ELEMENTY } from '@not-a-bird/model';\nimport {\n    registerUsableGame\n} from './use-game';\nimport {\n    createSinglePlayerGame\n} from './create-game';\n\nregisterUsableGame(\n    'elementy.singleplayer',\n    {\n        name: 'Elementy Singleplayer',\n        description: 'A game in which you combine elements to create new ones.',\n        chainInfo: 'Singleplayer, no chain'\n    },\n    createSinglePlayerGame(GAME_ELEMENTY)\n);",
      "contentHash": "8ea44e75c17fdd464a658b9377876ba4267ea939d7f7703da3fa9813b3047574",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/unifiers.singleplayer.game.ts",
      "content": "import { GAME_UNIFIERS } from '@not-a-bird/model';\nimport {\n    registerUsableGame\n} from './use-game';\nimport {\n    createSinglePlayerGame\n} from './create-game';\n\nregisterUsableGame(\n    'unifiers.singleplayer',\n    {\n        name: 'Unifiers Singleplayer',\n        description: 'A game created with the help of the Unifiers group',\n        chainInfo: 'Singleplayer, no chain'\n    },\n    createSinglePlayerGame(GAME_UNIFIERS)\n);",
      "contentHash": "aa0daea88b8aa7e180c2bdc004d04e848a42fb403c765d61bc188907ac4616fd",
      "noWriteIfExists": false
    }
  ]
}