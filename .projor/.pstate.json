{
  "generatedSource": [
    {
      "filename": "Cargo.toml",
      "content": "[workspace]\n\nresolver = \"2\"\nmembers = [\n  \"packages/contract-monkey/src\",\n  \"packages/contract-giraffe/src\",\n  \"packages/contract-bee/src\",\n  \"packages/contract-coin/src\",\n  \"packages/contract-swarm/src\",\n  \"packages/contract-hydra/src\",\n  \"packages/contract-monkey-branch/src\",\n  \"packages/contract-bridge/src\",\n  \"packages/contract-golden-gate/src\",\n  \"packages/contract-gold/src\",\n  \"packages/contract-silver/src\",\n  \"packages/contract-rhodium/src\",\n  \"packages/contract-hive/src\",\n  \"packages/contract-transaction/src\",\n  \"packages/contract-block/src\",\n  \"packages/contract-blockchain/src\",\n  \"packages/contract-polkadot/src\",\n  \"packages/contract-peer-review/src\",\n  \"packages/contract-cardano/src\",\n  \"packages/contract-bear/src\",\n  \"packages/contract-beer/src\",\n  \"packages/contract-lock/src\",\n  \"packages/contract-marmalade/src\",\n  \"packages/contract-super-marmalade/src\",\n  \"packages/contract-hyper-marmalade/src\",\n  \"packages/contract-water/src\",\n  \"packages/contract-fire/src\",\n  \"packages/contract-steam/src\",\n  \"packages/contract-earth/src\",\n  \"packages/contract-mud/src\",\n  \"packages/contract-lava/src\",\n  \"packages/contract-wind/src\",\n  \"packages/contract-dust/src\",\n  \"packages/contract-rain/src\",\n  \"packages/contract-smoke/src\",\n  \"packages/contract-geyser/src\",\n  \"packages/contract-clay/src\",\n  \"packages/contract-sand/src\",\n  \"packages/contract-plant/src\",\n  \"packages/contract-rainbow/src\",\n  \"packages/contract-storm/src\",\n  \"packages/contract-obsidian/src\",\n  \"packages/contract-ash/src\",\n  \"packages/contract-volcano/src\",\n  \"packages/contract-sandstorm/src\",\n  \"packages/contract-cloud/src\",\n  \"packages/contract-fog/src\",\n  \"packages/contract-tree/src\",\n  \"packages/contract-forest/src\",\n  \"packages/contract-seeds/src\",\n  \"packages/contract-pottery/src\",\n  \"packages/contract-brick/src\",\n  \"packages/contract-quicksand/src\",\n  \"packages/contract-glass/src\",\n  \"packages/contract-dune/src\",\n  \"packages/contract-charcoal/src\",\n  \"packages/contract-leaves/src\",\n  \"packages/contract-wildfire/src\",\n  \"packages/contract-jungle/src\",\n  \"packages/contract-frosted-glass/src\",\n  \"packages/contract-crystal/src\",\n  \"packages/contract-magma/src\",\n  \"packages/contract-rock/src\",\n  \"packages/contract-shard/src\",\n  \"packages/contract-pebble/src\",\n  \"packages/contract-mountain/src\",\n  \"packages/contract-fertilizer/src\",\n  \"packages/contract-soot/src\",\n  \"packages/contract-lightning/src\",\n  \"packages/contract-mist/src\",\n  \"packages/contract-haze/src\",\n  \"packages/contract-flood/src\",\n  \"packages/contract-landslide/src\",\n  \"packages/contract-thunder/src\",\n  \"packages/contract-tornado/src\",\n  \"packages/contract-garden/src\",\n  \"packages/contract-ember/src\",\n  \"packages/contract-kiln/src\",\n  \"packages/contract-pollination/src\",\n  \"packages/contract-sinkhole/src\",\n  \"packages/contract-beach/src\",\n  \"packages/contract-wetstone/src\",\n  \"packages/contract-erosion/src\",\n  \"packages/contract-basalt/src\",\n  \"packages/contract-magma-chamber/src\",\n  \"packages/contract-breeze/src\",\n  \"packages/contract-warm-breeze/src\",\n  \"packages/contract-soil/src\",\n  \"packages/contract-canyon/src\",\n  \"packages/contract-windmill/src\",\n  \"packages/contract-adobe/src\",\n  \"packages/contract-wall/src\",\n  \"packages/contract-pumice/src\",\n  \"packages/contract-barbecue/src\",\n  \"packages/contract-farm/src\",\n  \"packages/contract-shards/src\",\n  \"packages/contract-molten-glass/src\",\n  \"packages/contract-prism/src\",\n  \"packages/contract-sparkle/src\",\n  \"packages/contract-desert/src\",\n  \"packages/contract-oasis/src\",\n  \"packages/contract-mirage/src\",\n  \"packages/contract-sand-dune/src\",\n  \"packages/contract-dam/src\",\n  \"packages/contract-firewall/src\",\n  \"packages/contract-barricade/src\",\n  \"packages/contract-plateau/src\",\n  \"packages/contract-pond/src\",\n  \"packages/contract-aromas/src\",\n  \"packages/contract-flower/src\",\n  \"packages/contract-spore/src\",\n  \"packages/contract-spread/src\",\n  \"packages/contract-fertile-land/src\",\n  \"packages/contract-wetland/src\",\n  \"packages/contract-peat/src\",\n  \"packages/contract-reeds/src\",\n  \"packages/contract-valley/src\",\n  \"packages/contract-river/src\",\n  \"packages/contract-scorched-earth/src\",\n  \"packages/contract-delta/src\",\n  \"packages/contract-estuary/src\",\n  \"packages/contract-fire-swamp/src\",\n  \"packages/contract-riverbank/src\",\n  \"packages/contract-ravine/src\",\n  \"packages/contract-gorge/src\",\n  \"packages/contract-charred-ravine/src\",\n  \"packages/contract-echo/src\",\n  \"packages/contract-cave/src\",\n  \"packages/contract-underground-lake/src\",\n  \"packages/contract-lava-cave/src\",\n  \"packages/contract-whispering-cave/src\",\n  \"packages/contract-subterranean-pool/src\",\n  \"packages/contract-spring/src\",\n  \"packages/contract-hot-spring/src\",\n  \"packages/contract-grotto/src\",\n  \"packages/contract-fountain/src\",\n  \"packages/contract-steam-vent/src\",\n  \"packages/contract-cool-breeze/src\",\n  \"packages/contract-monument/src\",\n  \"packages/contract-waterfall/src\",\n  \"packages/contract-eternal-flame/src\",\n  \"packages/contract-pillar-of-wind/src\",\n  \"packages/contract-stream/src\",\n  \"packages/contract-zephyr/src\",\n  \"packages/contract-creek/src\",\n  \"packages/contract-brook/src\",\n  \"packages/contract-whisper/src\",\n  \"packages/contract-rivulet/src\",\n  \"packages/contract-tributary/src\",\n  \"packages/contract-murmur/src\",\n  \"packages/contract-watershed/src\",\n  \"packages/contract-aquifer/src\",\n  \"packages/contract-parched-earth/src\",\n  \"packages/contract-fresh-breeze/src\",\n  \"packages/contract-groundwater/src\",\n  \"packages/contract-reservoir/src\",\n  \"packages/contract-geothermal-spring/src\",\n  \"packages/contract-artesian-well/src\",\n  \"packages/contract-basin/src\",\n  \"packages/contract-lake/src\",\n  \"packages/contract-dry-basin/src\",\n  \"packages/contract-depression/src\",\n  \"packages/contract-island/src\",\n  \"packages/contract-lagoon/src\",\n  \"packages/contract-wave/src\",\n  \"packages/contract-reef/src\",\n  \"packages/contract-coral/src\",\n  \"packages/contract-whirl/src\",\n  \"packages/contract-limestone/src\",\n  \"packages/contract-karst/src\",\n  \"packages/contract-quicklime/src\",\n  \"packages/contract-blowhole/src\",\n  \"packages/contract-game/src\",\n  \"packages/contract-unifiers/src\",\n]\nexclude = [\n  \".cargo\",\n  \"target\"\n]\n\n[workspace.dependencies]\nink = { version = \"5.0.0\", default-features = false }",
      "contentHash": "1c2cf4affbd70936479c460ae3948d85f3a483ba486081361a0af0d117b48d0f",
      "noWriteIfExists": false
    },
    {
      "filename": "ITEMS.md",
      "content": "# Items\n\nIn this document we list all **items** (or _elements_) and **recipes** that can be found in the game. We also provide some explanation of the most important game mechanics revolving around items and recipes.\n\n## Buying\n\n**Buying an item**: Players may at any time call the game contract, transfer some value in the call, and receive items equal to the value transferred. The price of an item is calculated as follows:\n\nFor starters, each **item** has a **tier**. The item tier is a **positive integer number**. The game always has a **buy offer**, which is a tuple of (**native token price**, **received tier points**). When the player **buys**, they indirectly buy tier points, and may receive `floor(received_tier_points / tier)` items. The game only considers `floor(transfered_value / native_token_price)` amount of money transfered in, and the remainder is lost (or donated to the contract, however you want to see it).\n\n## Items\n\n* **Monkey** (`1`): We need a description here\n* **Giraffe** (`1`): We need a description here\n* **Bee** (`1`): We need a description here\n* **Coin** (`1`): We need a description here\n* **Swarm** (`2`): We need a description here\n* **Hydra** (`2`): We need a description here\n* **Monkey Branch** (`2`): We need a description here\n* **Bridge** (`2`): We need a description here\n* **Golden Gate** (`2`): We need a description here\n* **Gold** (`1`): We need a description here\n* **Silver** (`1`): We need a description here\n* **Rhodium** (`1`): We need a description here\n* **Hive** (`1`): We need a description here\n* **Transaction** (`1`): We need a description here\n* **Block** (`1`): We need a description here\n* **Blockchain** (`1`): We need a description here\n* **Polkadot** (`1`): We need a description here\n* **Peer Review** (`1`): We need a description here\n* **Cardano** (`2`): We need a description here\n* **Bear** (`1`): We need a description here\n* **Beer** (`2`): We need a description here\n* **Lock** (`2`): We need a description here\n* **Marmalade** (`1`): We need a description here\n* **Super Marmalade** (`2`): We need a description here\n* **Hyper Marmalade** (`2`): We need a description here\n* **Water** (`1`): We need a description here\n* **Fire** (`1`): We need a description here\n* **Steam** (`1`): We need a description here\n* **Earth** (`1`): We need a description here\n* **Mud** (`1`): We need a description here\n* **Lava** (`1`): We need a description here\n* **Wind** (`1`): We need a description here\n* **Dust** (`1`): We need a description here\n* **Rain** (`1`): We need a description here\n* **Smoke** (`1`): We need a description here\n* **Geyser** (`1`): We need a description here\n* **Clay** (`1`): We need a description here\n* **Sand** (`1`): We need a description here\n* **Plant** (`1`): We need a description here\n* **Rainbow** (`1`): We need a description here\n* **Storm** (`1`): We need a description here\n* **Obsidian** (`1`): We need a description here\n* **Ash** (`1`): We need a description here\n* **Volcano** (`1`): We need a description here\n* **Sandstorm** (`1`): We need a description here\n* **Cloud** (`1`): We need a description here\n* **Fog** (`1`): We need a description here\n* **Tree** (`1`): We need a description here\n* **Forest** (`1`): We need a description here\n* **Seeds** (`1`): We need a description here\n* **Pottery** (`1`): We need a description here\n* **Brick** (`1`): We need a description here\n* **Quicksand** (`1`): We need a description here\n* **Glass** (`1`): We need a description here\n* **Dune** (`1`): We need a description here\n* **Charcoal** (`1`): We need a description here\n* **Leaves** (`1`): We need a description here\n* **Wildfire** (`1`): We need a description here\n* **Jungle** (`1`): We need a description here\n* **Frosted Glass** (`1`): We need a description here\n* **Crystal** (`1`): We need a description here\n* **Magma** (`1`): We need a description here\n* **Rock** (`1`): We need a description here\n* **Shard** (`1`): We need a description here\n* **Pebble** (`1`): We need a description here\n* **Mountain** (`1`): We need a description here\n* **Fertilizer** (`1`): We need a description here\n* **Soot** (`1`): We need a description here\n* **Lightning** (`1`): We need a description here\n* **Mist** (`1`): We need a description here\n* **Haze** (`1`): We need a description here\n* **Flood** (`1`): We need a description here\n* **Landslide** (`1`): We need a description here\n* **Thunder** (`1`): We need a description here\n* **Tornado** (`1`): We need a description here\n* **Garden** (`1`): We need a description here\n* **Ember** (`1`): We need a description here\n* **Kiln** (`1`): We need a description here\n* **Pollination** (`1`): We need a description here\n* **Sinkhole** (`1`): We need a description here\n* **Beach** (`1`): We need a description here\n* **Wetstone** (`1`): We need a description here\n* **Erosion** (`1`): We need a description here\n* **Basalt** (`1`): We need a description here\n* **Magma Chamber** (`1`): We need a description here\n* **Breeze** (`1`): We need a description here\n* **Warm Breeze** (`1`): We need a description here\n* **Soil** (`1`): We need a description here\n* **Canyon** (`1`): We need a description here\n* **Windmill** (`1`): We need a description here\n* **Adobe** (`1`): We need a description here\n* **Wall** (`1`): We need a description here\n* **Pumice** (`1`): We need a description here\n* **Barbecue** (`1`): We need a description here\n* **Farm** (`1`): We need a description here\n* **Shards** (`1`): We need a description here\n* **Molten Glass** (`1`): We need a description here\n* **Prism** (`1`): We need a description here\n* **Sparkle** (`1`): We need a description here\n* **Desert** (`1`): We need a description here\n* **Oasis** (`1`): We need a description here\n* **Mirage** (`1`): We need a description here\n* **Sand Dune** (`1`): We need a description here\n* **Dam** (`1`): We need a description here\n* **Firewall** (`1`): We need a description here\n* **Barricade** (`1`): We need a description here\n* **Plateau** (`1`): We need a description here\n* **Pond** (`1`): We need a description here\n* **Aromas** (`1`): We need a description here\n* **Flower** (`1`): We need a description here\n* **Spore** (`1`): We need a description here\n* **Spread** (`1`): We need a description here\n* **Fertile Land** (`1`): We need a description here\n* **Wetland** (`1`): We need a description here\n* **Peat** (`1`): We need a description here\n* **Reeds** (`1`): We need a description here\n* **Valley** (`1`): We need a description here\n* **River** (`1`): We need a description here\n* **Scorched Earth** (`1`): We need a description here\n* **Delta** (`1`): We need a description here\n* **Estuary** (`1`): We need a description here\n* **Fire Swamp** (`1`): We need a description here\n* **Riverbank** (`1`): We need a description here\n* **Ravine** (`1`): We need a description here\n* **Gorge** (`1`): We need a description here\n* **Charred Ravine** (`1`): We need a description here\n* **Echo** (`1`): We need a description here\n* **Cave** (`1`): We need a description here\n* **Underground Lake** (`1`): We need a description here\n* **Lava Cave** (`1`): We need a description here\n* **Whispering Cave** (`1`): We need a description here\n* **Subterranean Pool** (`1`): We need a description here\n* **Spring** (`1`): We need a description here\n* **Hot Spring** (`1`): We need a description here\n* **Grotto** (`1`): We need a description here\n* **Fountain** (`1`): We need a description here\n* **Steam Vent** (`1`): We need a description here\n* **Cool Breeze** (`1`): We need a description here\n* **Monument** (`1`): We need a description here\n* **Waterfall** (`1`): We need a description here\n* **Eternal Flame** (`1`): We need a description here\n* **Pillar Of Wind** (`1`): We need a description here\n* **Stream** (`1`): We need a description here\n* **Zephyr** (`1`): We need a description here\n* **Creek** (`1`): We need a description here\n* **Brook** (`1`): We need a description here\n* **Whisper** (`1`): We need a description here\n* **Rivulet** (`1`): We need a description here\n* **Tributary** (`1`): We need a description here\n* **Murmur** (`1`): We need a description here\n* **Watershed** (`1`): We need a description here\n* **Aquifer** (`1`): We need a description here\n* **Parched Earth** (`1`): We need a description here\n* **Fresh Breeze** (`1`): We need a description here\n* **Groundwater** (`1`): We need a description here\n* **Reservoir** (`1`): We need a description here\n* **Geothermal Spring** (`1`): We need a description here\n* **Artesian Well** (`1`): We need a description here\n* **Basin** (`1`): We need a description here\n* **Lake** (`1`): We need a description here\n* **Dry Basin** (`1`): We need a description here\n* **Depression** (`1`): We need a description here\n* **Island** (`1`): We need a description here\n* **Lagoon** (`1`): We need a description here\n* **Wave** (`1`): We need a description here\n* **Reef** (`1`): We need a description here\n* **Coral** (`1`): We need a description here\n* **Whirl** (`1`): We need a description here\n* **Limestone** (`1`): We need a description here\n* **Karst** (`1`): We need a description here\n* **Quicklime** (`1`): We need a description here\n* **Blowhole** (`1`): We need a description here\n\n## Recipes\n\n* **Make Swarm** (`1 + 1 -> 2`) - **Bee** + **Bee** -> **Swarm**: \n* **Make Hydra** (`1 + 1 -> 2`) - **Giraffe** + **Giraffe** -> **Hydra**: \n* **Make Monkeybranch** (`1 + 2 -> 2`) - **Monkey** + **Hydra** -> **Monkey Branch**: \n* **Make Bridge** (`2 + 2 -> 2`) - **Monkey Branch** + **Monkey Branch** -> **Bridge**: \n* **Make Goldengate** (`1 + 2 -> 2`) - **Coin** + **Bridge** -> **Golden Gate**: \n* **Make Cardano** (`1 + 1 -> 2`) - **Blockchain** + **Peer Review** -> **Cardano**: \n* **Make Beer** (`1 + 1 -> 2`) - **Bee** + **Bear** -> **Beer**: \n* **Make Lock** (`1 + 1 -> 2`) - **Silver** + **Silver** -> **Lock**: \n* **Make Supermarmalade** (`1 + 1 -> 2`) - **Marmalade** + **Marmalade** -> **Super Marmalade**: \n* **Make Hypermarmalade** (`2 + 2 -> 2`) - **Super Marmalade** + **Super Marmalade** -> **Hyper Marmalade**: \n",
      "contentHash": "c24c728cf3b15db9fac06affabdecb0a16e0e092b27f6a35e2490929d5549574",
      "noWriteIfExists": false
    },
    {
      "filename": "package.json",
      "content": "{\n  \"name\": \"@siocode/not-a-bird\",\n  \"version\": \"0.0.1\",\n  \"private\": true,\n  \"workspaces\": [\n    \"packages/*\"\n  ],\n  \"dependencies\": {\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\",\n    \"rxjs\": \"7.8.1\",\n    \"@polkadot/api\": \"11.0.2\",\n    \"@polkadot/api-contract\": \"11.0.2\",\n    \"leva\": \"0.9.35\",\n    \"@unique-nft/accounts\": \"^0.3.7\",\n    \"@unique-nft/sdk\": \"^0.7.4\",\n    \"bulma\": \"1.0.0\",\n    \"listr2\": \"8.2.1\",\n    \"markdown-it-task-lists\": \"^2.1.1\",\n    \"markdown-it-textual-uml\": \"^0.17.1\",\n    \"yaml\": \"^2.4.2\",\n    \"commander\": \"12.1.0\"\n  },\n  \"devDependencies\": {\n    \"@types/react\": \"18.2.79\",\n    \"@types/react-dom\": \"18.2.25\",\n    \"chalk\": \"4\",\n    \"chokidar\": \"3.6.0\",\n    \"concurrently\": \"8.2.2\",\n    \"esbuild\": \"0.20.2\",\n    \"fs-extra\": \"11.2.0\",\n    \"sass\": \"1.75.0\",\n    \"typescript\": \"5.4.5\",\n    \"prettier\": \"^3.2.5\",\n    \"vitepress\": \"1.2.2\"\n  },\n  \"scripts\": {\n    \"c:monkey\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-monkey/src/Cargo.toml\",\n    \"c:giraffe\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-giraffe/src/Cargo.toml\",\n    \"c:bee\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-bee/src/Cargo.toml\",\n    \"c:coin\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-coin/src/Cargo.toml\",\n    \"c:swarm\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-swarm/src/Cargo.toml\",\n    \"c:hydra\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-hydra/src/Cargo.toml\",\n    \"c:monkey-branch\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-monkey-branch/src/Cargo.toml\",\n    \"c:bridge\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-bridge/src/Cargo.toml\",\n    \"c:golden-gate\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-golden-gate/src/Cargo.toml\",\n    \"c:gold\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-gold/src/Cargo.toml\",\n    \"c:silver\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-silver/src/Cargo.toml\",\n    \"c:rhodium\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-rhodium/src/Cargo.toml\",\n    \"c:hive\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-hive/src/Cargo.toml\",\n    \"c:transaction\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-transaction/src/Cargo.toml\",\n    \"c:block\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-block/src/Cargo.toml\",\n    \"c:blockchain\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-blockchain/src/Cargo.toml\",\n    \"c:polkadot\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-polkadot/src/Cargo.toml\",\n    \"c:peer-review\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-peer-review/src/Cargo.toml\",\n    \"c:cardano\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-cardano/src/Cargo.toml\",\n    \"c:bear\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-bear/src/Cargo.toml\",\n    \"c:beer\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-beer/src/Cargo.toml\",\n    \"c:lock\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-lock/src/Cargo.toml\",\n    \"c:marmalade\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-marmalade/src/Cargo.toml\",\n    \"c:super-marmalade\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-super-marmalade/src/Cargo.toml\",\n    \"c:hyper-marmalade\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-hyper-marmalade/src/Cargo.toml\",\n    \"c:water\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-water/src/Cargo.toml\",\n    \"c:fire\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-fire/src/Cargo.toml\",\n    \"c:steam\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-steam/src/Cargo.toml\",\n    \"c:earth\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-earth/src/Cargo.toml\",\n    \"c:mud\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-mud/src/Cargo.toml\",\n    \"c:lava\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-lava/src/Cargo.toml\",\n    \"c:wind\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-wind/src/Cargo.toml\",\n    \"c:dust\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-dust/src/Cargo.toml\",\n    \"c:rain\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-rain/src/Cargo.toml\",\n    \"c:smoke\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-smoke/src/Cargo.toml\",\n    \"c:geyser\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-geyser/src/Cargo.toml\",\n    \"c:clay\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-clay/src/Cargo.toml\",\n    \"c:sand\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-sand/src/Cargo.toml\",\n    \"c:plant\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-plant/src/Cargo.toml\",\n    \"c:rainbow\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-rainbow/src/Cargo.toml\",\n    \"c:storm\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-storm/src/Cargo.toml\",\n    \"c:obsidian\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-obsidian/src/Cargo.toml\",\n    \"c:ash\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-ash/src/Cargo.toml\",\n    \"c:volcano\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-volcano/src/Cargo.toml\",\n    \"c:sandstorm\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-sandstorm/src/Cargo.toml\",\n    \"c:cloud\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-cloud/src/Cargo.toml\",\n    \"c:fog\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-fog/src/Cargo.toml\",\n    \"c:tree\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-tree/src/Cargo.toml\",\n    \"c:forest\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-forest/src/Cargo.toml\",\n    \"c:seeds\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-seeds/src/Cargo.toml\",\n    \"c:pottery\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-pottery/src/Cargo.toml\",\n    \"c:brick\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-brick/src/Cargo.toml\",\n    \"c:quicksand\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-quicksand/src/Cargo.toml\",\n    \"c:glass\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-glass/src/Cargo.toml\",\n    \"c:dune\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-dune/src/Cargo.toml\",\n    \"c:charcoal\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-charcoal/src/Cargo.toml\",\n    \"c:leaves\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-leaves/src/Cargo.toml\",\n    \"c:wildfire\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-wildfire/src/Cargo.toml\",\n    \"c:jungle\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-jungle/src/Cargo.toml\",\n    \"c:frosted-glass\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-frosted-glass/src/Cargo.toml\",\n    \"c:crystal\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-crystal/src/Cargo.toml\",\n    \"c:magma\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-magma/src/Cargo.toml\",\n    \"c:rock\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-rock/src/Cargo.toml\",\n    \"c:shard\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-shard/src/Cargo.toml\",\n    \"c:pebble\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-pebble/src/Cargo.toml\",\n    \"c:mountain\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-mountain/src/Cargo.toml\",\n    \"c:fertilizer\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-fertilizer/src/Cargo.toml\",\n    \"c:soot\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-soot/src/Cargo.toml\",\n    \"c:lightning\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-lightning/src/Cargo.toml\",\n    \"c:mist\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-mist/src/Cargo.toml\",\n    \"c:haze\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-haze/src/Cargo.toml\",\n    \"c:flood\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-flood/src/Cargo.toml\",\n    \"c:landslide\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-landslide/src/Cargo.toml\",\n    \"c:thunder\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-thunder/src/Cargo.toml\",\n    \"c:tornado\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-tornado/src/Cargo.toml\",\n    \"c:garden\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-garden/src/Cargo.toml\",\n    \"c:ember\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-ember/src/Cargo.toml\",\n    \"c:kiln\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-kiln/src/Cargo.toml\",\n    \"c:pollination\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-pollination/src/Cargo.toml\",\n    \"c:sinkhole\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-sinkhole/src/Cargo.toml\",\n    \"c:beach\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-beach/src/Cargo.toml\",\n    \"c:wetstone\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-wetstone/src/Cargo.toml\",\n    \"c:erosion\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-erosion/src/Cargo.toml\",\n    \"c:basalt\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-basalt/src/Cargo.toml\",\n    \"c:magma-chamber\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-magma-chamber/src/Cargo.toml\",\n    \"c:breeze\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-breeze/src/Cargo.toml\",\n    \"c:warm-breeze\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-warm-breeze/src/Cargo.toml\",\n    \"c:soil\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-soil/src/Cargo.toml\",\n    \"c:canyon\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-canyon/src/Cargo.toml\",\n    \"c:windmill\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-windmill/src/Cargo.toml\",\n    \"c:adobe\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-adobe/src/Cargo.toml\",\n    \"c:wall\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-wall/src/Cargo.toml\",\n    \"c:pumice\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-pumice/src/Cargo.toml\",\n    \"c:barbecue\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-barbecue/src/Cargo.toml\",\n    \"c:farm\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-farm/src/Cargo.toml\",\n    \"c:shards\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-shards/src/Cargo.toml\",\n    \"c:molten-glass\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-molten-glass/src/Cargo.toml\",\n    \"c:prism\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-prism/src/Cargo.toml\",\n    \"c:sparkle\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-sparkle/src/Cargo.toml\",\n    \"c:desert\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-desert/src/Cargo.toml\",\n    \"c:oasis\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-oasis/src/Cargo.toml\",\n    \"c:mirage\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-mirage/src/Cargo.toml\",\n    \"c:sand-dune\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-sand-dune/src/Cargo.toml\",\n    \"c:dam\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-dam/src/Cargo.toml\",\n    \"c:firewall\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-firewall/src/Cargo.toml\",\n    \"c:barricade\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-barricade/src/Cargo.toml\",\n    \"c:plateau\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-plateau/src/Cargo.toml\",\n    \"c:pond\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-pond/src/Cargo.toml\",\n    \"c:aromas\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-aromas/src/Cargo.toml\",\n    \"c:flower\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-flower/src/Cargo.toml\",\n    \"c:spore\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-spore/src/Cargo.toml\",\n    \"c:spread\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-spread/src/Cargo.toml\",\n    \"c:fertile-land\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-fertile-land/src/Cargo.toml\",\n    \"c:wetland\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-wetland/src/Cargo.toml\",\n    \"c:peat\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-peat/src/Cargo.toml\",\n    \"c:reeds\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-reeds/src/Cargo.toml\",\n    \"c:valley\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-valley/src/Cargo.toml\",\n    \"c:river\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-river/src/Cargo.toml\",\n    \"c:scorched-earth\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-scorched-earth/src/Cargo.toml\",\n    \"c:delta\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-delta/src/Cargo.toml\",\n    \"c:estuary\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-estuary/src/Cargo.toml\",\n    \"c:fire-swamp\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-fire-swamp/src/Cargo.toml\",\n    \"c:riverbank\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-riverbank/src/Cargo.toml\",\n    \"c:ravine\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-ravine/src/Cargo.toml\",\n    \"c:gorge\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-gorge/src/Cargo.toml\",\n    \"c:charred-ravine\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-charred-ravine/src/Cargo.toml\",\n    \"c:echo\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-echo/src/Cargo.toml\",\n    \"c:cave\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-cave/src/Cargo.toml\",\n    \"c:underground-lake\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-underground-lake/src/Cargo.toml\",\n    \"c:lava-cave\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-lava-cave/src/Cargo.toml\",\n    \"c:whispering-cave\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-whispering-cave/src/Cargo.toml\",\n    \"c:subterranean-pool\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-subterranean-pool/src/Cargo.toml\",\n    \"c:spring\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-spring/src/Cargo.toml\",\n    \"c:hot-spring\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-hot-spring/src/Cargo.toml\",\n    \"c:grotto\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-grotto/src/Cargo.toml\",\n    \"c:fountain\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-fountain/src/Cargo.toml\",\n    \"c:steam-vent\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-steam-vent/src/Cargo.toml\",\n    \"c:cool-breeze\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-cool-breeze/src/Cargo.toml\",\n    \"c:monument\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-monument/src/Cargo.toml\",\n    \"c:waterfall\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-waterfall/src/Cargo.toml\",\n    \"c:eternal-flame\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-eternal-flame/src/Cargo.toml\",\n    \"c:pillar-of-wind\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-pillar-of-wind/src/Cargo.toml\",\n    \"c:stream\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-stream/src/Cargo.toml\",\n    \"c:zephyr\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-zephyr/src/Cargo.toml\",\n    \"c:creek\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-creek/src/Cargo.toml\",\n    \"c:brook\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-brook/src/Cargo.toml\",\n    \"c:whisper\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-whisper/src/Cargo.toml\",\n    \"c:rivulet\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-rivulet/src/Cargo.toml\",\n    \"c:tributary\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-tributary/src/Cargo.toml\",\n    \"c:murmur\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-murmur/src/Cargo.toml\",\n    \"c:watershed\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-watershed/src/Cargo.toml\",\n    \"c:aquifer\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-aquifer/src/Cargo.toml\",\n    \"c:parched-earth\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-parched-earth/src/Cargo.toml\",\n    \"c:fresh-breeze\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-fresh-breeze/src/Cargo.toml\",\n    \"c:groundwater\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-groundwater/src/Cargo.toml\",\n    \"c:reservoir\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-reservoir/src/Cargo.toml\",\n    \"c:geothermal-spring\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-geothermal-spring/src/Cargo.toml\",\n    \"c:artesian-well\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-artesian-well/src/Cargo.toml\",\n    \"c:basin\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-basin/src/Cargo.toml\",\n    \"c:lake\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-lake/src/Cargo.toml\",\n    \"c:dry-basin\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-dry-basin/src/Cargo.toml\",\n    \"c:depression\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-depression/src/Cargo.toml\",\n    \"c:island\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-island/src/Cargo.toml\",\n    \"c:lagoon\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-lagoon/src/Cargo.toml\",\n    \"c:wave\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-wave/src/Cargo.toml\",\n    \"c:reef\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-reef/src/Cargo.toml\",\n    \"c:coral\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-coral/src/Cargo.toml\",\n    \"c:whirl\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-whirl/src/Cargo.toml\",\n    \"c:limestone\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-limestone/src/Cargo.toml\",\n    \"c:karst\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-karst/src/Cargo.toml\",\n    \"c:quicklime\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-quicklime/src/Cargo.toml\",\n    \"c:blowhole\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-blowhole/src/Cargo.toml\",\n    \"c:unifiers\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-unifiers/src/Cargo.toml\",\n    \"c:game\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-game/src/Cargo.toml\",\n    \"build:contracts\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-game/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-monkey/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-giraffe/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-bee/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-coin/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-swarm/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-hydra/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-monkey-branch/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-bridge/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-golden-gate/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-gold/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-silver/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-rhodium/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-hive/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-transaction/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-block/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-blockchain/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-polkadot/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-peer-review/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-cardano/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-bear/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-beer/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-lock/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-marmalade/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-super-marmalade/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-hyper-marmalade/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-water/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-fire/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-steam/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-earth/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-mud/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-lava/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-wind/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-dust/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-rain/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-smoke/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-geyser/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-clay/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-sand/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-plant/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-rainbow/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-storm/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-obsidian/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-ash/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-volcano/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-sandstorm/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-cloud/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-fog/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-tree/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-forest/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-seeds/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-pottery/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-brick/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-quicksand/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-glass/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-dune/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-charcoal/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-leaves/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-wildfire/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-jungle/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-frosted-glass/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-crystal/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-magma/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-rock/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-shard/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-pebble/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-mountain/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-fertilizer/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-soot/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-lightning/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-mist/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-haze/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-flood/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-landslide/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-thunder/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-tornado/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-garden/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-ember/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-kiln/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-pollination/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-sinkhole/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-beach/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-wetstone/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-erosion/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-basalt/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-magma-chamber/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-breeze/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-warm-breeze/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-soil/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-canyon/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-windmill/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-adobe/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-wall/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-pumice/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-barbecue/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-farm/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-shards/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-molten-glass/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-prism/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-sparkle/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-desert/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-oasis/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-mirage/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-sand-dune/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-dam/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-firewall/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-barricade/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-plateau/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-pond/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-aromas/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-flower/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-spore/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-spread/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-fertile-land/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-wetland/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-peat/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-reeds/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-valley/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-river/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-scorched-earth/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-delta/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-estuary/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-fire-swamp/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-riverbank/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-ravine/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-gorge/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-charred-ravine/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-echo/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-cave/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-underground-lake/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-lava-cave/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-whispering-cave/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-subterranean-pool/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-spring/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-hot-spring/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-grotto/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-fountain/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-steam-vent/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-cool-breeze/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-monument/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-waterfall/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-eternal-flame/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-pillar-of-wind/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-stream/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-zephyr/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-creek/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-brook/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-whisper/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-rivulet/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-tributary/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-murmur/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-watershed/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-aquifer/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-parched-earth/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-fresh-breeze/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-groundwater/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-reservoir/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-geothermal-spring/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-artesian-well/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-basin/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-lake/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-dry-basin/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-depression/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-island/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-lagoon/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-wave/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-reef/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-coral/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-whirl/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-limestone/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-karst/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-quicklime/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-blowhole/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-unifiers/src/Cargo.toml\",\n    \"build\": \"npm run -w @not-a-bird/app-game build\",\n    \"serve\": \"npm run -w @not-a-bird/app-game serve\",\n    \"docs:build\": \"npm run -w @not-a-bird/docs build\",\n    \"docs:preview\": \"npm run -w @not-a-bird/docs preview\",\n    \"docs:dev\": \"npm run -w @not-a-bird/docs dev\",\n    \"deploy:contracts\": \"npm run -w @not-a-bird/deployer start\",\n    \"deploy:copy\": \"npm run -w @not-a-bird/deployer copy\",\n    \"deploy:extract\": \"npm run -w @not-a-bird/deployer extract\"\n  }\n}",
      "contentHash": "1a668f775a38b4a01de3b060df237d6f88b483ca92db9b304c19dec3b5a231bb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-adobe/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-adobe/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-adobe\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Adobe'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "30725befc3e678beea4edac7150b20f983c39ad8b3399cd201d7d66b6c316851",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-adobe/README.md",
      "content": "# Adobe - Contract\n\nThis is a Adobe contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "c190047757461967dc6b3c28a92600342af7ff728a84df7a91902d9fa68db8d2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-adobe/src/Cargo.toml",
      "content": "[package]\nname = \"adobe\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "25fe74e8d5332dd6fd24933586e26e4b72ee3f9802443f6ad57fcc7e0fe5944d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-adobe/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod adobe {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Adobe' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct AdobeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for AdobeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl AdobeContract {\n        /// Creates a new PSP-22 compatible Adobe Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Adobe\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MADOBE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "96a8eb76fe9966f831f1fc738be9c46afa537412a4bb31f4a300eeaa2f8a3eaf",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-aquifer/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-aquifer/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-aquifer\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Aquifer'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "bc3f65e3d273b6425ddf82da1de4946757390df430c27dec54d76a39bd5345b5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-aquifer/README.md",
      "content": "# Aquifer - Contract\n\nThis is a Aquifer contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "9af3b5d28ef4db993d957021060edc544b554ad5fc87f25a4f457fa42f39ac6a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-aquifer/src/Cargo.toml",
      "content": "[package]\nname = \"aquifer\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "a03566ad1baa152d003596a8ffa746fe289cf7adbb89e8db4c734d0fa16e7abf",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-aquifer/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod aquifer {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Aquifer' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct AquiferContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for AquiferContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl AquiferContract {\n        /// Creates a new PSP-22 compatible Aquifer Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Aquifer\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MAQUIFER\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "e35870e2e6c80526c8bc9362b2895fd5cefe26783c4369e9e5d5dbf67709d1d8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-aromas/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-aromas/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-aromas\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Aromas'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "1020e7f22addf056cc969e23666278ea5d70754c12857868df06ed1951fd99e9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-aromas/README.md",
      "content": "# Aromas - Contract\n\nThis is a Aromas contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "210110bc18e2293c706362035d221e8bea05c02292bade6e895b12b9f62aea12",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-aromas/src/Cargo.toml",
      "content": "[package]\nname = \"aromas\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "5e080a40189a377b51b848c6f1e163e5d03ea95086586a23c639f68ba44ee626",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-aromas/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod aromas {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Aromas' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct AromasContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for AromasContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl AromasContract {\n        /// Creates a new PSP-22 compatible Aromas Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Aromas\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MAROMAS\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "8b6d21de39c425370c3d8667681936958704172f4b87e1716de7097612a7fe2b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-artesian-well/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-artesian-well/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-artesian-well\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Artesian Well'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "ab6c01d7b4f771769b9394c03609d5267c73192b6d79c53a579871c673655756",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-artesian-well/README.md",
      "content": "# Artesian Well - Contract\n\nThis is a Artesian Well contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "2e5f43d945db8130f75eb486539e6016913d145d325f00cde9338a2380572680",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-artesian-well/src/Cargo.toml",
      "content": "[package]\nname = \"artesian_well\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "3ae0f8015d09ad52e8ad43616af178aeea0873540e7abbc87c4667bed9ff8e5b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-artesian-well/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod artesian_well {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Artesian Well' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct ArtesianWellContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for ArtesianWellContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl ArtesianWellContract {\n        /// Creates a new PSP-22 compatible Artesian Well Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Artesian Well\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MARTESIAN_WELL\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "6310b0bb6888b298bae391b5f220e0ec0746219afcfc894e02d0fae6b0580f62",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-ash/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-ash/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-ash\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Ash'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "5051ee28933d5a46bc3817ab0c5c49df67e3ee73c027c034f5834c685bc7bd50",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-ash/README.md",
      "content": "# Ash - Contract\n\nThis is a Ash contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "33383cdd07e0e9b2bf237d4c3ec26c42af494f044804b44c059ba95594a62d47",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-ash/src/Cargo.toml",
      "content": "[package]\nname = \"ash\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "45f0412ba935f72ffee67aa5b8b7af7b1b34169aa86939ae02e3a7da6b5e3f0b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-ash/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod ash {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Ash' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct AshContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for AshContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl AshContract {\n        /// Creates a new PSP-22 compatible Ash Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Ash\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MASH\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "de73cf3a398ce1fdc1e595ff07601706498e4786ab24aeaa42717bae3acef4e7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-barbecue/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-barbecue/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-barbecue\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Barbecue'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "881b78add288a78b22e7426a17f88ea86954470e1ccbf4f5a6150e3d6afb140a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-barbecue/README.md",
      "content": "# Barbecue - Contract\n\nThis is a Barbecue contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "216e372615ce4cebeba1b3a3a1424a5b1af3a666ed1ec8f65cfc784ee1a0f4bf",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-barbecue/src/Cargo.toml",
      "content": "[package]\nname = \"barbecue\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "d2c65fa9d94ab2ffe255cffb7a68f3e54264596ad3f35fe8b57d1730d345f649",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-barbecue/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod barbecue {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Barbecue' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BarbecueContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BarbecueContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BarbecueContract {\n        /// Creates a new PSP-22 compatible Barbecue Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Barbecue\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBARBECUE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "f29a1a69285685da42bc2abf973d87c6970663f478223c9cc8cc48f3a9739121",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-barricade/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-barricade/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-barricade\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Barricade'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "e062f2156f067c4257158c48729a305bad5aae8a5febc9af08bef73a97c4f3c9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-barricade/README.md",
      "content": "# Barricade - Contract\n\nThis is a Barricade contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "c43affd85dea314387bc6e24d8091328ed417a35595ef87db03d9f2ce071f386",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-barricade/src/Cargo.toml",
      "content": "[package]\nname = \"barricade\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "d2dc7d6a96ceb162888598283e0a595059e47b2245f4f006ad395a1e0494e883",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-barricade/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod barricade {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Barricade' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BarricadeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BarricadeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BarricadeContract {\n        /// Creates a new PSP-22 compatible Barricade Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Barricade\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBARRICADE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "748ad3f1272e52edb00d0f42aee9a2265d347282ca7b6b7bccdcd955cca582e9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-basalt/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-basalt/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-basalt\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Basalt'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "8140dad69803b6a219571ab23fcab2ff480e914d39c84a372f620f5a5dd9a2f0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-basalt/README.md",
      "content": "# Basalt - Contract\n\nThis is a Basalt contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "380583d29e8ed70c25d02168ffeeb0c6744f8676fc652d81d306e0c38a25ae19",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-basalt/src/Cargo.toml",
      "content": "[package]\nname = \"basalt\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "95d13370e7f3f930fbf86eca23c5eb31a2add60f425ebaeca59c8dda12eadaa1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-basalt/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod basalt {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Basalt' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BasaltContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BasaltContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BasaltContract {\n        /// Creates a new PSP-22 compatible Basalt Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Basalt\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBASALT\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "015b3768404dff4f336e161dddbd46651d18eb0ecec385de72db0da36c625b0f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-basin/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-basin/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-basin\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Basin'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "bbf75fc44e10751361f8832fe59c20738fd415f3b30404a9be30c486e9c44b4a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-basin/README.md",
      "content": "# Basin - Contract\n\nThis is a Basin contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "478efccafe4a20a9d7f602b73f8dfe9155752d87ef6f1e30e937fe9e045c5eeb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-basin/src/Cargo.toml",
      "content": "[package]\nname = \"basin\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "62fb640f117854073858a21ff0fc8b9128c3107b7352c9894906feffd59abe96",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-basin/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod basin {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Basin' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BasinContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BasinContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BasinContract {\n        /// Creates a new PSP-22 compatible Basin Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Basin\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBASIN\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "07e40b886f85f798a25d00987316d5a48d2ccd58db6b18ce006a08e5bebd5654",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-beach/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-beach/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-beach\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Beach'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "307f7d384bcac46ccf560c6d7f145dc12973da17d068c77fabfc5a7521540f17",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-beach/README.md",
      "content": "# Beach - Contract\n\nThis is a Beach contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "42eaa54fa2cac18b0399dd276e9db23b1cb6898038a7112ce9c45cf2df5a5e37",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-beach/src/Cargo.toml",
      "content": "[package]\nname = \"beach\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "8cdaa7afcf20fdd6520758d21c1575e84ad38600be3af115be0628331404b5f4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-beach/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod beach {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Beach' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BeachContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BeachContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BeachContract {\n        /// Creates a new PSP-22 compatible Beach Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Beach\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBEACH\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "b079202e986c7311df81bf4d437d2f2db5c478abfb793cdebc53f4e8721aee74",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bear/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bear/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-bear\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Bear'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "c5e820e944f8315655113d3a7309f6e7465579ed7c6357322e52050973c595aa",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bear/README.md",
      "content": "# Bear - Contract\n\nThis is a Bear contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "2e39386436559c232cef064aa2d58095f11999f380fd440efa3b2d39d87cf757",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bear/src/Cargo.toml",
      "content": "[package]\nname = \"bear\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "60704033e05fab4c47ecb60980d99ac3d6e1c490d027c3edccb837a47a885d8e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bear/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod bear {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Bear' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BearContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BearContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BearContract {\n        /// Creates a new PSP-22 compatible Bear Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Bear\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBEAR\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "ba8baed7d9751f9e5b4991eed8f7eab8a28db0a9e8b92213b9e2b4d694fa80c4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bee/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bee/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-bee\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Bee'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "df64f208eb3b5902955f976d625a85877511581920afa69e625468e37ae766f7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bee/README.md",
      "content": "# Bee - Contract\n\nThis is a Bee contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "42ba68de5e5347dd40443ff01fbc82bff826ab61e61a2d8b482bfb9fcbd772cd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bee/src/Cargo.toml",
      "content": "[package]\nname = \"bee\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "0e85afa1508d8f9529c480efd872ee6597794bf4bf28e4ec631ee91e5e2b8b4f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bee/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod bee {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Bee' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BeeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BeeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BeeContract {\n        /// Creates a new PSP-22 compatible Bee Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Bee\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBEE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "e6b381ec395d4a73d7050366847ebafbdba846a0e928311c565777102fb9a63d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-beer/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-beer/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-beer\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Beer'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "005d88ee68ee7a19518883da7c4b28740ed8cc718f5b528a8d7d4ecc38e555b3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-beer/README.md",
      "content": "# Beer - Contract\n\nThis is a Beer contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "6556596f4bcae348b32f702943fa832f42ecd2004c10804c33cde99e376c20bf",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-beer/src/Cargo.toml",
      "content": "[package]\nname = \"beer\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "4a35c94ae27cf7cc8f4d0f876e2d61353fe0b6b9493a06041c0a725fdce40be5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-beer/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod beer {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Beer' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BeerContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BeerContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BeerContract {\n        /// Creates a new PSP-22 compatible Beer Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Beer\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBEER\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "03ed0a6783e40fddd1cfc547f4feff517236da1093a0937861f1a1ddf2219ce7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-block/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-block/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-block\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Block'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "334d2d40813210cc72b266c9c2ad222b3e1ad182859785be9182f074baca289c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-block/README.md",
      "content": "# Block - Contract\n\nThis is a Block contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "13895fe29965cbd074b5c51b99dd9cf6b75a3cc4525ed46d83d51d37069f596e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-block/src/Cargo.toml",
      "content": "[package]\nname = \"block\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "f0e3a9150f2b7779226738fbaa6c128b225e9d1328025468eb34c029a8bb6c5f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-block/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod block {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Block' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BlockContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BlockContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BlockContract {\n        /// Creates a new PSP-22 compatible Block Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Block\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBLOCK\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "ee63644084ebc5d51b9b7a588f6911248a9186ed5634c784c1ec04c58779505b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-blockchain/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-blockchain/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-blockchain\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Blockchain'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "16670b267ea062759434a9ab7b70ad03b8a6b2d4a50d6ff9820a9c73aec6c2fd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-blockchain/README.md",
      "content": "# Blockchain - Contract\n\nThis is a Blockchain contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "89fd1eb1fc51bb576e9928b8589b28db9f874a64ba7ea17c7110262b532e8d29",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-blockchain/src/Cargo.toml",
      "content": "[package]\nname = \"blockchain\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "069aabba9bacef8822abdac9bf53a26022ceafdf37f3c8e153a8e155917112c7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-blockchain/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod blockchain {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Blockchain' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BlockchainContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BlockchainContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BlockchainContract {\n        /// Creates a new PSP-22 compatible Blockchain Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Blockchain\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBLOCKCHAIN\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "e10b499f0e6887309e713178a1d92558b718bcc9c298f4b1d7a0a32af1b14695",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-blowhole/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-blowhole/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-blowhole\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Blowhole'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "1060fa7195192853e38e4afe838e9eb4d947ae11dca75ce944a8f558a70e13b2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-blowhole/README.md",
      "content": "# Blowhole - Contract\n\nThis is a Blowhole contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "108de3c75e15ec39f80fa44210c1077ed91ced2d83956006a8d177130b8f3876",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-blowhole/src/Cargo.toml",
      "content": "[package]\nname = \"blowhole\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "27b0d5f122a9bcfd57c3316dbb6db6407e9da99db42b61e03f4b8f78563c69ea",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-blowhole/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod blowhole {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Blowhole' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BlowholeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BlowholeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BlowholeContract {\n        /// Creates a new PSP-22 compatible Blowhole Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Blowhole\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBLOWHOLE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "aaacf20891b54662a3261c54f7d682df64f33711ab3ebcdfaaa7783f8058474f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-breeze/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-breeze/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-breeze\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Breeze'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "87b928b1f1227e963386b1e5c9a2606f2bf113277aa579de6e271271da7d9205",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-breeze/README.md",
      "content": "# Breeze - Contract\n\nThis is a Breeze contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "9abf76ccff0c519deaa4b1d3bc41df273a89e040e99e123f10ef6265a7975cc4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-breeze/src/Cargo.toml",
      "content": "[package]\nname = \"breeze\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "e62a08ba6fe1c7428631bd31d2ee133aaee5221b235734750d0b8a6511b21ae5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-breeze/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod breeze {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Breeze' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BreezeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BreezeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BreezeContract {\n        /// Creates a new PSP-22 compatible Breeze Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Breeze\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBREEZE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "877da887a57694e6b91a405029bda6f99bd07a6715be5d3df31d57eb8c0fa55a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-brick/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-brick/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-brick\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Brick'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "76319fe8bf559ba2e9f0f949fb84589e025cf510a9bc5b1dd62575b508721481",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-brick/README.md",
      "content": "# Brick - Contract\n\nThis is a Brick contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "2a36a621d299616d964ab0646b326120f80a02af8d508117999b83f4c5bd4a30",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-brick/src/Cargo.toml",
      "content": "[package]\nname = \"brick\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "d0819371ccca2e44998df8c9c9fb1ff5c1f4d4825489333f6afde9db88363dee",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-brick/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod brick {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Brick' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BrickContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BrickContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BrickContract {\n        /// Creates a new PSP-22 compatible Brick Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Brick\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBRICK\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "cf96a14f365f1d457066b236f5efa0286b8186735c68f7e36e61c93526c7f0fb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bridge/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bridge/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-bridge\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Bridge'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "71e57b82fb51c0038e7815d651f794f959d29392f62e22fe9bd87602c88fbcc6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bridge/README.md",
      "content": "# Bridge - Contract\n\nThis is a Bridge contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "48c4e7c5c8fc03815d109d8ac28bfffb8c64584ab278c92c7038d07d8208d2f2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bridge/src/Cargo.toml",
      "content": "[package]\nname = \"bridge\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "822034f54388ed73573ab7cb52ac11802c17abc0060991b0055a86da5f10fcc7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-bridge/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod bridge {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Bridge' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BridgeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BridgeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BridgeContract {\n        /// Creates a new PSP-22 compatible Bridge Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Bridge\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBRIDGE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "a6216ae4fa6ca4dbfab290d7f1d6580fe363373f9c626b2efdfc28713394c49f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-brook/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-brook/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-brook\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Brook'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "cbae85d4824d8f9108e29c9950686fd6049798e24b19499557430559b91b8686",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-brook/README.md",
      "content": "# Brook - Contract\n\nThis is a Brook contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "df4f24e3cca3e088c2efef6a64d91779dcd1c62949a08e3208308cb5150b2acd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-brook/src/Cargo.toml",
      "content": "[package]\nname = \"brook\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "e8ae3ed1f08458f8b7a90bac7612ded7e87ad50143d4958b002729bdbc96b141",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-brook/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod brook {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Brook' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct BrookContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for BrookContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl BrookContract {\n        /// Creates a new PSP-22 compatible Brook Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Brook\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MBROOK\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "8309a49ee0a1f8969df238a6f1a4cb722afa5b28d1d99d584f4dd1d54f42e1f0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-canyon/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-canyon/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-canyon\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Canyon'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "419d058ae4998771e6f01b8b00d46142c240f012c16a5823b92802a1d2581eb5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-canyon/README.md",
      "content": "# Canyon - Contract\n\nThis is a Canyon contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "c3dbac9abbc4f404abbc2763a6ad4a715e5acbce2e92e2aba8f066ee2f949620",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-canyon/src/Cargo.toml",
      "content": "[package]\nname = \"canyon\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "cefab5afdcdfe39aa89735fa1a22744393829f1fb5bb067ae9cb0279e8c86126",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-canyon/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod canyon {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Canyon' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct CanyonContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for CanyonContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl CanyonContract {\n        /// Creates a new PSP-22 compatible Canyon Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Canyon\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MCANYON\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "25b502083a11fdc23e0a9457801e3018f7d79fc3558abcffb32ac58b5c7613ec",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cardano/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cardano/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-cardano\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Cardano'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "6cd90711295a05aba86bdc6cbd519d49351c793cfc191565d6b7623dd622c51d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cardano/README.md",
      "content": "# Cardano - Contract\n\nThis is a Cardano contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "e50327f0e5f343e9bad8e9c4531ef3b6173917ffc7473062bc1d24260f1cfcb9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cardano/src/Cargo.toml",
      "content": "[package]\nname = \"cardano\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "a70bc88fa4d69eec39df5bca97c6e17c7f332659e98bdb548c8336c9901027c0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cardano/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod cardano {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Cardano' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct CardanoContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for CardanoContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl CardanoContract {\n        /// Creates a new PSP-22 compatible Cardano Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Cardano\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MCARDANO\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "6289ff33bfd827f122a875fa42a3ac292a47726f123ab7a1503faf188945e79c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cave/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cave/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-cave\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Cave'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "dbe227fa226fe1abd40cb3b98f12d5101da4de26113c1866145853b472dc227e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cave/README.md",
      "content": "# Cave - Contract\n\nThis is a Cave contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "854d106e72f0107b9e5e44a3febc27a22e86c5ee8bf021f414134aa9e1a215fc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cave/src/Cargo.toml",
      "content": "[package]\nname = \"cave\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "1e0fb6293cb182abcb04ffe60695d2b111fc34a54f1d93d16915e59c092bc372",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cave/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod cave {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Cave' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct CaveContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for CaveContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl CaveContract {\n        /// Creates a new PSP-22 compatible Cave Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Cave\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MCAVE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "b45eb325e684547f5244db3752b4039a25418d070111a2ee52df799dec4b4b5f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-charcoal/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-charcoal/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-charcoal\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Charcoal'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "d54e101f28752311df6bd790533bc7dacb92c02cbdee18d47801d65847ff5184",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-charcoal/README.md",
      "content": "# Charcoal - Contract\n\nThis is a Charcoal contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "e29b5211e62d68326c7d5d0d19220566717fca26c51c321c398db629ff7eb7ec",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-charcoal/src/Cargo.toml",
      "content": "[package]\nname = \"charcoal\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "7fa36eb89d0c0ac64cd9dac32ebad4fca7e4a974c46d15b995b4de723d5f11f1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-charcoal/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod charcoal {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Charcoal' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct CharcoalContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for CharcoalContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl CharcoalContract {\n        /// Creates a new PSP-22 compatible Charcoal Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Charcoal\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MCHARCOAL\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "50843ebbd796ee2b769dddb8211c1566ec70e0162d350a9af80f18e266e81ceb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-charred-ravine/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-charred-ravine/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-charred-ravine\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Charred Ravine'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "fb55f04b25305776b15f26ed7fc6589a19c1e62e37366beca16148b9da4485bd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-charred-ravine/README.md",
      "content": "# Charred Ravine - Contract\n\nThis is a Charred Ravine contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "499159656f852cb368e354672062aa51914b4493b1e7a0ae7887240a543cb253",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-charred-ravine/src/Cargo.toml",
      "content": "[package]\nname = \"charred_ravine\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "4d3304754934c4ef82232dc169daea6c7b121677203060ce840b46fbd44dec4b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-charred-ravine/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod charred_ravine {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Charred Ravine' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct CharredRavineContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for CharredRavineContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl CharredRavineContract {\n        /// Creates a new PSP-22 compatible Charred Ravine Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Charred Ravine\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MCHARRED_RAVINE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "c63113d34f5839092a0dd05fd4c653cdad91fbd91c5a51b27db43c671e58967d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-clay/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-clay/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-clay\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Clay'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "fbc044fe7075ac07fb833e80c2835deecce2f9be43b5d9222b8781a3c29e36b4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-clay/README.md",
      "content": "# Clay - Contract\n\nThis is a Clay contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "d60cb85c8d427888ebcbcb124afbb080aeaafb7a970fa113f69b147e8c1be82e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-clay/src/Cargo.toml",
      "content": "[package]\nname = \"clay\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "8749bd6167dd651e91edd1accc6a937f88c34e8da860e2b3e003a2884355360d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-clay/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod clay {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Clay' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct ClayContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for ClayContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl ClayContract {\n        /// Creates a new PSP-22 compatible Clay Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Clay\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MCLAY\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "0072873937185d00e3c5fd787341113929eaf6e4e5c1eac4dc99f6acbe3398d3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cloud/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cloud/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-cloud\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Cloud'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "05500dcfe1e77420b2b3d09b08d3ebe0c2dd5b6d1774931d6c09b157f3398670",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cloud/README.md",
      "content": "# Cloud - Contract\n\nThis is a Cloud contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "89791c84bdfd2215c32cf80bd90c1db9b5ef44c2f30c1996955adcf070987fbd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cloud/src/Cargo.toml",
      "content": "[package]\nname = \"cloud\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "65e3093c1e1ea7fea926b876645ad3815434758afe07161de13037ef86e0ecbf",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cloud/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod cloud {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Cloud' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct CloudContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for CloudContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl CloudContract {\n        /// Creates a new PSP-22 compatible Cloud Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Cloud\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MCLOUD\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "810505610bb154a349224225d764f642019654ff2b0ae01fd536b3c88893ad84",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-coin/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-coin/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-coin\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Coin'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "c01f7f0195c293e8b2637c9ddfa32450c159c21145e74c16d991e6dd3d9d54aa",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-coin/README.md",
      "content": "# Coin - Contract\n\nThis is a Coin contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "bf8289471baa5931743abce48670040b5cdc475561d9e9fe8c51e3ee88953a6d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-coin/src/Cargo.toml",
      "content": "[package]\nname = \"coin\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "8f30cc841cfd8df72c67fc0ab25254dfc3ff5936b80bd983bb7cf83699e52cc6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-coin/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod coin {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Coin' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct CoinContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for CoinContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl CoinContract {\n        /// Creates a new PSP-22 compatible Coin Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Coin\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MCOIN\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "f9ae3f6a1e24162d0676552b60bcee822aea852b2ff6a213a23c27e8a68e2a37",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cool-breeze/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cool-breeze/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-cool-breeze\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Cool Breeze'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "0c62dd25e3c4a2d2edb77f53038b77844496eb681575d75fb6863c13ed9d2887",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cool-breeze/README.md",
      "content": "# Cool Breeze - Contract\n\nThis is a Cool Breeze contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "a0a44adb2e900455b6513b810b2a836ddc175d187693835d3aaa87afb3db90d3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cool-breeze/src/Cargo.toml",
      "content": "[package]\nname = \"cool_breeze\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "5eb02545e9dd7eade669bda6a750fa649b2baed0456dbde14825d3a359d38718",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-cool-breeze/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod cool_breeze {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Cool Breeze' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct CoolBreezeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for CoolBreezeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl CoolBreezeContract {\n        /// Creates a new PSP-22 compatible Cool Breeze Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Cool Breeze\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MCOOL_BREEZE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "55182b1ebf0da27333709ae53ed44208aa4f7cb1704bbee09fcfd6faec94708e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-coral/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-coral/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-coral\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Coral'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "c7333b90a96ff9bdbe5dd67ad5d731e6138fdfadc3f4199f1fe31a9ffb4310fb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-coral/README.md",
      "content": "# Coral - Contract\n\nThis is a Coral contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "7fdbe83aaeececc4dbf57b2452dca99c0bcac8d0717966d2e231acac07d00300",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-coral/src/Cargo.toml",
      "content": "[package]\nname = \"coral\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "676bc33b5a3bae91acf7eb478c5d0db2c572b886a6a14577b3bcee8d1d42ad31",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-coral/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod coral {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Coral' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct CoralContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for CoralContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl CoralContract {\n        /// Creates a new PSP-22 compatible Coral Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Coral\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MCORAL\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "813d91e7140b870d28df2585c6fb90ca63405841c89106c3c88f6215394f31f0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-creek/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-creek/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-creek\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Creek'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "b255befcaec9b1b4e472e40e44a2ad56ad1f499d788c24691ceba6ce6b8b357d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-creek/README.md",
      "content": "# Creek - Contract\n\nThis is a Creek contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "27062c9288920642e118663f56931731101ac59e149659d47d2772e1db9db6d0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-creek/src/Cargo.toml",
      "content": "[package]\nname = \"creek\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "ca212f716a59412313ede300a75081485428c1bca5fbd62952db02f0b16de6b7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-creek/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod creek {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Creek' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct CreekContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for CreekContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl CreekContract {\n        /// Creates a new PSP-22 compatible Creek Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Creek\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MCREEK\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "6ca94f51a5be6f8a574f14b2eea74715085e7801c6a577e99090b89d585ca0a3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-crystal/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-crystal/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-crystal\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Crystal'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "8c74d24c31a6bb43e621f235ad1d310bff560747a49448e9d9017d61259429d7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-crystal/README.md",
      "content": "# Crystal - Contract\n\nThis is a Crystal contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "578c72210e2c636083a38e22c927ae21baab1794767b9d3d0755f8fcebf5e66d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-crystal/src/Cargo.toml",
      "content": "[package]\nname = \"crystal\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "fa89ccd9ff70d4caf805e4a790f438028deac989e1992807ab75593e65e5329e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-crystal/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod crystal {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Crystal' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct CrystalContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for CrystalContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl CrystalContract {\n        /// Creates a new PSP-22 compatible Crystal Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Crystal\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MCRYSTAL\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "fb3b7550c1249cc416df5630a4ecebcfef2e2830bc3fd133eafa5572c7491b47",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dam/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dam/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-dam\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Dam'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "7bbf643586e2d342ad1f7be537e79259825882b3dc6239e626957bf64fafacd3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dam/README.md",
      "content": "# Dam - Contract\n\nThis is a Dam contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "e3ceedabff0046fcb27485676aefd077200e89983cadb08e74b4c127fa2684db",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dam/src/Cargo.toml",
      "content": "[package]\nname = \"dam\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "76f225dc4c254e64e0ffbfae5d34b84a90d6076700f9100d9b2a9b0967491730",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dam/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod dam {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Dam' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct DamContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for DamContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl DamContract {\n        /// Creates a new PSP-22 compatible Dam Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Dam\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MDAM\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "27630fe1958306cccf5d1ad5ca6daca80d7d67c774e4a2fcc831638300e791a7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-delta/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-delta/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-delta\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Delta'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "7782b85f0cdb4b15d4df8944b5db7523cd20e434b40ac1771812b8a6b2e7c17f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-delta/README.md",
      "content": "# Delta - Contract\n\nThis is a Delta contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "3ddadb4ff604910336b0a96a291cd26d4ee6c5ed53df7acac25f18f8b6cbd089",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-delta/src/Cargo.toml",
      "content": "[package]\nname = \"delta\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "a510890e93d6b16cceaa2764b5d2325c06cc8341578613ce1a4c8e6cf1210a52",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-delta/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod delta {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Delta' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct DeltaContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for DeltaContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl DeltaContract {\n        /// Creates a new PSP-22 compatible Delta Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Delta\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MDELTA\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "bfba24874e374fafb188a53ea3cb4e930ca11e2ec2863d15666c214e88fe8655",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-depression/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-depression/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-depression\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Depression'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "90db89dbf043856be8adf1a83d093706dfea2248e1297a4d3f45719d8d900841",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-depression/README.md",
      "content": "# Depression - Contract\n\nThis is a Depression contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "ee8b1971b5ce9cd1680cc3c431db62686030ce214c2d055a00f7b8234c04aa62",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-depression/src/Cargo.toml",
      "content": "[package]\nname = \"depression\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "08f4f0e19ceb81405b3c8a04294a4464697ddae778e2ef6a8ceb45467f264396",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-depression/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod depression {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Depression' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct DepressionContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for DepressionContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl DepressionContract {\n        /// Creates a new PSP-22 compatible Depression Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Depression\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MDEPRESSION\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "1e392b327d1ee7db65aca32de1ab13f3288b8da7ce6a3cb8d8899d11d043f9fe",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-desert/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-desert/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-desert\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Desert'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "e316ebaa37a732ce839a0ac730f97d54c583c1e847807f0dc30aaa6d6e9272ba",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-desert/README.md",
      "content": "# Desert - Contract\n\nThis is a Desert contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "5cb4f927542bfa20438173f2ac43fdebe8cc8a23777b9e01e565c59e09ecf9bd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-desert/src/Cargo.toml",
      "content": "[package]\nname = \"desert\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "30962f9d16752c7a20d6126fedc62d4624987ff74fce54f1053dfd98d4f18d7c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-desert/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod desert {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Desert' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct DesertContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for DesertContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl DesertContract {\n        /// Creates a new PSP-22 compatible Desert Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Desert\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MDESERT\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "d2019e012b45f5a1353612c47d1fffb50cfb82604254bd1aaa6f75dc54ba4a63",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dry-basin/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dry-basin/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-dry-basin\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Dry Basin'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "575dc677cfa686c3f67ed4ef9f3e4ff1b7a08a78d178fc3e204e1ffe58b9ea1b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dry-basin/README.md",
      "content": "# Dry Basin - Contract\n\nThis is a Dry Basin contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "6bfe0e6fbd8a76524c7e8bb142d083a0a5e06e74d19dcb086ee387e04702d314",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dry-basin/src/Cargo.toml",
      "content": "[package]\nname = \"dry_basin\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "be3160d9cd775ad6acf12e2538b89b6dec8ce62c749084351888e070f9902abb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dry-basin/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod dry_basin {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Dry Basin' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct DryBasinContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for DryBasinContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl DryBasinContract {\n        /// Creates a new PSP-22 compatible Dry Basin Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Dry Basin\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MDRY_BASIN\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "e8ac34c2c501cd6025461cefd4d2d9fb134874052851d38ce733a9d051e3002b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dune/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dune/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-dune\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Dune'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "37d50bbe1a6962bc88b67ff9a0f1444fc6c11dbd07063b903ce8a4d9ffefb2ad",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dune/README.md",
      "content": "# Dune - Contract\n\nThis is a Dune contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "b2ed3f44b00afe77babeb7be77cbd2db317f04d271c1a2ba405248341e1a277d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dune/src/Cargo.toml",
      "content": "[package]\nname = \"dune\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "ca6e34c3de848c81a4581e9e6737a8708b6876743cfe4c2d47ffa46e435f3ff6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dune/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod dune {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Dune' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct DuneContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for DuneContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl DuneContract {\n        /// Creates a new PSP-22 compatible Dune Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Dune\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MDUNE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "5c49c5a80ae0b35593bc33b1c69153bb282fcb738017fce08f1d3448a6f72fdd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dust/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dust/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-dust\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Dust'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "da280c441b1bc8654d31686804fcc7f5b436e5a5f17caaa2159a58a9d0514b70",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dust/README.md",
      "content": "# Dust - Contract\n\nThis is a Dust contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "4f9e7e86864bdd2c739c15164ced30fd8ba9e3266f2c2c4c6cdcd4cc9fd1e87a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dust/src/Cargo.toml",
      "content": "[package]\nname = \"dust\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "2c5da92afd2ab4c1a46805903cb929d325417b42418c57d6c30ba6aef07fbee3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-dust/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod dust {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Dust' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct DustContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for DustContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl DustContract {\n        /// Creates a new PSP-22 compatible Dust Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Dust\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MDUST\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "4c89880e342998e8802dafae29bd3855bcfa30173aa34074ca234161929f016d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-earth/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-earth/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-earth\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Earth'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "b69ad1a6835071fe2fffb3a5227703f6484c4bee5b117761f2c69a3871a0ba7c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-earth/README.md",
      "content": "# Earth - Contract\n\nThis is a Earth contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "17641144f3956bf4a92afc6e6fada89f684c207df1261fe9f8f1c211b7f1d55e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-earth/src/Cargo.toml",
      "content": "[package]\nname = \"earth\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "ca9d5007293a66afc8cdb1b691f90b51d9e8f2aa9ba074c730fa25ab1e456ca2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-earth/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod earth {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Earth' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct EarthContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for EarthContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl EarthContract {\n        /// Creates a new PSP-22 compatible Earth Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Earth\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MEARTH\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "33e5bb9a6ef51103f35fe4268e6f19f9e24952b6638840001bad6299bdea09e3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-echo/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-echo/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-echo\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Echo'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "f428d06c9ab1e5734e9f921aa7bde713e3d09b5c99c559f72bb9c28b4ab7da43",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-echo/README.md",
      "content": "# Echo - Contract\n\nThis is a Echo contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "244fb65c7dbb166d2ad909109bf7a1e65ebea03e6ec1819fb63af1a7581d0b0a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-echo/src/Cargo.toml",
      "content": "[package]\nname = \"echo\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "7d1074c77c6b8856e363f9af423eeab19d0e7bc4a99d97271f6a4c7971dce9a2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-echo/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod echo {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Echo' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct EchoContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for EchoContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl EchoContract {\n        /// Creates a new PSP-22 compatible Echo Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Echo\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MECHO\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "87e8bc3d3c0bb1576a64d113fc90c3cac23b5fb8377f41c9904b5b6633899cb0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-ember/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-ember/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-ember\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Ember'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "2703a7ad435cfe7e9cc9846f3f22bce88b1e4a6f6cda38615cc3613bfb5c3647",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-ember/README.md",
      "content": "# Ember - Contract\n\nThis is a Ember contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "34b9b87b147a04f3c245702554936ea5294e3112e799f0e0b8aefcc131415fbe",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-ember/src/Cargo.toml",
      "content": "[package]\nname = \"ember\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "9e951fd4ff7590797631373116916c4c032be5c9bdd36ab124cf6cddaca13c3d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-ember/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod ember {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Ember' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct EmberContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for EmberContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl EmberContract {\n        /// Creates a new PSP-22 compatible Ember Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Ember\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MEMBER\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "43f34e995d6fd2619b4258ab27c695915ce95e81880ecd651dae79a4d5c73019",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-erosion/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-erosion/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-erosion\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Erosion'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "09f4eed16ec69b52bdbed70893abea337e0058a944b1fd5fa34b04d2866a7a07",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-erosion/README.md",
      "content": "# Erosion - Contract\n\nThis is a Erosion contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "a71ef5d17e79ab27a44eea7c233106ac8ad231e124727c61bf847933d2aef6d0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-erosion/src/Cargo.toml",
      "content": "[package]\nname = \"erosion\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "e5f4956e00e57397d2ec09d8566d2e1de1c7834797ff4aeb245110108939c5e5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-erosion/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod erosion {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Erosion' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct ErosionContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for ErosionContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl ErosionContract {\n        /// Creates a new PSP-22 compatible Erosion Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Erosion\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MEROSION\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "53ebdf0c3e22e208fe21c3dbfef81f99322859d99a393ef2b0eabb1f7086b989",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-estuary/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-estuary/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-estuary\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Estuary'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "ea08c9fb8c2b1c760834fa154c5f7574b91b5495fa05bdce478cac98a20e4cb6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-estuary/README.md",
      "content": "# Estuary - Contract\n\nThis is a Estuary contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "e228cc5940db3bec1b8bd6b17fe724655c77a940603034eedfde1137ab9f35f7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-estuary/src/Cargo.toml",
      "content": "[package]\nname = \"estuary\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "4dd8e5b080b1e1f17ae293e2864159cf1c575da05bf25e2a553abacf5408b858",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-estuary/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod estuary {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Estuary' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct EstuaryContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for EstuaryContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl EstuaryContract {\n        /// Creates a new PSP-22 compatible Estuary Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Estuary\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MESTUARY\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "33f1d6a0a3b3006cd3d020e800e1c027f41081aaf9c0e1a8c6fbf2b42fc15957",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-eternal-flame/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-eternal-flame/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-eternal-flame\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Eternal Flame'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "7189e0382ea78265b39a43a96ef075a14ca794c5455bc3ba4b25aaee88dd358e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-eternal-flame/README.md",
      "content": "# Eternal Flame - Contract\n\nThis is a Eternal Flame contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "72a1e3366e821b57a9584fff99641f52158e1e86b4814df63a5db9b9436ac730",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-eternal-flame/src/Cargo.toml",
      "content": "[package]\nname = \"eternal_flame\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "c61e98f409ca02a7f6de002c58ac3ba3382879a684b8351311e7f1ce9f2a75d2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-eternal-flame/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod eternal_flame {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Eternal Flame' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct EternalFlameContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for EternalFlameContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl EternalFlameContract {\n        /// Creates a new PSP-22 compatible Eternal Flame Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Eternal Flame\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"METERNAL_FLAME\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "b074e82c2b2c27525e4a14a84a2c24a93fbabbca9bf74b03436abb5325617539",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-farm/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-farm/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-farm\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Farm'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "c4a196b4408ae1d8d08b2245e482f572ea7e4b22a95cea860aab972b5b8ac4b1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-farm/README.md",
      "content": "# Farm - Contract\n\nThis is a Farm contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "3842cc5029918d7defeb489091e56159db8fa7fe98d4f1c9c6e4e0967b6360dc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-farm/src/Cargo.toml",
      "content": "[package]\nname = \"farm\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "0f730192837250cb2fde15ae1564baa767dc464ce3a7b09eccbd52b393dd4009",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-farm/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod farm {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Farm' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct FarmContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for FarmContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl FarmContract {\n        /// Creates a new PSP-22 compatible Farm Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Farm\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MFARM\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "52bf044004900ba61a969b2bbc906df444ee28bac682ffab15e1a87971d2b4ce",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fertile-land/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fertile-land/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-fertile-land\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Fertile Land'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "5bc5fc4b247f3dc83acab08eb068f246422649cce4ef1f321129fb59723adf40",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fertile-land/README.md",
      "content": "# Fertile Land - Contract\n\nThis is a Fertile Land contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "a2f29246a0a6079f9860a236ff5934572edab7e877fb33fb7e78032dbfc98e0e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fertile-land/src/Cargo.toml",
      "content": "[package]\nname = \"fertile_land\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "8f8855e22cfceaa37325f55a95120ba9d22bd53f5a50bbf0c8330831bd79f5ce",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fertile-land/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod fertile_land {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Fertile Land' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct FertileLandContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for FertileLandContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl FertileLandContract {\n        /// Creates a new PSP-22 compatible Fertile Land Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Fertile Land\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MFERTILE_LAND\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "0539c51e2198581236a6a8f81e5e586f911497d28a94e7b35a7ce0c0fc778b8a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fertilizer/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fertilizer/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-fertilizer\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Fertilizer'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "1b6c0a3d7a3034aa866c3afd9f2143ab0b80b17d81a42c47ef3372b4b0354c16",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fertilizer/README.md",
      "content": "# Fertilizer - Contract\n\nThis is a Fertilizer contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "0fec6f331033bd81d58d7e0a23a26dc2c91f294dae3d1dcc7eef81f39f31f5d5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fertilizer/src/Cargo.toml",
      "content": "[package]\nname = \"fertilizer\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "f72ccea02d963fa93fe2f40c10d5ed2f654dcb8ccd541d4680ce7326e8d30aad",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fertilizer/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod fertilizer {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Fertilizer' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct FertilizerContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for FertilizerContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl FertilizerContract {\n        /// Creates a new PSP-22 compatible Fertilizer Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Fertilizer\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MFERTILIZER\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "9af3e0e595db13c055edf54dc36ce981ace4916cafb6b521f9d5374cf477bc05",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fire-swamp/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fire-swamp/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-fire-swamp\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Fire Swamp'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "54f33d0cfc6314ec88c9c24999517d19301d0c0fdbaa60bbb0332aaa6adbb7d5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fire-swamp/README.md",
      "content": "# Fire Swamp - Contract\n\nThis is a Fire Swamp contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "99f15cdcc88679768ad8d47c1008b469f4bf03671ca3770d399fd6b7e30be19b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fire-swamp/src/Cargo.toml",
      "content": "[package]\nname = \"fire_swamp\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "b7a3272605ffe8154a4d94f3ec72d82aa247aee50a465b5360098204449d2ef7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fire-swamp/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod fire_swamp {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Fire Swamp' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct FireSwampContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for FireSwampContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl FireSwampContract {\n        /// Creates a new PSP-22 compatible Fire Swamp Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Fire Swamp\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MFIRE_SWAMP\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "a0d74f5d286a17277f52c8d4e0e937eb4edcbf037a10251b96dedc9659c39faf",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fire/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fire/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-fire\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Fire'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "e8c665d7ea2ade4e5ac672b7b286a119d49816e3b6a973ff45dddd69e89ef47d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fire/README.md",
      "content": "# Fire - Contract\n\nThis is a Fire contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "fb244d7c22082eab97129bac506b811223a18ebf2978aa827f2b85ce67a57723",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fire/src/Cargo.toml",
      "content": "[package]\nname = \"fire\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "9520e61b9f13f56d2ba329c527b622fda115a62c838d3a98a45336964f2f38e2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fire/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod fire {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Fire' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct FireContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for FireContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl FireContract {\n        /// Creates a new PSP-22 compatible Fire Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Fire\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MFIRE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "d5a0870423c235a6bfd5374ee6f9124c76773dc839e8cf91a9bd1e60dcc1ff20",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-firewall/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-firewall/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-firewall\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Firewall'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "6c4c993202e42aa1e163a6058b08638aa4b50b3b9e62d3bffde91c0399b2c5c8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-firewall/README.md",
      "content": "# Firewall - Contract\n\nThis is a Firewall contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "12f841420b26c69093ed64a1e215368d62fad11bb50fd27e7b7ba42b3ee1ce78",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-firewall/src/Cargo.toml",
      "content": "[package]\nname = \"firewall\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "39d57f04b40db4e18ad025d10c3416ab7348585201b2453da1108f0e4a640325",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-firewall/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod firewall {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Firewall' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct FirewallContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for FirewallContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl FirewallContract {\n        /// Creates a new PSP-22 compatible Firewall Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Firewall\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MFIREWALL\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "72416225e84e48aa4b79094e85b92d2c52f55f47ff75ee6b19dd96422cbb6dde",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-flood/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-flood/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-flood\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Flood'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "967dd9f18be705fdd59105cd9efa15311f713a2a597b5619736c055fb0df425a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-flood/README.md",
      "content": "# Flood - Contract\n\nThis is a Flood contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "49d85dd491127862da4da376a39753ee3a1a6ff950cba197cb1af39ab537a302",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-flood/src/Cargo.toml",
      "content": "[package]\nname = \"flood\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "d9f51eb11eb2fc04cd739d8ce88845be65f6c31ac0ca4d495cf9e583c4422028",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-flood/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod flood {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Flood' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct FloodContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for FloodContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl FloodContract {\n        /// Creates a new PSP-22 compatible Flood Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Flood\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MFLOOD\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "ee8c799603e0a6b37950c96c522c7363f91447638fd2731689bfbbbc0a2f39bc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-flower/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-flower/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-flower\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Flower'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "8c18d2e96a72661eff63a5c0f8b12644eaf968bae1fa977d871ae733a8c163bf",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-flower/README.md",
      "content": "# Flower - Contract\n\nThis is a Flower contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "001b9a3bbc69dec3272b0a536ecb57e1fef3463fad0c6ec1947cb9d1355c64a1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-flower/src/Cargo.toml",
      "content": "[package]\nname = \"flower\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "2a8b7b36daac405e24a93d97665111a1cc987cc8a9df6f8bba9639c53ba5f000",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-flower/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod flower {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Flower' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct FlowerContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for FlowerContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl FlowerContract {\n        /// Creates a new PSP-22 compatible Flower Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Flower\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MFLOWER\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "f8849719c1fe3a423c2748a0564fab75fe629584d330a8879d31d1fad907f0e1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fog/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fog/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-fog\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Fog'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "37ee64e82e9a23d0088e9c093d769f596a09ccf2d08e464bb9c12a54cc8c68af",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fog/README.md",
      "content": "# Fog - Contract\n\nThis is a Fog contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "79ee2f43469cc1d6ed489603d4ef0bce49facd71cc9c0255f3f83733d9ac4a36",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fog/src/Cargo.toml",
      "content": "[package]\nname = \"fog\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "49f73c96f1cd2986e92a641b8751c86e8d5b01534598a65f64ec2f78dd21692f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fog/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod fog {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Fog' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct FogContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for FogContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl FogContract {\n        /// Creates a new PSP-22 compatible Fog Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Fog\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MFOG\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "0cf1145e29335847ef15bda4d67ab714f1afa1334aac8594ba762c8af9fb2003",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-forest/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-forest/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-forest\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Forest'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "eb8c3af05e020dfebbac2628a7561ac8620e3d341922d0a407bc45cb7cabf54b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-forest/README.md",
      "content": "# Forest - Contract\n\nThis is a Forest contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "203a7de20d1839ea37126d554ca905ed3ab9beca549a960ccb44e855b97e7fcd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-forest/src/Cargo.toml",
      "content": "[package]\nname = \"forest\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "3f039f079e9a74b3ea083138edcb65a3b430b889ea847719132a01aee6a8b387",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-forest/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod forest {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Forest' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct ForestContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for ForestContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl ForestContract {\n        /// Creates a new PSP-22 compatible Forest Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Forest\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MFOREST\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "baceaca29a2a804801c546155d9bd289ebbb935d98e3e9206c43061f858b41c4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fountain/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fountain/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-fountain\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Fountain'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "cca4b58f6dfe9e1e70708731690522bdc4c4e1c522ee8266b6964289f27c8a90",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fountain/README.md",
      "content": "# Fountain - Contract\n\nThis is a Fountain contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "47f5c5f5eabec4acb0011b847f701cb8df56b71da31046909af2dbffb40d34d2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fountain/src/Cargo.toml",
      "content": "[package]\nname = \"fountain\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "1d67ab0e68f257746f0b340b043d7b6b666c2067da88ed20d8134106c5a7af29",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fountain/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod fountain {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Fountain' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct FountainContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for FountainContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl FountainContract {\n        /// Creates a new PSP-22 compatible Fountain Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Fountain\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MFOUNTAIN\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "04faec224d9c28c9436bd7de0e04528292a0ce46f707b103d087b15a657f93c4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fresh-breeze/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fresh-breeze/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-fresh-breeze\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Fresh Breeze'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "3681ddbb439f4adabf44ca0aeb12986ba07ed909880d868f85c6073b8b67d1e4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fresh-breeze/README.md",
      "content": "# Fresh Breeze - Contract\n\nThis is a Fresh Breeze contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "e1615ff69ba5bf8da08f2f959cbb4c10f004ccf8c30837095c4cebc75f210580",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fresh-breeze/src/Cargo.toml",
      "content": "[package]\nname = \"fresh_breeze\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "791bdc86e90ba7fab239900fbdba0ee1fb534acbce47e19040ccaab71044626f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fresh-breeze/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod fresh_breeze {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Fresh Breeze' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct FreshBreezeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for FreshBreezeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl FreshBreezeContract {\n        /// Creates a new PSP-22 compatible Fresh Breeze Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Fresh Breeze\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MFRESH_BREEZE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "a48ba073d54e852670bf06822ccdd4356584c6365f783e61df12519c427b32c6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-frosted-glass/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-frosted-glass/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-frosted-glass\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Frosted Glass'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "60ce299e94ef49a1dc656eaa568f076834d8761aa31b432a7caeb7692ac83520",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-frosted-glass/README.md",
      "content": "# Frosted Glass - Contract\n\nThis is a Frosted Glass contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "aa330228971631be238ac2754645a96c6d71a43569893ffaf7441a51e74ef3c4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-frosted-glass/src/Cargo.toml",
      "content": "[package]\nname = \"frosted_glass\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "96c9136ac0d774c5d4348176c15bdaaf74b4f0d0b63635171f4cf71cc51e9394",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-frosted-glass/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod frosted_glass {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Frosted Glass' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct FrostedGlassContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for FrostedGlassContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl FrostedGlassContract {\n        /// Creates a new PSP-22 compatible Frosted Glass Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Frosted Glass\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MFROSTED_GLASS\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "4244137d952fbdfa4e60d1350d4fd9b67cbf14c48e58f64c907bc538c4bff769",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-garden/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-garden/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-garden\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Garden'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "1729c35bac31818252c800e0938045a85552c706750835cf58c67cbdfa2acb58",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-garden/README.md",
      "content": "# Garden - Contract\n\nThis is a Garden contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "54eb34def0fa686ff0d16590add5cfa4efa10c57d8545f7f78e0b5af77e10412",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-garden/src/Cargo.toml",
      "content": "[package]\nname = \"garden\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "04c3a6f1a2b2ca65c0f83f24307dbd265d7d6db56267ac08065aa77b3cf70301",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-garden/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod garden {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Garden' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct GardenContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for GardenContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl GardenContract {\n        /// Creates a new PSP-22 compatible Garden Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Garden\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MGARDEN\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "e35cefe15b177c03e38c1116d89f968f8cc4d8cc8b7c93675ed727b0eee59125",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-geothermal-spring/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-geothermal-spring/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-geothermal-spring\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Geothermal Spring'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "d6ff7e9bf44bbcaa5920b5584eff103ca57843a7a0343b7b0693b9623e359a8f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-geothermal-spring/README.md",
      "content": "# Geothermal Spring - Contract\n\nThis is a Geothermal Spring contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "222c5b42603d168d7c3afbfa27ee46ab178011b14d870d95fe129268091231f2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-geothermal-spring/src/Cargo.toml",
      "content": "[package]\nname = \"geothermal_spring\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "a5a1d03b15e37b700b4f620193f49bcb4945982eeeeb22b0a12f7e31819683ae",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-geothermal-spring/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod geothermal_spring {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Geothermal Spring' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct GeothermalSpringContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for GeothermalSpringContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl GeothermalSpringContract {\n        /// Creates a new PSP-22 compatible Geothermal Spring Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Geothermal Spring\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MGEOTHERMAL_SPRING\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "7f9151d14fada84e6006057f8d8f0ba716d6f714c13c871e195621fbe836fea6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-geyser/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-geyser/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-geyser\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Geyser'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "0883e775f2e586b424d40fce379bd0c91d44f94ce596584ddc5d619576043107",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-geyser/README.md",
      "content": "# Geyser - Contract\n\nThis is a Geyser contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "e41613cb6a08235833d7b4e3d5ae1ff028487ca87d220d01f42c934882b27f21",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-geyser/src/Cargo.toml",
      "content": "[package]\nname = \"geyser\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "223d610baf5dc1480cc01069b1fa57e2ff2d7efb461140cc46d4978290a255e9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-geyser/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod geyser {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Geyser' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct GeyserContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for GeyserContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl GeyserContract {\n        /// Creates a new PSP-22 compatible Geyser Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Geyser\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MGEYSER\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "0960c7a560560a2e27e9def99e59fec1f6634134bc37bf248f9df819f3d0990f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-giraffe/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-giraffe/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-giraffe\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Giraffe'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "9ab37aa292aea97759eb079afc0a1ed13cbbe07c2146a9c1c9a66437b8a0647c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-giraffe/README.md",
      "content": "# Giraffe - Contract\n\nThis is a Giraffe contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "ccfc0ee2c15d5195774e45cd40e7ff8df5eca00da502cc996a2b5c26757ea7a8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-giraffe/src/Cargo.toml",
      "content": "[package]\nname = \"giraffe\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "dd2c9f669ee88d2a3c3fa2d9bcd351cff275320990a81c87a55b38d68c80ff10",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-giraffe/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod giraffe {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Giraffe' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct GiraffeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for GiraffeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl GiraffeContract {\n        /// Creates a new PSP-22 compatible Giraffe Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Giraffe\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MGIRAFFE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "97471cd37cff0add32955f7bb977a44a2d706dcc2ffb827144ef20d75b0a5c7e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-glass/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-glass/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-glass\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Glass'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "45c1eccfa1e43f6165685b9f28ad81e28bda3939fce18974019ca71c59fec0f2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-glass/README.md",
      "content": "# Glass - Contract\n\nThis is a Glass contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "d5de2dc723ca3a54e1d29b2d8433a2e24d610a07cc823625651ccc3f9b2d3cc2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-glass/src/Cargo.toml",
      "content": "[package]\nname = \"glass\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "7ef2070cd4cd939d35c5b8af549b652ddbc6d2fc52bd55731ad1d7d988d28263",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-glass/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod glass {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Glass' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct GlassContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for GlassContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl GlassContract {\n        /// Creates a new PSP-22 compatible Glass Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Glass\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MGLASS\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "c10725e48a4d62481d828a9ae11d32c39b111a7e02d996c5e7d9053907909595",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-gold/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-gold/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-gold\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Gold'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "f11aa5053c746bfe2fdacafa76749ec8151de17909ceda192f5037ca4a35789b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-gold/README.md",
      "content": "# Gold - Contract\n\nThis is a Gold contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "bd6c32971670789fc6782a9cfe64761d704716d704be3802ef74930e5f6c5038",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-gold/src/Cargo.toml",
      "content": "[package]\nname = \"gold\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "4744d485a69314636ce0e6d4696b8cf4ef151005920d947d59d4f9f8419e0bb2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-gold/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod gold {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Gold' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct GoldContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for GoldContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl GoldContract {\n        /// Creates a new PSP-22 compatible Gold Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Gold\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MGOLD\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "1bf31f1ecfc78be555541f6e8ef6c1c49bb7f6baad45650add82608c72cff88d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-golden-gate/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-golden-gate/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-golden-gate\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'GoldenGate'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "b95c1f9f8e48798c34791591167ab62fb6d5395b13c049c90ea8a8d24db4cedb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-golden-gate/README.md",
      "content": "# GoldenGate - Contract\n\nThis is a GoldenGate contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "1932e4513aa7b3da879888bdca7c5de11d1a34f7e3649d352a57f5d424402415",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-golden-gate/src/Cargo.toml",
      "content": "[package]\nname = \"golden_gate\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "45e0b56582c45d117111235d4157c37653da5ead7f7bdd653adcca73648bdaf6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-golden-gate/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod golden_gate {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'GoldenGate' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct GoldenGateContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for GoldenGateContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl GoldenGateContract {\n        /// Creates a new PSP-22 compatible Golden Gate Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Golden Gate\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MGOLDEN_GATE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "23ac764ea4341d18eecb7c8ccd8f50f3345fc47501b55c825b431fb7ab63cf87",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-gorge/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-gorge/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-gorge\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Gorge'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "c6de8937532e770ff293334115cc316b5628dcd9e76cce493ce4b0172c27ba91",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-gorge/README.md",
      "content": "# Gorge - Contract\n\nThis is a Gorge contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "a12477c8a9cb818b5de23fb675ad7b94ec2fda0c6b1f826803665a2f003cda64",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-gorge/src/Cargo.toml",
      "content": "[package]\nname = \"gorge\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "233f8f7c0a3666bce3a372506e731b3937fa7f0a5d6fa1bdbaffe1ce97b13d84",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-gorge/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod gorge {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Gorge' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct GorgeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for GorgeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl GorgeContract {\n        /// Creates a new PSP-22 compatible Gorge Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Gorge\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MGORGE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "c0f3912919dd8d96b83129b710fbc184b1db905a33da1a786d0443583704df18",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-grotto/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-grotto/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-grotto\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Grotto'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "1bbf0af374d6c94e118ebc98365da8c87da98994ea725a0412f66a19b932953b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-grotto/README.md",
      "content": "# Grotto - Contract\n\nThis is a Grotto contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "069589a7b219c29989353f16b5f848c5ac72d4600aaf556a88cd826a08b37c1e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-grotto/src/Cargo.toml",
      "content": "[package]\nname = \"grotto\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "d3e22923d43be74172cc9af66d09c28b98028dcaa1341e86709dc867693e51c1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-grotto/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod grotto {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Grotto' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct GrottoContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for GrottoContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl GrottoContract {\n        /// Creates a new PSP-22 compatible Grotto Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Grotto\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MGROTTO\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "753671004e4ccedaa6e75df4cdd8a419c13dee4435d10358b3662bf4d60f2afd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-groundwater/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-groundwater/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-groundwater\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Groundwater'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "1f12c852166eb24dff7f0f015e3571235b2dc28bec573f0954f8c54354a91795",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-groundwater/README.md",
      "content": "# Groundwater - Contract\n\nThis is a Groundwater contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "b08d0d193cdb00701625ea988cf8279d2a7f25671ea476dd7952e7a439cc7b4f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-groundwater/src/Cargo.toml",
      "content": "[package]\nname = \"groundwater\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "07996e0bc4dba9adbc5dc79789612b6f3e04831dfbbd4628b409332c03fed0d0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-groundwater/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod groundwater {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Groundwater' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct GroundwaterContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for GroundwaterContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl GroundwaterContract {\n        /// Creates a new PSP-22 compatible Groundwater Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Groundwater\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MGROUNDWATER\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "24e856e7e66caeee7704aad592c3e234222ce4bca3cca9cf4b9ef6edb582af25",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-haze/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-haze/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-haze\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Haze'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "8d777f7fe3d005a4b599448042bb6fb6f6e97e8169ffc36d2170c4fe133c7ba2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-haze/README.md",
      "content": "# Haze - Contract\n\nThis is a Haze contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "6334f8f94193034de12c17773d31271ca2f1dbb37299ed04101dd6532ef415a9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-haze/src/Cargo.toml",
      "content": "[package]\nname = \"haze\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "594742b5316b6f82a2c1a64a56ef27fcb8b76709b6422408b092b087a020de4c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-haze/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod haze {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Haze' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct HazeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for HazeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl HazeContract {\n        /// Creates a new PSP-22 compatible Haze Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Haze\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MHAZE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "fdd0191d032e07dc2b0af9588ecc7fbad8af1cc665e5f580d8317a2c62e8bbe4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hive/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hive/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-hive\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Hive'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "cde7ec20c8f10435404d021925ec77007917a7799215340fb137b4df5d399a4c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hive/README.md",
      "content": "# Hive - Contract\n\nThis is a Hive contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "5d576fb4fe865a41e413953672d12eeaa28ccfee5e18ab4147e746a45ebb1838",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hive/src/Cargo.toml",
      "content": "[package]\nname = \"hive\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "d2605dfba42a28e60498eec922d6552b3969807793e9ca93959a86ae9416ff07",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hive/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod hive {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Hive' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct HiveContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for HiveContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl HiveContract {\n        /// Creates a new PSP-22 compatible Hive Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Hive\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MHIVE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "75a37fd20ceeef476e2a4d0211bca5cb91ce270bfccd24f0423de052e67582f3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hot-spring/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hot-spring/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-hot-spring\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Hot Spring'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "40c569f3c0135442ecedd46ffc4ac7dd71718299be21b02f2c2e1ea6415d651d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hot-spring/README.md",
      "content": "# Hot Spring - Contract\n\nThis is a Hot Spring contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "22fe285ea5c4fce66377d5991c4f17a463c287073dc75553763ba4b0449ba42b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hot-spring/src/Cargo.toml",
      "content": "[package]\nname = \"hot_spring\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "d46cd78328389bc5a5849a64f6701cdb259bdadbb9134310e42070eb56bc7a6f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hot-spring/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod hot_spring {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Hot Spring' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct HotSpringContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for HotSpringContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl HotSpringContract {\n        /// Creates a new PSP-22 compatible Hot Spring Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Hot Spring\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MHOT_SPRING\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "24174684cdd14f20034e029cd5e088024ee2687673128d2956fb8caed72d93c3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hydra/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hydra/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-hydra\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Hydra'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "d5c05fa62915939b813e1f02a41a0e99aec48e5975679a2b4743c975b61ee065",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hydra/README.md",
      "content": "# Hydra - Contract\n\nThis is a Hydra contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "fc131ebe193171c5b792e3af19b11f593e30fdcd7855e412b6c271bff00890e3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hydra/src/Cargo.toml",
      "content": "[package]\nname = \"hydra\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "0caaa876a93b04705396fb01474a007f16eb92f9e0848e7db129845bbfcb646f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hydra/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod hydra {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Hydra' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct HydraContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for HydraContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl HydraContract {\n        /// Creates a new PSP-22 compatible Hydra Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Hydra\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MHYDRA\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "554fd625c7aad4eb6923da13783e140e5266b806e7ca2ef8a0ed536cbae5f8c4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hyper-marmalade/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hyper-marmalade/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-hyper-marmalade\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'HyperMarmalade'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "8feef154feadcea3438aa5d5f49d5fab1de4c7c1fec641a2b776f9f2a4b4d52a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hyper-marmalade/README.md",
      "content": "# HyperMarmalade - Contract\n\nThis is a HyperMarmalade contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "e240856fc2104866007c6a789a5b5a82ec9d3c7e5733f42425850c4e131ec145",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hyper-marmalade/src/Cargo.toml",
      "content": "[package]\nname = \"hyper_marmalade\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "6d473bef655c2a15d2c817b95b09af4d9182e61d3672757513c0ecc762ae2cec",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-hyper-marmalade/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod hyper_marmalade {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'HyperMarmalade' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct HyperMarmaladeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for HyperMarmaladeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl HyperMarmaladeContract {\n        /// Creates a new PSP-22 compatible Hyper Marmalade Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Hyper Marmalade\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MHYPER_MARMALADE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "6753c6db33c3eb29dfc8db32451852a6b1b0a1869132d8cfa68bd6d0b81b6686",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-island/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-island/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-island\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Island'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "a5c39f71ca7ffe47e057a5f6003b1ffde6dda7c4e261b5483da114722e86e6cf",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-island/README.md",
      "content": "# Island - Contract\n\nThis is a Island contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "4ff834328d416bf1b48eefddfff53e441a9b3501382508adfac68da5342b1346",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-island/src/Cargo.toml",
      "content": "[package]\nname = \"island\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "28761f231d714b09eaf58c097695c9d6a8103a538070492faed94128a9de5f87",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-island/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod island {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Island' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct IslandContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for IslandContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl IslandContract {\n        /// Creates a new PSP-22 compatible Island Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Island\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MISLAND\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "315a7172e6ad180f74cbf9d2027da2f4a4b1731a9c588977bab2ed3efbf427ae",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-jungle/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-jungle/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-jungle\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Jungle'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "836af793d262e05a4709f899f7a86c1b7628c391e09478492f5861be80faccff",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-jungle/README.md",
      "content": "# Jungle - Contract\n\nThis is a Jungle contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "658f3d071d0c07901f13bd51ba87a0f8fd4896e710223f16996b9c10db7817ab",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-jungle/src/Cargo.toml",
      "content": "[package]\nname = \"jungle\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "cfcfde4cb693b226fadd45779e9af35a77be7a16a9fbdee0effebda5002a6608",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-jungle/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod jungle {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Jungle' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct JungleContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for JungleContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl JungleContract {\n        /// Creates a new PSP-22 compatible Jungle Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Jungle\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MJUNGLE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "aaeb7eda2b82d5c914737f1a6e43dc69c7c36bbdbd9e363cf8fb78d998837302",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-karst/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-karst/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-karst\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Karst'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "0d29714324aa357adff658c0db09db771c2b030b5591f8ccd3a60c4db1ea2826",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-karst/README.md",
      "content": "# Karst - Contract\n\nThis is a Karst contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "d7546fc73c28f84f19078f729358d5bf3fb1d071af997bc1ea08594691652cdf",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-karst/src/Cargo.toml",
      "content": "[package]\nname = \"karst\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "f6f7eeb614d7c8cc7a3d92595b71e25be09e9df7f7e454bcafe02be9f72b7efc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-karst/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod karst {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Karst' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct KarstContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for KarstContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl KarstContract {\n        /// Creates a new PSP-22 compatible Karst Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Karst\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MKARST\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "848fd10932816fdcbbb185b44645457153bc3809b870f1fd193fe3b724f89be6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-kiln/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-kiln/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-kiln\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Kiln'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "81a197797505b332edef2305e6d0f195e9d1d7441caea692f4b37254d6378167",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-kiln/README.md",
      "content": "# Kiln - Contract\n\nThis is a Kiln contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "ec232e7bccc90420b2e4d3e033623c4a990ed03d61814757870f5e060ae2b29c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-kiln/src/Cargo.toml",
      "content": "[package]\nname = \"kiln\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "2c0c549d8c158d7a4512d8d1ca084458b8809e62469f2c0f3af4fdc02ea330d5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-kiln/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod kiln {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Kiln' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct KilnContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for KilnContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl KilnContract {\n        /// Creates a new PSP-22 compatible Kiln Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Kiln\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MKILN\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "80c109874b1832f78fd35bc5a4d5e28dcf49b257e6af8ad90b81440ba22dd28a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lagoon/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lagoon/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-lagoon\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Lagoon'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "7180b7cc7cef9b9ab8986079dae562a7293fd80234e8e97ff3e2fcd85b08dc4a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lagoon/README.md",
      "content": "# Lagoon - Contract\n\nThis is a Lagoon contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "c8569328fd795299fb928a79e8f1873783209058f3acd60e6d73b7461c50eb0e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lagoon/src/Cargo.toml",
      "content": "[package]\nname = \"lagoon\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "a436d7eb1116d764c9c4fc56c925c229dcaa79cbe25be3c0f5b25ef53fba5911",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lagoon/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod lagoon {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Lagoon' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct LagoonContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for LagoonContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl LagoonContract {\n        /// Creates a new PSP-22 compatible Lagoon Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Lagoon\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MLAGOON\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "72e5a43fb2069853f354989ffd0ac74bc5710736ad1025b1a8aa8f693c3e3523",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lake/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lake/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-lake\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Lake'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "123beb96842eb62ce09e5809f77555850a9c0f57cb8ce7c330134566a7eb6c7b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lake/README.md",
      "content": "# Lake - Contract\n\nThis is a Lake contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "6941cd795e530047e82ddd9e9e150e6419cc86d322165bd51953721a60d93faa",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lake/src/Cargo.toml",
      "content": "[package]\nname = \"lake\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "eec61c8d9d2ef33a0797ea55e494309afd72117d59d1c00935e62c20a3afff1e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lake/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod lake {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Lake' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct LakeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for LakeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl LakeContract {\n        /// Creates a new PSP-22 compatible Lake Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Lake\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MLAKE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "a5491b25aa9e5126fc02d187075dc473c27db7afb4b8448d9980c83860e7fc3f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-landslide/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-landslide/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-landslide\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Landslide'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "66a661ab746f273cc7f063a420748e6e156baa743fa5a5f91bd1289b51988688",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-landslide/README.md",
      "content": "# Landslide - Contract\n\nThis is a Landslide contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "2b1a0506c885f9e131a993e809d3e3b6f1aedb605cf42797596c421a7ec6ec74",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-landslide/src/Cargo.toml",
      "content": "[package]\nname = \"landslide\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "4b084e577ca2d85112ba44627016baf952cc787269ecf27e92af17652ee6d1bb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-landslide/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod landslide {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Landslide' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct LandslideContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for LandslideContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl LandslideContract {\n        /// Creates a new PSP-22 compatible Landslide Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Landslide\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MLANDSLIDE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "dbd40fc89bc4e0258d4889229af6c0882c9ac78b9e5e52533d8fe95ff23e96c7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lava-cave/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lava-cave/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-lava-cave\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Lava Cave'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "8fc394a9cbd942bd3b239ce5484a3a58b5eba497fc2973ea5251393a09caea09",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lava-cave/README.md",
      "content": "# Lava Cave - Contract\n\nThis is a Lava Cave contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "de539e688fcf9f6fcb4ecae55535683ed7aaa8ff35f48b3e6f5f1ec2dd26500e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lava-cave/src/Cargo.toml",
      "content": "[package]\nname = \"lava_cave\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "6d04b2d01c48b3a402504d4a2b4321f02c226086416ce83fc3d93b6d6379e0c5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lava-cave/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod lava_cave {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Lava Cave' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct LavaCaveContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for LavaCaveContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl LavaCaveContract {\n        /// Creates a new PSP-22 compatible Lava Cave Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Lava Cave\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MLAVA_CAVE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "fb02bd96e522e9a2eeb09732ae7cd6428cba01b3e5e36a35d3d104bb678661ae",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lava/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lava/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-lava\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Lava'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "e22ea3fe3e5226fddd95bbb6ab3ac26199365b1a7079beb9a17149034a5efe7f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lava/README.md",
      "content": "# Lava - Contract\n\nThis is a Lava contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "692aae091c4f83adbe2f763c0421a7b90597aeab349b35df84696a3b53e6683e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lava/src/Cargo.toml",
      "content": "[package]\nname = \"lava\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "cf4e4458d2d341a7314d99f5f2bb600b3ecfb6d3ec4a650d0f7dd203873364c7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lava/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod lava {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Lava' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct LavaContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for LavaContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl LavaContract {\n        /// Creates a new PSP-22 compatible Lava Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Lava\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MLAVA\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "924f50b020f00179abaf0f54b1f4689cb5a379a1eb012955808ddd5a26d76afa",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-leaves/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-leaves/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-leaves\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Leaves'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "a02d1783e7a8e7580d3686117661aad4c635948a4b3b3abf5410f31000268334",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-leaves/README.md",
      "content": "# Leaves - Contract\n\nThis is a Leaves contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "4060fed2253b0791883eb510600f8b3f82307d33409dc282d7ae397f95db4de1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-leaves/src/Cargo.toml",
      "content": "[package]\nname = \"leaves\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "2cbfb70a76f069b87f3b6545fa68daf71e1bcb4ec9973678370a8863120df941",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-leaves/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod leaves {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Leaves' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct LeavesContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for LeavesContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl LeavesContract {\n        /// Creates a new PSP-22 compatible Leaves Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Leaves\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MLEAVES\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "27963bb507caa432d17a00d6b0283b342837b5c64c3791c97420371d7b5d1593",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lightning/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lightning/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-lightning\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Lightning'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "0b4568b41383cf1f4b436fbcc6980b81f07205c5e3035151500a29bc6d7baaf8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lightning/README.md",
      "content": "# Lightning - Contract\n\nThis is a Lightning contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "cf6901976766cb931a8e00a10a04bdc6eda003f9519db768e5152f95fe483ff4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lightning/src/Cargo.toml",
      "content": "[package]\nname = \"lightning\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "6d6ee54c8c6e46b218231cda45c343a5b4ee4f59dba8d361713666af2cd35309",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lightning/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod lightning {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Lightning' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct LightningContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for LightningContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl LightningContract {\n        /// Creates a new PSP-22 compatible Lightning Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Lightning\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MLIGHTNING\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "a09e359beae3e7df7e018a54e1aaca325683757c6e7ab4e4737af07d1d1e7c97",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-limestone/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-limestone/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-limestone\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Limestone'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "02e30828f2cf74d8a5d7178fafaf00e38cd7f5672d3112b786a24440e5eae305",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-limestone/README.md",
      "content": "# Limestone - Contract\n\nThis is a Limestone contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "1381ffe88d8788e325868a0d933322be46701861fbe066fd93730876712bb22c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-limestone/src/Cargo.toml",
      "content": "[package]\nname = \"limestone\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "0c7c0668a23ff5da2e72b8626007c3d6053005f5af9825cdecc4e4783499a457",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-limestone/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod limestone {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Limestone' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct LimestoneContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for LimestoneContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl LimestoneContract {\n        /// Creates a new PSP-22 compatible Limestone Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Limestone\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MLIMESTONE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "586dbb0c7d0264db9690af360cc4c4017645a04e44d028a833a072e0a8be725f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lock/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lock/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-lock\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Lock'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "e71f4face98093d848aec0167212897a7201f7dbdb908474cab088641ca23116",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lock/README.md",
      "content": "# Lock - Contract\n\nThis is a Lock contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "97e2cdf1b9ddefa6f3f76a74ae5048a2bb5c30e507d9dc691db7a831272a1f04",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lock/src/Cargo.toml",
      "content": "[package]\nname = \"lock\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "c31f2a897a0978d62d065789d4f771b45818e06358e8118727c874b4434b12ef",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lock/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod lock {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Lock' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct LockContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for LockContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl LockContract {\n        /// Creates a new PSP-22 compatible Lock Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Lock\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MLOCK\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "762fcad080ea449dc8f5d8938548b3e69474e6392dcaf2f5a7ba19090244590a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-magma-chamber/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-magma-chamber/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-magma-chamber\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Magma Chamber'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "03935fef71764a1810b0bdfd1e1e2006f30069b01aa0c13da80b2a99016a935e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-magma-chamber/README.md",
      "content": "# Magma Chamber - Contract\n\nThis is a Magma Chamber contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "87c9e5155f8ba44b9a32ed3701833111cd205e77d4b2871b8877288120898fb9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-magma-chamber/src/Cargo.toml",
      "content": "[package]\nname = \"magma_chamber\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "05ceed7f7ea89f3d65d66b35363c8cf0fa8f954df7f7c1c339b07b591232122a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-magma-chamber/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod magma_chamber {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Magma Chamber' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct MagmaChamberContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for MagmaChamberContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl MagmaChamberContract {\n        /// Creates a new PSP-22 compatible Magma Chamber Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Magma Chamber\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MMAGMA_CHAMBER\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "49e9747d0a420aecb17fd19fa81ad143fe77613c65ecc2ecc0977bfe3db21ba0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-magma/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-magma/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-magma\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Magma'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "4e8f5b6f9979edfd3da725611a48db72c4afaa7eb635cb86e3ebdebfde609dca",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-magma/README.md",
      "content": "# Magma - Contract\n\nThis is a Magma contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "474679e6c51974264a034d56131b6713a0e0430b10ac86f15278d8812360e7d3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-magma/src/Cargo.toml",
      "content": "[package]\nname = \"magma\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "9d29f0307ddac5746a814043706209b27f5e2952a67fe95e98e84597a15b0e00",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-magma/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod magma {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Magma' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct MagmaContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for MagmaContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl MagmaContract {\n        /// Creates a new PSP-22 compatible Magma Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Magma\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MMAGMA\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "f5c8079e3b2e901daafa772e02b6157e098d65820b9d210c6f1418ef49e22a6e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-marmalade/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-marmalade/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-marmalade\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Marmalade'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "3327b1212b5a102bf1ccf62522ec1ca06606766d15cd1956d4fa359105f0bc89",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-marmalade/README.md",
      "content": "# Marmalade - Contract\n\nThis is a Marmalade contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "e2212a2d07aea142b29abfc5e594eb20b8d85fc2c413b556b7ab71b801a0bc86",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-marmalade/src/Cargo.toml",
      "content": "[package]\nname = \"marmalade\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "183944a233218611a90c6e110398a59bdf193992556d7331a39490d79c2ae9be",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-marmalade/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod marmalade {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Marmalade' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct MarmaladeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for MarmaladeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl MarmaladeContract {\n        /// Creates a new PSP-22 compatible Marmalade Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Marmalade\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MMARMALADE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "3b48dd0d6a151f3c6fcd8d3e397c4d90c174cd8384f4df59998e57f9d345cd04",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mirage/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mirage/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-mirage\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Mirage'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "a3a2da2efb69b52a7bf00904213da69359a2e92bf98a3ba8c1f91c689d8b21f9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mirage/README.md",
      "content": "# Mirage - Contract\n\nThis is a Mirage contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "bb28defbcdcb5f4ef84833bde0b34188f0d80f5d650c3e6673962a302afd2229",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mirage/src/Cargo.toml",
      "content": "[package]\nname = \"mirage\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "134c4d8d2267eb8ce3979f01364db894db6977f21e2d85bb89d94e7db9212d3f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mirage/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod mirage {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Mirage' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct MirageContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for MirageContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl MirageContract {\n        /// Creates a new PSP-22 compatible Mirage Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Mirage\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MMIRAGE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "3de971db6f452bc013eb736918518619e681f3e0ca657de5cd87171e9333fac4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mist/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mist/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-mist\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Mist'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "90e0ef922c7dce4044627ffcb4744e2bbf623c655bf3c53fbdee8836c4e0fced",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mist/README.md",
      "content": "# Mist - Contract\n\nThis is a Mist contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "3e0e203f3ee5c34431cb8385c126e8191f41b632c6a742ee0f9fca900d274d3d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mist/src/Cargo.toml",
      "content": "[package]\nname = \"mist\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "88e0470c34debdb973b148b34429f9826da0366923bb76ef29259f2765007ff3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mist/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod mist {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Mist' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct MistContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for MistContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl MistContract {\n        /// Creates a new PSP-22 compatible Mist Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Mist\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MMIST\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "53d3104a46c22e6c4c4115e47296891b338d02dbfbe795b8b0a24bb236527468",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-molten-glass/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-molten-glass/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-molten-glass\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Molten Glass'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "850532669ca8f6a48734c586229a9b52a0b51442ab1eb335b38394212ef00885",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-molten-glass/README.md",
      "content": "# Molten Glass - Contract\n\nThis is a Molten Glass contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "7d117878661bd538a92d6a8b4e289fc3d6b38d8ef5b5f1f1373e569c252cdf4e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-molten-glass/src/Cargo.toml",
      "content": "[package]\nname = \"molten_glass\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "8bc7b3d9d312d007f55ff1b16387b0a65db967ffc5d438218a8de32e9a55c8cb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-molten-glass/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod molten_glass {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Molten Glass' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct MoltenGlassContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for MoltenGlassContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl MoltenGlassContract {\n        /// Creates a new PSP-22 compatible Molten Glass Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Molten Glass\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MMOLTEN_GLASS\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "81f9183e779faaf41426876606e3377cd6b610c9423783c49c847e99c2e96163",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monkey-branch/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monkey-branch/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-monkey-branch\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'MonkeyBranch'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "eb787efb08b5fc8bc11996e01d17bec955550d8492f78250a384059252156cb0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monkey-branch/README.md",
      "content": "# MonkeyBranch - Contract\n\nThis is a MonkeyBranch contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "5e1f576f11911a96a603d73bf315812c43381903a7b86a00f1c7232ccfa7c5f4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monkey-branch/src/Cargo.toml",
      "content": "[package]\nname = \"monkey_branch\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "7000c0a534a43b8262b003e2e77f00c504293d5a11328f12d1833dac4add41b3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monkey-branch/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod monkey_branch {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'MonkeyBranch' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct MonkeyBranchContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for MonkeyBranchContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl MonkeyBranchContract {\n        /// Creates a new PSP-22 compatible Monkey Branch Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Monkey Branch\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MMONKEY_BRANCH\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "ed0fd02a3347786423250507fe073cc5c6fdd5ee2d856bb7c4b2f125f5402e5d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monkey/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monkey/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-monkey\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Monkey'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "de14ebeaea51e73d0f1747dcee917bc533e3ea4a72ec5a723216ab77b5c8ff0d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monkey/README.md",
      "content": "# Monkey - Contract\n\nThis is a Monkey contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "0fe44480ded17f5789b1971f83f2f32ddc380bb8d46300682eb8afbae74c3462",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monkey/src/Cargo.toml",
      "content": "[package]\nname = \"monkey\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "7f6f7dabf709af47b4eb4a27d330ee0dfd4dabd8cfe0896733088724015c9c92",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monkey/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod monkey {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Monkey' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct MonkeyContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for MonkeyContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl MonkeyContract {\n        /// Creates a new PSP-22 compatible Monkey Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Monkey\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MMONKEY\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "c61a23b45a84087b3389cc01e039cd04a59ef2d3aec7bf670ee1ca6b366b7c6e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monument/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monument/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-monument\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Monument'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "66c1aac49506005745cb6c414cb560569ec631ebf7aafa129585906b85920989",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monument/README.md",
      "content": "# Monument - Contract\n\nThis is a Monument contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "438c37e9fec54264d9f3b7ab22373d1be7455a8797aebca04bf68d3b162364dd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monument/src/Cargo.toml",
      "content": "[package]\nname = \"monument\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "4b46787f6964624a51af35d6b6b41053eb9e90bbc101ec9154daa195b6d3b355",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-monument/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod monument {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Monument' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct MonumentContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for MonumentContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl MonumentContract {\n        /// Creates a new PSP-22 compatible Monument Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Monument\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MMONUMENT\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "3ff985955cd88e182cd6670876c5e56ed3886f5482419cb85ddc7cf4a9046ea1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mountain/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mountain/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-mountain\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Mountain'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "5c837a7249f1fe8862ae72c9ebb0e22d8ce0c251c2a8c8112242ff831433daaf",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mountain/README.md",
      "content": "# Mountain - Contract\n\nThis is a Mountain contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "81e6d587b395f00cb6ffbe68fcd8298f2961af99bfc12e31dd8dd84633d1074b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mountain/src/Cargo.toml",
      "content": "[package]\nname = \"mountain\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "ba1dfb92e112a15dec343311bc6664dcdef79c24a109a7c4ea1e16926f980909",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mountain/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod mountain {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Mountain' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct MountainContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for MountainContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl MountainContract {\n        /// Creates a new PSP-22 compatible Mountain Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Mountain\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MMOUNTAIN\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "a1ffa3ef35daaf7281a78bd1975afff70c2cc54702a932f1d292fa145f68312f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mud/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mud/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-mud\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Mud'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "8649315c55e2cbca95b6f1d5efaa3e0b73a01271cac91bdacc3def3c574e1a92",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mud/README.md",
      "content": "# Mud - Contract\n\nThis is a Mud contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "fdcf7bc71bc649a720764584cc21f0988571d95ac631c9b6c2d203466a4f7673",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mud/src/Cargo.toml",
      "content": "[package]\nname = \"mud\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "3393acac1721fa1045c89a239378c7054be7c2198788e3589bc575aa4f4174ae",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-mud/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod mud {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Mud' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct MudContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for MudContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl MudContract {\n        /// Creates a new PSP-22 compatible Mud Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Mud\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MMUD\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "c7ba72a2daf00ff560998b6e0f8f5b1c6845a66d2811adde55c82871da37c6f5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-murmur/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-murmur/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-murmur\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Murmur'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "caded0c52b8fe56dc272fe38f5c770171def41d89bf5f717c7680faf9333337f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-murmur/README.md",
      "content": "# Murmur - Contract\n\nThis is a Murmur contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "4b078686b61a85b99e5a215d3e17e8c9b7b5c5ad2bb8f5fe92371173fb4e6309",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-murmur/src/Cargo.toml",
      "content": "[package]\nname = \"murmur\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "798ac8618135583d092da0c7eee1e592848bf93f1f880adec1d475b6752c7f12",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-murmur/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod murmur {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Murmur' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct MurmurContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for MurmurContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl MurmurContract {\n        /// Creates a new PSP-22 compatible Murmur Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Murmur\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MMURMUR\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "ae4b60d888b82fe65fa077186779cea701e25e16fb950c28d09365ea75d5c9ef",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-oasis/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-oasis/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-oasis\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Oasis'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "3fd028e2987f766dbe75ad5468c3fca48591e9fd99d447b8e6b50892fb882682",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-oasis/README.md",
      "content": "# Oasis - Contract\n\nThis is a Oasis contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "dbebcf29f3ef3ebab9b4f26e7fbb49a0e90acb4c886250727ed148df04b1ccb6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-oasis/src/Cargo.toml",
      "content": "[package]\nname = \"oasis\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "de7726263abf74cef42bdd24d5881446092b9e0822ee6ae3e2c50194e8b282a5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-oasis/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod oasis {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Oasis' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct OasisContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for OasisContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl OasisContract {\n        /// Creates a new PSP-22 compatible Oasis Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Oasis\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MOASIS\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "db24ce35ced16bdd9c92545ec60189c37a0938abf2d6dcd81c3df95acb34f130",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-obsidian/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-obsidian/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-obsidian\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Obsidian'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "166128a2cad1988f2b9af0473340168439a2c2d8ef808adf766e949a24712c20",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-obsidian/README.md",
      "content": "# Obsidian - Contract\n\nThis is a Obsidian contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "48d53bc8ec4da135f944d67b60f4423d5fa86c60a41a694b0016a728189afc42",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-obsidian/src/Cargo.toml",
      "content": "[package]\nname = \"obsidian\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "7ad5bd97024acf415d02426602f8da03db61fad651b282961e1df1fdb39f8543",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-obsidian/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod obsidian {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Obsidian' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct ObsidianContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for ObsidianContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl ObsidianContract {\n        /// Creates a new PSP-22 compatible Obsidian Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Obsidian\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MOBSIDIAN\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "2211c619fc6a57108d187203a53b331edcb05efc97a7eb5861ddbc2072d92995",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-parched-earth/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-parched-earth/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-parched-earth\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Parched Earth'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "ea4748c800a35abb1c15d14f75502163955d0be61f6abccb69d2ca48cb4add6b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-parched-earth/README.md",
      "content": "# Parched Earth - Contract\n\nThis is a Parched Earth contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "cf5cc0279b55d0ba30223ea9e930398e5c405fa6dc9450b9424ae08c23b05060",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-parched-earth/src/Cargo.toml",
      "content": "[package]\nname = \"parched_earth\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "fa07f997fbc2e5c13481ff1db57d2d58fef91444e28681f31a8d0cf2633d9f18",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-parched-earth/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod parched_earth {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Parched Earth' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct ParchedEarthContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for ParchedEarthContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl ParchedEarthContract {\n        /// Creates a new PSP-22 compatible Parched Earth Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Parched Earth\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MPARCHED_EARTH\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "018e3ba1c2354732c0df7ad10a8cda6712f8f00d22aae239a57899dfb837435e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-peat/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-peat/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-peat\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Peat'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "f28d3c6d259fee14a92ea9516ffa2cefcad615459e4cf8dc9177910bd131c3c5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-peat/README.md",
      "content": "# Peat - Contract\n\nThis is a Peat contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "1b7f21ac428c75d4977784877636b700a73d85510c94b3f6c3ae7170f6d9e659",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-peat/src/Cargo.toml",
      "content": "[package]\nname = \"peat\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "3829bad603bff40546e2a01c45e13372a925355637a886236d4d3c7b128463fa",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-peat/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod peat {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Peat' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct PeatContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for PeatContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl PeatContract {\n        /// Creates a new PSP-22 compatible Peat Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Peat\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MPEAT\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "285c92022507cdf6997654c2748cc92871004671c2d5eddb75dcfc6354e7b111",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pebble/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pebble/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-pebble\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Pebble'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "8006e8b6726ef3fac55dade6021ca8973fb33e9bb3b36955c95e20972f095734",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pebble/README.md",
      "content": "# Pebble - Contract\n\nThis is a Pebble contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "124039991c5ec919006bbc4fc7cb2999e799584d1a788dda78367f70da96888b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pebble/src/Cargo.toml",
      "content": "[package]\nname = \"pebble\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "4a91c1eed70cbaa330a1f11993392610fb86e540ecb52cc90a9e47d8d8b4db75",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pebble/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod pebble {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Pebble' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct PebbleContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for PebbleContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl PebbleContract {\n        /// Creates a new PSP-22 compatible Pebble Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Pebble\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MPEBBLE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "8aa65748e0f9ea1e36f194c9c08dd1fdd7f6a2756acd5ce040dfd4ae839f3071",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-peer-review/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-peer-review/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-peer-review\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'PeerReview'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "4f32783a421fe39c823946001632ce16944ee59eac0309737d5c084560c796b1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-peer-review/README.md",
      "content": "# PeerReview - Contract\n\nThis is a PeerReview contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "ed19b9c3427d248e4eee1a77c43607a2317d9ded59c7fc7cfb440e1f73e7ac0c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-peer-review/src/Cargo.toml",
      "content": "[package]\nname = \"peer_review\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "d6979f10e0b8b3d93bcd4ad72a74ecb5f9679af23d008c1b81921ff749680dad",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-peer-review/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod peer_review {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'PeerReview' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct PeerReviewContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for PeerReviewContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl PeerReviewContract {\n        /// Creates a new PSP-22 compatible Peer Review Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Peer Review\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MPEER_REVIEW\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "8bf2a8521b9992f770255b4837641cfbae5aff1b43b8e5fca0dc6683195b73f4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pillar-of-wind/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pillar-of-wind/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-pillar-of-wind\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Pillar of Wind'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "0a419e7dffcf714caf27204e721a87b675954c0ec6585b1a26c85eb645aba3e3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pillar-of-wind/README.md",
      "content": "# Pillar of Wind - Contract\n\nThis is a Pillar of Wind contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "cfa3dec18a6dfc2ba71ed31959210401a8ed52b1ebfe8e2002338e007340963c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pillar-of-wind/src/Cargo.toml",
      "content": "[package]\nname = \"pillar_of_wind\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "e69b476c39a721f2151eb67ed06921a8c526a9aad1cbc30901f253c3c7acd57d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pillar-of-wind/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod pillar_of_wind {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Pillar of Wind' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct PillarOfWindContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for PillarOfWindContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl PillarOfWindContract {\n        /// Creates a new PSP-22 compatible Pillar Of Wind Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Pillar Of Wind\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MPILLAR_OF_WIND\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "9ab38f922a7c58264e6081dea254a3eccd51c6aba27fd8524d397040f2135e4b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-plant/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-plant/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-plant\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Plant'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "93ed7bec61543e84af1e505055a2c01227c05fc7f2e5461e05460e892e1aed41",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-plant/README.md",
      "content": "# Plant - Contract\n\nThis is a Plant contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "6db0f6cbdbcc919abad35c441e0d8cd1ecd105a13d3f7cd3374ff1406ab3cc35",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-plant/src/Cargo.toml",
      "content": "[package]\nname = \"plant\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "496b9d845acc9df18699bd4e2fb3dda6028eb8b409b5c0478196c263b55cd7fc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-plant/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod plant {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Plant' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct PlantContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for PlantContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl PlantContract {\n        /// Creates a new PSP-22 compatible Plant Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Plant\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MPLANT\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "86f7836940c5d750bcd8013fb12ea0debd513c311166e9c9fa107b9ef3a2c434",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-plateau/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-plateau/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-plateau\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Plateau'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "3437b02c35e78227c7de3a60d547930fc5d88a8cbd47d673b68a19d0000ca07f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-plateau/README.md",
      "content": "# Plateau - Contract\n\nThis is a Plateau contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "fadaedff4082a32e699ca70c42b53278d004385883c14dfd0617280d9198e831",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-plateau/src/Cargo.toml",
      "content": "[package]\nname = \"plateau\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "35beb48a18656795a5de3129cec25cc51a747f28db300818abdaa1f95666e8fe",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-plateau/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod plateau {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Plateau' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct PlateauContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for PlateauContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl PlateauContract {\n        /// Creates a new PSP-22 compatible Plateau Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Plateau\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MPLATEAU\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "9d54e65d493d7fa9accf429a9c1010348e2ebf0b819c1f051917fa9978d55927",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-polkadot/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-polkadot/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-polkadot\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Polkadot'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "cd9d8d09b5e590980bf26d85a3731eb15ff8f0bceefe5932c807b244c8f9d207",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-polkadot/README.md",
      "content": "# Polkadot - Contract\n\nThis is a Polkadot contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "9b0fa293dc49386b4cfa6be13f796490255812517a493d54d3df339e251f5fbf",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-polkadot/src/Cargo.toml",
      "content": "[package]\nname = \"polkadot\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "4a2d079862b27c896f4a4be1ef2577e4b00e21b7a5e03ba2d92ca853d495cf3a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-polkadot/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod polkadot {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Polkadot' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct PolkadotContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for PolkadotContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl PolkadotContract {\n        /// Creates a new PSP-22 compatible Polkadot Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Polkadot\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MPOLKADOT\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "417a9d721c82f963d8a402427273d2d39ed5850c01429d1866b15f1c4147a42b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pollination/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pollination/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-pollination\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Pollination'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "28d7e1c2382088aa5adb545c7683e90d52f0ff5fde5354c1f6e0765b7e86e853",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pollination/README.md",
      "content": "# Pollination - Contract\n\nThis is a Pollination contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "60993a23b384d3b18af98a44f4fb26a97deea53211dfbb8f2441f237624c5ba7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pollination/src/Cargo.toml",
      "content": "[package]\nname = \"pollination\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "a0d281b9d3e6be84a7b6a579b81d23b879d3a6263525ba16ee441398fb12b22d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pollination/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod pollination {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Pollination' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct PollinationContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for PollinationContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl PollinationContract {\n        /// Creates a new PSP-22 compatible Pollination Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Pollination\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MPOLLINATION\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "3a066316752d89c8bcc9603c69e38c053a93e1ac421216839868638b6576297b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pond/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pond/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-pond\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Pond'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "b1decedf4161362c538fc7fa087d35134546d14fa9b3cb9157e97df8f4ffb927",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pond/README.md",
      "content": "# Pond - Contract\n\nThis is a Pond contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "0801fe4beb8532a52252cbbf6e8c833615bca5c4c8327bb0b5dd332682181959",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pond/src/Cargo.toml",
      "content": "[package]\nname = \"pond\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "0003370bf4eb7beb33234f717f1b15645608ac92df7e12b13eaf8f0e1e41241b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pond/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod pond {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Pond' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct PondContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for PondContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl PondContract {\n        /// Creates a new PSP-22 compatible Pond Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Pond\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MPOND\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "1d0ca702d6dfedef412cae657f47d9e567ac83f928ffbe3860c4486e69d97db4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pottery/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pottery/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-pottery\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Pottery'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "8fa9702c7066aa76228fbed46378da174b49fdadf137c7acdd385eee1a02550a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pottery/README.md",
      "content": "# Pottery - Contract\n\nThis is a Pottery contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "7761a3e2e27ea5ca10b633384ef5b0ce8ea89cd13e50fc357d2d9c8ca19ab8a8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pottery/src/Cargo.toml",
      "content": "[package]\nname = \"pottery\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "e899502c5f7fb86cd9a00ec368b80a6774c0b20c8bca1c0430319f26d353e179",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pottery/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod pottery {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Pottery' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct PotteryContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for PotteryContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl PotteryContract {\n        /// Creates a new PSP-22 compatible Pottery Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Pottery\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MPOTTERY\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "020b68d596e1f6e02f7459761183552938d9bc78c2fc9af59b34f60787f110fc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-prism/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-prism/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-prism\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Prism'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "57b9ddf861e29bfde74c5dd853bdc30ffcdfd185efd12716ff6136edaecf8c0e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-prism/README.md",
      "content": "# Prism - Contract\n\nThis is a Prism contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "8c2b3b56e383ad85cf57d43480a2666b1b2f87014991817ccaa3bf517e8ce214",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-prism/src/Cargo.toml",
      "content": "[package]\nname = \"prism\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "cc8e9f969c197fb3bfdcd0d7124c55ce32df54837b016b8b46f4806968620337",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-prism/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod prism {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Prism' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct PrismContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for PrismContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl PrismContract {\n        /// Creates a new PSP-22 compatible Prism Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Prism\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MPRISM\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "6cfd8fc3e67de0d0bf25cb9621e7004f306449f1dbe769d0de135fdffe48d77e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pumice/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pumice/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-pumice\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Pumice'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "a414769fbe3997c73b617c4222ca251bb5c2cc92548958f467ce46665eb56b7b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pumice/README.md",
      "content": "# Pumice - Contract\n\nThis is a Pumice contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "42c6de0bfefbf1c9577bbbd44248bad0d0ade0a770baf9d5fde725040457db63",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pumice/src/Cargo.toml",
      "content": "[package]\nname = \"pumice\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "3fe60e6a480f1b2c9c25f65cb4176bf9ce802b9fd257f1b939c3cc3f53400544",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-pumice/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod pumice {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Pumice' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct PumiceContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for PumiceContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl PumiceContract {\n        /// Creates a new PSP-22 compatible Pumice Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Pumice\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MPUMICE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "35e155370b7b888b2b9ef08eb84b5f1a2e3ad6aa61572fd217f9674598bef4c0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-quicklime/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-quicklime/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-quicklime\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Quicklime'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "867b990175da7156606e675b4516cdad45aaa3c90c9b4f3bf4dab0e18bdb38d9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-quicklime/README.md",
      "content": "# Quicklime - Contract\n\nThis is a Quicklime contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "c54d72679cdb18e873c628fa7c083a06b52250f55ca5c91faa8decdc8d7fcddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-quicklime/src/Cargo.toml",
      "content": "[package]\nname = \"quicklime\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "619a28f9e7e74d9a9aab3dad62a7cbd7ee3942d70ec43e1bb28960f832358f35",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-quicklime/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod quicklime {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Quicklime' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct QuicklimeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for QuicklimeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl QuicklimeContract {\n        /// Creates a new PSP-22 compatible Quicklime Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Quicklime\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MQUICKLIME\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "bc3390dcc7a9ef5a59110235b90abf2c7a029501817547f22f4b5211a4cbb957",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-quicksand/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-quicksand/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-quicksand\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Quicksand'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "466c31d4f034faf80754a7a441a7d6f5dcf5c889a24fb62484547894bcd9d67d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-quicksand/README.md",
      "content": "# Quicksand - Contract\n\nThis is a Quicksand contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "a9b1a462d50451b119517aacc1c7045364275546b111dd3baa9709a070e1e671",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-quicksand/src/Cargo.toml",
      "content": "[package]\nname = \"quicksand\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "e7534ee5aa3a149aa8c5ba94c4c8a38607b9988913f478181acf34ab8aca7499",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-quicksand/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod quicksand {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Quicksand' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct QuicksandContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for QuicksandContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl QuicksandContract {\n        /// Creates a new PSP-22 compatible Quicksand Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Quicksand\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MQUICKSAND\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "5ed24d0385e9dc0729577640a40ccdf942130d4330bd79506c5a39dd2fe00cc4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rain/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rain/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-rain\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Rain'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "363cf550441fc65a9ba3796cf2958d58166bf7bb832027d47c7eb4e95f9f0ae3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rain/README.md",
      "content": "# Rain - Contract\n\nThis is a Rain contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "c097c481b98d68650d65b7fc9c635e0d6de5e040df3fc9790acec5cde0f6ad99",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rain/src/Cargo.toml",
      "content": "[package]\nname = \"rain\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "e74497e05235cbf693bb091e20265d98cc8b107a0d8f1f0c113262fa258eb93a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rain/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod rain {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Rain' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct RainContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for RainContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl RainContract {\n        /// Creates a new PSP-22 compatible Rain Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Rain\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MRAIN\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "e3c998eedfbe270a65a95235a92a12d0bcd8afcdef5c4aec9fcb3ccd8e7d2058",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rainbow/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rainbow/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-rainbow\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Rainbow'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "23ebe835588c09b30ccab76e941584f1895eedf5356c02690dd1640060c08b05",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rainbow/README.md",
      "content": "# Rainbow - Contract\n\nThis is a Rainbow contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "7f66f56b0d6dedbd973edc173a85ac4f666f6d1cfa260e7f685e66abaf7d1d89",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rainbow/src/Cargo.toml",
      "content": "[package]\nname = \"rainbow\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "d4f5a8d8b99773525f6a9c669477435fe7415838f4cf057a1c61a00cc4532f1a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rainbow/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod rainbow {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Rainbow' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct RainbowContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for RainbowContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl RainbowContract {\n        /// Creates a new PSP-22 compatible Rainbow Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Rainbow\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MRAINBOW\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "7f246c29ebfd72d008d616488d55c48f2d413d1f5108a7ed394f279d68d36043",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-ravine/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-ravine/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-ravine\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Ravine'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "d2eef133b9a6ab94b3788f9c426c1e9e9436205637bb1267524aa3ac3b6abc46",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-ravine/README.md",
      "content": "# Ravine - Contract\n\nThis is a Ravine contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "6db45db698ce647cdc39bd50dc1ac7e7cc2ce5a9fd0e305d6100ad2f600a742c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-ravine/src/Cargo.toml",
      "content": "[package]\nname = \"ravine\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "03d3bff529fd6335320f90a3e7d13d9e7866b345f980de0a26bad66459566282",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-ravine/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod ravine {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Ravine' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct RavineContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for RavineContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl RavineContract {\n        /// Creates a new PSP-22 compatible Ravine Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Ravine\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MRAVINE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "865b78ddcc716451c5e2c039b36f030cce395200914b890c317a5aea057ffe31",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-reeds/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-reeds/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-reeds\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Reeds'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "e5e51656102750bf22b5bc3238a3a42b15139752efc7c26b007613df5e9eee51",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-reeds/README.md",
      "content": "# Reeds - Contract\n\nThis is a Reeds contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "7c45b20bbdde52c7132dc1a7aa1e8c7c5a98f62fd6d1d8bd98f8197f2f9492b8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-reeds/src/Cargo.toml",
      "content": "[package]\nname = \"reeds\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "ff3aea8e69a2fe0e190071d4cdb88eac84b507d486ccbcba973c91c54d73d021",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-reeds/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod reeds {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Reeds' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct ReedsContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for ReedsContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl ReedsContract {\n        /// Creates a new PSP-22 compatible Reeds Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Reeds\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MREEDS\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "a4e1900244120476e85fbe66ba48685c9cf02770ba678c35ce2276bf7f2e7da6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-reef/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-reef/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-reef\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Reef'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "1f8d077eabd626e423db0e1fc5b3b35070bd8972b3dd58414944f0d7a0ca3e7b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-reef/README.md",
      "content": "# Reef - Contract\n\nThis is a Reef contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "cd007cf5ff74c5c70e3647ec404196da7e28282d3a1bd87aaae5cc9f7d22519d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-reef/src/Cargo.toml",
      "content": "[package]\nname = \"reef\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "b9b1777286967db71015acafa732d10b6782f09eb7686fd19eb9ebdc00ddd26c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-reef/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod reef {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Reef' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct ReefContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for ReefContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl ReefContract {\n        /// Creates a new PSP-22 compatible Reef Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Reef\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MREEF\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "3ee3f9c72125adcb19235e78d123ab153250ecf00f9c8aa7dde3ec1e24eccc7c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-reservoir/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-reservoir/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-reservoir\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Reservoir'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "c66c0391d68afb25e1d8277279782421ab2d32d0dc11b7ec15e6e70476aefd6f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-reservoir/README.md",
      "content": "# Reservoir - Contract\n\nThis is a Reservoir contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "215152b75a95b4c2a869c2e4864da9f8b38b66b777093b8704dd675b347c9ac8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-reservoir/src/Cargo.toml",
      "content": "[package]\nname = \"reservoir\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "131ee7e313ef0262ffc2152c1d589f3235c38d9982140d68240bc302671d4b36",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-reservoir/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod reservoir {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Reservoir' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct ReservoirContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for ReservoirContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl ReservoirContract {\n        /// Creates a new PSP-22 compatible Reservoir Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Reservoir\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MRESERVOIR\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "bba78e1c1c229308c2d614e7125d19f78a6609a6ac96fb95b648dc88643c1e5d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rhodium/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rhodium/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-rhodium\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Rhodium'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "a57bffc26e2a9520d4d747f8e9fabc068aef6311f8903aef05e05df1e127bb3c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rhodium/README.md",
      "content": "# Rhodium - Contract\n\nThis is a Rhodium contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "d2a98c179a3e4fb60c62738edd955f8f680ed3b673d6f2682ff4d3f9653ad832",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rhodium/src/Cargo.toml",
      "content": "[package]\nname = \"rhodium\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "414c27a3b895c0eb8b7988bc34570a47f14b7ddeaa8dbaa568a0aa7aa6719880",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rhodium/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod rhodium {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Rhodium' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct RhodiumContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for RhodiumContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl RhodiumContract {\n        /// Creates a new PSP-22 compatible Rhodium Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Rhodium\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MRHODIUM\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "eea946d93632fa8112601b0879b9cd9f757cdc8093b7d694f8fe36bacb73369e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-river/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-river/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-river\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'River'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "0db6909803e88df190634d8be968ab4fb92cf95605c1135ab63a6de2cd0765dc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-river/README.md",
      "content": "# River - Contract\n\nThis is a River contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "ac887ec03659acc7adfa8794e382b0664329870f4564bed3cd2971babaeefd55",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-river/src/Cargo.toml",
      "content": "[package]\nname = \"river\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "89ffddc9b0b9a177d538830c5451a6d928addc8b2aa0c2b0d29ac7073d7a0bc8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-river/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod river {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'River' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct RiverContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for RiverContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl RiverContract {\n        /// Creates a new PSP-22 compatible River Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"River\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MRIVER\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "d65ed742c321852a061855f40066d7dfa13d65e1edefb01c11c46cb8ccb3ccc9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-riverbank/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-riverbank/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-riverbank\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Riverbank'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "c94adc6fef36335e1b0d5574fcf0152fdaf1df74bddac04a9f0f376a0b3fe7f0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-riverbank/README.md",
      "content": "# Riverbank - Contract\n\nThis is a Riverbank contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "216c84b51f5d310ffe7221c5dbc0818d9aa9c2a06d83de2930a95c208e269860",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-riverbank/src/Cargo.toml",
      "content": "[package]\nname = \"riverbank\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "0b7db53ebcef5711efd7beb4e1f47b828aaf522817826afcfcd124387a5ba10b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-riverbank/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod riverbank {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Riverbank' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct RiverbankContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for RiverbankContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl RiverbankContract {\n        /// Creates a new PSP-22 compatible Riverbank Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Riverbank\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MRIVERBANK\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "d13b4d9f56d0143e85b2100980b7ed5ffc05248bb8bb38d7d7b42e5b5523e1af",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rivulet/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rivulet/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-rivulet\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Rivulet'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "7f7d6cc92c61c0966f83a3a53a23579cdaa0adba6313c9d703f576d728a54f42",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rivulet/README.md",
      "content": "# Rivulet - Contract\n\nThis is a Rivulet contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "77debbc06d8d329412ac38952c8e315032bac45e1def7bef9479a333a3869e73",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rivulet/src/Cargo.toml",
      "content": "[package]\nname = \"rivulet\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "395eee590eeb89aa69c33051992597f4b03ec45c412c1d921d9e41f96ed3ba48",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rivulet/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod rivulet {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Rivulet' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct RivuletContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for RivuletContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl RivuletContract {\n        /// Creates a new PSP-22 compatible Rivulet Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Rivulet\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MRIVULET\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "b78007eafe4ff27709fb3b8f7e132b2127ce89c8292a0d21e9332c2ff1fc2ceb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rock/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rock/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-rock\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Rock'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "9ab5e2cd0b2016481be9fb903bbac70ab5c68b970ea155ccb2a7aaae1204fda4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rock/README.md",
      "content": "# Rock - Contract\n\nThis is a Rock contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "93dd228667a4e2f99e944fe5a927fa9530da5400b3a9c7f5a5ecd33767901d33",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rock/src/Cargo.toml",
      "content": "[package]\nname = \"rock\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "e7336f55fb90e57fb7673f000fc0f5b81c9bdbc241d44e85e60642aef027d889",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-rock/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod rock {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Rock' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct RockContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for RockContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl RockContract {\n        /// Creates a new PSP-22 compatible Rock Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Rock\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MROCK\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "686c3ca7bd3c520977aef76d5e450a96f4d94632d487ebee7ca66987ea662005",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sand-dune/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sand-dune/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-sand-dune\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Sand Dune'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "4c0661ccdf79c5c72cb70f6c53a954ed20fd455528987e15aa09e71819da0147",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sand-dune/README.md",
      "content": "# Sand Dune - Contract\n\nThis is a Sand Dune contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "e0bb40bf34f0786fdd9595ce1f9805da4feb94ebc96517d6fe405da96b10b8ce",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sand-dune/src/Cargo.toml",
      "content": "[package]\nname = \"sand_dune\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "3c73e08b388a3b05f4c7ae9e398aa2fa8bcf7e68e7266a6e6d82addfa97051fc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sand-dune/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod sand_dune {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Sand Dune' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SandDuneContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SandDuneContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SandDuneContract {\n        /// Creates a new PSP-22 compatible Sand Dune Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Sand Dune\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSAND_DUNE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "6abc4436209ecd1dace6147dfc4bb6b7e77ffe8f244647cb9e843c11c6afba46",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sand/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sand/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-sand\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Sand'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "f12de0aeaa01bd320fc46631b1dc420227fdac50677022ca84a8b2403a412ece",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sand/README.md",
      "content": "# Sand - Contract\n\nThis is a Sand contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "3bfb9259f411860223cfb632b42f6ec907cc37ce8095bcd4ac6f14bf5bf05bbf",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sand/src/Cargo.toml",
      "content": "[package]\nname = \"sand\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "ef44ce780b292d99976fc89b51e70acff6e8efbc62ef2b63f522d61b7d8ed42a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sand/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod sand {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Sand' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SandContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SandContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SandContract {\n        /// Creates a new PSP-22 compatible Sand Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Sand\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSAND\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "f14356b65c7f601e50a7f8862d3dae68846632cab4ea4683702033d5139c2c14",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sandstorm/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sandstorm/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-sandstorm\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Sandstorm'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "4105554f6160e1f7f6018bd1191fa500eaeb01c183908b23cb0c0b89fdee70d2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sandstorm/README.md",
      "content": "# Sandstorm - Contract\n\nThis is a Sandstorm contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "6d9433e9724c47b546459a812a80da45945d0628d8790850e1b80e7960f1c1ab",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sandstorm/src/Cargo.toml",
      "content": "[package]\nname = \"sandstorm\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "2b788b2d48e6f5e4501d4e972ce42a391cfd9ae6b4b9ce738faaf8f22348d706",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sandstorm/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod sandstorm {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Sandstorm' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SandstormContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SandstormContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SandstormContract {\n        /// Creates a new PSP-22 compatible Sandstorm Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Sandstorm\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSANDSTORM\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "3f6a80f3b628c89e8c2e810322de25234c9fbbe023fccba9bba672e77da915b8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-scorched-earth/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-scorched-earth/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-scorched-earth\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Scorched Earth'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "2c7eb9da0207b820d0840bcd71198db12c8894aad514fdaffab5b78741508d84",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-scorched-earth/README.md",
      "content": "# Scorched Earth - Contract\n\nThis is a Scorched Earth contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "bc13b3e6fcce5a462190972f50bffa47e6661d43bfac393140fd6c7fb9c08708",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-scorched-earth/src/Cargo.toml",
      "content": "[package]\nname = \"scorched_earth\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "4acde9f5cc434948b9806f79ed7694a2b0214b52e27ef764bcefdf38181c0fdc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-scorched-earth/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod scorched_earth {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Scorched Earth' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct ScorchedEarthContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for ScorchedEarthContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl ScorchedEarthContract {\n        /// Creates a new PSP-22 compatible Scorched Earth Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Scorched Earth\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSCORCHED_EARTH\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "2172ad10936c0ead8c0ca955c1173b0e34a14ecab368b9dfe54c95152056df38",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-seeds/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-seeds/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-seeds\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Seeds'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "1021f92e83fbabd1ce54cb0d9a3df5c437d06a02754e4357a12221a332c42732",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-seeds/README.md",
      "content": "# Seeds - Contract\n\nThis is a Seeds contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "42281317b303984ab177c311eb3da4937fca362587a701cb1f442e32885a1eec",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-seeds/src/Cargo.toml",
      "content": "[package]\nname = \"seeds\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "7702755fb3030a1c892b087ea9600e7aec71fa36e331eb86d065b0e39d745207",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-seeds/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod seeds {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Seeds' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SeedsContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SeedsContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SeedsContract {\n        /// Creates a new PSP-22 compatible Seeds Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Seeds\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSEEDS\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "d51878a268ec2f9ca3d6586509dacc9197906ca9278a3f1315a9953e40be489b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-shard/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-shard/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-shard\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Shard'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "b849a7da64ee26d99625d563be639f890323369a3d0fa7089e917b2d1a307373",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-shard/README.md",
      "content": "# Shard - Contract\n\nThis is a Shard contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "c22f9dd78fa669361e0b696012cf591323ec49cae280e1e68c24e854e1620524",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-shard/src/Cargo.toml",
      "content": "[package]\nname = \"shard\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "0dd98ad00a4e34d37c4d42eeac3ee09f8a18c63ca5e3dd6c0cc1c9a8c4f9aa23",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-shard/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod shard {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Shard' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct ShardContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for ShardContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl ShardContract {\n        /// Creates a new PSP-22 compatible Shard Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Shard\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSHARD\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "eb3e552f96c3eaea41c6d92db0ea41fc0e058edbd001f4e4e295a341f3a2acb9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-shards/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-shards/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-shards\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Shards'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "9dd9f34b85fa37fd2c9f6231d1def42b6482623c88ff6c6691d61d557910101e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-shards/README.md",
      "content": "# Shards - Contract\n\nThis is a Shards contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "5f544b9f81183fdd634d29f39e351931602470212f0c9d121adab5828ca4dd61",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-shards/src/Cargo.toml",
      "content": "[package]\nname = \"shards\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "352d289fe63dc4a9d4ebdb0e97a071efc08285b766fe20ada8cb22f3456a6f30",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-shards/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod shards {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Shards' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct ShardsContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for ShardsContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl ShardsContract {\n        /// Creates a new PSP-22 compatible Shards Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Shards\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSHARDS\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "25d05c6a22cbb87c9b68339f5e4a7508a8d8db3c3557fe05f124bf10cc2c1f0f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-silver/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-silver/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-silver\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Silver'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "6e2dc39f3f1b81b1564e86d365de304326de8538b07d469f1700076fad8c3dc2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-silver/README.md",
      "content": "# Silver - Contract\n\nThis is a Silver contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "36d6a2d5374bde49dff6544ba9e5153176d7e8057e81e4b4f2aa4ef0369fd04d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-silver/src/Cargo.toml",
      "content": "[package]\nname = \"silver\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "1ee2ed8aa6a8e3b8e0d946fcc2163cd36eb1f5e3fdb951f2a62f5a97f52ccf8d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-silver/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod silver {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Silver' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SilverContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SilverContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SilverContract {\n        /// Creates a new PSP-22 compatible Silver Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Silver\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSILVER\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "e9c3798061df660990fdb101970902e4351570120a3ab9758b94fd6ed9f077fe",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sinkhole/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sinkhole/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-sinkhole\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Sinkhole'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "1597ff7b0a11573c904d652666ae7b4c7231898b6b7e233c60b548f0f61bb06c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sinkhole/README.md",
      "content": "# Sinkhole - Contract\n\nThis is a Sinkhole contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "990e6d39a8b5515d592119fffe8e032e110064ce98ef28f5b55624c761737f77",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sinkhole/src/Cargo.toml",
      "content": "[package]\nname = \"sinkhole\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "3a411bb017c367c3296bddcb8b79d329e7eb5936f341b498ea53fe02351b0eaa",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sinkhole/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod sinkhole {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Sinkhole' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SinkholeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SinkholeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SinkholeContract {\n        /// Creates a new PSP-22 compatible Sinkhole Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Sinkhole\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSINKHOLE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "99a13628815bb2526e2e516bec7aee8472914dd77cf09f995525bf1dc493e0c0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-smoke/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-smoke/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-smoke\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Smoke'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "407a463dec69ed67f914e61ba93433b02fb50cc2cd40acd4fa1ccd2ae9958e53",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-smoke/README.md",
      "content": "# Smoke - Contract\n\nThis is a Smoke contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "2d9fb7ea586981d62f849c11a3ea968cefcf067833bcb69e37a1334d1289900b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-smoke/src/Cargo.toml",
      "content": "[package]\nname = \"smoke\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "ce2de53c0dbff85f9ea0cd5651cf0e5d0b0e07a9c62ac7f22b0d703f520bd898",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-smoke/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod smoke {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Smoke' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SmokeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SmokeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SmokeContract {\n        /// Creates a new PSP-22 compatible Smoke Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Smoke\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSMOKE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "0b0e0bbf98caabdaf3b551ab9fb760ac83c9e3712357f2097498746d506da28b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-soil/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-soil/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-soil\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Soil'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "de71165f8021bfe6ae0821aa9211e4dd09b89f3517d8ed350080b957f502b5eb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-soil/README.md",
      "content": "# Soil - Contract\n\nThis is a Soil contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "1a70f5fd2ebf6e806c8308d499ffeb2d01430331dcad51aea624fa62adb669db",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-soil/src/Cargo.toml",
      "content": "[package]\nname = \"soil\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "8fdcb1f086d09bd129d2872163980fcc463c9734d1e1ea8fe1ad5a9c49f38f8f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-soil/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod soil {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Soil' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SoilContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SoilContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SoilContract {\n        /// Creates a new PSP-22 compatible Soil Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Soil\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSOIL\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "13767f532bb37e0059a8ba3f760f9115fa6f10cac6f9be72758e202d852facbd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-soot/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-soot/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-soot\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Soot'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "7261ab6ba1522afad9d864f4ed1855f709276c3fd8c7d71e6b8601ca468c78fc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-soot/README.md",
      "content": "# Soot - Contract\n\nThis is a Soot contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "9bcaef2f92f4ff6b5d6a0691c8aa49521855455c35258584eb65b3949c3a024e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-soot/src/Cargo.toml",
      "content": "[package]\nname = \"soot\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "47d7306b94c41185f34d7789a543c4509ac0372ca44f5e188bb61eda897a2a31",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-soot/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod soot {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Soot' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SootContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SootContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SootContract {\n        /// Creates a new PSP-22 compatible Soot Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Soot\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSOOT\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "77666ad963d62113ce42c01c5feba12bbeb8f93301990e01038c9e88f56207fe",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sparkle/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sparkle/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-sparkle\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Sparkle'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "9c054992687383d437f72d9c2c9a2a694c5c3c953bb3a0b63738210f8abe5d02",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sparkle/README.md",
      "content": "# Sparkle - Contract\n\nThis is a Sparkle contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "b0da838f45070581c44dd5c144c37b77e2f55330fa737a5aac57cbdee6ee720f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sparkle/src/Cargo.toml",
      "content": "[package]\nname = \"sparkle\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "34a800669a8d1b87342bd04726597985942a0cd610d028f8ddc02fc62ee24f7e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-sparkle/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod sparkle {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Sparkle' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SparkleContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SparkleContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SparkleContract {\n        /// Creates a new PSP-22 compatible Sparkle Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Sparkle\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSPARKLE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "2680a659ba01c48885dc83e61c6864867382681302511ec4f5d1e740bc499777",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-spore/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-spore/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-spore\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Spore'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "04ac9dfb34975b16c82b0a16c12e0d9525db5a32ca89143c320f2c4384b2052d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-spore/README.md",
      "content": "# Spore - Contract\n\nThis is a Spore contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "ba9c39ff2eceafece7e77333962555e09217b720b151b1084159f1d33ddf56a4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-spore/src/Cargo.toml",
      "content": "[package]\nname = \"spore\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "e332555c0da9150d2363ad318c38d4c74ee1c9c138a0ad4bb7282bf0ac9a13e7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-spore/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod spore {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Spore' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SporeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SporeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SporeContract {\n        /// Creates a new PSP-22 compatible Spore Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Spore\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSPORE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "4ae1cd7b0e27bb608db2d5f96ec7527c4abce9b726baa9e147341b05f0dac031",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-spread/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-spread/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-spread\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Spread'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "f0cc42c2a5154cdbaf19a8713fdaca0a55cfa7728b87c898898622a8c7a715eb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-spread/README.md",
      "content": "# Spread - Contract\n\nThis is a Spread contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "a626241dc02c56468f1c44488c03393a08eef69c416bba8469378b00b7caaec0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-spread/src/Cargo.toml",
      "content": "[package]\nname = \"spread\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "a385b86e02c6a87dc54114f338c3ae4086823115b24ebd6084b1289386b0976d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-spread/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod spread {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Spread' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SpreadContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SpreadContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SpreadContract {\n        /// Creates a new PSP-22 compatible Spread Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Spread\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSPREAD\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "0d789cad6085a88aa21b065f65b4d947a59f1c812bc4c32b616f39beee382a82",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-spring/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-spring/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-spring\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Spring'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "16e55ba503a4eab74e43ed9b8cd2e381be542be0f2a548ddc9938817dbfa03df",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-spring/README.md",
      "content": "# Spring - Contract\n\nThis is a Spring contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "c46129dd165a76212fa67072d63c2cb22020134e48de05dbc30e70349da77df3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-spring/src/Cargo.toml",
      "content": "[package]\nname = \"spring\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "61b7d96c8665dc82cf22782ec4515065da854a153dabb1a57523286e816b98c8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-spring/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod spring {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Spring' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SpringContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SpringContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SpringContract {\n        /// Creates a new PSP-22 compatible Spring Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Spring\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSPRING\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "543191e811945e136d58af565b5d3e63f1d14ebc1a30d12856de74e97d4d98e7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-steam-vent/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-steam-vent/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-steam-vent\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Steam Vent'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "ecae10d5b0bb11070998790c3f0423e12b5d1241cc63ea82c2139eaf19442c12",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-steam-vent/README.md",
      "content": "# Steam Vent - Contract\n\nThis is a Steam Vent contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "439fb3a2f2cfd6b5a795c9072533c7f504679bf6e26fb4143b4345109b423b09",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-steam-vent/src/Cargo.toml",
      "content": "[package]\nname = \"steam_vent\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "819dda8574f53b76756ce412adeec6f3750b0d38ec5ae26c4548b100e67ccf30",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-steam-vent/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod steam_vent {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Steam Vent' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SteamVentContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SteamVentContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SteamVentContract {\n        /// Creates a new PSP-22 compatible Steam Vent Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Steam Vent\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSTEAM_VENT\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "aa5d1c64a001841b7ada8e14b0d5aff312c3bc2bf30dc6d7f2f8e3d0f64d4011",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-steam/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-steam/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-steam\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Steam'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "9a4476a31fe4573b138639d8854d76d5b8a36693eecb04a1c0bd86db71369d6e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-steam/README.md",
      "content": "# Steam - Contract\n\nThis is a Steam contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "b71377a76edcfe04c75c31bee81a77cd189a8430b0ce527f8789e98ce3caea54",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-steam/src/Cargo.toml",
      "content": "[package]\nname = \"steam\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "2d3f08718a123afbdc37359cedcf6ef1d0508a8b2724d284dbfc2824fa6a95b9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-steam/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod steam {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Steam' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SteamContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SteamContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SteamContract {\n        /// Creates a new PSP-22 compatible Steam Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Steam\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSTEAM\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "9a7bb6c77d50910fcd313ce8eb72703cce500070159dbde8f9b140d5efef3bbc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-storm/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-storm/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-storm\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Storm'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "92b27b79d6e772a98aaa1dba431d2687333d173360027f9e6d0ebb0e5bad7e33",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-storm/README.md",
      "content": "# Storm - Contract\n\nThis is a Storm contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "ef485507b6ad7a7f07ca817459b33fe78b1cc1b9984bc9f15139ad28fd6007cb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-storm/src/Cargo.toml",
      "content": "[package]\nname = \"storm\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "794a7db66b103941766ef0d938aa55f27ed2cc2dd9d489717550562b30779ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-storm/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod storm {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Storm' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct StormContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for StormContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl StormContract {\n        /// Creates a new PSP-22 compatible Storm Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Storm\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSTORM\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "792e1799c65552ce166e1a45a231f3b72a69f88737bf72a96b71c8d07c66bb21",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-stream/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-stream/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-stream\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Stream'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "48c5572851f48308251989289fd495b0b4e0c4624440363a8aa5687bd4aab98a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-stream/README.md",
      "content": "# Stream - Contract\n\nThis is a Stream contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "f8c50e818a5edb5afad984f4f92dcb42c01aa3a29e302a7b6a9eedb3e045abdf",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-stream/src/Cargo.toml",
      "content": "[package]\nname = \"stream\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "305254b1e8673be8ac3f79afae484594e149af30f3e7bb1e75ff03bffcb7b4dd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-stream/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod stream {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Stream' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct StreamContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for StreamContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl StreamContract {\n        /// Creates a new PSP-22 compatible Stream Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Stream\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSTREAM\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "69908a1c438b4c04ce0828baaf5f95819639797e55eaba3c49ace5c1a0cf3beb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-subterranean-pool/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-subterranean-pool/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-subterranean-pool\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Subterranean Pool'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "c4730019ed28caead64a541782c18982e32c0c55f673eb8c7ee606e5022baa34",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-subterranean-pool/README.md",
      "content": "# Subterranean Pool - Contract\n\nThis is a Subterranean Pool contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "08825abaad2e4565604fd59d674fd6b7e57c8533a3cee9a3370664d07a0cbbe0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-subterranean-pool/src/Cargo.toml",
      "content": "[package]\nname = \"subterranean_pool\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "8ea52517c25f42e1d13ed85da58571fa15f08d594127380e7e6e81411752151c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-subterranean-pool/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod subterranean_pool {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Subterranean Pool' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SubterraneanPoolContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SubterraneanPoolContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SubterraneanPoolContract {\n        /// Creates a new PSP-22 compatible Subterranean Pool Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Subterranean Pool\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSUBTERRANEAN_POOL\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "788c293ee5839e8ebd54351ae062ece642d7f6512715987ed5fcc55d0697f01a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-super-marmalade/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-super-marmalade/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-super-marmalade\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'SuperMarmalade'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "7b75ec668e54bab3a27e0e970cae537d6f14844eec2035ab1e6ca8dbb946c60b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-super-marmalade/README.md",
      "content": "# SuperMarmalade - Contract\n\nThis is a SuperMarmalade contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "23c60316bfbc481ae784edfa0f7c056817f0dec14204a823768399cd4959f806",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-super-marmalade/src/Cargo.toml",
      "content": "[package]\nname = \"super_marmalade\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "ebd07d2637898d5e1f8db47c9210ab93a6c0505087d298601a578558540b0e8c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-super-marmalade/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod super_marmalade {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'SuperMarmalade' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SuperMarmaladeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SuperMarmaladeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SuperMarmaladeContract {\n        /// Creates a new PSP-22 compatible Super Marmalade Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Super Marmalade\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSUPER_MARMALADE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "e6eebe1bc30c4fdaa8160d45ad2db8958e01d74ed77a1af303726e1cd02b7f22",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-swarm/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-swarm/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-swarm\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'SWARM'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "a3d7be01a635940b781898b92e55bbdcb051e116932166f58a17e1067adf3ab0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-swarm/README.md",
      "content": "# SWARM - Contract\n\nThis is a SWARM contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "1db21a4f0eaffb851bfe93889c36e943a319589e6642f01c984cab99b4b51534",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-swarm/src/Cargo.toml",
      "content": "[package]\nname = \"swarm\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "df2924d132cabcce9275dec8e7982775dd93f4fd566ce6daf782cc501a78be94",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-swarm/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod swarm {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'SWARM' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SwarmContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SwarmContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SwarmContract {\n        /// Creates a new PSP-22 compatible Swarm Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Swarm\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSWARM\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "c8f6fa88bd917a4812e3617390c3dfc8c38b1f6422100cb35bbc2466baee2dc7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-thunder/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-thunder/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-thunder\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Thunder'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "cb5af0f3605c89ab0972598986fdc77fdb688512993a22b87f1400c30b152d75",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-thunder/README.md",
      "content": "# Thunder - Contract\n\nThis is a Thunder contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "43f9e9c7880b8c7820b1ec0ac5deb3f21907b52623e1ed7fcdd6c169d5e1450b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-thunder/src/Cargo.toml",
      "content": "[package]\nname = \"thunder\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "c4c5e971c7fa4010d1f846c3e751615089106858729d3ee4c0aa280f1f89dcca",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-thunder/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod thunder {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Thunder' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct ThunderContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for ThunderContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl ThunderContract {\n        /// Creates a new PSP-22 compatible Thunder Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Thunder\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MTHUNDER\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "863bee3ff5eca5530aa90351698e6e7869ff8284d09489b1e20fd517da7b426f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-tornado/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-tornado/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-tornado\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Tornado'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "c4fad6628ee786c8474f217bc64adc3465e579268b9ab0637a36794a2b34673a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-tornado/README.md",
      "content": "# Tornado - Contract\n\nThis is a Tornado contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "ad5bed14a8e2698eaf594acf9856597b209250a5b53f1a59d89603e15fa9f98a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-tornado/src/Cargo.toml",
      "content": "[package]\nname = \"tornado\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "4435160fb91bac02bbc3ad0e8bc88dae63cacda9fc1ce26355542bd141a651b6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-tornado/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod tornado {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Tornado' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct TornadoContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for TornadoContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl TornadoContract {\n        /// Creates a new PSP-22 compatible Tornado Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Tornado\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MTORNADO\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "e95126ce3368e26c207692535a4d3390510df8d61d95c03f6a14c58449506b6f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-transaction/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-transaction/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-transaction\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Transaction'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "bfc0a12319e481e9d6795e19d4ef48234ba06899e12abbfa1452960817e1a491",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-transaction/README.md",
      "content": "# Transaction - Contract\n\nThis is a Transaction contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "23d86b5a34010d8861080333bf0f25821954fd175aac4e20d068dbc3decc3571",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-transaction/src/Cargo.toml",
      "content": "[package]\nname = \"transaction\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "976dc687c50ea89a82fc48fbc36c7e1f6a9c81686cb73d40ca810f771f7a4635",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-transaction/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod transaction {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Transaction' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct TransactionContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for TransactionContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl TransactionContract {\n        /// Creates a new PSP-22 compatible Transaction Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Transaction\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MTRANSACTION\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "ddddd002a817db1b6730b448836b9ee1d6e35d4f335acf1ec975fce7c78a9534",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-tree/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-tree/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-tree\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Tree'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "3cc87b3de3835b1e5ac54817537a43b0aea0aea377caaf5bc37c08ada2c358fd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-tree/README.md",
      "content": "# Tree - Contract\n\nThis is a Tree contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "e6c18344d628f5a1ab5ce9aa2ca1369819d083a01e18cb02cefb1fdd1ac50781",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-tree/src/Cargo.toml",
      "content": "[package]\nname = \"tree\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "79e86d0f3bca4b5be1f539a405afd6955fbde76c774cb44cacb2351af7a9f5c5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-tree/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod tree {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Tree' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct TreeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for TreeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl TreeContract {\n        /// Creates a new PSP-22 compatible Tree Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Tree\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MTREE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "4ae50394b3946ac0da7b21e31424e995ee43685b523a4799950fc9df963ecfb0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-tributary/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-tributary/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-tributary\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Tributary'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "fa335b9126c2de7072b612916205354c7934212d6075bf90de56309a549c7d37",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-tributary/README.md",
      "content": "# Tributary - Contract\n\nThis is a Tributary contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "bf463a7f09d2e91099f11c6930df52ed0d0217700d405fdc5cffb8c702a182ca",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-tributary/src/Cargo.toml",
      "content": "[package]\nname = \"tributary\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "6ff0c58800d8edb355ab1a69fc9705faf8680d6d232dd18afabce150b914021b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-tributary/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod tributary {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Tributary' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct TributaryContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for TributaryContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl TributaryContract {\n        /// Creates a new PSP-22 compatible Tributary Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Tributary\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MTRIBUTARY\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "773c72f2ec5e311651cd05e548cbe67771f2f78e32bc0897d11f032b34ad086d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-underground-lake/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-underground-lake/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-underground-lake\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Underground Lake'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "3888866a305d6ca69caaa2ba47dad9ca8d31c11ce5bf04825997944beb38e7e7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-underground-lake/README.md",
      "content": "# Underground Lake - Contract\n\nThis is a Underground Lake contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "8af51e94f8b80e52218ee23252715eea118bedffecac3b0361813f87b34b9b82",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-underground-lake/src/Cargo.toml",
      "content": "[package]\nname = \"underground_lake\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "e798cc81ad0af1d121a29ef0057f050612ebe6cdf34122eed9194e3c0607c5f1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-underground-lake/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod underground_lake {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Underground Lake' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct UndergroundLakeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for UndergroundLakeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl UndergroundLakeContract {\n        /// Creates a new PSP-22 compatible Underground Lake Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Underground Lake\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MUNDERGROUND_LAKE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "ff3aae2661a9f2ebbfbc651521c16e178b26ccbab8fe2e66ccc01e21112b3655",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-unifiers/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-unifiers/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-unifiers\",\n    \"description\": \"The Game Contract of the game Unifiers\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "394aadf17341df2cbcfceda609096b5d5f15fa7e8b12c0b53323f402fd797d4f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-unifiers/README.md",
      "content": "# Unifiers - Game Contract\n\nThis is the **main outer contract** that the **game logic** interacts with.",
      "contentHash": "5ed8906052112c082200b96d9d322863a5b38d18c40e6f8c0c138e678d0822e0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-unifiers/src/Cargo.toml",
      "content": "[package]\nname = \"unifiers\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "8d18f99d5d06f990db4eef7f7ba554e6754e650209a0fa2522d7b10ce220a726",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-unifiers/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n/// A game created with the help of the Unifiers group\n#[ink::contract]\npub mod unifiers {\n    pub use ink::prelude::string::String;\n    pub use ink::prelude::format;\n    pub use ink::storage::Mapping;\n    use ink::{\n        env::{\n            call::{build_call, ExecutionInput, Selector},\n            CallFlags, DefaultEnvironment,\n        },\n    };\n\n    /** Error type for the game contract for Unifiers */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        Custom(String),\n        ElementContractError(String),\n        InkError(ink::primitives::LangError),\n        FatalError(String),\n        ElementContractIsNotLocked,\n        ElementContractAlreadyLocked,\n        NotTheOwner,\n        OwnerAlreadySet,\n        BuyOfferIsNotSet,\n        InsufficientBuyTransferredValue,\n        InvalidRecipe,\n        NotEnoughElements,\n        InvalidElement,\n    }\n\n    #[ink(storage)]\n    pub struct GameContract {\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        element_contract_ids: Mapping<u32, AccountId>,\n        buy_offer_price_native_tokens: u128,\n        buy_offer_reward_tier_points: u128,\n        buy_offer_is_set: bool,\n    }\n\n    struct Element {\n        id: u32,\n        name: &'static str,\n        description: &'static str,\n        tier: u32,\n    }\n\n    struct Recipe {\n        id: u32,\n        a: u32,\n        b: u32,\n        c: u32,\n    }\n\n    const ELEMENT_MONKEY: Element = Element {\n        id: 0,\n        name: \"Monkey\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_GIRAFFE: Element = Element {\n        id: 1,\n        name: \"Giraffe\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_BEE: Element = Element {\n        id: 2,\n        name: \"Bee\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_COIN: Element = Element {\n        id: 3,\n        name: \"Coin\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_SWARM: Element = Element {\n        id: 4,\n        name: \"SWARM\",\n        description: \"We need a description here\",\n        tier: 2,\n    };\n    const ELEMENT_HYDRA: Element = Element {\n        id: 5,\n        name: \"Hydra\",\n        description: \"We need a description here\",\n        tier: 2,\n    };\n    const ELEMENT_MONKEY_BRANCH: Element = Element {\n        id: 6,\n        name: \"MonkeyBranch\",\n        description: \"We need a description here\",\n        tier: 2,\n    };\n    const ELEMENT_BRIDGE: Element = Element {\n        id: 7,\n        name: \"Bridge\",\n        description: \"We need a description here\",\n        tier: 2,\n    };\n    const ELEMENT_GOLDEN_GATE: Element = Element {\n        id: 8,\n        name: \"GoldenGate\",\n        description: \"We need a description here\",\n        tier: 2,\n    };\n    const ELEMENT_GOLD: Element = Element {\n        id: 9,\n        name: \"Gold\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_SILVER: Element = Element {\n        id: 10,\n        name: \"Silver\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_RHODIUM: Element = Element {\n        id: 11,\n        name: \"Rhodium\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_HIVE: Element = Element {\n        id: 12,\n        name: \"Hive\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_TRANSACTION: Element = Element {\n        id: 13,\n        name: \"Transaction\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_BLOCK: Element = Element {\n        id: 14,\n        name: \"Block\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_BLOCKCHAIN: Element = Element {\n        id: 15,\n        name: \"Blockchain\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_POLKADOT: Element = Element {\n        id: 16,\n        name: \"Polkadot\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_PEER_REVIEW: Element = Element {\n        id: 17,\n        name: \"PeerReview\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_CARDANO: Element = Element {\n        id: 18,\n        name: \"Cardano\",\n        description: \"We need a description here\",\n        tier: 2,\n    };\n    const ELEMENT_BEAR: Element = Element {\n        id: 19,\n        name: \"Bear\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_BEER: Element = Element {\n        id: 20,\n        name: \"Beer\",\n        description: \"We need a description here\",\n        tier: 2,\n    };\n    const ELEMENT_LOCK: Element = Element {\n        id: 21,\n        name: \"Lock\",\n        description: \"We need a description here\",\n        tier: 2,\n    };\n    const ELEMENT_MARMALADE: Element = Element {\n        id: 22,\n        name: \"Marmalade\",\n        description: \"We need a description here\",\n        tier: 1,\n    };\n    const ELEMENT_SUPER_MARMALADE: Element = Element {\n        id: 23,\n        name: \"SuperMarmalade\",\n        description: \"We need a description here\",\n        tier: 2,\n    };\n    const ELEMENT_HYPER_MARMALADE: Element = Element {\n        id: 24,\n        name: \"HyperMarmalade\",\n        description: \"We need a description here\",\n        tier: 2,\n    };\n    const RECIPE_MAKE_SWARM: Recipe = Recipe {\n        id: 0,\n        a: 2,\n        b: 2,\n        c: 4,\n    };\n    const RECIPE_MAKE_HYDRA: Recipe = Recipe {\n        id: 1,\n        a: 1,\n        b: 1,\n        c: 5,\n    };\n    const RECIPE_MAKE_MONKEYBRANCH: Recipe = Recipe {\n        id: 2,\n        a: 0,\n        b: 5,\n        c: 6,\n    };\n    const RECIPE_MAKE_BRIDGE: Recipe = Recipe {\n        id: 3,\n        a: 6,\n        b: 6,\n        c: 7,\n    };\n    const RECIPE_MAKE_GOLDENGATE: Recipe = Recipe {\n        id: 4,\n        a: 3,\n        b: 7,\n        c: 8,\n    };\n    const RECIPE_MAKE_CARDANO: Recipe = Recipe {\n        id: 5,\n        a: 15,\n        b: 17,\n        c: 18,\n    };\n    const RECIPE_MAKE_BEER: Recipe = Recipe {\n        id: 6,\n        a: 2,\n        b: 19,\n        c: 20,\n    };\n    const RECIPE_MAKE_LOCK: Recipe = Recipe {\n        id: 7,\n        a: 10,\n        b: 10,\n        c: 21,\n    };\n    const RECIPE_MAKE_SUPERMARMALADE: Recipe = Recipe {\n        id: 8,\n        a: 22,\n        b: 22,\n        c: 23,\n    };\n    const RECIPE_MAKE_HYPERMARMALADE: Recipe = Recipe {\n        id: 9,\n        a: 23,\n        b: 23,\n        c: 24,\n    };\n\n    fn find_item(index: u32) -> Option<Element> {\n        if index == 0 {\n            return Some(ELEMENT_MONKEY);\n        }\n        if index == 1 {\n            return Some(ELEMENT_GIRAFFE);\n        }\n        if index == 2 {\n            return Some(ELEMENT_BEE);\n        }\n        if index == 3 {\n            return Some(ELEMENT_COIN);\n        }\n        if index == 4 {\n            return Some(ELEMENT_SWARM);\n        }\n        if index == 5 {\n            return Some(ELEMENT_HYDRA);\n        }\n        if index == 6 {\n            return Some(ELEMENT_MONKEY_BRANCH);\n        }\n        if index == 7 {\n            return Some(ELEMENT_BRIDGE);\n        }\n        if index == 8 {\n            return Some(ELEMENT_GOLDEN_GATE);\n        }\n        if index == 9 {\n            return Some(ELEMENT_GOLD);\n        }\n        if index == 10 {\n            return Some(ELEMENT_SILVER);\n        }\n        if index == 11 {\n            return Some(ELEMENT_RHODIUM);\n        }\n        if index == 12 {\n            return Some(ELEMENT_HIVE);\n        }\n        if index == 13 {\n            return Some(ELEMENT_TRANSACTION);\n        }\n        if index == 14 {\n            return Some(ELEMENT_BLOCK);\n        }\n        if index == 15 {\n            return Some(ELEMENT_BLOCKCHAIN);\n        }\n        if index == 16 {\n            return Some(ELEMENT_POLKADOT);\n        }\n        if index == 17 {\n            return Some(ELEMENT_PEER_REVIEW);\n        }\n        if index == 18 {\n            return Some(ELEMENT_CARDANO);\n        }\n        if index == 19 {\n            return Some(ELEMENT_BEAR);\n        }\n        if index == 20 {\n            return Some(ELEMENT_BEER);\n        }\n        if index == 21 {\n            return Some(ELEMENT_LOCK);\n        }\n        if index == 22 {\n            return Some(ELEMENT_MARMALADE);\n        }\n        if index == 23 {\n            return Some(ELEMENT_SUPER_MARMALADE);\n        }\n        if index == 24 {\n            return Some(ELEMENT_HYPER_MARMALADE);\n        }\n        None\n    }\n\n    fn find_recipe(index: u32) -> Option<Recipe> {\n        if index == 0 {\n            return Some(RECIPE_MAKE_SWARM);\n        }\n        if index == 1 {\n            return Some(RECIPE_MAKE_HYDRA);\n        }\n        if index == 2 {\n            return Some(RECIPE_MAKE_MONKEYBRANCH);\n        }\n        if index == 3 {\n            return Some(RECIPE_MAKE_BRIDGE);\n        }\n        if index == 4 {\n            return Some(RECIPE_MAKE_GOLDENGATE);\n        }\n        if index == 5 {\n            return Some(RECIPE_MAKE_CARDANO);\n        }\n        if index == 6 {\n            return Some(RECIPE_MAKE_BEER);\n        }\n        if index == 7 {\n            return Some(RECIPE_MAKE_LOCK);\n        }\n        if index == 8 {\n            return Some(RECIPE_MAKE_SUPERMARMALADE);\n        }\n        if index == 9 {\n            return Some(RECIPE_MAKE_HYPERMARMALADE);\n        }\n        None\n    }\n\n\n    impl Default for GameContract {\n        fn default() -> Self {\n            let element_contract_ids = Mapping::new();\n            Self {\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                element_contract_ids,\n                buy_offer_price_native_tokens: 0,\n                buy_offer_reward_tier_points: 0,\n                buy_offer_is_set: false,\n            }\n        }\n    }\n\n    impl GameContract {\n        /// Creates a new PSP-22 compatible Lava Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        /// Sets the owner of the contract\n        #[ink(message)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::OwnerAlreadySet);\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        /// Locks the contract id of an element\n        #[ink(message)]\n        pub fn lock_element_contract(&mut self, element_id: u32, element_contract_id: AccountId) -> Result<(), Error> {\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::NotTheOwner);\n            }\n            if self.element_contract_ids.contains(element_id) {\n                return Err(Error::ElementContractAlreadyLocked);\n            }\n            self.element_contract_ids.insert(element_id, &element_contract_id);\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn balance_of_element(&self, element_id: u32) -> Result<u128, Error> {\n            let element_contract_id = self.element_contract_ids.get(element_id).unwrap_or(AccountId::from([0xFF; 32]));\n            if element_contract_id == AccountId::from([0xFF; 32]) {\n                return Err(Error::ElementContractIsNotLocked);\n            }\n            let call_result = build_call::<DefaultEnvironment>()\n                .call(element_contract_id)\n                .exec_input(\n                    ExecutionInput::new(Selector::new(\n                            // Selector of PSP22::balance_of -> 0x6568382f\n                            [0x65, 0x68, 0x38, 0x2f]\n                        ))\n                        .push_arg(&self.env().caller()) // owner: AccountId parameter\n                )\n                .returns::<u128>()\n                .try_invoke();\n            match call_result {\n                Ok(okresult) => match okresult {\n                    Ok(result) => Ok(result),\n                    Err(reserr) => Err(Error::InkError(reserr))\n                },\n                Err(_) => Err(Error::FatalError(String::from(\"Error invoking PSP22::balance_of\")))\n            }\n        }\n\n        #[ink(message)]\n        pub fn set_buy_offer(&mut self, price: u128, reward_tier_points: u128) -> Result<(), Error> {\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::NotTheOwner);\n            }\n            self.buy_offer_price_native_tokens = price;\n            self.buy_offer_reward_tier_points = reward_tier_points;\n            self.buy_offer_is_set = true;\n            Ok(())\n        }\n        \n        #[ink(message)]\n        pub fn buy_offer(&self) -> Result<(u128, u128), Error> {\n            Ok((self.buy_offer_price_native_tokens, self.buy_offer_reward_tier_points))\n        }\n\n        #[ink(message, payable)]\n        pub fn buy(&mut self, element_id: u32) -> Result<(), Error> {\n            if !self.buy_offer_is_set {\n                return Err(Error::BuyOfferIsNotSet);\n            }\n\n            let val = self.env().transferred_value();\n\n            if val < self.buy_offer_price_native_tokens {\n                return Err(Error::InsufficientBuyTransferredValue);\n            }\n\n            let buy_count = val.checked_div(self.buy_offer_price_native_tokens).unwrap_or(0);\n\n            if buy_count == 0 {\n                return Err(Error::InsufficientBuyTransferredValue);\n            }\n\n            // TODO: Add element tiers and calculate number of received items based on that\n            let reward_tier_points = self.buy_offer_reward_tier_points.checked_mul(buy_count).unwrap_or(0);\n\n            if reward_tier_points == 0 {\n                return Err(Error::FatalError(String::from(\"Error calculating reward tier points, possible overflow\")));\n            }\n\n            let element_contract_id = self.element_contract_ids.get(element_id).unwrap_or(AccountId::from([0xFF; 32]));\n\n            if element_contract_id == AccountId::from([0xFF; 32]) {\n                return Err(Error::ElementContractIsNotLocked);\n            }\n\n            let element = find_item(element_id);\n\n            if element.is_none() {\n                return Err(Error::InvalidElement);\n            }\n\n            let el = element.unwrap();\n\n            let reward_items: u128 = reward_tier_points.checked_div(el.tier.into()).unwrap_or(0);\n\n            if reward_items == 0 {\n                return Err(Error::InsufficientBuyTransferredValue);\n            }\n\n            let call_result = build_call::<DefaultEnvironment>()\n                .call(element_contract_id)\n                .call_flags(CallFlags::TAIL_CALL)\n                .exec_input(\n                    ExecutionInput::new(Selector::new(\n                            // Selector of ElementContract::mint -> 0x21615d0f\n                            [0x21, 0x61, 0x5d, 0x0f]\n                        ))\n                        .push_arg::<AccountId>(self.env().caller()) // owner: AccountId parameter\n                        .push_arg::<u128>(reward_items) // value: u128 parameter\n                )\n                .returns::<()>()\n                .try_invoke();\n            match call_result {\n                Ok(okresult) => match okresult {\n                    Ok(_) => Ok(()),\n                    Err(reserr) => Err(Error::InkError(reserr))\n                },\n                Err(fatalerr) => Err(Error::FatalError(format!(\"Error invoking ElementContract::mint: {:?}\", fatalerr)))\n            }\n        }\n\n        #[ink(message)]\n        pub fn craft(&mut self, recipe_id: u32) -> Result<(), Error> {\n            let recipe = find_recipe(recipe_id);\n\n            if recipe.is_none() {\n                return Err(Error::InvalidRecipe);\n            }\n\n            let rec = recipe.unwrap();\n\n            let element_a_index = rec.a;\n            let element_b_index = rec.b;\n            let element_c_index = rec.c;\n\n            let element_a_contract_id = self.element_contract_ids.get(element_a_index).unwrap_or(AccountId::from([0xFF; 32]));\n            let element_b_contract_id = self.element_contract_ids.get(element_b_index).unwrap_or(AccountId::from([0xFF; 32]));\n            let element_c_contract_id = self.element_contract_ids.get(element_c_index).unwrap_or(AccountId::from([0xFF; 32]));\n\n            let element_a_balance = self.balance_of_element(element_a_index).unwrap_or(0);\n            let element_b_balance = self.balance_of_element(element_b_index).unwrap_or(0);\n\n            if element_a_contract_id == AccountId::from([0xFF; 32]) || element_b_contract_id == AccountId::from([0xFF; 32]) || element_c_contract_id == AccountId::from([0xFF; 32]) {\n                return Err(Error::ElementContractIsNotLocked);\n            }\n\n            if element_a_balance == 0 || element_b_balance == 0 {\n                return Err(Error::NotEnoughElements);\n            }\n\n            // Burn calls to element contracts\n            let call_result_a = build_call::<DefaultEnvironment>()\n                .call(element_a_contract_id)\n                .call_flags(CallFlags::ALLOW_REENTRY)\n                .exec_input(\n                    ExecutionInput::new(Selector::new(\n                            // Selector of ElementContract::burn -> 0x100fa9ca\n                            [0x10, 0x0f, 0xa9, 0xca]\n                        ))\n                        .push_arg::<AccountId>(self.env().caller()) // owner: AccountId parameter\n                        .push_arg::<u128>(1) // value: u128 parameter\n                )\n                .returns::<Result<(), Error>>()\n                .try_invoke();\n            \n            let call_result_b = build_call::<DefaultEnvironment>()\n                .call(element_b_contract_id)\n                .call_flags(CallFlags::ALLOW_REENTRY)\n                .exec_input(\n                    ExecutionInput::new(Selector::new(\n                            // Selector of ElementContract::burn -> 0x100fa9ca\n                            [0x10, 0x0f, 0xa9, 0xca]\n                        ))\n                        .push_arg::<AccountId>(self.env().caller()) // owner: AccountId parameter\n                        .push_arg::<u128>(1) // value: u128 parameter\n                )\n                .returns::<Result<(), Error>>()\n                .try_invoke();\n            \n            match call_result_a {\n                Ok(okresult1) => match okresult1 {\n                    Ok(_) => (),\n                    Err(reserr1) => return Err(Error::InkError(reserr1))\n                },\n                Err(fatalerr1) => return Err(Error::FatalError(format!(\"Error invoking ElementContract::burn (1 / 3): {:?}\", fatalerr1)))\n            }\n\n            match call_result_b {\n                Ok(okresult2) => match okresult2 {\n                    Ok(_) => (),\n                    Err(reserr2) => return Err(Error::InkError(reserr2))\n                },\n                Err(fatalerr2) => return Err(Error::FatalError(format!(\"Error invoking ElementContract::burn (2 / 3): {:?}\", fatalerr2)))\n            }\n            \n            // Mint call to element contract\n            let call_result_c = build_call::<DefaultEnvironment>()\n                .call(element_c_contract_id)\n                .call_flags(CallFlags::TAIL_CALL)\n                .exec_input(\n                    ExecutionInput::new(Selector::new(\n                            // Selector of ElementContract::mint -> 0x21615d0f\n                            [0x21, 0x61, 0x5d, 0x0f]\n                        ))\n                        .push_arg::<AccountId>(self.env().caller()) // owner: AccountId parameter\n                        .push_arg::<u128>(1) // value: u128 parameter\n                )\n                .returns::<Result<(), Error>>()\n                .try_invoke();\n    \n            match call_result_c {\n                Ok(okresult3) => match okresult3 {\n                    Ok(_) => Ok(()),\n                    Err(reserr3) => Err(Error::InkError(reserr3))\n                },\n                Err(fatalerr3) => Err(Error::FatalError(format!(\"Error invoking ElementContract::mint (3 / 3): {:?}\", fatalerr3)))\n            }\n            \n        }\n    }\n\n}",
      "contentHash": "f65e3ec7de560822ff6978eaf9a584da02a5a533d9879ff2fae3cc5c6ab353fa",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-valley/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-valley/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-valley\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Valley'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "abd92315df3c8f3b3e39287249181f0cc63f9b1d9ccd0fc41d4eed994dda112c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-valley/README.md",
      "content": "# Valley - Contract\n\nThis is a Valley contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "921835428c3361bc70b0740c201362cefc39389f59b9ff6804410a417b7703ca",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-valley/src/Cargo.toml",
      "content": "[package]\nname = \"valley\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "7857edf381598423251f5614dc1952d279fcbc2ee0003ccd827f9a7e60af3e89",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-valley/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod valley {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Valley' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct ValleyContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for ValleyContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl ValleyContract {\n        /// Creates a new PSP-22 compatible Valley Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Valley\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MVALLEY\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "ffc5095f1e43b4517c007c551d9b6e772f6f060df329a285645438a53e8ad585",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-volcano/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-volcano/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-volcano\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Volcano'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "366f1a9aaa13886d203dadbaaadae1a23eb6669792df31774945983056606986",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-volcano/README.md",
      "content": "# Volcano - Contract\n\nThis is a Volcano contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "c2e3f3acf8ea78fa029dea91fc4669a8d8c5e82dab62d4ed7df1ea67a012c570",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-volcano/src/Cargo.toml",
      "content": "[package]\nname = \"volcano\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "66cd3aa7e347ce9e3644a6791c6dc1060b704ba64163458214f46ba453956ea9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-volcano/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod volcano {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Volcano' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct VolcanoContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for VolcanoContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl VolcanoContract {\n        /// Creates a new PSP-22 compatible Volcano Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Volcano\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MVOLCANO\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "eaef7e479449a0e2fdcc87891e98d948265545a56b87e79fd81e10b156007602",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wall/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wall/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-wall\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Wall'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "74468e5d9b074d49b82aff0a73b83b21f7be364740ff19ab0e53dd24ce84b548",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wall/README.md",
      "content": "# Wall - Contract\n\nThis is a Wall contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "b98ed6f62fa22b3d61d01e65dc5fe499b0bc0bf17668c9a43763dd5d22d90172",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wall/src/Cargo.toml",
      "content": "[package]\nname = \"wall\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "7f90fa7e280bd2bf2a33cf0299f3a18799f65c07634984a62189367941690c4f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wall/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod wall {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Wall' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct WallContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for WallContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl WallContract {\n        /// Creates a new PSP-22 compatible Wall Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Wall\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MWALL\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "e04be09d102c56f3a1dd53082ec5d3aba9821f683e5bff42b8a0438603b34ed8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-warm-breeze/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-warm-breeze/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-warm-breeze\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Warm Breeze'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "36dbfa9d9189be93e71f907ade56c4f53f5dc4c39f57fc821c789cf92ec9d826",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-warm-breeze/README.md",
      "content": "# Warm Breeze - Contract\n\nThis is a Warm Breeze contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "ef9c3296d93b7f55261e7ba64ff11c88f539fdc602dc20242a42a880f1870a38",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-warm-breeze/src/Cargo.toml",
      "content": "[package]\nname = \"warm_breeze\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "bff19a24a6a8ff617d4ad306384a414371221904d1b709cb05a1b54ccf106844",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-warm-breeze/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod warm_breeze {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Warm Breeze' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct WarmBreezeContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for WarmBreezeContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl WarmBreezeContract {\n        /// Creates a new PSP-22 compatible Warm Breeze Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Warm Breeze\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MWARM_BREEZE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "e13b6f0d4ece81cbed4d84e1a770fe09d89f0b2d801447d71542db8c323aad5f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-water/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-water/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-water\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Water'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "cac610073d5c6afeb359903b063fcc0e813e2ecacef11556dbd0d48c820fa524",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-water/README.md",
      "content": "# Water - Contract\n\nThis is a Water contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "2ee24c587a6f6cceb45089d79a8516a392d29014d8f304d6a07b1c02c84e1fff",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-water/src/Cargo.toml",
      "content": "[package]\nname = \"water\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "abfd355630ccda731ba36c9d63cb728037ba4c3557041154e1e23ed0202a2032",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-water/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod water {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Water' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct WaterContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for WaterContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl WaterContract {\n        /// Creates a new PSP-22 compatible Water Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Water\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MWATER\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "d3193a3ab40afe663f596be9b274dd571d279290f243456447ce74484285e363",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-waterfall/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-waterfall/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-waterfall\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Waterfall'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "aac290306454e2eecd0571cb788e6c8814f5a982db26a153974aff69a4d821b5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-waterfall/README.md",
      "content": "# Waterfall - Contract\n\nThis is a Waterfall contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "8dcef6a4fe9c6b2a2d46430bae72425e6967cb350e276e5d42b68b4cc469c05f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-waterfall/src/Cargo.toml",
      "content": "[package]\nname = \"waterfall\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "1c3eb99ddf2277173a20e22119960b6d7f5eed833b1d3b632533b3186466b625",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-waterfall/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod waterfall {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Waterfall' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct WaterfallContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for WaterfallContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl WaterfallContract {\n        /// Creates a new PSP-22 compatible Waterfall Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Waterfall\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MWATERFALL\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "50ac20f7b7ba09d116490e7cf895c9fb4e77c47d0a75f04ba0934825ea9bf66d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-watershed/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-watershed/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-watershed\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Watershed'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "d5fd86513735d4aa9cdd7d4207d4188325793902171a75352597b61aa99e9975",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-watershed/README.md",
      "content": "# Watershed - Contract\n\nThis is a Watershed contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "8e6518063f6aa490aba0af837a9792e3361769a31173246ccb289429ae7213ef",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-watershed/src/Cargo.toml",
      "content": "[package]\nname = \"watershed\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "c231a081b5dd8ba353241718efcd54cc414eaac94b8a3af8cf0a85f9818dcf95",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-watershed/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod watershed {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Watershed' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct WatershedContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for WatershedContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl WatershedContract {\n        /// Creates a new PSP-22 compatible Watershed Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Watershed\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MWATERSHED\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "891956aaf83eb990a81fb22d3e277a2b05721ea895121c415aaf6fc100a4a504",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wave/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wave/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-wave\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Wave'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "affebf6b1a59a90ad7fbaf60aca24bbbdbc82de77a49fb6b36f20c94a4b8e457",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wave/README.md",
      "content": "# Wave - Contract\n\nThis is a Wave contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "b9020f318272290ea1ff606e93d1613c8908ef8433a7110d6f761ac4d30c30de",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wave/src/Cargo.toml",
      "content": "[package]\nname = \"wave\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "f2a5f5c478d3b1fc41017aa4d32279c35239d23c693876ce1c811a08f05c748f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wave/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod wave {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Wave' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct WaveContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for WaveContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl WaveContract {\n        /// Creates a new PSP-22 compatible Wave Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Wave\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MWAVE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "0941976fdf1f15b84fb817be4ad582c98deac356bc41669fd10cb1ed8233cac4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wetland/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wetland/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-wetland\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Wetland'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "404062119b051b295c0f93338b0f1a2f35507af1bbac10987ee5652ad4ba57e5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wetland/README.md",
      "content": "# Wetland - Contract\n\nThis is a Wetland contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "c62cb4195c400a5d9ccde595e2e5b7736c12ddcdf3336ac83b7082e80cf9973c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wetland/src/Cargo.toml",
      "content": "[package]\nname = \"wetland\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "f7d095aa9ec34e27169781b6256e9af62485d3522eed81e386836f8c135bb6bc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wetland/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod wetland {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Wetland' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct WetlandContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for WetlandContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl WetlandContract {\n        /// Creates a new PSP-22 compatible Wetland Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Wetland\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MWETLAND\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "626205b8fb6a4baff55d35525712234148518ed2ad3f6393996d020c668e2fd0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wetstone/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wetstone/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-wetstone\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Wetstone'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "7d717dd6c5a9b5af4a161ee9cd23195853b443ed9a61411b368ca4fac3d64ed5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wetstone/README.md",
      "content": "# Wetstone - Contract\n\nThis is a Wetstone contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "4aa1386c2e4a9e10ee3c1d2f55e5919c854ef625f82fb3f80eb780911830135c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wetstone/src/Cargo.toml",
      "content": "[package]\nname = \"wetstone\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "e5ac1a04602f62142d92897fd052b27ed6e867cd9f5ea9ed3268cccd3cd3b072",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wetstone/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod wetstone {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Wetstone' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct WetstoneContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for WetstoneContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl WetstoneContract {\n        /// Creates a new PSP-22 compatible Wetstone Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Wetstone\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MWETSTONE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "cfc1adf775971837f5755feacb00f6036ea744ab392077dca82976eee42a925f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-whirl/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-whirl/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-whirl\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Whirl'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "a4a1e34ccd77d369eae05c65a667cf6e7d8be41100ffc5ee5b428762622651a4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-whirl/README.md",
      "content": "# Whirl - Contract\n\nThis is a Whirl contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "c6f02f6f0f4eb166ecebfd6f718345cab33135cfabef637f4ec9db9144197491",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-whirl/src/Cargo.toml",
      "content": "[package]\nname = \"whirl\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "936ccac57bbf7cf9a1188c31bd2ce3ebe56e2e1d21c2a81fa71bdc84086bf5db",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-whirl/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod whirl {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Whirl' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct WhirlContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for WhirlContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl WhirlContract {\n        /// Creates a new PSP-22 compatible Whirl Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Whirl\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MWHIRL\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "e9b461539996ba0c45a0046a80f94f474d112cef290418f3e13f3bcef4fe8546",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-whisper/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-whisper/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-whisper\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Whisper'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "cfc0f9c0b96273ffd60e3c029d22c32e2958e52e09edeb13d6b955be287cfe1c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-whisper/README.md",
      "content": "# Whisper - Contract\n\nThis is a Whisper contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "816477648b39734e90ea71ce1438ee35c759cc2419f23ba54d059ea00cb95ed4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-whisper/src/Cargo.toml",
      "content": "[package]\nname = \"whisper\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "f362deea832da44a8f04ec8b50dd40364d90810defdee82f2f35905ddaffa401",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-whisper/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod whisper {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Whisper' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct WhisperContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for WhisperContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl WhisperContract {\n        /// Creates a new PSP-22 compatible Whisper Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Whisper\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MWHISPER\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "81d87cd26da437b59a0ab9ec223b76073dc278db78bbc3cc31a88c85ecc93e95",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-whispering-cave/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-whispering-cave/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-whispering-cave\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Whispering Cave'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "4a7b67a6e263cde7d8f041eb2c76bd54a1ca16c3a56df080dfa5cab211076613",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-whispering-cave/README.md",
      "content": "# Whispering Cave - Contract\n\nThis is a Whispering Cave contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "9b3bee8a2739950cadeee75a24d211e14d0581c7a026ca64bc6419b1462a8e36",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-whispering-cave/src/Cargo.toml",
      "content": "[package]\nname = \"whispering_cave\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "869d34ee3615d31f32bf38099c3ae1597a192eabaf6d3ea39e1c2cc088f4a02c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-whispering-cave/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod whispering_cave {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Whispering Cave' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct WhisperingCaveContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for WhisperingCaveContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl WhisperingCaveContract {\n        /// Creates a new PSP-22 compatible Whispering Cave Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Whispering Cave\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MWHISPERING_CAVE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "81a6d56d4fcb2b759a983da704306da0e63b7ed12f7a031b04899bce1b9f932c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wildfire/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wildfire/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-wildfire\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Wildfire'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "2454aec1cc10c16f39d2102b06492542a51f04067540acf7f3f0188b6e136570",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wildfire/README.md",
      "content": "# Wildfire - Contract\n\nThis is a Wildfire contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "bf76595bd36a015e8d3f667feee928e23be91fde7b57b6a16c6225ede27804d6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wildfire/src/Cargo.toml",
      "content": "[package]\nname = \"wildfire\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "3cc88ab592f52d6d5d65d3f42809a468dde4f8881b4e071191efb29f328b3f39",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wildfire/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod wildfire {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Wildfire' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct WildfireContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for WildfireContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl WildfireContract {\n        /// Creates a new PSP-22 compatible Wildfire Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Wildfire\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MWILDFIRE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "181d50741712261b6e1152ccf8567fe0e31d2f7a6c658757f0534dfc74265e94",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wind/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wind/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-wind\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Wind'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "e579eb4e55264beef5b24f3e218818847d450f39e0f742a066caee6bd664a9a1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wind/README.md",
      "content": "# Wind - Contract\n\nThis is a Wind contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "e36f2a7d3384067c56dcbd7a2c479663d2a02f6d75b61a6d94d63068f8d3c00d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wind/src/Cargo.toml",
      "content": "[package]\nname = \"wind\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "2e39508e830b660b682c7fd30dc3acb237c9d70e016c1e30536e419d8d55a956",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-wind/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod wind {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Wind' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct WindContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for WindContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl WindContract {\n        /// Creates a new PSP-22 compatible Wind Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Wind\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MWIND\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "bf3251a0a55a95dfeef589bed8bf28fa644bdf7d2e722bc3f151f706664bb1fe",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-windmill/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-windmill/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-windmill\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Windmill'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "c4aa86247f43c89f6a8f15cdcaf850848bc771c49b165b708a3e6021c540e7d0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-windmill/README.md",
      "content": "# Windmill - Contract\n\nThis is a Windmill contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "9854f834aba0452969d75a65be8151934f82887333975d8c6766ad7f289d1445",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-windmill/src/Cargo.toml",
      "content": "[package]\nname = \"windmill\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "06c0e100e96a2460950ba3637ac18ce32fb4c8ff62399dd623b6fd14731d7b65",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-windmill/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod windmill {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Windmill' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct WindmillContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for WindmillContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl WindmillContract {\n        /// Creates a new PSP-22 compatible Windmill Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Windmill\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MWINDMILL\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "435515782bf8e889592d5c10da5b7e5c180ca7af2659e74428f15faf62d4bfe6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-zephyr/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-zephyr/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-zephyr\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'Zephyr'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "0c3f927768c0db482fd08c21f665fa36d58e9c3ba3b69f29ed28be4d64f4cc2c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-zephyr/README.md",
      "content": "# Zephyr - Contract\n\nThis is a Zephyr contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "16e97c7f0d8115aaa98f4300ea814fd3c782ac04e8cd2c9559753645a5f492a9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-zephyr/src/Cargo.toml",
      "content": "[package]\nname = \"zephyr\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "0ca27123cf282b835de85af2be2e9af201b191e48edb8dab7f8132fd53a550b4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-zephyr/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod zephyr {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'Zephyr' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct ZephyrContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for ZephyrContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl ZephyrContract {\n        /// Creates a new PSP-22 compatible Zephyr Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Zephyr\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MZEPHYR\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            // FIXME: Only allow locking ONCE\n            /* if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            } */\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            // FIXME: Only allow minting for the game contract\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            } */\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "120dc4315fa893c40c0f5fbc5a2d999a61eba07c3ac3d07aee08dec2c454b625",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/deployer/copy-contracts.js",
      "content": "const fs = require('fs');\nconst path = require('path');\n\nconst POSSIBLE_TARGET_INK_DIRS = [\n    \"../../target/ink\",\n    \"../../../target/ink\",\n    \"target/ink\",\n];\nconst POSSIBLE_CONTRACTS_V1_README_MD_FILES = [\n    \"../../contracts.v1/README.md\",\n    \"../../../contracts.v1/README.md\",\n    \"contracts.v1/README.md\",\n]\n\nconst realTargetInkIndex = POSSIBLE_TARGET_INK_DIRS.findIndex((dir) => fs.existsSync(dir));\nconst targetInkDir = POSSIBLE_TARGET_INK_DIRS[realTargetInkIndex];\n\nconsole.log(`Copying contracts from ${POSSIBLE_TARGET_INK_DIRS[realTargetInkIndex]} ...`);\n\nconst realContractsV1ReadmeMdIndex = POSSIBLE_CONTRACTS_V1_README_MD_FILES.findIndex((file) => fs.existsSync(file));\nconst contractsV1ReadmeMd = POSSIBLE_CONTRACTS_V1_README_MD_FILES[realContractsV1ReadmeMdIndex];\nconst contractsV1Dir = path.join(path.dirname(contractsV1ReadmeMd), \"artifacts\");\n\nconsole.log(`Copying contracts into ${contractsV1Dir} ...`);\n\nif(!fs.existsSync(contractsV1Dir)) {\n    fs.mkdirSync(contractsV1Dir, { recursive: true });\n}\n\nconst itemMonkeyPath = path.join(targetInkDir, 'monkey/monkey.contract');\nconst itemGiraffePath = path.join(targetInkDir, 'giraffe/giraffe.contract');\nconst itemBeePath = path.join(targetInkDir, 'bee/bee.contract');\nconst itemCoinPath = path.join(targetInkDir, 'coin/coin.contract');\nconst itemSwarmPath = path.join(targetInkDir, 'swarm/swarm.contract');\nconst itemHydraPath = path.join(targetInkDir, 'hydra/hydra.contract');\nconst itemMonkeyBranchPath = path.join(targetInkDir, 'monkey_branch/monkey_branch.contract');\nconst itemBridgePath = path.join(targetInkDir, 'bridge/bridge.contract');\nconst itemGoldenGatePath = path.join(targetInkDir, 'golden_gate/golden_gate.contract');\nconst itemGoldPath = path.join(targetInkDir, 'gold/gold.contract');\nconst itemSilverPath = path.join(targetInkDir, 'silver/silver.contract');\nconst itemRhodiumPath = path.join(targetInkDir, 'rhodium/rhodium.contract');\nconst itemHivePath = path.join(targetInkDir, 'hive/hive.contract');\nconst itemTransactionPath = path.join(targetInkDir, 'transaction/transaction.contract');\nconst itemBlockPath = path.join(targetInkDir, 'block/block.contract');\nconst itemBlockchainPath = path.join(targetInkDir, 'blockchain/blockchain.contract');\nconst itemPolkadotPath = path.join(targetInkDir, 'polkadot/polkadot.contract');\nconst itemPeerReviewPath = path.join(targetInkDir, 'peer_review/peer_review.contract');\nconst itemCardanoPath = path.join(targetInkDir, 'cardano/cardano.contract');\nconst itemBearPath = path.join(targetInkDir, 'bear/bear.contract');\nconst itemBeerPath = path.join(targetInkDir, 'beer/beer.contract');\nconst itemLockPath = path.join(targetInkDir, 'lock/lock.contract');\nconst itemMarmaladePath = path.join(targetInkDir, 'marmalade/marmalade.contract');\nconst itemSuperMarmaladePath = path.join(targetInkDir, 'super_marmalade/super_marmalade.contract');\nconst itemHyperMarmaladePath = path.join(targetInkDir, 'hyper_marmalade/hyper_marmalade.contract');\nconst itemWaterPath = path.join(targetInkDir, 'water/water.contract');\nconst itemFirePath = path.join(targetInkDir, 'fire/fire.contract');\nconst itemSteamPath = path.join(targetInkDir, 'steam/steam.contract');\nconst itemEarthPath = path.join(targetInkDir, 'earth/earth.contract');\nconst itemMudPath = path.join(targetInkDir, 'mud/mud.contract');\nconst itemLavaPath = path.join(targetInkDir, 'lava/lava.contract');\nconst itemWindPath = path.join(targetInkDir, 'wind/wind.contract');\nconst itemDustPath = path.join(targetInkDir, 'dust/dust.contract');\nconst itemRainPath = path.join(targetInkDir, 'rain/rain.contract');\nconst itemSmokePath = path.join(targetInkDir, 'smoke/smoke.contract');\nconst itemGeyserPath = path.join(targetInkDir, 'geyser/geyser.contract');\nconst itemClayPath = path.join(targetInkDir, 'clay/clay.contract');\nconst itemSandPath = path.join(targetInkDir, 'sand/sand.contract');\nconst itemPlantPath = path.join(targetInkDir, 'plant/plant.contract');\nconst itemRainbowPath = path.join(targetInkDir, 'rainbow/rainbow.contract');\nconst itemStormPath = path.join(targetInkDir, 'storm/storm.contract');\nconst itemObsidianPath = path.join(targetInkDir, 'obsidian/obsidian.contract');\nconst itemAshPath = path.join(targetInkDir, 'ash/ash.contract');\nconst itemVolcanoPath = path.join(targetInkDir, 'volcano/volcano.contract');\nconst itemSandstormPath = path.join(targetInkDir, 'sandstorm/sandstorm.contract');\nconst itemCloudPath = path.join(targetInkDir, 'cloud/cloud.contract');\nconst itemFogPath = path.join(targetInkDir, 'fog/fog.contract');\nconst itemTreePath = path.join(targetInkDir, 'tree/tree.contract');\nconst itemForestPath = path.join(targetInkDir, 'forest/forest.contract');\nconst itemSeedsPath = path.join(targetInkDir, 'seeds/seeds.contract');\nconst itemPotteryPath = path.join(targetInkDir, 'pottery/pottery.contract');\nconst itemBrickPath = path.join(targetInkDir, 'brick/brick.contract');\nconst itemQuicksandPath = path.join(targetInkDir, 'quicksand/quicksand.contract');\nconst itemGlassPath = path.join(targetInkDir, 'glass/glass.contract');\nconst itemDunePath = path.join(targetInkDir, 'dune/dune.contract');\nconst itemCharcoalPath = path.join(targetInkDir, 'charcoal/charcoal.contract');\nconst itemLeavesPath = path.join(targetInkDir, 'leaves/leaves.contract');\nconst itemWildfirePath = path.join(targetInkDir, 'wildfire/wildfire.contract');\nconst itemJunglePath = path.join(targetInkDir, 'jungle/jungle.contract');\nconst itemFrostedGlassPath = path.join(targetInkDir, 'frosted_glass/frosted_glass.contract');\nconst itemCrystalPath = path.join(targetInkDir, 'crystal/crystal.contract');\nconst itemMagmaPath = path.join(targetInkDir, 'magma/magma.contract');\nconst itemRockPath = path.join(targetInkDir, 'rock/rock.contract');\nconst itemShardPath = path.join(targetInkDir, 'shard/shard.contract');\nconst itemPebblePath = path.join(targetInkDir, 'pebble/pebble.contract');\nconst itemMountainPath = path.join(targetInkDir, 'mountain/mountain.contract');\nconst itemFertilizerPath = path.join(targetInkDir, 'fertilizer/fertilizer.contract');\nconst itemSootPath = path.join(targetInkDir, 'soot/soot.contract');\nconst itemLightningPath = path.join(targetInkDir, 'lightning/lightning.contract');\nconst itemMistPath = path.join(targetInkDir, 'mist/mist.contract');\nconst itemHazePath = path.join(targetInkDir, 'haze/haze.contract');\nconst itemFloodPath = path.join(targetInkDir, 'flood/flood.contract');\nconst itemLandslidePath = path.join(targetInkDir, 'landslide/landslide.contract');\nconst itemThunderPath = path.join(targetInkDir, 'thunder/thunder.contract');\nconst itemTornadoPath = path.join(targetInkDir, 'tornado/tornado.contract');\nconst itemGardenPath = path.join(targetInkDir, 'garden/garden.contract');\nconst itemEmberPath = path.join(targetInkDir, 'ember/ember.contract');\nconst itemKilnPath = path.join(targetInkDir, 'kiln/kiln.contract');\nconst itemPollinationPath = path.join(targetInkDir, 'pollination/pollination.contract');\nconst itemSinkholePath = path.join(targetInkDir, 'sinkhole/sinkhole.contract');\nconst itemBeachPath = path.join(targetInkDir, 'beach/beach.contract');\nconst itemWetstonePath = path.join(targetInkDir, 'wetstone/wetstone.contract');\nconst itemErosionPath = path.join(targetInkDir, 'erosion/erosion.contract');\nconst itemBasaltPath = path.join(targetInkDir, 'basalt/basalt.contract');\nconst itemMagmaChamberPath = path.join(targetInkDir, 'magma_chamber/magma_chamber.contract');\nconst itemBreezePath = path.join(targetInkDir, 'breeze/breeze.contract');\nconst itemWarmBreezePath = path.join(targetInkDir, 'warm_breeze/warm_breeze.contract');\nconst itemSoilPath = path.join(targetInkDir, 'soil/soil.contract');\nconst itemCanyonPath = path.join(targetInkDir, 'canyon/canyon.contract');\nconst itemWindmillPath = path.join(targetInkDir, 'windmill/windmill.contract');\nconst itemAdobePath = path.join(targetInkDir, 'adobe/adobe.contract');\nconst itemWallPath = path.join(targetInkDir, 'wall/wall.contract');\nconst itemPumicePath = path.join(targetInkDir, 'pumice/pumice.contract');\nconst itemBarbecuePath = path.join(targetInkDir, 'barbecue/barbecue.contract');\nconst itemFarmPath = path.join(targetInkDir, 'farm/farm.contract');\nconst itemShardsPath = path.join(targetInkDir, 'shards/shards.contract');\nconst itemMoltenGlassPath = path.join(targetInkDir, 'molten_glass/molten_glass.contract');\nconst itemPrismPath = path.join(targetInkDir, 'prism/prism.contract');\nconst itemSparklePath = path.join(targetInkDir, 'sparkle/sparkle.contract');\nconst itemDesertPath = path.join(targetInkDir, 'desert/desert.contract');\nconst itemOasisPath = path.join(targetInkDir, 'oasis/oasis.contract');\nconst itemMiragePath = path.join(targetInkDir, 'mirage/mirage.contract');\nconst itemSandDunePath = path.join(targetInkDir, 'sand_dune/sand_dune.contract');\nconst itemDamPath = path.join(targetInkDir, 'dam/dam.contract');\nconst itemFirewallPath = path.join(targetInkDir, 'firewall/firewall.contract');\nconst itemBarricadePath = path.join(targetInkDir, 'barricade/barricade.contract');\nconst itemPlateauPath = path.join(targetInkDir, 'plateau/plateau.contract');\nconst itemPondPath = path.join(targetInkDir, 'pond/pond.contract');\nconst itemAromasPath = path.join(targetInkDir, 'aromas/aromas.contract');\nconst itemFlowerPath = path.join(targetInkDir, 'flower/flower.contract');\nconst itemSporePath = path.join(targetInkDir, 'spore/spore.contract');\nconst itemSpreadPath = path.join(targetInkDir, 'spread/spread.contract');\nconst itemFertileLandPath = path.join(targetInkDir, 'fertile_land/fertile_land.contract');\nconst itemWetlandPath = path.join(targetInkDir, 'wetland/wetland.contract');\nconst itemPeatPath = path.join(targetInkDir, 'peat/peat.contract');\nconst itemReedsPath = path.join(targetInkDir, 'reeds/reeds.contract');\nconst itemValleyPath = path.join(targetInkDir, 'valley/valley.contract');\nconst itemRiverPath = path.join(targetInkDir, 'river/river.contract');\nconst itemScorchedEarthPath = path.join(targetInkDir, 'scorched_earth/scorched_earth.contract');\nconst itemDeltaPath = path.join(targetInkDir, 'delta/delta.contract');\nconst itemEstuaryPath = path.join(targetInkDir, 'estuary/estuary.contract');\nconst itemFireSwampPath = path.join(targetInkDir, 'fire_swamp/fire_swamp.contract');\nconst itemRiverbankPath = path.join(targetInkDir, 'riverbank/riverbank.contract');\nconst itemRavinePath = path.join(targetInkDir, 'ravine/ravine.contract');\nconst itemGorgePath = path.join(targetInkDir, 'gorge/gorge.contract');\nconst itemCharredRavinePath = path.join(targetInkDir, 'charred_ravine/charred_ravine.contract');\nconst itemEchoPath = path.join(targetInkDir, 'echo/echo.contract');\nconst itemCavePath = path.join(targetInkDir, 'cave/cave.contract');\nconst itemUndergroundLakePath = path.join(targetInkDir, 'underground_lake/underground_lake.contract');\nconst itemLavaCavePath = path.join(targetInkDir, 'lava_cave/lava_cave.contract');\nconst itemWhisperingCavePath = path.join(targetInkDir, 'whispering_cave/whispering_cave.contract');\nconst itemSubterraneanPoolPath = path.join(targetInkDir, 'subterranean_pool/subterranean_pool.contract');\nconst itemSpringPath = path.join(targetInkDir, 'spring/spring.contract');\nconst itemHotSpringPath = path.join(targetInkDir, 'hot_spring/hot_spring.contract');\nconst itemGrottoPath = path.join(targetInkDir, 'grotto/grotto.contract');\nconst itemFountainPath = path.join(targetInkDir, 'fountain/fountain.contract');\nconst itemSteamVentPath = path.join(targetInkDir, 'steam_vent/steam_vent.contract');\nconst itemCoolBreezePath = path.join(targetInkDir, 'cool_breeze/cool_breeze.contract');\nconst itemMonumentPath = path.join(targetInkDir, 'monument/monument.contract');\nconst itemWaterfallPath = path.join(targetInkDir, 'waterfall/waterfall.contract');\nconst itemEternalFlamePath = path.join(targetInkDir, 'eternal_flame/eternal_flame.contract');\nconst itemPillarOfWindPath = path.join(targetInkDir, 'pillar_of_wind/pillar_of_wind.contract');\nconst itemStreamPath = path.join(targetInkDir, 'stream/stream.contract');\nconst itemZephyrPath = path.join(targetInkDir, 'zephyr/zephyr.contract');\nconst itemCreekPath = path.join(targetInkDir, 'creek/creek.contract');\nconst itemBrookPath = path.join(targetInkDir, 'brook/brook.contract');\nconst itemWhisperPath = path.join(targetInkDir, 'whisper/whisper.contract');\nconst itemRivuletPath = path.join(targetInkDir, 'rivulet/rivulet.contract');\nconst itemTributaryPath = path.join(targetInkDir, 'tributary/tributary.contract');\nconst itemMurmurPath = path.join(targetInkDir, 'murmur/murmur.contract');\nconst itemWatershedPath = path.join(targetInkDir, 'watershed/watershed.contract');\nconst itemAquiferPath = path.join(targetInkDir, 'aquifer/aquifer.contract');\nconst itemParchedEarthPath = path.join(targetInkDir, 'parched_earth/parched_earth.contract');\nconst itemFreshBreezePath = path.join(targetInkDir, 'fresh_breeze/fresh_breeze.contract');\nconst itemGroundwaterPath = path.join(targetInkDir, 'groundwater/groundwater.contract');\nconst itemReservoirPath = path.join(targetInkDir, 'reservoir/reservoir.contract');\nconst itemGeothermalSpringPath = path.join(targetInkDir, 'geothermal_spring/geothermal_spring.contract');\nconst itemArtesianWellPath = path.join(targetInkDir, 'artesian_well/artesian_well.contract');\nconst itemBasinPath = path.join(targetInkDir, 'basin/basin.contract');\nconst itemLakePath = path.join(targetInkDir, 'lake/lake.contract');\nconst itemDryBasinPath = path.join(targetInkDir, 'dry_basin/dry_basin.contract');\nconst itemDepressionPath = path.join(targetInkDir, 'depression/depression.contract');\nconst itemIslandPath = path.join(targetInkDir, 'island/island.contract');\nconst itemLagoonPath = path.join(targetInkDir, 'lagoon/lagoon.contract');\nconst itemWavePath = path.join(targetInkDir, 'wave/wave.contract');\nconst itemReefPath = path.join(targetInkDir, 'reef/reef.contract');\nconst itemCoralPath = path.join(targetInkDir, 'coral/coral.contract');\nconst itemWhirlPath = path.join(targetInkDir, 'whirl/whirl.contract');\nconst itemLimestonePath = path.join(targetInkDir, 'limestone/limestone.contract');\nconst itemKarstPath = path.join(targetInkDir, 'karst/karst.contract');\nconst itemQuicklimePath = path.join(targetInkDir, 'quicklime/quicklime.contract');\nconst itemBlowholePath = path.join(targetInkDir, 'blowhole/blowhole.contract');\nconst gameUnifiersPath = path.join(targetInkDir, 'unifiers/unifiers.contract');\n\nif(fs.existsSync(itemMonkeyPath)) {\n    console.log(`Copying monkey ...`);\n    fs.copyFileSync(itemMonkeyPath, path.join(contractsV1Dir, 'monkey.contract.json'));\n} else {\n    console.log(`monkey not found`);\n}\nif(fs.existsSync(itemGiraffePath)) {\n    console.log(`Copying giraffe ...`);\n    fs.copyFileSync(itemGiraffePath, path.join(contractsV1Dir, 'giraffe.contract.json'));\n} else {\n    console.log(`giraffe not found`);\n}\nif(fs.existsSync(itemBeePath)) {\n    console.log(`Copying bee ...`);\n    fs.copyFileSync(itemBeePath, path.join(contractsV1Dir, 'bee.contract.json'));\n} else {\n    console.log(`bee not found`);\n}\nif(fs.existsSync(itemCoinPath)) {\n    console.log(`Copying coin ...`);\n    fs.copyFileSync(itemCoinPath, path.join(contractsV1Dir, 'coin.contract.json'));\n} else {\n    console.log(`coin not found`);\n}\nif(fs.existsSync(itemSwarmPath)) {\n    console.log(`Copying swarm ...`);\n    fs.copyFileSync(itemSwarmPath, path.join(contractsV1Dir, 'swarm.contract.json'));\n} else {\n    console.log(`swarm not found`);\n}\nif(fs.existsSync(itemHydraPath)) {\n    console.log(`Copying hydra ...`);\n    fs.copyFileSync(itemHydraPath, path.join(contractsV1Dir, 'hydra.contract.json'));\n} else {\n    console.log(`hydra not found`);\n}\nif(fs.existsSync(itemMonkeyBranchPath)) {\n    console.log(`Copying monkey_branch ...`);\n    fs.copyFileSync(itemMonkeyBranchPath, path.join(contractsV1Dir, 'monkey_branch.contract.json'));\n} else {\n    console.log(`monkey_branch not found`);\n}\nif(fs.existsSync(itemBridgePath)) {\n    console.log(`Copying bridge ...`);\n    fs.copyFileSync(itemBridgePath, path.join(contractsV1Dir, 'bridge.contract.json'));\n} else {\n    console.log(`bridge not found`);\n}\nif(fs.existsSync(itemGoldenGatePath)) {\n    console.log(`Copying golden_gate ...`);\n    fs.copyFileSync(itemGoldenGatePath, path.join(contractsV1Dir, 'golden_gate.contract.json'));\n} else {\n    console.log(`golden_gate not found`);\n}\nif(fs.existsSync(itemGoldPath)) {\n    console.log(`Copying gold ...`);\n    fs.copyFileSync(itemGoldPath, path.join(contractsV1Dir, 'gold.contract.json'));\n} else {\n    console.log(`gold not found`);\n}\nif(fs.existsSync(itemSilverPath)) {\n    console.log(`Copying silver ...`);\n    fs.copyFileSync(itemSilverPath, path.join(contractsV1Dir, 'silver.contract.json'));\n} else {\n    console.log(`silver not found`);\n}\nif(fs.existsSync(itemRhodiumPath)) {\n    console.log(`Copying rhodium ...`);\n    fs.copyFileSync(itemRhodiumPath, path.join(contractsV1Dir, 'rhodium.contract.json'));\n} else {\n    console.log(`rhodium not found`);\n}\nif(fs.existsSync(itemHivePath)) {\n    console.log(`Copying hive ...`);\n    fs.copyFileSync(itemHivePath, path.join(contractsV1Dir, 'hive.contract.json'));\n} else {\n    console.log(`hive not found`);\n}\nif(fs.existsSync(itemTransactionPath)) {\n    console.log(`Copying transaction ...`);\n    fs.copyFileSync(itemTransactionPath, path.join(contractsV1Dir, 'transaction.contract.json'));\n} else {\n    console.log(`transaction not found`);\n}\nif(fs.existsSync(itemBlockPath)) {\n    console.log(`Copying block ...`);\n    fs.copyFileSync(itemBlockPath, path.join(contractsV1Dir, 'block.contract.json'));\n} else {\n    console.log(`block not found`);\n}\nif(fs.existsSync(itemBlockchainPath)) {\n    console.log(`Copying blockchain ...`);\n    fs.copyFileSync(itemBlockchainPath, path.join(contractsV1Dir, 'blockchain.contract.json'));\n} else {\n    console.log(`blockchain not found`);\n}\nif(fs.existsSync(itemPolkadotPath)) {\n    console.log(`Copying polkadot ...`);\n    fs.copyFileSync(itemPolkadotPath, path.join(contractsV1Dir, 'polkadot.contract.json'));\n} else {\n    console.log(`polkadot not found`);\n}\nif(fs.existsSync(itemPeerReviewPath)) {\n    console.log(`Copying peer_review ...`);\n    fs.copyFileSync(itemPeerReviewPath, path.join(contractsV1Dir, 'peer_review.contract.json'));\n} else {\n    console.log(`peer_review not found`);\n}\nif(fs.existsSync(itemCardanoPath)) {\n    console.log(`Copying cardano ...`);\n    fs.copyFileSync(itemCardanoPath, path.join(contractsV1Dir, 'cardano.contract.json'));\n} else {\n    console.log(`cardano not found`);\n}\nif(fs.existsSync(itemBearPath)) {\n    console.log(`Copying bear ...`);\n    fs.copyFileSync(itemBearPath, path.join(contractsV1Dir, 'bear.contract.json'));\n} else {\n    console.log(`bear not found`);\n}\nif(fs.existsSync(itemBeerPath)) {\n    console.log(`Copying beer ...`);\n    fs.copyFileSync(itemBeerPath, path.join(contractsV1Dir, 'beer.contract.json'));\n} else {\n    console.log(`beer not found`);\n}\nif(fs.existsSync(itemLockPath)) {\n    console.log(`Copying lock ...`);\n    fs.copyFileSync(itemLockPath, path.join(contractsV1Dir, 'lock.contract.json'));\n} else {\n    console.log(`lock not found`);\n}\nif(fs.existsSync(itemMarmaladePath)) {\n    console.log(`Copying marmalade ...`);\n    fs.copyFileSync(itemMarmaladePath, path.join(contractsV1Dir, 'marmalade.contract.json'));\n} else {\n    console.log(`marmalade not found`);\n}\nif(fs.existsSync(itemSuperMarmaladePath)) {\n    console.log(`Copying super_marmalade ...`);\n    fs.copyFileSync(itemSuperMarmaladePath, path.join(contractsV1Dir, 'super_marmalade.contract.json'));\n} else {\n    console.log(`super_marmalade not found`);\n}\nif(fs.existsSync(itemHyperMarmaladePath)) {\n    console.log(`Copying hyper_marmalade ...`);\n    fs.copyFileSync(itemHyperMarmaladePath, path.join(contractsV1Dir, 'hyper_marmalade.contract.json'));\n} else {\n    console.log(`hyper_marmalade not found`);\n}\nif(fs.existsSync(itemWaterPath)) {\n    console.log(`Copying water ...`);\n    fs.copyFileSync(itemWaterPath, path.join(contractsV1Dir, 'water.contract.json'));\n} else {\n    console.log(`water not found`);\n}\nif(fs.existsSync(itemFirePath)) {\n    console.log(`Copying fire ...`);\n    fs.copyFileSync(itemFirePath, path.join(contractsV1Dir, 'fire.contract.json'));\n} else {\n    console.log(`fire not found`);\n}\nif(fs.existsSync(itemSteamPath)) {\n    console.log(`Copying steam ...`);\n    fs.copyFileSync(itemSteamPath, path.join(contractsV1Dir, 'steam.contract.json'));\n} else {\n    console.log(`steam not found`);\n}\nif(fs.existsSync(itemEarthPath)) {\n    console.log(`Copying earth ...`);\n    fs.copyFileSync(itemEarthPath, path.join(contractsV1Dir, 'earth.contract.json'));\n} else {\n    console.log(`earth not found`);\n}\nif(fs.existsSync(itemMudPath)) {\n    console.log(`Copying mud ...`);\n    fs.copyFileSync(itemMudPath, path.join(contractsV1Dir, 'mud.contract.json'));\n} else {\n    console.log(`mud not found`);\n}\nif(fs.existsSync(itemLavaPath)) {\n    console.log(`Copying lava ...`);\n    fs.copyFileSync(itemLavaPath, path.join(contractsV1Dir, 'lava.contract.json'));\n} else {\n    console.log(`lava not found`);\n}\nif(fs.existsSync(itemWindPath)) {\n    console.log(`Copying wind ...`);\n    fs.copyFileSync(itemWindPath, path.join(contractsV1Dir, 'wind.contract.json'));\n} else {\n    console.log(`wind not found`);\n}\nif(fs.existsSync(itemDustPath)) {\n    console.log(`Copying dust ...`);\n    fs.copyFileSync(itemDustPath, path.join(contractsV1Dir, 'dust.contract.json'));\n} else {\n    console.log(`dust not found`);\n}\nif(fs.existsSync(itemRainPath)) {\n    console.log(`Copying rain ...`);\n    fs.copyFileSync(itemRainPath, path.join(contractsV1Dir, 'rain.contract.json'));\n} else {\n    console.log(`rain not found`);\n}\nif(fs.existsSync(itemSmokePath)) {\n    console.log(`Copying smoke ...`);\n    fs.copyFileSync(itemSmokePath, path.join(contractsV1Dir, 'smoke.contract.json'));\n} else {\n    console.log(`smoke not found`);\n}\nif(fs.existsSync(itemGeyserPath)) {\n    console.log(`Copying geyser ...`);\n    fs.copyFileSync(itemGeyserPath, path.join(contractsV1Dir, 'geyser.contract.json'));\n} else {\n    console.log(`geyser not found`);\n}\nif(fs.existsSync(itemClayPath)) {\n    console.log(`Copying clay ...`);\n    fs.copyFileSync(itemClayPath, path.join(contractsV1Dir, 'clay.contract.json'));\n} else {\n    console.log(`clay not found`);\n}\nif(fs.existsSync(itemSandPath)) {\n    console.log(`Copying sand ...`);\n    fs.copyFileSync(itemSandPath, path.join(contractsV1Dir, 'sand.contract.json'));\n} else {\n    console.log(`sand not found`);\n}\nif(fs.existsSync(itemPlantPath)) {\n    console.log(`Copying plant ...`);\n    fs.copyFileSync(itemPlantPath, path.join(contractsV1Dir, 'plant.contract.json'));\n} else {\n    console.log(`plant not found`);\n}\nif(fs.existsSync(itemRainbowPath)) {\n    console.log(`Copying rainbow ...`);\n    fs.copyFileSync(itemRainbowPath, path.join(contractsV1Dir, 'rainbow.contract.json'));\n} else {\n    console.log(`rainbow not found`);\n}\nif(fs.existsSync(itemStormPath)) {\n    console.log(`Copying storm ...`);\n    fs.copyFileSync(itemStormPath, path.join(contractsV1Dir, 'storm.contract.json'));\n} else {\n    console.log(`storm not found`);\n}\nif(fs.existsSync(itemObsidianPath)) {\n    console.log(`Copying obsidian ...`);\n    fs.copyFileSync(itemObsidianPath, path.join(contractsV1Dir, 'obsidian.contract.json'));\n} else {\n    console.log(`obsidian not found`);\n}\nif(fs.existsSync(itemAshPath)) {\n    console.log(`Copying ash ...`);\n    fs.copyFileSync(itemAshPath, path.join(contractsV1Dir, 'ash.contract.json'));\n} else {\n    console.log(`ash not found`);\n}\nif(fs.existsSync(itemVolcanoPath)) {\n    console.log(`Copying volcano ...`);\n    fs.copyFileSync(itemVolcanoPath, path.join(contractsV1Dir, 'volcano.contract.json'));\n} else {\n    console.log(`volcano not found`);\n}\nif(fs.existsSync(itemSandstormPath)) {\n    console.log(`Copying sandstorm ...`);\n    fs.copyFileSync(itemSandstormPath, path.join(contractsV1Dir, 'sandstorm.contract.json'));\n} else {\n    console.log(`sandstorm not found`);\n}\nif(fs.existsSync(itemCloudPath)) {\n    console.log(`Copying cloud ...`);\n    fs.copyFileSync(itemCloudPath, path.join(contractsV1Dir, 'cloud.contract.json'));\n} else {\n    console.log(`cloud not found`);\n}\nif(fs.existsSync(itemFogPath)) {\n    console.log(`Copying fog ...`);\n    fs.copyFileSync(itemFogPath, path.join(contractsV1Dir, 'fog.contract.json'));\n} else {\n    console.log(`fog not found`);\n}\nif(fs.existsSync(itemTreePath)) {\n    console.log(`Copying tree ...`);\n    fs.copyFileSync(itemTreePath, path.join(contractsV1Dir, 'tree.contract.json'));\n} else {\n    console.log(`tree not found`);\n}\nif(fs.existsSync(itemForestPath)) {\n    console.log(`Copying forest ...`);\n    fs.copyFileSync(itemForestPath, path.join(contractsV1Dir, 'forest.contract.json'));\n} else {\n    console.log(`forest not found`);\n}\nif(fs.existsSync(itemSeedsPath)) {\n    console.log(`Copying seeds ...`);\n    fs.copyFileSync(itemSeedsPath, path.join(contractsV1Dir, 'seeds.contract.json'));\n} else {\n    console.log(`seeds not found`);\n}\nif(fs.existsSync(itemPotteryPath)) {\n    console.log(`Copying pottery ...`);\n    fs.copyFileSync(itemPotteryPath, path.join(contractsV1Dir, 'pottery.contract.json'));\n} else {\n    console.log(`pottery not found`);\n}\nif(fs.existsSync(itemBrickPath)) {\n    console.log(`Copying brick ...`);\n    fs.copyFileSync(itemBrickPath, path.join(contractsV1Dir, 'brick.contract.json'));\n} else {\n    console.log(`brick not found`);\n}\nif(fs.existsSync(itemQuicksandPath)) {\n    console.log(`Copying quicksand ...`);\n    fs.copyFileSync(itemQuicksandPath, path.join(contractsV1Dir, 'quicksand.contract.json'));\n} else {\n    console.log(`quicksand not found`);\n}\nif(fs.existsSync(itemGlassPath)) {\n    console.log(`Copying glass ...`);\n    fs.copyFileSync(itemGlassPath, path.join(contractsV1Dir, 'glass.contract.json'));\n} else {\n    console.log(`glass not found`);\n}\nif(fs.existsSync(itemDunePath)) {\n    console.log(`Copying dune ...`);\n    fs.copyFileSync(itemDunePath, path.join(contractsV1Dir, 'dune.contract.json'));\n} else {\n    console.log(`dune not found`);\n}\nif(fs.existsSync(itemCharcoalPath)) {\n    console.log(`Copying charcoal ...`);\n    fs.copyFileSync(itemCharcoalPath, path.join(contractsV1Dir, 'charcoal.contract.json'));\n} else {\n    console.log(`charcoal not found`);\n}\nif(fs.existsSync(itemLeavesPath)) {\n    console.log(`Copying leaves ...`);\n    fs.copyFileSync(itemLeavesPath, path.join(contractsV1Dir, 'leaves.contract.json'));\n} else {\n    console.log(`leaves not found`);\n}\nif(fs.existsSync(itemWildfirePath)) {\n    console.log(`Copying wildfire ...`);\n    fs.copyFileSync(itemWildfirePath, path.join(contractsV1Dir, 'wildfire.contract.json'));\n} else {\n    console.log(`wildfire not found`);\n}\nif(fs.existsSync(itemJunglePath)) {\n    console.log(`Copying jungle ...`);\n    fs.copyFileSync(itemJunglePath, path.join(contractsV1Dir, 'jungle.contract.json'));\n} else {\n    console.log(`jungle not found`);\n}\nif(fs.existsSync(itemFrostedGlassPath)) {\n    console.log(`Copying frosted_glass ...`);\n    fs.copyFileSync(itemFrostedGlassPath, path.join(contractsV1Dir, 'frosted_glass.contract.json'));\n} else {\n    console.log(`frosted_glass not found`);\n}\nif(fs.existsSync(itemCrystalPath)) {\n    console.log(`Copying crystal ...`);\n    fs.copyFileSync(itemCrystalPath, path.join(contractsV1Dir, 'crystal.contract.json'));\n} else {\n    console.log(`crystal not found`);\n}\nif(fs.existsSync(itemMagmaPath)) {\n    console.log(`Copying magma ...`);\n    fs.copyFileSync(itemMagmaPath, path.join(contractsV1Dir, 'magma.contract.json'));\n} else {\n    console.log(`magma not found`);\n}\nif(fs.existsSync(itemRockPath)) {\n    console.log(`Copying rock ...`);\n    fs.copyFileSync(itemRockPath, path.join(contractsV1Dir, 'rock.contract.json'));\n} else {\n    console.log(`rock not found`);\n}\nif(fs.existsSync(itemShardPath)) {\n    console.log(`Copying shard ...`);\n    fs.copyFileSync(itemShardPath, path.join(contractsV1Dir, 'shard.contract.json'));\n} else {\n    console.log(`shard not found`);\n}\nif(fs.existsSync(itemPebblePath)) {\n    console.log(`Copying pebble ...`);\n    fs.copyFileSync(itemPebblePath, path.join(contractsV1Dir, 'pebble.contract.json'));\n} else {\n    console.log(`pebble not found`);\n}\nif(fs.existsSync(itemMountainPath)) {\n    console.log(`Copying mountain ...`);\n    fs.copyFileSync(itemMountainPath, path.join(contractsV1Dir, 'mountain.contract.json'));\n} else {\n    console.log(`mountain not found`);\n}\nif(fs.existsSync(itemFertilizerPath)) {\n    console.log(`Copying fertilizer ...`);\n    fs.copyFileSync(itemFertilizerPath, path.join(contractsV1Dir, 'fertilizer.contract.json'));\n} else {\n    console.log(`fertilizer not found`);\n}\nif(fs.existsSync(itemSootPath)) {\n    console.log(`Copying soot ...`);\n    fs.copyFileSync(itemSootPath, path.join(contractsV1Dir, 'soot.contract.json'));\n} else {\n    console.log(`soot not found`);\n}\nif(fs.existsSync(itemLightningPath)) {\n    console.log(`Copying lightning ...`);\n    fs.copyFileSync(itemLightningPath, path.join(contractsV1Dir, 'lightning.contract.json'));\n} else {\n    console.log(`lightning not found`);\n}\nif(fs.existsSync(itemMistPath)) {\n    console.log(`Copying mist ...`);\n    fs.copyFileSync(itemMistPath, path.join(contractsV1Dir, 'mist.contract.json'));\n} else {\n    console.log(`mist not found`);\n}\nif(fs.existsSync(itemHazePath)) {\n    console.log(`Copying haze ...`);\n    fs.copyFileSync(itemHazePath, path.join(contractsV1Dir, 'haze.contract.json'));\n} else {\n    console.log(`haze not found`);\n}\nif(fs.existsSync(itemFloodPath)) {\n    console.log(`Copying flood ...`);\n    fs.copyFileSync(itemFloodPath, path.join(contractsV1Dir, 'flood.contract.json'));\n} else {\n    console.log(`flood not found`);\n}\nif(fs.existsSync(itemLandslidePath)) {\n    console.log(`Copying landslide ...`);\n    fs.copyFileSync(itemLandslidePath, path.join(contractsV1Dir, 'landslide.contract.json'));\n} else {\n    console.log(`landslide not found`);\n}\nif(fs.existsSync(itemThunderPath)) {\n    console.log(`Copying thunder ...`);\n    fs.copyFileSync(itemThunderPath, path.join(contractsV1Dir, 'thunder.contract.json'));\n} else {\n    console.log(`thunder not found`);\n}\nif(fs.existsSync(itemTornadoPath)) {\n    console.log(`Copying tornado ...`);\n    fs.copyFileSync(itemTornadoPath, path.join(contractsV1Dir, 'tornado.contract.json'));\n} else {\n    console.log(`tornado not found`);\n}\nif(fs.existsSync(itemGardenPath)) {\n    console.log(`Copying garden ...`);\n    fs.copyFileSync(itemGardenPath, path.join(contractsV1Dir, 'garden.contract.json'));\n} else {\n    console.log(`garden not found`);\n}\nif(fs.existsSync(itemEmberPath)) {\n    console.log(`Copying ember ...`);\n    fs.copyFileSync(itemEmberPath, path.join(contractsV1Dir, 'ember.contract.json'));\n} else {\n    console.log(`ember not found`);\n}\nif(fs.existsSync(itemKilnPath)) {\n    console.log(`Copying kiln ...`);\n    fs.copyFileSync(itemKilnPath, path.join(contractsV1Dir, 'kiln.contract.json'));\n} else {\n    console.log(`kiln not found`);\n}\nif(fs.existsSync(itemPollinationPath)) {\n    console.log(`Copying pollination ...`);\n    fs.copyFileSync(itemPollinationPath, path.join(contractsV1Dir, 'pollination.contract.json'));\n} else {\n    console.log(`pollination not found`);\n}\nif(fs.existsSync(itemSinkholePath)) {\n    console.log(`Copying sinkhole ...`);\n    fs.copyFileSync(itemSinkholePath, path.join(contractsV1Dir, 'sinkhole.contract.json'));\n} else {\n    console.log(`sinkhole not found`);\n}\nif(fs.existsSync(itemBeachPath)) {\n    console.log(`Copying beach ...`);\n    fs.copyFileSync(itemBeachPath, path.join(contractsV1Dir, 'beach.contract.json'));\n} else {\n    console.log(`beach not found`);\n}\nif(fs.existsSync(itemWetstonePath)) {\n    console.log(`Copying wetstone ...`);\n    fs.copyFileSync(itemWetstonePath, path.join(contractsV1Dir, 'wetstone.contract.json'));\n} else {\n    console.log(`wetstone not found`);\n}\nif(fs.existsSync(itemErosionPath)) {\n    console.log(`Copying erosion ...`);\n    fs.copyFileSync(itemErosionPath, path.join(contractsV1Dir, 'erosion.contract.json'));\n} else {\n    console.log(`erosion not found`);\n}\nif(fs.existsSync(itemBasaltPath)) {\n    console.log(`Copying basalt ...`);\n    fs.copyFileSync(itemBasaltPath, path.join(contractsV1Dir, 'basalt.contract.json'));\n} else {\n    console.log(`basalt not found`);\n}\nif(fs.existsSync(itemMagmaChamberPath)) {\n    console.log(`Copying magma_chamber ...`);\n    fs.copyFileSync(itemMagmaChamberPath, path.join(contractsV1Dir, 'magma_chamber.contract.json'));\n} else {\n    console.log(`magma_chamber not found`);\n}\nif(fs.existsSync(itemBreezePath)) {\n    console.log(`Copying breeze ...`);\n    fs.copyFileSync(itemBreezePath, path.join(contractsV1Dir, 'breeze.contract.json'));\n} else {\n    console.log(`breeze not found`);\n}\nif(fs.existsSync(itemWarmBreezePath)) {\n    console.log(`Copying warm_breeze ...`);\n    fs.copyFileSync(itemWarmBreezePath, path.join(contractsV1Dir, 'warm_breeze.contract.json'));\n} else {\n    console.log(`warm_breeze not found`);\n}\nif(fs.existsSync(itemSoilPath)) {\n    console.log(`Copying soil ...`);\n    fs.copyFileSync(itemSoilPath, path.join(contractsV1Dir, 'soil.contract.json'));\n} else {\n    console.log(`soil not found`);\n}\nif(fs.existsSync(itemCanyonPath)) {\n    console.log(`Copying canyon ...`);\n    fs.copyFileSync(itemCanyonPath, path.join(contractsV1Dir, 'canyon.contract.json'));\n} else {\n    console.log(`canyon not found`);\n}\nif(fs.existsSync(itemWindmillPath)) {\n    console.log(`Copying windmill ...`);\n    fs.copyFileSync(itemWindmillPath, path.join(contractsV1Dir, 'windmill.contract.json'));\n} else {\n    console.log(`windmill not found`);\n}\nif(fs.existsSync(itemAdobePath)) {\n    console.log(`Copying adobe ...`);\n    fs.copyFileSync(itemAdobePath, path.join(contractsV1Dir, 'adobe.contract.json'));\n} else {\n    console.log(`adobe not found`);\n}\nif(fs.existsSync(itemWallPath)) {\n    console.log(`Copying wall ...`);\n    fs.copyFileSync(itemWallPath, path.join(contractsV1Dir, 'wall.contract.json'));\n} else {\n    console.log(`wall not found`);\n}\nif(fs.existsSync(itemPumicePath)) {\n    console.log(`Copying pumice ...`);\n    fs.copyFileSync(itemPumicePath, path.join(contractsV1Dir, 'pumice.contract.json'));\n} else {\n    console.log(`pumice not found`);\n}\nif(fs.existsSync(itemBarbecuePath)) {\n    console.log(`Copying barbecue ...`);\n    fs.copyFileSync(itemBarbecuePath, path.join(contractsV1Dir, 'barbecue.contract.json'));\n} else {\n    console.log(`barbecue not found`);\n}\nif(fs.existsSync(itemFarmPath)) {\n    console.log(`Copying farm ...`);\n    fs.copyFileSync(itemFarmPath, path.join(contractsV1Dir, 'farm.contract.json'));\n} else {\n    console.log(`farm not found`);\n}\nif(fs.existsSync(itemShardsPath)) {\n    console.log(`Copying shards ...`);\n    fs.copyFileSync(itemShardsPath, path.join(contractsV1Dir, 'shards.contract.json'));\n} else {\n    console.log(`shards not found`);\n}\nif(fs.existsSync(itemMoltenGlassPath)) {\n    console.log(`Copying molten_glass ...`);\n    fs.copyFileSync(itemMoltenGlassPath, path.join(contractsV1Dir, 'molten_glass.contract.json'));\n} else {\n    console.log(`molten_glass not found`);\n}\nif(fs.existsSync(itemPrismPath)) {\n    console.log(`Copying prism ...`);\n    fs.copyFileSync(itemPrismPath, path.join(contractsV1Dir, 'prism.contract.json'));\n} else {\n    console.log(`prism not found`);\n}\nif(fs.existsSync(itemSparklePath)) {\n    console.log(`Copying sparkle ...`);\n    fs.copyFileSync(itemSparklePath, path.join(contractsV1Dir, 'sparkle.contract.json'));\n} else {\n    console.log(`sparkle not found`);\n}\nif(fs.existsSync(itemDesertPath)) {\n    console.log(`Copying desert ...`);\n    fs.copyFileSync(itemDesertPath, path.join(contractsV1Dir, 'desert.contract.json'));\n} else {\n    console.log(`desert not found`);\n}\nif(fs.existsSync(itemOasisPath)) {\n    console.log(`Copying oasis ...`);\n    fs.copyFileSync(itemOasisPath, path.join(contractsV1Dir, 'oasis.contract.json'));\n} else {\n    console.log(`oasis not found`);\n}\nif(fs.existsSync(itemMiragePath)) {\n    console.log(`Copying mirage ...`);\n    fs.copyFileSync(itemMiragePath, path.join(contractsV1Dir, 'mirage.contract.json'));\n} else {\n    console.log(`mirage not found`);\n}\nif(fs.existsSync(itemSandDunePath)) {\n    console.log(`Copying sand_dune ...`);\n    fs.copyFileSync(itemSandDunePath, path.join(contractsV1Dir, 'sand_dune.contract.json'));\n} else {\n    console.log(`sand_dune not found`);\n}\nif(fs.existsSync(itemDamPath)) {\n    console.log(`Copying dam ...`);\n    fs.copyFileSync(itemDamPath, path.join(contractsV1Dir, 'dam.contract.json'));\n} else {\n    console.log(`dam not found`);\n}\nif(fs.existsSync(itemFirewallPath)) {\n    console.log(`Copying firewall ...`);\n    fs.copyFileSync(itemFirewallPath, path.join(contractsV1Dir, 'firewall.contract.json'));\n} else {\n    console.log(`firewall not found`);\n}\nif(fs.existsSync(itemBarricadePath)) {\n    console.log(`Copying barricade ...`);\n    fs.copyFileSync(itemBarricadePath, path.join(contractsV1Dir, 'barricade.contract.json'));\n} else {\n    console.log(`barricade not found`);\n}\nif(fs.existsSync(itemPlateauPath)) {\n    console.log(`Copying plateau ...`);\n    fs.copyFileSync(itemPlateauPath, path.join(contractsV1Dir, 'plateau.contract.json'));\n} else {\n    console.log(`plateau not found`);\n}\nif(fs.existsSync(itemPondPath)) {\n    console.log(`Copying pond ...`);\n    fs.copyFileSync(itemPondPath, path.join(contractsV1Dir, 'pond.contract.json'));\n} else {\n    console.log(`pond not found`);\n}\nif(fs.existsSync(itemAromasPath)) {\n    console.log(`Copying aromas ...`);\n    fs.copyFileSync(itemAromasPath, path.join(contractsV1Dir, 'aromas.contract.json'));\n} else {\n    console.log(`aromas not found`);\n}\nif(fs.existsSync(itemFlowerPath)) {\n    console.log(`Copying flower ...`);\n    fs.copyFileSync(itemFlowerPath, path.join(contractsV1Dir, 'flower.contract.json'));\n} else {\n    console.log(`flower not found`);\n}\nif(fs.existsSync(itemSporePath)) {\n    console.log(`Copying spore ...`);\n    fs.copyFileSync(itemSporePath, path.join(contractsV1Dir, 'spore.contract.json'));\n} else {\n    console.log(`spore not found`);\n}\nif(fs.existsSync(itemSpreadPath)) {\n    console.log(`Copying spread ...`);\n    fs.copyFileSync(itemSpreadPath, path.join(contractsV1Dir, 'spread.contract.json'));\n} else {\n    console.log(`spread not found`);\n}\nif(fs.existsSync(itemFertileLandPath)) {\n    console.log(`Copying fertile_land ...`);\n    fs.copyFileSync(itemFertileLandPath, path.join(contractsV1Dir, 'fertile_land.contract.json'));\n} else {\n    console.log(`fertile_land not found`);\n}\nif(fs.existsSync(itemWetlandPath)) {\n    console.log(`Copying wetland ...`);\n    fs.copyFileSync(itemWetlandPath, path.join(contractsV1Dir, 'wetland.contract.json'));\n} else {\n    console.log(`wetland not found`);\n}\nif(fs.existsSync(itemPeatPath)) {\n    console.log(`Copying peat ...`);\n    fs.copyFileSync(itemPeatPath, path.join(contractsV1Dir, 'peat.contract.json'));\n} else {\n    console.log(`peat not found`);\n}\nif(fs.existsSync(itemReedsPath)) {\n    console.log(`Copying reeds ...`);\n    fs.copyFileSync(itemReedsPath, path.join(contractsV1Dir, 'reeds.contract.json'));\n} else {\n    console.log(`reeds not found`);\n}\nif(fs.existsSync(itemValleyPath)) {\n    console.log(`Copying valley ...`);\n    fs.copyFileSync(itemValleyPath, path.join(contractsV1Dir, 'valley.contract.json'));\n} else {\n    console.log(`valley not found`);\n}\nif(fs.existsSync(itemRiverPath)) {\n    console.log(`Copying river ...`);\n    fs.copyFileSync(itemRiverPath, path.join(contractsV1Dir, 'river.contract.json'));\n} else {\n    console.log(`river not found`);\n}\nif(fs.existsSync(itemScorchedEarthPath)) {\n    console.log(`Copying scorched_earth ...`);\n    fs.copyFileSync(itemScorchedEarthPath, path.join(contractsV1Dir, 'scorched_earth.contract.json'));\n} else {\n    console.log(`scorched_earth not found`);\n}\nif(fs.existsSync(itemDeltaPath)) {\n    console.log(`Copying delta ...`);\n    fs.copyFileSync(itemDeltaPath, path.join(contractsV1Dir, 'delta.contract.json'));\n} else {\n    console.log(`delta not found`);\n}\nif(fs.existsSync(itemEstuaryPath)) {\n    console.log(`Copying estuary ...`);\n    fs.copyFileSync(itemEstuaryPath, path.join(contractsV1Dir, 'estuary.contract.json'));\n} else {\n    console.log(`estuary not found`);\n}\nif(fs.existsSync(itemFireSwampPath)) {\n    console.log(`Copying fire_swamp ...`);\n    fs.copyFileSync(itemFireSwampPath, path.join(contractsV1Dir, 'fire_swamp.contract.json'));\n} else {\n    console.log(`fire_swamp not found`);\n}\nif(fs.existsSync(itemRiverbankPath)) {\n    console.log(`Copying riverbank ...`);\n    fs.copyFileSync(itemRiverbankPath, path.join(contractsV1Dir, 'riverbank.contract.json'));\n} else {\n    console.log(`riverbank not found`);\n}\nif(fs.existsSync(itemRavinePath)) {\n    console.log(`Copying ravine ...`);\n    fs.copyFileSync(itemRavinePath, path.join(contractsV1Dir, 'ravine.contract.json'));\n} else {\n    console.log(`ravine not found`);\n}\nif(fs.existsSync(itemGorgePath)) {\n    console.log(`Copying gorge ...`);\n    fs.copyFileSync(itemGorgePath, path.join(contractsV1Dir, 'gorge.contract.json'));\n} else {\n    console.log(`gorge not found`);\n}\nif(fs.existsSync(itemCharredRavinePath)) {\n    console.log(`Copying charred_ravine ...`);\n    fs.copyFileSync(itemCharredRavinePath, path.join(contractsV1Dir, 'charred_ravine.contract.json'));\n} else {\n    console.log(`charred_ravine not found`);\n}\nif(fs.existsSync(itemEchoPath)) {\n    console.log(`Copying echo ...`);\n    fs.copyFileSync(itemEchoPath, path.join(contractsV1Dir, 'echo.contract.json'));\n} else {\n    console.log(`echo not found`);\n}\nif(fs.existsSync(itemCavePath)) {\n    console.log(`Copying cave ...`);\n    fs.copyFileSync(itemCavePath, path.join(contractsV1Dir, 'cave.contract.json'));\n} else {\n    console.log(`cave not found`);\n}\nif(fs.existsSync(itemUndergroundLakePath)) {\n    console.log(`Copying underground_lake ...`);\n    fs.copyFileSync(itemUndergroundLakePath, path.join(contractsV1Dir, 'underground_lake.contract.json'));\n} else {\n    console.log(`underground_lake not found`);\n}\nif(fs.existsSync(itemLavaCavePath)) {\n    console.log(`Copying lava_cave ...`);\n    fs.copyFileSync(itemLavaCavePath, path.join(contractsV1Dir, 'lava_cave.contract.json'));\n} else {\n    console.log(`lava_cave not found`);\n}\nif(fs.existsSync(itemWhisperingCavePath)) {\n    console.log(`Copying whispering_cave ...`);\n    fs.copyFileSync(itemWhisperingCavePath, path.join(contractsV1Dir, 'whispering_cave.contract.json'));\n} else {\n    console.log(`whispering_cave not found`);\n}\nif(fs.existsSync(itemSubterraneanPoolPath)) {\n    console.log(`Copying subterranean_pool ...`);\n    fs.copyFileSync(itemSubterraneanPoolPath, path.join(contractsV1Dir, 'subterranean_pool.contract.json'));\n} else {\n    console.log(`subterranean_pool not found`);\n}\nif(fs.existsSync(itemSpringPath)) {\n    console.log(`Copying spring ...`);\n    fs.copyFileSync(itemSpringPath, path.join(contractsV1Dir, 'spring.contract.json'));\n} else {\n    console.log(`spring not found`);\n}\nif(fs.existsSync(itemHotSpringPath)) {\n    console.log(`Copying hot_spring ...`);\n    fs.copyFileSync(itemHotSpringPath, path.join(contractsV1Dir, 'hot_spring.contract.json'));\n} else {\n    console.log(`hot_spring not found`);\n}\nif(fs.existsSync(itemGrottoPath)) {\n    console.log(`Copying grotto ...`);\n    fs.copyFileSync(itemGrottoPath, path.join(contractsV1Dir, 'grotto.contract.json'));\n} else {\n    console.log(`grotto not found`);\n}\nif(fs.existsSync(itemFountainPath)) {\n    console.log(`Copying fountain ...`);\n    fs.copyFileSync(itemFountainPath, path.join(contractsV1Dir, 'fountain.contract.json'));\n} else {\n    console.log(`fountain not found`);\n}\nif(fs.existsSync(itemSteamVentPath)) {\n    console.log(`Copying steam_vent ...`);\n    fs.copyFileSync(itemSteamVentPath, path.join(contractsV1Dir, 'steam_vent.contract.json'));\n} else {\n    console.log(`steam_vent not found`);\n}\nif(fs.existsSync(itemCoolBreezePath)) {\n    console.log(`Copying cool_breeze ...`);\n    fs.copyFileSync(itemCoolBreezePath, path.join(contractsV1Dir, 'cool_breeze.contract.json'));\n} else {\n    console.log(`cool_breeze not found`);\n}\nif(fs.existsSync(itemMonumentPath)) {\n    console.log(`Copying monument ...`);\n    fs.copyFileSync(itemMonumentPath, path.join(contractsV1Dir, 'monument.contract.json'));\n} else {\n    console.log(`monument not found`);\n}\nif(fs.existsSync(itemWaterfallPath)) {\n    console.log(`Copying waterfall ...`);\n    fs.copyFileSync(itemWaterfallPath, path.join(contractsV1Dir, 'waterfall.contract.json'));\n} else {\n    console.log(`waterfall not found`);\n}\nif(fs.existsSync(itemEternalFlamePath)) {\n    console.log(`Copying eternal_flame ...`);\n    fs.copyFileSync(itemEternalFlamePath, path.join(contractsV1Dir, 'eternal_flame.contract.json'));\n} else {\n    console.log(`eternal_flame not found`);\n}\nif(fs.existsSync(itemPillarOfWindPath)) {\n    console.log(`Copying pillar_of_wind ...`);\n    fs.copyFileSync(itemPillarOfWindPath, path.join(contractsV1Dir, 'pillar_of_wind.contract.json'));\n} else {\n    console.log(`pillar_of_wind not found`);\n}\nif(fs.existsSync(itemStreamPath)) {\n    console.log(`Copying stream ...`);\n    fs.copyFileSync(itemStreamPath, path.join(contractsV1Dir, 'stream.contract.json'));\n} else {\n    console.log(`stream not found`);\n}\nif(fs.existsSync(itemZephyrPath)) {\n    console.log(`Copying zephyr ...`);\n    fs.copyFileSync(itemZephyrPath, path.join(contractsV1Dir, 'zephyr.contract.json'));\n} else {\n    console.log(`zephyr not found`);\n}\nif(fs.existsSync(itemCreekPath)) {\n    console.log(`Copying creek ...`);\n    fs.copyFileSync(itemCreekPath, path.join(contractsV1Dir, 'creek.contract.json'));\n} else {\n    console.log(`creek not found`);\n}\nif(fs.existsSync(itemBrookPath)) {\n    console.log(`Copying brook ...`);\n    fs.copyFileSync(itemBrookPath, path.join(contractsV1Dir, 'brook.contract.json'));\n} else {\n    console.log(`brook not found`);\n}\nif(fs.existsSync(itemWhisperPath)) {\n    console.log(`Copying whisper ...`);\n    fs.copyFileSync(itemWhisperPath, path.join(contractsV1Dir, 'whisper.contract.json'));\n} else {\n    console.log(`whisper not found`);\n}\nif(fs.existsSync(itemRivuletPath)) {\n    console.log(`Copying rivulet ...`);\n    fs.copyFileSync(itemRivuletPath, path.join(contractsV1Dir, 'rivulet.contract.json'));\n} else {\n    console.log(`rivulet not found`);\n}\nif(fs.existsSync(itemTributaryPath)) {\n    console.log(`Copying tributary ...`);\n    fs.copyFileSync(itemTributaryPath, path.join(contractsV1Dir, 'tributary.contract.json'));\n} else {\n    console.log(`tributary not found`);\n}\nif(fs.existsSync(itemMurmurPath)) {\n    console.log(`Copying murmur ...`);\n    fs.copyFileSync(itemMurmurPath, path.join(contractsV1Dir, 'murmur.contract.json'));\n} else {\n    console.log(`murmur not found`);\n}\nif(fs.existsSync(itemWatershedPath)) {\n    console.log(`Copying watershed ...`);\n    fs.copyFileSync(itemWatershedPath, path.join(contractsV1Dir, 'watershed.contract.json'));\n} else {\n    console.log(`watershed not found`);\n}\nif(fs.existsSync(itemAquiferPath)) {\n    console.log(`Copying aquifer ...`);\n    fs.copyFileSync(itemAquiferPath, path.join(contractsV1Dir, 'aquifer.contract.json'));\n} else {\n    console.log(`aquifer not found`);\n}\nif(fs.existsSync(itemParchedEarthPath)) {\n    console.log(`Copying parched_earth ...`);\n    fs.copyFileSync(itemParchedEarthPath, path.join(contractsV1Dir, 'parched_earth.contract.json'));\n} else {\n    console.log(`parched_earth not found`);\n}\nif(fs.existsSync(itemFreshBreezePath)) {\n    console.log(`Copying fresh_breeze ...`);\n    fs.copyFileSync(itemFreshBreezePath, path.join(contractsV1Dir, 'fresh_breeze.contract.json'));\n} else {\n    console.log(`fresh_breeze not found`);\n}\nif(fs.existsSync(itemGroundwaterPath)) {\n    console.log(`Copying groundwater ...`);\n    fs.copyFileSync(itemGroundwaterPath, path.join(contractsV1Dir, 'groundwater.contract.json'));\n} else {\n    console.log(`groundwater not found`);\n}\nif(fs.existsSync(itemReservoirPath)) {\n    console.log(`Copying reservoir ...`);\n    fs.copyFileSync(itemReservoirPath, path.join(contractsV1Dir, 'reservoir.contract.json'));\n} else {\n    console.log(`reservoir not found`);\n}\nif(fs.existsSync(itemGeothermalSpringPath)) {\n    console.log(`Copying geothermal_spring ...`);\n    fs.copyFileSync(itemGeothermalSpringPath, path.join(contractsV1Dir, 'geothermal_spring.contract.json'));\n} else {\n    console.log(`geothermal_spring not found`);\n}\nif(fs.existsSync(itemArtesianWellPath)) {\n    console.log(`Copying artesian_well ...`);\n    fs.copyFileSync(itemArtesianWellPath, path.join(contractsV1Dir, 'artesian_well.contract.json'));\n} else {\n    console.log(`artesian_well not found`);\n}\nif(fs.existsSync(itemBasinPath)) {\n    console.log(`Copying basin ...`);\n    fs.copyFileSync(itemBasinPath, path.join(contractsV1Dir, 'basin.contract.json'));\n} else {\n    console.log(`basin not found`);\n}\nif(fs.existsSync(itemLakePath)) {\n    console.log(`Copying lake ...`);\n    fs.copyFileSync(itemLakePath, path.join(contractsV1Dir, 'lake.contract.json'));\n} else {\n    console.log(`lake not found`);\n}\nif(fs.existsSync(itemDryBasinPath)) {\n    console.log(`Copying dry_basin ...`);\n    fs.copyFileSync(itemDryBasinPath, path.join(contractsV1Dir, 'dry_basin.contract.json'));\n} else {\n    console.log(`dry_basin not found`);\n}\nif(fs.existsSync(itemDepressionPath)) {\n    console.log(`Copying depression ...`);\n    fs.copyFileSync(itemDepressionPath, path.join(contractsV1Dir, 'depression.contract.json'));\n} else {\n    console.log(`depression not found`);\n}\nif(fs.existsSync(itemIslandPath)) {\n    console.log(`Copying island ...`);\n    fs.copyFileSync(itemIslandPath, path.join(contractsV1Dir, 'island.contract.json'));\n} else {\n    console.log(`island not found`);\n}\nif(fs.existsSync(itemLagoonPath)) {\n    console.log(`Copying lagoon ...`);\n    fs.copyFileSync(itemLagoonPath, path.join(contractsV1Dir, 'lagoon.contract.json'));\n} else {\n    console.log(`lagoon not found`);\n}\nif(fs.existsSync(itemWavePath)) {\n    console.log(`Copying wave ...`);\n    fs.copyFileSync(itemWavePath, path.join(contractsV1Dir, 'wave.contract.json'));\n} else {\n    console.log(`wave not found`);\n}\nif(fs.existsSync(itemReefPath)) {\n    console.log(`Copying reef ...`);\n    fs.copyFileSync(itemReefPath, path.join(contractsV1Dir, 'reef.contract.json'));\n} else {\n    console.log(`reef not found`);\n}\nif(fs.existsSync(itemCoralPath)) {\n    console.log(`Copying coral ...`);\n    fs.copyFileSync(itemCoralPath, path.join(contractsV1Dir, 'coral.contract.json'));\n} else {\n    console.log(`coral not found`);\n}\nif(fs.existsSync(itemWhirlPath)) {\n    console.log(`Copying whirl ...`);\n    fs.copyFileSync(itemWhirlPath, path.join(contractsV1Dir, 'whirl.contract.json'));\n} else {\n    console.log(`whirl not found`);\n}\nif(fs.existsSync(itemLimestonePath)) {\n    console.log(`Copying limestone ...`);\n    fs.copyFileSync(itemLimestonePath, path.join(contractsV1Dir, 'limestone.contract.json'));\n} else {\n    console.log(`limestone not found`);\n}\nif(fs.existsSync(itemKarstPath)) {\n    console.log(`Copying karst ...`);\n    fs.copyFileSync(itemKarstPath, path.join(contractsV1Dir, 'karst.contract.json'));\n} else {\n    console.log(`karst not found`);\n}\nif(fs.existsSync(itemQuicklimePath)) {\n    console.log(`Copying quicklime ...`);\n    fs.copyFileSync(itemQuicklimePath, path.join(contractsV1Dir, 'quicklime.contract.json'));\n} else {\n    console.log(`quicklime not found`);\n}\nif(fs.existsSync(itemBlowholePath)) {\n    console.log(`Copying blowhole ...`);\n    fs.copyFileSync(itemBlowholePath, path.join(contractsV1Dir, 'blowhole.contract.json'));\n} else {\n    console.log(`blowhole not found`);\n}\n\nif(fs.existsSync(gameUnifiersPath)) {\n    console.log(`Copying unifiers ...`);\n    fs.copyFileSync(gameUnifiersPath, path.join(contractsV1Dir, 'unifiers.contract.json'));\n} else {\n    console.log(`unifiers not found`);\n}\n",
      "contentHash": "f24b9c9294969deee16c9cde774c65da42bce4c3a29aa856b0853c08b4bc7169",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/deployer/extract-metadata.js",
      "content": "const fs = require('fs');\nconst path = require('path');\n\nconst POSSIBLE_CONTRACTS_V1_README_MD_FILES = [\n    \"../../contracts.v1/README.md\",\n    \"../../../contracts.v1/README.md\",\n    \"contracts.v1/README.md\",\n]\n\nconst realContractsV1ReadmeMdIndex = POSSIBLE_CONTRACTS_V1_README_MD_FILES.findIndex((file) => fs.existsSync(file));\nconst contractsV1ReadmeMd = POSSIBLE_CONTRACTS_V1_README_MD_FILES[realContractsV1ReadmeMdIndex];\nconst contractsV1Dir = path.join(path.dirname(contractsV1ReadmeMd), \"artifacts\");\nconst contractInterfacesV1Dir = path.join(path.dirname(contractsV1ReadmeMd), \"interfaces\");\n\nconsole.log(`Loading contracts from ${contractsV1Dir} ...`);\n\nif (!fs.existsSync(contractsV1Dir)) {\n    throw new Error(`Contracts not found at ${contractsV1Dir}`);\n}\n\nif (!fs.existsSync(contractInterfacesV1Dir)) {\n    fs.mkdirSync(contractInterfacesV1Dir, { recursive: true });\n}\n\nconst monkeyPath = path.join(contractsV1Dir, \"monkey.contract.json\");\nconst monkeyInterfacePath = path.join(contractInterfacesV1Dir, \"monkey.interface.json\");\nif(fs.existsSync(monkeyPath)) {\n    const monkeyData = JSON.parse(\n        fs.readFileSync(monkeyPath, { encoding: 'utf-8' })\n    );\n    if(!monkeyData.source) {\n        console.log(`No source found for Monkey at ${ monkeyPath }`)\n        return;\n    }\n    delete monkeyData.source.wasm;\n    fs.writeFileSync(monkeyInterfacePath, JSON.stringify(monkeyData, null, 4));\n    console.log(`Extracted metadata for Monkey to ${ monkeyInterfacePath }`)\n} else {\n    console.log(`No metadata found for Monkey at ${ monkeyPath }`)\n}\nconst giraffePath = path.join(contractsV1Dir, \"giraffe.contract.json\");\nconst giraffeInterfacePath = path.join(contractInterfacesV1Dir, \"giraffe.interface.json\");\nif(fs.existsSync(giraffePath)) {\n    const giraffeData = JSON.parse(\n        fs.readFileSync(giraffePath, { encoding: 'utf-8' })\n    );\n    if(!giraffeData.source) {\n        console.log(`No source found for Giraffe at ${ giraffePath }`)\n        return;\n    }\n    delete giraffeData.source.wasm;\n    fs.writeFileSync(giraffeInterfacePath, JSON.stringify(giraffeData, null, 4));\n    console.log(`Extracted metadata for Giraffe to ${ giraffeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Giraffe at ${ giraffePath }`)\n}\nconst beePath = path.join(contractsV1Dir, \"bee.contract.json\");\nconst beeInterfacePath = path.join(contractInterfacesV1Dir, \"bee.interface.json\");\nif(fs.existsSync(beePath)) {\n    const beeData = JSON.parse(\n        fs.readFileSync(beePath, { encoding: 'utf-8' })\n    );\n    if(!beeData.source) {\n        console.log(`No source found for Bee at ${ beePath }`)\n        return;\n    }\n    delete beeData.source.wasm;\n    fs.writeFileSync(beeInterfacePath, JSON.stringify(beeData, null, 4));\n    console.log(`Extracted metadata for Bee to ${ beeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Bee at ${ beePath }`)\n}\nconst coinPath = path.join(contractsV1Dir, \"coin.contract.json\");\nconst coinInterfacePath = path.join(contractInterfacesV1Dir, \"coin.interface.json\");\nif(fs.existsSync(coinPath)) {\n    const coinData = JSON.parse(\n        fs.readFileSync(coinPath, { encoding: 'utf-8' })\n    );\n    if(!coinData.source) {\n        console.log(`No source found for Coin at ${ coinPath }`)\n        return;\n    }\n    delete coinData.source.wasm;\n    fs.writeFileSync(coinInterfacePath, JSON.stringify(coinData, null, 4));\n    console.log(`Extracted metadata for Coin to ${ coinInterfacePath }`)\n} else {\n    console.log(`No metadata found for Coin at ${ coinPath }`)\n}\nconst swarmPath = path.join(contractsV1Dir, \"swarm.contract.json\");\nconst swarmInterfacePath = path.join(contractInterfacesV1Dir, \"swarm.interface.json\");\nif(fs.existsSync(swarmPath)) {\n    const swarmData = JSON.parse(\n        fs.readFileSync(swarmPath, { encoding: 'utf-8' })\n    );\n    if(!swarmData.source) {\n        console.log(`No source found for SWARM at ${ swarmPath }`)\n        return;\n    }\n    delete swarmData.source.wasm;\n    fs.writeFileSync(swarmInterfacePath, JSON.stringify(swarmData, null, 4));\n    console.log(`Extracted metadata for SWARM to ${ swarmInterfacePath }`)\n} else {\n    console.log(`No metadata found for SWARM at ${ swarmPath }`)\n}\nconst hydraPath = path.join(contractsV1Dir, \"hydra.contract.json\");\nconst hydraInterfacePath = path.join(contractInterfacesV1Dir, \"hydra.interface.json\");\nif(fs.existsSync(hydraPath)) {\n    const hydraData = JSON.parse(\n        fs.readFileSync(hydraPath, { encoding: 'utf-8' })\n    );\n    if(!hydraData.source) {\n        console.log(`No source found for Hydra at ${ hydraPath }`)\n        return;\n    }\n    delete hydraData.source.wasm;\n    fs.writeFileSync(hydraInterfacePath, JSON.stringify(hydraData, null, 4));\n    console.log(`Extracted metadata for Hydra to ${ hydraInterfacePath }`)\n} else {\n    console.log(`No metadata found for Hydra at ${ hydraPath }`)\n}\nconst monkeyBranchPath = path.join(contractsV1Dir, \"monkey_branch.contract.json\");\nconst monkeyBranchInterfacePath = path.join(contractInterfacesV1Dir, \"monkey_branch.interface.json\");\nif(fs.existsSync(monkeyBranchPath)) {\n    const monkeyBranchData = JSON.parse(\n        fs.readFileSync(monkeyBranchPath, { encoding: 'utf-8' })\n    );\n    if(!monkeyBranchData.source) {\n        console.log(`No source found for MonkeyBranch at ${ monkeyBranchPath }`)\n        return;\n    }\n    delete monkeyBranchData.source.wasm;\n    fs.writeFileSync(monkeyBranchInterfacePath, JSON.stringify(monkeyBranchData, null, 4));\n    console.log(`Extracted metadata for MonkeyBranch to ${ monkeyBranchInterfacePath }`)\n} else {\n    console.log(`No metadata found for MonkeyBranch at ${ monkeyBranchPath }`)\n}\nconst bridgePath = path.join(contractsV1Dir, \"bridge.contract.json\");\nconst bridgeInterfacePath = path.join(contractInterfacesV1Dir, \"bridge.interface.json\");\nif(fs.existsSync(bridgePath)) {\n    const bridgeData = JSON.parse(\n        fs.readFileSync(bridgePath, { encoding: 'utf-8' })\n    );\n    if(!bridgeData.source) {\n        console.log(`No source found for Bridge at ${ bridgePath }`)\n        return;\n    }\n    delete bridgeData.source.wasm;\n    fs.writeFileSync(bridgeInterfacePath, JSON.stringify(bridgeData, null, 4));\n    console.log(`Extracted metadata for Bridge to ${ bridgeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Bridge at ${ bridgePath }`)\n}\nconst goldenGatePath = path.join(contractsV1Dir, \"golden_gate.contract.json\");\nconst goldenGateInterfacePath = path.join(contractInterfacesV1Dir, \"golden_gate.interface.json\");\nif(fs.existsSync(goldenGatePath)) {\n    const goldenGateData = JSON.parse(\n        fs.readFileSync(goldenGatePath, { encoding: 'utf-8' })\n    );\n    if(!goldenGateData.source) {\n        console.log(`No source found for GoldenGate at ${ goldenGatePath }`)\n        return;\n    }\n    delete goldenGateData.source.wasm;\n    fs.writeFileSync(goldenGateInterfacePath, JSON.stringify(goldenGateData, null, 4));\n    console.log(`Extracted metadata for GoldenGate to ${ goldenGateInterfacePath }`)\n} else {\n    console.log(`No metadata found for GoldenGate at ${ goldenGatePath }`)\n}\nconst goldPath = path.join(contractsV1Dir, \"gold.contract.json\");\nconst goldInterfacePath = path.join(contractInterfacesV1Dir, \"gold.interface.json\");\nif(fs.existsSync(goldPath)) {\n    const goldData = JSON.parse(\n        fs.readFileSync(goldPath, { encoding: 'utf-8' })\n    );\n    if(!goldData.source) {\n        console.log(`No source found for Gold at ${ goldPath }`)\n        return;\n    }\n    delete goldData.source.wasm;\n    fs.writeFileSync(goldInterfacePath, JSON.stringify(goldData, null, 4));\n    console.log(`Extracted metadata for Gold to ${ goldInterfacePath }`)\n} else {\n    console.log(`No metadata found for Gold at ${ goldPath }`)\n}\nconst silverPath = path.join(contractsV1Dir, \"silver.contract.json\");\nconst silverInterfacePath = path.join(contractInterfacesV1Dir, \"silver.interface.json\");\nif(fs.existsSync(silverPath)) {\n    const silverData = JSON.parse(\n        fs.readFileSync(silverPath, { encoding: 'utf-8' })\n    );\n    if(!silverData.source) {\n        console.log(`No source found for Silver at ${ silverPath }`)\n        return;\n    }\n    delete silverData.source.wasm;\n    fs.writeFileSync(silverInterfacePath, JSON.stringify(silverData, null, 4));\n    console.log(`Extracted metadata for Silver to ${ silverInterfacePath }`)\n} else {\n    console.log(`No metadata found for Silver at ${ silverPath }`)\n}\nconst rhodiumPath = path.join(contractsV1Dir, \"rhodium.contract.json\");\nconst rhodiumInterfacePath = path.join(contractInterfacesV1Dir, \"rhodium.interface.json\");\nif(fs.existsSync(rhodiumPath)) {\n    const rhodiumData = JSON.parse(\n        fs.readFileSync(rhodiumPath, { encoding: 'utf-8' })\n    );\n    if(!rhodiumData.source) {\n        console.log(`No source found for Rhodium at ${ rhodiumPath }`)\n        return;\n    }\n    delete rhodiumData.source.wasm;\n    fs.writeFileSync(rhodiumInterfacePath, JSON.stringify(rhodiumData, null, 4));\n    console.log(`Extracted metadata for Rhodium to ${ rhodiumInterfacePath }`)\n} else {\n    console.log(`No metadata found for Rhodium at ${ rhodiumPath }`)\n}\nconst hivePath = path.join(contractsV1Dir, \"hive.contract.json\");\nconst hiveInterfacePath = path.join(contractInterfacesV1Dir, \"hive.interface.json\");\nif(fs.existsSync(hivePath)) {\n    const hiveData = JSON.parse(\n        fs.readFileSync(hivePath, { encoding: 'utf-8' })\n    );\n    if(!hiveData.source) {\n        console.log(`No source found for Hive at ${ hivePath }`)\n        return;\n    }\n    delete hiveData.source.wasm;\n    fs.writeFileSync(hiveInterfacePath, JSON.stringify(hiveData, null, 4));\n    console.log(`Extracted metadata for Hive to ${ hiveInterfacePath }`)\n} else {\n    console.log(`No metadata found for Hive at ${ hivePath }`)\n}\nconst transactionPath = path.join(contractsV1Dir, \"transaction.contract.json\");\nconst transactionInterfacePath = path.join(contractInterfacesV1Dir, \"transaction.interface.json\");\nif(fs.existsSync(transactionPath)) {\n    const transactionData = JSON.parse(\n        fs.readFileSync(transactionPath, { encoding: 'utf-8' })\n    );\n    if(!transactionData.source) {\n        console.log(`No source found for Transaction at ${ transactionPath }`)\n        return;\n    }\n    delete transactionData.source.wasm;\n    fs.writeFileSync(transactionInterfacePath, JSON.stringify(transactionData, null, 4));\n    console.log(`Extracted metadata for Transaction to ${ transactionInterfacePath }`)\n} else {\n    console.log(`No metadata found for Transaction at ${ transactionPath }`)\n}\nconst blockPath = path.join(contractsV1Dir, \"block.contract.json\");\nconst blockInterfacePath = path.join(contractInterfacesV1Dir, \"block.interface.json\");\nif(fs.existsSync(blockPath)) {\n    const blockData = JSON.parse(\n        fs.readFileSync(blockPath, { encoding: 'utf-8' })\n    );\n    if(!blockData.source) {\n        console.log(`No source found for Block at ${ blockPath }`)\n        return;\n    }\n    delete blockData.source.wasm;\n    fs.writeFileSync(blockInterfacePath, JSON.stringify(blockData, null, 4));\n    console.log(`Extracted metadata for Block to ${ blockInterfacePath }`)\n} else {\n    console.log(`No metadata found for Block at ${ blockPath }`)\n}\nconst blockchainPath = path.join(contractsV1Dir, \"blockchain.contract.json\");\nconst blockchainInterfacePath = path.join(contractInterfacesV1Dir, \"blockchain.interface.json\");\nif(fs.existsSync(blockchainPath)) {\n    const blockchainData = JSON.parse(\n        fs.readFileSync(blockchainPath, { encoding: 'utf-8' })\n    );\n    if(!blockchainData.source) {\n        console.log(`No source found for Blockchain at ${ blockchainPath }`)\n        return;\n    }\n    delete blockchainData.source.wasm;\n    fs.writeFileSync(blockchainInterfacePath, JSON.stringify(blockchainData, null, 4));\n    console.log(`Extracted metadata for Blockchain to ${ blockchainInterfacePath }`)\n} else {\n    console.log(`No metadata found for Blockchain at ${ blockchainPath }`)\n}\nconst polkadotPath = path.join(contractsV1Dir, \"polkadot.contract.json\");\nconst polkadotInterfacePath = path.join(contractInterfacesV1Dir, \"polkadot.interface.json\");\nif(fs.existsSync(polkadotPath)) {\n    const polkadotData = JSON.parse(\n        fs.readFileSync(polkadotPath, { encoding: 'utf-8' })\n    );\n    if(!polkadotData.source) {\n        console.log(`No source found for Polkadot at ${ polkadotPath }`)\n        return;\n    }\n    delete polkadotData.source.wasm;\n    fs.writeFileSync(polkadotInterfacePath, JSON.stringify(polkadotData, null, 4));\n    console.log(`Extracted metadata for Polkadot to ${ polkadotInterfacePath }`)\n} else {\n    console.log(`No metadata found for Polkadot at ${ polkadotPath }`)\n}\nconst peerReviewPath = path.join(contractsV1Dir, \"peer_review.contract.json\");\nconst peerReviewInterfacePath = path.join(contractInterfacesV1Dir, \"peer_review.interface.json\");\nif(fs.existsSync(peerReviewPath)) {\n    const peerReviewData = JSON.parse(\n        fs.readFileSync(peerReviewPath, { encoding: 'utf-8' })\n    );\n    if(!peerReviewData.source) {\n        console.log(`No source found for PeerReview at ${ peerReviewPath }`)\n        return;\n    }\n    delete peerReviewData.source.wasm;\n    fs.writeFileSync(peerReviewInterfacePath, JSON.stringify(peerReviewData, null, 4));\n    console.log(`Extracted metadata for PeerReview to ${ peerReviewInterfacePath }`)\n} else {\n    console.log(`No metadata found for PeerReview at ${ peerReviewPath }`)\n}\nconst cardanoPath = path.join(contractsV1Dir, \"cardano.contract.json\");\nconst cardanoInterfacePath = path.join(contractInterfacesV1Dir, \"cardano.interface.json\");\nif(fs.existsSync(cardanoPath)) {\n    const cardanoData = JSON.parse(\n        fs.readFileSync(cardanoPath, { encoding: 'utf-8' })\n    );\n    if(!cardanoData.source) {\n        console.log(`No source found for Cardano at ${ cardanoPath }`)\n        return;\n    }\n    delete cardanoData.source.wasm;\n    fs.writeFileSync(cardanoInterfacePath, JSON.stringify(cardanoData, null, 4));\n    console.log(`Extracted metadata for Cardano to ${ cardanoInterfacePath }`)\n} else {\n    console.log(`No metadata found for Cardano at ${ cardanoPath }`)\n}\nconst bearPath = path.join(contractsV1Dir, \"bear.contract.json\");\nconst bearInterfacePath = path.join(contractInterfacesV1Dir, \"bear.interface.json\");\nif(fs.existsSync(bearPath)) {\n    const bearData = JSON.parse(\n        fs.readFileSync(bearPath, { encoding: 'utf-8' })\n    );\n    if(!bearData.source) {\n        console.log(`No source found for Bear at ${ bearPath }`)\n        return;\n    }\n    delete bearData.source.wasm;\n    fs.writeFileSync(bearInterfacePath, JSON.stringify(bearData, null, 4));\n    console.log(`Extracted metadata for Bear to ${ bearInterfacePath }`)\n} else {\n    console.log(`No metadata found for Bear at ${ bearPath }`)\n}\nconst beerPath = path.join(contractsV1Dir, \"beer.contract.json\");\nconst beerInterfacePath = path.join(contractInterfacesV1Dir, \"beer.interface.json\");\nif(fs.existsSync(beerPath)) {\n    const beerData = JSON.parse(\n        fs.readFileSync(beerPath, { encoding: 'utf-8' })\n    );\n    if(!beerData.source) {\n        console.log(`No source found for Beer at ${ beerPath }`)\n        return;\n    }\n    delete beerData.source.wasm;\n    fs.writeFileSync(beerInterfacePath, JSON.stringify(beerData, null, 4));\n    console.log(`Extracted metadata for Beer to ${ beerInterfacePath }`)\n} else {\n    console.log(`No metadata found for Beer at ${ beerPath }`)\n}\nconst lockPath = path.join(contractsV1Dir, \"lock.contract.json\");\nconst lockInterfacePath = path.join(contractInterfacesV1Dir, \"lock.interface.json\");\nif(fs.existsSync(lockPath)) {\n    const lockData = JSON.parse(\n        fs.readFileSync(lockPath, { encoding: 'utf-8' })\n    );\n    if(!lockData.source) {\n        console.log(`No source found for Lock at ${ lockPath }`)\n        return;\n    }\n    delete lockData.source.wasm;\n    fs.writeFileSync(lockInterfacePath, JSON.stringify(lockData, null, 4));\n    console.log(`Extracted metadata for Lock to ${ lockInterfacePath }`)\n} else {\n    console.log(`No metadata found for Lock at ${ lockPath }`)\n}\nconst marmaladePath = path.join(contractsV1Dir, \"marmalade.contract.json\");\nconst marmaladeInterfacePath = path.join(contractInterfacesV1Dir, \"marmalade.interface.json\");\nif(fs.existsSync(marmaladePath)) {\n    const marmaladeData = JSON.parse(\n        fs.readFileSync(marmaladePath, { encoding: 'utf-8' })\n    );\n    if(!marmaladeData.source) {\n        console.log(`No source found for Marmalade at ${ marmaladePath }`)\n        return;\n    }\n    delete marmaladeData.source.wasm;\n    fs.writeFileSync(marmaladeInterfacePath, JSON.stringify(marmaladeData, null, 4));\n    console.log(`Extracted metadata for Marmalade to ${ marmaladeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Marmalade at ${ marmaladePath }`)\n}\nconst superMarmaladePath = path.join(contractsV1Dir, \"super_marmalade.contract.json\");\nconst superMarmaladeInterfacePath = path.join(contractInterfacesV1Dir, \"super_marmalade.interface.json\");\nif(fs.existsSync(superMarmaladePath)) {\n    const superMarmaladeData = JSON.parse(\n        fs.readFileSync(superMarmaladePath, { encoding: 'utf-8' })\n    );\n    if(!superMarmaladeData.source) {\n        console.log(`No source found for SuperMarmalade at ${ superMarmaladePath }`)\n        return;\n    }\n    delete superMarmaladeData.source.wasm;\n    fs.writeFileSync(superMarmaladeInterfacePath, JSON.stringify(superMarmaladeData, null, 4));\n    console.log(`Extracted metadata for SuperMarmalade to ${ superMarmaladeInterfacePath }`)\n} else {\n    console.log(`No metadata found for SuperMarmalade at ${ superMarmaladePath }`)\n}\nconst hyperMarmaladePath = path.join(contractsV1Dir, \"hyper_marmalade.contract.json\");\nconst hyperMarmaladeInterfacePath = path.join(contractInterfacesV1Dir, \"hyper_marmalade.interface.json\");\nif(fs.existsSync(hyperMarmaladePath)) {\n    const hyperMarmaladeData = JSON.parse(\n        fs.readFileSync(hyperMarmaladePath, { encoding: 'utf-8' })\n    );\n    if(!hyperMarmaladeData.source) {\n        console.log(`No source found for HyperMarmalade at ${ hyperMarmaladePath }`)\n        return;\n    }\n    delete hyperMarmaladeData.source.wasm;\n    fs.writeFileSync(hyperMarmaladeInterfacePath, JSON.stringify(hyperMarmaladeData, null, 4));\n    console.log(`Extracted metadata for HyperMarmalade to ${ hyperMarmaladeInterfacePath }`)\n} else {\n    console.log(`No metadata found for HyperMarmalade at ${ hyperMarmaladePath }`)\n}\nconst waterPath = path.join(contractsV1Dir, \"water.contract.json\");\nconst waterInterfacePath = path.join(contractInterfacesV1Dir, \"water.interface.json\");\nif(fs.existsSync(waterPath)) {\n    const waterData = JSON.parse(\n        fs.readFileSync(waterPath, { encoding: 'utf-8' })\n    );\n    if(!waterData.source) {\n        console.log(`No source found for Water at ${ waterPath }`)\n        return;\n    }\n    delete waterData.source.wasm;\n    fs.writeFileSync(waterInterfacePath, JSON.stringify(waterData, null, 4));\n    console.log(`Extracted metadata for Water to ${ waterInterfacePath }`)\n} else {\n    console.log(`No metadata found for Water at ${ waterPath }`)\n}\nconst firePath = path.join(contractsV1Dir, \"fire.contract.json\");\nconst fireInterfacePath = path.join(contractInterfacesV1Dir, \"fire.interface.json\");\nif(fs.existsSync(firePath)) {\n    const fireData = JSON.parse(\n        fs.readFileSync(firePath, { encoding: 'utf-8' })\n    );\n    if(!fireData.source) {\n        console.log(`No source found for Fire at ${ firePath }`)\n        return;\n    }\n    delete fireData.source.wasm;\n    fs.writeFileSync(fireInterfacePath, JSON.stringify(fireData, null, 4));\n    console.log(`Extracted metadata for Fire to ${ fireInterfacePath }`)\n} else {\n    console.log(`No metadata found for Fire at ${ firePath }`)\n}\nconst steamPath = path.join(contractsV1Dir, \"steam.contract.json\");\nconst steamInterfacePath = path.join(contractInterfacesV1Dir, \"steam.interface.json\");\nif(fs.existsSync(steamPath)) {\n    const steamData = JSON.parse(\n        fs.readFileSync(steamPath, { encoding: 'utf-8' })\n    );\n    if(!steamData.source) {\n        console.log(`No source found for Steam at ${ steamPath }`)\n        return;\n    }\n    delete steamData.source.wasm;\n    fs.writeFileSync(steamInterfacePath, JSON.stringify(steamData, null, 4));\n    console.log(`Extracted metadata for Steam to ${ steamInterfacePath }`)\n} else {\n    console.log(`No metadata found for Steam at ${ steamPath }`)\n}\nconst earthPath = path.join(contractsV1Dir, \"earth.contract.json\");\nconst earthInterfacePath = path.join(contractInterfacesV1Dir, \"earth.interface.json\");\nif(fs.existsSync(earthPath)) {\n    const earthData = JSON.parse(\n        fs.readFileSync(earthPath, { encoding: 'utf-8' })\n    );\n    if(!earthData.source) {\n        console.log(`No source found for Earth at ${ earthPath }`)\n        return;\n    }\n    delete earthData.source.wasm;\n    fs.writeFileSync(earthInterfacePath, JSON.stringify(earthData, null, 4));\n    console.log(`Extracted metadata for Earth to ${ earthInterfacePath }`)\n} else {\n    console.log(`No metadata found for Earth at ${ earthPath }`)\n}\nconst mudPath = path.join(contractsV1Dir, \"mud.contract.json\");\nconst mudInterfacePath = path.join(contractInterfacesV1Dir, \"mud.interface.json\");\nif(fs.existsSync(mudPath)) {\n    const mudData = JSON.parse(\n        fs.readFileSync(mudPath, { encoding: 'utf-8' })\n    );\n    if(!mudData.source) {\n        console.log(`No source found for Mud at ${ mudPath }`)\n        return;\n    }\n    delete mudData.source.wasm;\n    fs.writeFileSync(mudInterfacePath, JSON.stringify(mudData, null, 4));\n    console.log(`Extracted metadata for Mud to ${ mudInterfacePath }`)\n} else {\n    console.log(`No metadata found for Mud at ${ mudPath }`)\n}\nconst lavaPath = path.join(contractsV1Dir, \"lava.contract.json\");\nconst lavaInterfacePath = path.join(contractInterfacesV1Dir, \"lava.interface.json\");\nif(fs.existsSync(lavaPath)) {\n    const lavaData = JSON.parse(\n        fs.readFileSync(lavaPath, { encoding: 'utf-8' })\n    );\n    if(!lavaData.source) {\n        console.log(`No source found for Lava at ${ lavaPath }`)\n        return;\n    }\n    delete lavaData.source.wasm;\n    fs.writeFileSync(lavaInterfacePath, JSON.stringify(lavaData, null, 4));\n    console.log(`Extracted metadata for Lava to ${ lavaInterfacePath }`)\n} else {\n    console.log(`No metadata found for Lava at ${ lavaPath }`)\n}\nconst windPath = path.join(contractsV1Dir, \"wind.contract.json\");\nconst windInterfacePath = path.join(contractInterfacesV1Dir, \"wind.interface.json\");\nif(fs.existsSync(windPath)) {\n    const windData = JSON.parse(\n        fs.readFileSync(windPath, { encoding: 'utf-8' })\n    );\n    if(!windData.source) {\n        console.log(`No source found for Wind at ${ windPath }`)\n        return;\n    }\n    delete windData.source.wasm;\n    fs.writeFileSync(windInterfacePath, JSON.stringify(windData, null, 4));\n    console.log(`Extracted metadata for Wind to ${ windInterfacePath }`)\n} else {\n    console.log(`No metadata found for Wind at ${ windPath }`)\n}\nconst dustPath = path.join(contractsV1Dir, \"dust.contract.json\");\nconst dustInterfacePath = path.join(contractInterfacesV1Dir, \"dust.interface.json\");\nif(fs.existsSync(dustPath)) {\n    const dustData = JSON.parse(\n        fs.readFileSync(dustPath, { encoding: 'utf-8' })\n    );\n    if(!dustData.source) {\n        console.log(`No source found for Dust at ${ dustPath }`)\n        return;\n    }\n    delete dustData.source.wasm;\n    fs.writeFileSync(dustInterfacePath, JSON.stringify(dustData, null, 4));\n    console.log(`Extracted metadata for Dust to ${ dustInterfacePath }`)\n} else {\n    console.log(`No metadata found for Dust at ${ dustPath }`)\n}\nconst rainPath = path.join(contractsV1Dir, \"rain.contract.json\");\nconst rainInterfacePath = path.join(contractInterfacesV1Dir, \"rain.interface.json\");\nif(fs.existsSync(rainPath)) {\n    const rainData = JSON.parse(\n        fs.readFileSync(rainPath, { encoding: 'utf-8' })\n    );\n    if(!rainData.source) {\n        console.log(`No source found for Rain at ${ rainPath }`)\n        return;\n    }\n    delete rainData.source.wasm;\n    fs.writeFileSync(rainInterfacePath, JSON.stringify(rainData, null, 4));\n    console.log(`Extracted metadata for Rain to ${ rainInterfacePath }`)\n} else {\n    console.log(`No metadata found for Rain at ${ rainPath }`)\n}\nconst smokePath = path.join(contractsV1Dir, \"smoke.contract.json\");\nconst smokeInterfacePath = path.join(contractInterfacesV1Dir, \"smoke.interface.json\");\nif(fs.existsSync(smokePath)) {\n    const smokeData = JSON.parse(\n        fs.readFileSync(smokePath, { encoding: 'utf-8' })\n    );\n    if(!smokeData.source) {\n        console.log(`No source found for Smoke at ${ smokePath }`)\n        return;\n    }\n    delete smokeData.source.wasm;\n    fs.writeFileSync(smokeInterfacePath, JSON.stringify(smokeData, null, 4));\n    console.log(`Extracted metadata for Smoke to ${ smokeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Smoke at ${ smokePath }`)\n}\nconst geyserPath = path.join(contractsV1Dir, \"geyser.contract.json\");\nconst geyserInterfacePath = path.join(contractInterfacesV1Dir, \"geyser.interface.json\");\nif(fs.existsSync(geyserPath)) {\n    const geyserData = JSON.parse(\n        fs.readFileSync(geyserPath, { encoding: 'utf-8' })\n    );\n    if(!geyserData.source) {\n        console.log(`No source found for Geyser at ${ geyserPath }`)\n        return;\n    }\n    delete geyserData.source.wasm;\n    fs.writeFileSync(geyserInterfacePath, JSON.stringify(geyserData, null, 4));\n    console.log(`Extracted metadata for Geyser to ${ geyserInterfacePath }`)\n} else {\n    console.log(`No metadata found for Geyser at ${ geyserPath }`)\n}\nconst clayPath = path.join(contractsV1Dir, \"clay.contract.json\");\nconst clayInterfacePath = path.join(contractInterfacesV1Dir, \"clay.interface.json\");\nif(fs.existsSync(clayPath)) {\n    const clayData = JSON.parse(\n        fs.readFileSync(clayPath, { encoding: 'utf-8' })\n    );\n    if(!clayData.source) {\n        console.log(`No source found for Clay at ${ clayPath }`)\n        return;\n    }\n    delete clayData.source.wasm;\n    fs.writeFileSync(clayInterfacePath, JSON.stringify(clayData, null, 4));\n    console.log(`Extracted metadata for Clay to ${ clayInterfacePath }`)\n} else {\n    console.log(`No metadata found for Clay at ${ clayPath }`)\n}\nconst sandPath = path.join(contractsV1Dir, \"sand.contract.json\");\nconst sandInterfacePath = path.join(contractInterfacesV1Dir, \"sand.interface.json\");\nif(fs.existsSync(sandPath)) {\n    const sandData = JSON.parse(\n        fs.readFileSync(sandPath, { encoding: 'utf-8' })\n    );\n    if(!sandData.source) {\n        console.log(`No source found for Sand at ${ sandPath }`)\n        return;\n    }\n    delete sandData.source.wasm;\n    fs.writeFileSync(sandInterfacePath, JSON.stringify(sandData, null, 4));\n    console.log(`Extracted metadata for Sand to ${ sandInterfacePath }`)\n} else {\n    console.log(`No metadata found for Sand at ${ sandPath }`)\n}\nconst plantPath = path.join(contractsV1Dir, \"plant.contract.json\");\nconst plantInterfacePath = path.join(contractInterfacesV1Dir, \"plant.interface.json\");\nif(fs.existsSync(plantPath)) {\n    const plantData = JSON.parse(\n        fs.readFileSync(plantPath, { encoding: 'utf-8' })\n    );\n    if(!plantData.source) {\n        console.log(`No source found for Plant at ${ plantPath }`)\n        return;\n    }\n    delete plantData.source.wasm;\n    fs.writeFileSync(plantInterfacePath, JSON.stringify(plantData, null, 4));\n    console.log(`Extracted metadata for Plant to ${ plantInterfacePath }`)\n} else {\n    console.log(`No metadata found for Plant at ${ plantPath }`)\n}\nconst rainbowPath = path.join(contractsV1Dir, \"rainbow.contract.json\");\nconst rainbowInterfacePath = path.join(contractInterfacesV1Dir, \"rainbow.interface.json\");\nif(fs.existsSync(rainbowPath)) {\n    const rainbowData = JSON.parse(\n        fs.readFileSync(rainbowPath, { encoding: 'utf-8' })\n    );\n    if(!rainbowData.source) {\n        console.log(`No source found for Rainbow at ${ rainbowPath }`)\n        return;\n    }\n    delete rainbowData.source.wasm;\n    fs.writeFileSync(rainbowInterfacePath, JSON.stringify(rainbowData, null, 4));\n    console.log(`Extracted metadata for Rainbow to ${ rainbowInterfacePath }`)\n} else {\n    console.log(`No metadata found for Rainbow at ${ rainbowPath }`)\n}\nconst stormPath = path.join(contractsV1Dir, \"storm.contract.json\");\nconst stormInterfacePath = path.join(contractInterfacesV1Dir, \"storm.interface.json\");\nif(fs.existsSync(stormPath)) {\n    const stormData = JSON.parse(\n        fs.readFileSync(stormPath, { encoding: 'utf-8' })\n    );\n    if(!stormData.source) {\n        console.log(`No source found for Storm at ${ stormPath }`)\n        return;\n    }\n    delete stormData.source.wasm;\n    fs.writeFileSync(stormInterfacePath, JSON.stringify(stormData, null, 4));\n    console.log(`Extracted metadata for Storm to ${ stormInterfacePath }`)\n} else {\n    console.log(`No metadata found for Storm at ${ stormPath }`)\n}\nconst obsidianPath = path.join(contractsV1Dir, \"obsidian.contract.json\");\nconst obsidianInterfacePath = path.join(contractInterfacesV1Dir, \"obsidian.interface.json\");\nif(fs.existsSync(obsidianPath)) {\n    const obsidianData = JSON.parse(\n        fs.readFileSync(obsidianPath, { encoding: 'utf-8' })\n    );\n    if(!obsidianData.source) {\n        console.log(`No source found for Obsidian at ${ obsidianPath }`)\n        return;\n    }\n    delete obsidianData.source.wasm;\n    fs.writeFileSync(obsidianInterfacePath, JSON.stringify(obsidianData, null, 4));\n    console.log(`Extracted metadata for Obsidian to ${ obsidianInterfacePath }`)\n} else {\n    console.log(`No metadata found for Obsidian at ${ obsidianPath }`)\n}\nconst ashPath = path.join(contractsV1Dir, \"ash.contract.json\");\nconst ashInterfacePath = path.join(contractInterfacesV1Dir, \"ash.interface.json\");\nif(fs.existsSync(ashPath)) {\n    const ashData = JSON.parse(\n        fs.readFileSync(ashPath, { encoding: 'utf-8' })\n    );\n    if(!ashData.source) {\n        console.log(`No source found for Ash at ${ ashPath }`)\n        return;\n    }\n    delete ashData.source.wasm;\n    fs.writeFileSync(ashInterfacePath, JSON.stringify(ashData, null, 4));\n    console.log(`Extracted metadata for Ash to ${ ashInterfacePath }`)\n} else {\n    console.log(`No metadata found for Ash at ${ ashPath }`)\n}\nconst volcanoPath = path.join(contractsV1Dir, \"volcano.contract.json\");\nconst volcanoInterfacePath = path.join(contractInterfacesV1Dir, \"volcano.interface.json\");\nif(fs.existsSync(volcanoPath)) {\n    const volcanoData = JSON.parse(\n        fs.readFileSync(volcanoPath, { encoding: 'utf-8' })\n    );\n    if(!volcanoData.source) {\n        console.log(`No source found for Volcano at ${ volcanoPath }`)\n        return;\n    }\n    delete volcanoData.source.wasm;\n    fs.writeFileSync(volcanoInterfacePath, JSON.stringify(volcanoData, null, 4));\n    console.log(`Extracted metadata for Volcano to ${ volcanoInterfacePath }`)\n} else {\n    console.log(`No metadata found for Volcano at ${ volcanoPath }`)\n}\nconst sandstormPath = path.join(contractsV1Dir, \"sandstorm.contract.json\");\nconst sandstormInterfacePath = path.join(contractInterfacesV1Dir, \"sandstorm.interface.json\");\nif(fs.existsSync(sandstormPath)) {\n    const sandstormData = JSON.parse(\n        fs.readFileSync(sandstormPath, { encoding: 'utf-8' })\n    );\n    if(!sandstormData.source) {\n        console.log(`No source found for Sandstorm at ${ sandstormPath }`)\n        return;\n    }\n    delete sandstormData.source.wasm;\n    fs.writeFileSync(sandstormInterfacePath, JSON.stringify(sandstormData, null, 4));\n    console.log(`Extracted metadata for Sandstorm to ${ sandstormInterfacePath }`)\n} else {\n    console.log(`No metadata found for Sandstorm at ${ sandstormPath }`)\n}\nconst cloudPath = path.join(contractsV1Dir, \"cloud.contract.json\");\nconst cloudInterfacePath = path.join(contractInterfacesV1Dir, \"cloud.interface.json\");\nif(fs.existsSync(cloudPath)) {\n    const cloudData = JSON.parse(\n        fs.readFileSync(cloudPath, { encoding: 'utf-8' })\n    );\n    if(!cloudData.source) {\n        console.log(`No source found for Cloud at ${ cloudPath }`)\n        return;\n    }\n    delete cloudData.source.wasm;\n    fs.writeFileSync(cloudInterfacePath, JSON.stringify(cloudData, null, 4));\n    console.log(`Extracted metadata for Cloud to ${ cloudInterfacePath }`)\n} else {\n    console.log(`No metadata found for Cloud at ${ cloudPath }`)\n}\nconst fogPath = path.join(contractsV1Dir, \"fog.contract.json\");\nconst fogInterfacePath = path.join(contractInterfacesV1Dir, \"fog.interface.json\");\nif(fs.existsSync(fogPath)) {\n    const fogData = JSON.parse(\n        fs.readFileSync(fogPath, { encoding: 'utf-8' })\n    );\n    if(!fogData.source) {\n        console.log(`No source found for Fog at ${ fogPath }`)\n        return;\n    }\n    delete fogData.source.wasm;\n    fs.writeFileSync(fogInterfacePath, JSON.stringify(fogData, null, 4));\n    console.log(`Extracted metadata for Fog to ${ fogInterfacePath }`)\n} else {\n    console.log(`No metadata found for Fog at ${ fogPath }`)\n}\nconst treePath = path.join(contractsV1Dir, \"tree.contract.json\");\nconst treeInterfacePath = path.join(contractInterfacesV1Dir, \"tree.interface.json\");\nif(fs.existsSync(treePath)) {\n    const treeData = JSON.parse(\n        fs.readFileSync(treePath, { encoding: 'utf-8' })\n    );\n    if(!treeData.source) {\n        console.log(`No source found for Tree at ${ treePath }`)\n        return;\n    }\n    delete treeData.source.wasm;\n    fs.writeFileSync(treeInterfacePath, JSON.stringify(treeData, null, 4));\n    console.log(`Extracted metadata for Tree to ${ treeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Tree at ${ treePath }`)\n}\nconst forestPath = path.join(contractsV1Dir, \"forest.contract.json\");\nconst forestInterfacePath = path.join(contractInterfacesV1Dir, \"forest.interface.json\");\nif(fs.existsSync(forestPath)) {\n    const forestData = JSON.parse(\n        fs.readFileSync(forestPath, { encoding: 'utf-8' })\n    );\n    if(!forestData.source) {\n        console.log(`No source found for Forest at ${ forestPath }`)\n        return;\n    }\n    delete forestData.source.wasm;\n    fs.writeFileSync(forestInterfacePath, JSON.stringify(forestData, null, 4));\n    console.log(`Extracted metadata for Forest to ${ forestInterfacePath }`)\n} else {\n    console.log(`No metadata found for Forest at ${ forestPath }`)\n}\nconst seedsPath = path.join(contractsV1Dir, \"seeds.contract.json\");\nconst seedsInterfacePath = path.join(contractInterfacesV1Dir, \"seeds.interface.json\");\nif(fs.existsSync(seedsPath)) {\n    const seedsData = JSON.parse(\n        fs.readFileSync(seedsPath, { encoding: 'utf-8' })\n    );\n    if(!seedsData.source) {\n        console.log(`No source found for Seeds at ${ seedsPath }`)\n        return;\n    }\n    delete seedsData.source.wasm;\n    fs.writeFileSync(seedsInterfacePath, JSON.stringify(seedsData, null, 4));\n    console.log(`Extracted metadata for Seeds to ${ seedsInterfacePath }`)\n} else {\n    console.log(`No metadata found for Seeds at ${ seedsPath }`)\n}\nconst potteryPath = path.join(contractsV1Dir, \"pottery.contract.json\");\nconst potteryInterfacePath = path.join(contractInterfacesV1Dir, \"pottery.interface.json\");\nif(fs.existsSync(potteryPath)) {\n    const potteryData = JSON.parse(\n        fs.readFileSync(potteryPath, { encoding: 'utf-8' })\n    );\n    if(!potteryData.source) {\n        console.log(`No source found for Pottery at ${ potteryPath }`)\n        return;\n    }\n    delete potteryData.source.wasm;\n    fs.writeFileSync(potteryInterfacePath, JSON.stringify(potteryData, null, 4));\n    console.log(`Extracted metadata for Pottery to ${ potteryInterfacePath }`)\n} else {\n    console.log(`No metadata found for Pottery at ${ potteryPath }`)\n}\nconst brickPath = path.join(contractsV1Dir, \"brick.contract.json\");\nconst brickInterfacePath = path.join(contractInterfacesV1Dir, \"brick.interface.json\");\nif(fs.existsSync(brickPath)) {\n    const brickData = JSON.parse(\n        fs.readFileSync(brickPath, { encoding: 'utf-8' })\n    );\n    if(!brickData.source) {\n        console.log(`No source found for Brick at ${ brickPath }`)\n        return;\n    }\n    delete brickData.source.wasm;\n    fs.writeFileSync(brickInterfacePath, JSON.stringify(brickData, null, 4));\n    console.log(`Extracted metadata for Brick to ${ brickInterfacePath }`)\n} else {\n    console.log(`No metadata found for Brick at ${ brickPath }`)\n}\nconst quicksandPath = path.join(contractsV1Dir, \"quicksand.contract.json\");\nconst quicksandInterfacePath = path.join(contractInterfacesV1Dir, \"quicksand.interface.json\");\nif(fs.existsSync(quicksandPath)) {\n    const quicksandData = JSON.parse(\n        fs.readFileSync(quicksandPath, { encoding: 'utf-8' })\n    );\n    if(!quicksandData.source) {\n        console.log(`No source found for Quicksand at ${ quicksandPath }`)\n        return;\n    }\n    delete quicksandData.source.wasm;\n    fs.writeFileSync(quicksandInterfacePath, JSON.stringify(quicksandData, null, 4));\n    console.log(`Extracted metadata for Quicksand to ${ quicksandInterfacePath }`)\n} else {\n    console.log(`No metadata found for Quicksand at ${ quicksandPath }`)\n}\nconst glassPath = path.join(contractsV1Dir, \"glass.contract.json\");\nconst glassInterfacePath = path.join(contractInterfacesV1Dir, \"glass.interface.json\");\nif(fs.existsSync(glassPath)) {\n    const glassData = JSON.parse(\n        fs.readFileSync(glassPath, { encoding: 'utf-8' })\n    );\n    if(!glassData.source) {\n        console.log(`No source found for Glass at ${ glassPath }`)\n        return;\n    }\n    delete glassData.source.wasm;\n    fs.writeFileSync(glassInterfacePath, JSON.stringify(glassData, null, 4));\n    console.log(`Extracted metadata for Glass to ${ glassInterfacePath }`)\n} else {\n    console.log(`No metadata found for Glass at ${ glassPath }`)\n}\nconst dunePath = path.join(contractsV1Dir, \"dune.contract.json\");\nconst duneInterfacePath = path.join(contractInterfacesV1Dir, \"dune.interface.json\");\nif(fs.existsSync(dunePath)) {\n    const duneData = JSON.parse(\n        fs.readFileSync(dunePath, { encoding: 'utf-8' })\n    );\n    if(!duneData.source) {\n        console.log(`No source found for Dune at ${ dunePath }`)\n        return;\n    }\n    delete duneData.source.wasm;\n    fs.writeFileSync(duneInterfacePath, JSON.stringify(duneData, null, 4));\n    console.log(`Extracted metadata for Dune to ${ duneInterfacePath }`)\n} else {\n    console.log(`No metadata found for Dune at ${ dunePath }`)\n}\nconst charcoalPath = path.join(contractsV1Dir, \"charcoal.contract.json\");\nconst charcoalInterfacePath = path.join(contractInterfacesV1Dir, \"charcoal.interface.json\");\nif(fs.existsSync(charcoalPath)) {\n    const charcoalData = JSON.parse(\n        fs.readFileSync(charcoalPath, { encoding: 'utf-8' })\n    );\n    if(!charcoalData.source) {\n        console.log(`No source found for Charcoal at ${ charcoalPath }`)\n        return;\n    }\n    delete charcoalData.source.wasm;\n    fs.writeFileSync(charcoalInterfacePath, JSON.stringify(charcoalData, null, 4));\n    console.log(`Extracted metadata for Charcoal to ${ charcoalInterfacePath }`)\n} else {\n    console.log(`No metadata found for Charcoal at ${ charcoalPath }`)\n}\nconst leavesPath = path.join(contractsV1Dir, \"leaves.contract.json\");\nconst leavesInterfacePath = path.join(contractInterfacesV1Dir, \"leaves.interface.json\");\nif(fs.existsSync(leavesPath)) {\n    const leavesData = JSON.parse(\n        fs.readFileSync(leavesPath, { encoding: 'utf-8' })\n    );\n    if(!leavesData.source) {\n        console.log(`No source found for Leaves at ${ leavesPath }`)\n        return;\n    }\n    delete leavesData.source.wasm;\n    fs.writeFileSync(leavesInterfacePath, JSON.stringify(leavesData, null, 4));\n    console.log(`Extracted metadata for Leaves to ${ leavesInterfacePath }`)\n} else {\n    console.log(`No metadata found for Leaves at ${ leavesPath }`)\n}\nconst wildfirePath = path.join(contractsV1Dir, \"wildfire.contract.json\");\nconst wildfireInterfacePath = path.join(contractInterfacesV1Dir, \"wildfire.interface.json\");\nif(fs.existsSync(wildfirePath)) {\n    const wildfireData = JSON.parse(\n        fs.readFileSync(wildfirePath, { encoding: 'utf-8' })\n    );\n    if(!wildfireData.source) {\n        console.log(`No source found for Wildfire at ${ wildfirePath }`)\n        return;\n    }\n    delete wildfireData.source.wasm;\n    fs.writeFileSync(wildfireInterfacePath, JSON.stringify(wildfireData, null, 4));\n    console.log(`Extracted metadata for Wildfire to ${ wildfireInterfacePath }`)\n} else {\n    console.log(`No metadata found for Wildfire at ${ wildfirePath }`)\n}\nconst junglePath = path.join(contractsV1Dir, \"jungle.contract.json\");\nconst jungleInterfacePath = path.join(contractInterfacesV1Dir, \"jungle.interface.json\");\nif(fs.existsSync(junglePath)) {\n    const jungleData = JSON.parse(\n        fs.readFileSync(junglePath, { encoding: 'utf-8' })\n    );\n    if(!jungleData.source) {\n        console.log(`No source found for Jungle at ${ junglePath }`)\n        return;\n    }\n    delete jungleData.source.wasm;\n    fs.writeFileSync(jungleInterfacePath, JSON.stringify(jungleData, null, 4));\n    console.log(`Extracted metadata for Jungle to ${ jungleInterfacePath }`)\n} else {\n    console.log(`No metadata found for Jungle at ${ junglePath }`)\n}\nconst frostedGlassPath = path.join(contractsV1Dir, \"frosted_glass.contract.json\");\nconst frostedGlassInterfacePath = path.join(contractInterfacesV1Dir, \"frosted_glass.interface.json\");\nif(fs.existsSync(frostedGlassPath)) {\n    const frostedGlassData = JSON.parse(\n        fs.readFileSync(frostedGlassPath, { encoding: 'utf-8' })\n    );\n    if(!frostedGlassData.source) {\n        console.log(`No source found for Frosted Glass at ${ frostedGlassPath }`)\n        return;\n    }\n    delete frostedGlassData.source.wasm;\n    fs.writeFileSync(frostedGlassInterfacePath, JSON.stringify(frostedGlassData, null, 4));\n    console.log(`Extracted metadata for Frosted Glass to ${ frostedGlassInterfacePath }`)\n} else {\n    console.log(`No metadata found for Frosted Glass at ${ frostedGlassPath }`)\n}\nconst crystalPath = path.join(contractsV1Dir, \"crystal.contract.json\");\nconst crystalInterfacePath = path.join(contractInterfacesV1Dir, \"crystal.interface.json\");\nif(fs.existsSync(crystalPath)) {\n    const crystalData = JSON.parse(\n        fs.readFileSync(crystalPath, { encoding: 'utf-8' })\n    );\n    if(!crystalData.source) {\n        console.log(`No source found for Crystal at ${ crystalPath }`)\n        return;\n    }\n    delete crystalData.source.wasm;\n    fs.writeFileSync(crystalInterfacePath, JSON.stringify(crystalData, null, 4));\n    console.log(`Extracted metadata for Crystal to ${ crystalInterfacePath }`)\n} else {\n    console.log(`No metadata found for Crystal at ${ crystalPath }`)\n}\nconst magmaPath = path.join(contractsV1Dir, \"magma.contract.json\");\nconst magmaInterfacePath = path.join(contractInterfacesV1Dir, \"magma.interface.json\");\nif(fs.existsSync(magmaPath)) {\n    const magmaData = JSON.parse(\n        fs.readFileSync(magmaPath, { encoding: 'utf-8' })\n    );\n    if(!magmaData.source) {\n        console.log(`No source found for Magma at ${ magmaPath }`)\n        return;\n    }\n    delete magmaData.source.wasm;\n    fs.writeFileSync(magmaInterfacePath, JSON.stringify(magmaData, null, 4));\n    console.log(`Extracted metadata for Magma to ${ magmaInterfacePath }`)\n} else {\n    console.log(`No metadata found for Magma at ${ magmaPath }`)\n}\nconst rockPath = path.join(contractsV1Dir, \"rock.contract.json\");\nconst rockInterfacePath = path.join(contractInterfacesV1Dir, \"rock.interface.json\");\nif(fs.existsSync(rockPath)) {\n    const rockData = JSON.parse(\n        fs.readFileSync(rockPath, { encoding: 'utf-8' })\n    );\n    if(!rockData.source) {\n        console.log(`No source found for Rock at ${ rockPath }`)\n        return;\n    }\n    delete rockData.source.wasm;\n    fs.writeFileSync(rockInterfacePath, JSON.stringify(rockData, null, 4));\n    console.log(`Extracted metadata for Rock to ${ rockInterfacePath }`)\n} else {\n    console.log(`No metadata found for Rock at ${ rockPath }`)\n}\nconst shardPath = path.join(contractsV1Dir, \"shard.contract.json\");\nconst shardInterfacePath = path.join(contractInterfacesV1Dir, \"shard.interface.json\");\nif(fs.existsSync(shardPath)) {\n    const shardData = JSON.parse(\n        fs.readFileSync(shardPath, { encoding: 'utf-8' })\n    );\n    if(!shardData.source) {\n        console.log(`No source found for Shard at ${ shardPath }`)\n        return;\n    }\n    delete shardData.source.wasm;\n    fs.writeFileSync(shardInterfacePath, JSON.stringify(shardData, null, 4));\n    console.log(`Extracted metadata for Shard to ${ shardInterfacePath }`)\n} else {\n    console.log(`No metadata found for Shard at ${ shardPath }`)\n}\nconst pebblePath = path.join(contractsV1Dir, \"pebble.contract.json\");\nconst pebbleInterfacePath = path.join(contractInterfacesV1Dir, \"pebble.interface.json\");\nif(fs.existsSync(pebblePath)) {\n    const pebbleData = JSON.parse(\n        fs.readFileSync(pebblePath, { encoding: 'utf-8' })\n    );\n    if(!pebbleData.source) {\n        console.log(`No source found for Pebble at ${ pebblePath }`)\n        return;\n    }\n    delete pebbleData.source.wasm;\n    fs.writeFileSync(pebbleInterfacePath, JSON.stringify(pebbleData, null, 4));\n    console.log(`Extracted metadata for Pebble to ${ pebbleInterfacePath }`)\n} else {\n    console.log(`No metadata found for Pebble at ${ pebblePath }`)\n}\nconst mountainPath = path.join(contractsV1Dir, \"mountain.contract.json\");\nconst mountainInterfacePath = path.join(contractInterfacesV1Dir, \"mountain.interface.json\");\nif(fs.existsSync(mountainPath)) {\n    const mountainData = JSON.parse(\n        fs.readFileSync(mountainPath, { encoding: 'utf-8' })\n    );\n    if(!mountainData.source) {\n        console.log(`No source found for Mountain at ${ mountainPath }`)\n        return;\n    }\n    delete mountainData.source.wasm;\n    fs.writeFileSync(mountainInterfacePath, JSON.stringify(mountainData, null, 4));\n    console.log(`Extracted metadata for Mountain to ${ mountainInterfacePath }`)\n} else {\n    console.log(`No metadata found for Mountain at ${ mountainPath }`)\n}\nconst fertilizerPath = path.join(contractsV1Dir, \"fertilizer.contract.json\");\nconst fertilizerInterfacePath = path.join(contractInterfacesV1Dir, \"fertilizer.interface.json\");\nif(fs.existsSync(fertilizerPath)) {\n    const fertilizerData = JSON.parse(\n        fs.readFileSync(fertilizerPath, { encoding: 'utf-8' })\n    );\n    if(!fertilizerData.source) {\n        console.log(`No source found for Fertilizer at ${ fertilizerPath }`)\n        return;\n    }\n    delete fertilizerData.source.wasm;\n    fs.writeFileSync(fertilizerInterfacePath, JSON.stringify(fertilizerData, null, 4));\n    console.log(`Extracted metadata for Fertilizer to ${ fertilizerInterfacePath }`)\n} else {\n    console.log(`No metadata found for Fertilizer at ${ fertilizerPath }`)\n}\nconst sootPath = path.join(contractsV1Dir, \"soot.contract.json\");\nconst sootInterfacePath = path.join(contractInterfacesV1Dir, \"soot.interface.json\");\nif(fs.existsSync(sootPath)) {\n    const sootData = JSON.parse(\n        fs.readFileSync(sootPath, { encoding: 'utf-8' })\n    );\n    if(!sootData.source) {\n        console.log(`No source found for Soot at ${ sootPath }`)\n        return;\n    }\n    delete sootData.source.wasm;\n    fs.writeFileSync(sootInterfacePath, JSON.stringify(sootData, null, 4));\n    console.log(`Extracted metadata for Soot to ${ sootInterfacePath }`)\n} else {\n    console.log(`No metadata found for Soot at ${ sootPath }`)\n}\nconst lightningPath = path.join(contractsV1Dir, \"lightning.contract.json\");\nconst lightningInterfacePath = path.join(contractInterfacesV1Dir, \"lightning.interface.json\");\nif(fs.existsSync(lightningPath)) {\n    const lightningData = JSON.parse(\n        fs.readFileSync(lightningPath, { encoding: 'utf-8' })\n    );\n    if(!lightningData.source) {\n        console.log(`No source found for Lightning at ${ lightningPath }`)\n        return;\n    }\n    delete lightningData.source.wasm;\n    fs.writeFileSync(lightningInterfacePath, JSON.stringify(lightningData, null, 4));\n    console.log(`Extracted metadata for Lightning to ${ lightningInterfacePath }`)\n} else {\n    console.log(`No metadata found for Lightning at ${ lightningPath }`)\n}\nconst mistPath = path.join(contractsV1Dir, \"mist.contract.json\");\nconst mistInterfacePath = path.join(contractInterfacesV1Dir, \"mist.interface.json\");\nif(fs.existsSync(mistPath)) {\n    const mistData = JSON.parse(\n        fs.readFileSync(mistPath, { encoding: 'utf-8' })\n    );\n    if(!mistData.source) {\n        console.log(`No source found for Mist at ${ mistPath }`)\n        return;\n    }\n    delete mistData.source.wasm;\n    fs.writeFileSync(mistInterfacePath, JSON.stringify(mistData, null, 4));\n    console.log(`Extracted metadata for Mist to ${ mistInterfacePath }`)\n} else {\n    console.log(`No metadata found for Mist at ${ mistPath }`)\n}\nconst hazePath = path.join(contractsV1Dir, \"haze.contract.json\");\nconst hazeInterfacePath = path.join(contractInterfacesV1Dir, \"haze.interface.json\");\nif(fs.existsSync(hazePath)) {\n    const hazeData = JSON.parse(\n        fs.readFileSync(hazePath, { encoding: 'utf-8' })\n    );\n    if(!hazeData.source) {\n        console.log(`No source found for Haze at ${ hazePath }`)\n        return;\n    }\n    delete hazeData.source.wasm;\n    fs.writeFileSync(hazeInterfacePath, JSON.stringify(hazeData, null, 4));\n    console.log(`Extracted metadata for Haze to ${ hazeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Haze at ${ hazePath }`)\n}\nconst floodPath = path.join(contractsV1Dir, \"flood.contract.json\");\nconst floodInterfacePath = path.join(contractInterfacesV1Dir, \"flood.interface.json\");\nif(fs.existsSync(floodPath)) {\n    const floodData = JSON.parse(\n        fs.readFileSync(floodPath, { encoding: 'utf-8' })\n    );\n    if(!floodData.source) {\n        console.log(`No source found for Flood at ${ floodPath }`)\n        return;\n    }\n    delete floodData.source.wasm;\n    fs.writeFileSync(floodInterfacePath, JSON.stringify(floodData, null, 4));\n    console.log(`Extracted metadata for Flood to ${ floodInterfacePath }`)\n} else {\n    console.log(`No metadata found for Flood at ${ floodPath }`)\n}\nconst landslidePath = path.join(contractsV1Dir, \"landslide.contract.json\");\nconst landslideInterfacePath = path.join(contractInterfacesV1Dir, \"landslide.interface.json\");\nif(fs.existsSync(landslidePath)) {\n    const landslideData = JSON.parse(\n        fs.readFileSync(landslidePath, { encoding: 'utf-8' })\n    );\n    if(!landslideData.source) {\n        console.log(`No source found for Landslide at ${ landslidePath }`)\n        return;\n    }\n    delete landslideData.source.wasm;\n    fs.writeFileSync(landslideInterfacePath, JSON.stringify(landslideData, null, 4));\n    console.log(`Extracted metadata for Landslide to ${ landslideInterfacePath }`)\n} else {\n    console.log(`No metadata found for Landslide at ${ landslidePath }`)\n}\nconst thunderPath = path.join(contractsV1Dir, \"thunder.contract.json\");\nconst thunderInterfacePath = path.join(contractInterfacesV1Dir, \"thunder.interface.json\");\nif(fs.existsSync(thunderPath)) {\n    const thunderData = JSON.parse(\n        fs.readFileSync(thunderPath, { encoding: 'utf-8' })\n    );\n    if(!thunderData.source) {\n        console.log(`No source found for Thunder at ${ thunderPath }`)\n        return;\n    }\n    delete thunderData.source.wasm;\n    fs.writeFileSync(thunderInterfacePath, JSON.stringify(thunderData, null, 4));\n    console.log(`Extracted metadata for Thunder to ${ thunderInterfacePath }`)\n} else {\n    console.log(`No metadata found for Thunder at ${ thunderPath }`)\n}\nconst tornadoPath = path.join(contractsV1Dir, \"tornado.contract.json\");\nconst tornadoInterfacePath = path.join(contractInterfacesV1Dir, \"tornado.interface.json\");\nif(fs.existsSync(tornadoPath)) {\n    const tornadoData = JSON.parse(\n        fs.readFileSync(tornadoPath, { encoding: 'utf-8' })\n    );\n    if(!tornadoData.source) {\n        console.log(`No source found for Tornado at ${ tornadoPath }`)\n        return;\n    }\n    delete tornadoData.source.wasm;\n    fs.writeFileSync(tornadoInterfacePath, JSON.stringify(tornadoData, null, 4));\n    console.log(`Extracted metadata for Tornado to ${ tornadoInterfacePath }`)\n} else {\n    console.log(`No metadata found for Tornado at ${ tornadoPath }`)\n}\nconst gardenPath = path.join(contractsV1Dir, \"garden.contract.json\");\nconst gardenInterfacePath = path.join(contractInterfacesV1Dir, \"garden.interface.json\");\nif(fs.existsSync(gardenPath)) {\n    const gardenData = JSON.parse(\n        fs.readFileSync(gardenPath, { encoding: 'utf-8' })\n    );\n    if(!gardenData.source) {\n        console.log(`No source found for Garden at ${ gardenPath }`)\n        return;\n    }\n    delete gardenData.source.wasm;\n    fs.writeFileSync(gardenInterfacePath, JSON.stringify(gardenData, null, 4));\n    console.log(`Extracted metadata for Garden to ${ gardenInterfacePath }`)\n} else {\n    console.log(`No metadata found for Garden at ${ gardenPath }`)\n}\nconst emberPath = path.join(contractsV1Dir, \"ember.contract.json\");\nconst emberInterfacePath = path.join(contractInterfacesV1Dir, \"ember.interface.json\");\nif(fs.existsSync(emberPath)) {\n    const emberData = JSON.parse(\n        fs.readFileSync(emberPath, { encoding: 'utf-8' })\n    );\n    if(!emberData.source) {\n        console.log(`No source found for Ember at ${ emberPath }`)\n        return;\n    }\n    delete emberData.source.wasm;\n    fs.writeFileSync(emberInterfacePath, JSON.stringify(emberData, null, 4));\n    console.log(`Extracted metadata for Ember to ${ emberInterfacePath }`)\n} else {\n    console.log(`No metadata found for Ember at ${ emberPath }`)\n}\nconst kilnPath = path.join(contractsV1Dir, \"kiln.contract.json\");\nconst kilnInterfacePath = path.join(contractInterfacesV1Dir, \"kiln.interface.json\");\nif(fs.existsSync(kilnPath)) {\n    const kilnData = JSON.parse(\n        fs.readFileSync(kilnPath, { encoding: 'utf-8' })\n    );\n    if(!kilnData.source) {\n        console.log(`No source found for Kiln at ${ kilnPath }`)\n        return;\n    }\n    delete kilnData.source.wasm;\n    fs.writeFileSync(kilnInterfacePath, JSON.stringify(kilnData, null, 4));\n    console.log(`Extracted metadata for Kiln to ${ kilnInterfacePath }`)\n} else {\n    console.log(`No metadata found for Kiln at ${ kilnPath }`)\n}\nconst pollinationPath = path.join(contractsV1Dir, \"pollination.contract.json\");\nconst pollinationInterfacePath = path.join(contractInterfacesV1Dir, \"pollination.interface.json\");\nif(fs.existsSync(pollinationPath)) {\n    const pollinationData = JSON.parse(\n        fs.readFileSync(pollinationPath, { encoding: 'utf-8' })\n    );\n    if(!pollinationData.source) {\n        console.log(`No source found for Pollination at ${ pollinationPath }`)\n        return;\n    }\n    delete pollinationData.source.wasm;\n    fs.writeFileSync(pollinationInterfacePath, JSON.stringify(pollinationData, null, 4));\n    console.log(`Extracted metadata for Pollination to ${ pollinationInterfacePath }`)\n} else {\n    console.log(`No metadata found for Pollination at ${ pollinationPath }`)\n}\nconst sinkholePath = path.join(contractsV1Dir, \"sinkhole.contract.json\");\nconst sinkholeInterfacePath = path.join(contractInterfacesV1Dir, \"sinkhole.interface.json\");\nif(fs.existsSync(sinkholePath)) {\n    const sinkholeData = JSON.parse(\n        fs.readFileSync(sinkholePath, { encoding: 'utf-8' })\n    );\n    if(!sinkholeData.source) {\n        console.log(`No source found for Sinkhole at ${ sinkholePath }`)\n        return;\n    }\n    delete sinkholeData.source.wasm;\n    fs.writeFileSync(sinkholeInterfacePath, JSON.stringify(sinkholeData, null, 4));\n    console.log(`Extracted metadata for Sinkhole to ${ sinkholeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Sinkhole at ${ sinkholePath }`)\n}\nconst beachPath = path.join(contractsV1Dir, \"beach.contract.json\");\nconst beachInterfacePath = path.join(contractInterfacesV1Dir, \"beach.interface.json\");\nif(fs.existsSync(beachPath)) {\n    const beachData = JSON.parse(\n        fs.readFileSync(beachPath, { encoding: 'utf-8' })\n    );\n    if(!beachData.source) {\n        console.log(`No source found for Beach at ${ beachPath }`)\n        return;\n    }\n    delete beachData.source.wasm;\n    fs.writeFileSync(beachInterfacePath, JSON.stringify(beachData, null, 4));\n    console.log(`Extracted metadata for Beach to ${ beachInterfacePath }`)\n} else {\n    console.log(`No metadata found for Beach at ${ beachPath }`)\n}\nconst wetstonePath = path.join(contractsV1Dir, \"wetstone.contract.json\");\nconst wetstoneInterfacePath = path.join(contractInterfacesV1Dir, \"wetstone.interface.json\");\nif(fs.existsSync(wetstonePath)) {\n    const wetstoneData = JSON.parse(\n        fs.readFileSync(wetstonePath, { encoding: 'utf-8' })\n    );\n    if(!wetstoneData.source) {\n        console.log(`No source found for Wetstone at ${ wetstonePath }`)\n        return;\n    }\n    delete wetstoneData.source.wasm;\n    fs.writeFileSync(wetstoneInterfacePath, JSON.stringify(wetstoneData, null, 4));\n    console.log(`Extracted metadata for Wetstone to ${ wetstoneInterfacePath }`)\n} else {\n    console.log(`No metadata found for Wetstone at ${ wetstonePath }`)\n}\nconst erosionPath = path.join(contractsV1Dir, \"erosion.contract.json\");\nconst erosionInterfacePath = path.join(contractInterfacesV1Dir, \"erosion.interface.json\");\nif(fs.existsSync(erosionPath)) {\n    const erosionData = JSON.parse(\n        fs.readFileSync(erosionPath, { encoding: 'utf-8' })\n    );\n    if(!erosionData.source) {\n        console.log(`No source found for Erosion at ${ erosionPath }`)\n        return;\n    }\n    delete erosionData.source.wasm;\n    fs.writeFileSync(erosionInterfacePath, JSON.stringify(erosionData, null, 4));\n    console.log(`Extracted metadata for Erosion to ${ erosionInterfacePath }`)\n} else {\n    console.log(`No metadata found for Erosion at ${ erosionPath }`)\n}\nconst basaltPath = path.join(contractsV1Dir, \"basalt.contract.json\");\nconst basaltInterfacePath = path.join(contractInterfacesV1Dir, \"basalt.interface.json\");\nif(fs.existsSync(basaltPath)) {\n    const basaltData = JSON.parse(\n        fs.readFileSync(basaltPath, { encoding: 'utf-8' })\n    );\n    if(!basaltData.source) {\n        console.log(`No source found for Basalt at ${ basaltPath }`)\n        return;\n    }\n    delete basaltData.source.wasm;\n    fs.writeFileSync(basaltInterfacePath, JSON.stringify(basaltData, null, 4));\n    console.log(`Extracted metadata for Basalt to ${ basaltInterfacePath }`)\n} else {\n    console.log(`No metadata found for Basalt at ${ basaltPath }`)\n}\nconst magmaChamberPath = path.join(contractsV1Dir, \"magma_chamber.contract.json\");\nconst magmaChamberInterfacePath = path.join(contractInterfacesV1Dir, \"magma_chamber.interface.json\");\nif(fs.existsSync(magmaChamberPath)) {\n    const magmaChamberData = JSON.parse(\n        fs.readFileSync(magmaChamberPath, { encoding: 'utf-8' })\n    );\n    if(!magmaChamberData.source) {\n        console.log(`No source found for Magma Chamber at ${ magmaChamberPath }`)\n        return;\n    }\n    delete magmaChamberData.source.wasm;\n    fs.writeFileSync(magmaChamberInterfacePath, JSON.stringify(magmaChamberData, null, 4));\n    console.log(`Extracted metadata for Magma Chamber to ${ magmaChamberInterfacePath }`)\n} else {\n    console.log(`No metadata found for Magma Chamber at ${ magmaChamberPath }`)\n}\nconst breezePath = path.join(contractsV1Dir, \"breeze.contract.json\");\nconst breezeInterfacePath = path.join(contractInterfacesV1Dir, \"breeze.interface.json\");\nif(fs.existsSync(breezePath)) {\n    const breezeData = JSON.parse(\n        fs.readFileSync(breezePath, { encoding: 'utf-8' })\n    );\n    if(!breezeData.source) {\n        console.log(`No source found for Breeze at ${ breezePath }`)\n        return;\n    }\n    delete breezeData.source.wasm;\n    fs.writeFileSync(breezeInterfacePath, JSON.stringify(breezeData, null, 4));\n    console.log(`Extracted metadata for Breeze to ${ breezeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Breeze at ${ breezePath }`)\n}\nconst warmBreezePath = path.join(contractsV1Dir, \"warm_breeze.contract.json\");\nconst warmBreezeInterfacePath = path.join(contractInterfacesV1Dir, \"warm_breeze.interface.json\");\nif(fs.existsSync(warmBreezePath)) {\n    const warmBreezeData = JSON.parse(\n        fs.readFileSync(warmBreezePath, { encoding: 'utf-8' })\n    );\n    if(!warmBreezeData.source) {\n        console.log(`No source found for Warm Breeze at ${ warmBreezePath }`)\n        return;\n    }\n    delete warmBreezeData.source.wasm;\n    fs.writeFileSync(warmBreezeInterfacePath, JSON.stringify(warmBreezeData, null, 4));\n    console.log(`Extracted metadata for Warm Breeze to ${ warmBreezeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Warm Breeze at ${ warmBreezePath }`)\n}\nconst soilPath = path.join(contractsV1Dir, \"soil.contract.json\");\nconst soilInterfacePath = path.join(contractInterfacesV1Dir, \"soil.interface.json\");\nif(fs.existsSync(soilPath)) {\n    const soilData = JSON.parse(\n        fs.readFileSync(soilPath, { encoding: 'utf-8' })\n    );\n    if(!soilData.source) {\n        console.log(`No source found for Soil at ${ soilPath }`)\n        return;\n    }\n    delete soilData.source.wasm;\n    fs.writeFileSync(soilInterfacePath, JSON.stringify(soilData, null, 4));\n    console.log(`Extracted metadata for Soil to ${ soilInterfacePath }`)\n} else {\n    console.log(`No metadata found for Soil at ${ soilPath }`)\n}\nconst canyonPath = path.join(contractsV1Dir, \"canyon.contract.json\");\nconst canyonInterfacePath = path.join(contractInterfacesV1Dir, \"canyon.interface.json\");\nif(fs.existsSync(canyonPath)) {\n    const canyonData = JSON.parse(\n        fs.readFileSync(canyonPath, { encoding: 'utf-8' })\n    );\n    if(!canyonData.source) {\n        console.log(`No source found for Canyon at ${ canyonPath }`)\n        return;\n    }\n    delete canyonData.source.wasm;\n    fs.writeFileSync(canyonInterfacePath, JSON.stringify(canyonData, null, 4));\n    console.log(`Extracted metadata for Canyon to ${ canyonInterfacePath }`)\n} else {\n    console.log(`No metadata found for Canyon at ${ canyonPath }`)\n}\nconst windmillPath = path.join(contractsV1Dir, \"windmill.contract.json\");\nconst windmillInterfacePath = path.join(contractInterfacesV1Dir, \"windmill.interface.json\");\nif(fs.existsSync(windmillPath)) {\n    const windmillData = JSON.parse(\n        fs.readFileSync(windmillPath, { encoding: 'utf-8' })\n    );\n    if(!windmillData.source) {\n        console.log(`No source found for Windmill at ${ windmillPath }`)\n        return;\n    }\n    delete windmillData.source.wasm;\n    fs.writeFileSync(windmillInterfacePath, JSON.stringify(windmillData, null, 4));\n    console.log(`Extracted metadata for Windmill to ${ windmillInterfacePath }`)\n} else {\n    console.log(`No metadata found for Windmill at ${ windmillPath }`)\n}\nconst adobePath = path.join(contractsV1Dir, \"adobe.contract.json\");\nconst adobeInterfacePath = path.join(contractInterfacesV1Dir, \"adobe.interface.json\");\nif(fs.existsSync(adobePath)) {\n    const adobeData = JSON.parse(\n        fs.readFileSync(adobePath, { encoding: 'utf-8' })\n    );\n    if(!adobeData.source) {\n        console.log(`No source found for Adobe at ${ adobePath }`)\n        return;\n    }\n    delete adobeData.source.wasm;\n    fs.writeFileSync(adobeInterfacePath, JSON.stringify(adobeData, null, 4));\n    console.log(`Extracted metadata for Adobe to ${ adobeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Adobe at ${ adobePath }`)\n}\nconst wallPath = path.join(contractsV1Dir, \"wall.contract.json\");\nconst wallInterfacePath = path.join(contractInterfacesV1Dir, \"wall.interface.json\");\nif(fs.existsSync(wallPath)) {\n    const wallData = JSON.parse(\n        fs.readFileSync(wallPath, { encoding: 'utf-8' })\n    );\n    if(!wallData.source) {\n        console.log(`No source found for Wall at ${ wallPath }`)\n        return;\n    }\n    delete wallData.source.wasm;\n    fs.writeFileSync(wallInterfacePath, JSON.stringify(wallData, null, 4));\n    console.log(`Extracted metadata for Wall to ${ wallInterfacePath }`)\n} else {\n    console.log(`No metadata found for Wall at ${ wallPath }`)\n}\nconst pumicePath = path.join(contractsV1Dir, \"pumice.contract.json\");\nconst pumiceInterfacePath = path.join(contractInterfacesV1Dir, \"pumice.interface.json\");\nif(fs.existsSync(pumicePath)) {\n    const pumiceData = JSON.parse(\n        fs.readFileSync(pumicePath, { encoding: 'utf-8' })\n    );\n    if(!pumiceData.source) {\n        console.log(`No source found for Pumice at ${ pumicePath }`)\n        return;\n    }\n    delete pumiceData.source.wasm;\n    fs.writeFileSync(pumiceInterfacePath, JSON.stringify(pumiceData, null, 4));\n    console.log(`Extracted metadata for Pumice to ${ pumiceInterfacePath }`)\n} else {\n    console.log(`No metadata found for Pumice at ${ pumicePath }`)\n}\nconst barbecuePath = path.join(contractsV1Dir, \"barbecue.contract.json\");\nconst barbecueInterfacePath = path.join(contractInterfacesV1Dir, \"barbecue.interface.json\");\nif(fs.existsSync(barbecuePath)) {\n    const barbecueData = JSON.parse(\n        fs.readFileSync(barbecuePath, { encoding: 'utf-8' })\n    );\n    if(!barbecueData.source) {\n        console.log(`No source found for Barbecue at ${ barbecuePath }`)\n        return;\n    }\n    delete barbecueData.source.wasm;\n    fs.writeFileSync(barbecueInterfacePath, JSON.stringify(barbecueData, null, 4));\n    console.log(`Extracted metadata for Barbecue to ${ barbecueInterfacePath }`)\n} else {\n    console.log(`No metadata found for Barbecue at ${ barbecuePath }`)\n}\nconst farmPath = path.join(contractsV1Dir, \"farm.contract.json\");\nconst farmInterfacePath = path.join(contractInterfacesV1Dir, \"farm.interface.json\");\nif(fs.existsSync(farmPath)) {\n    const farmData = JSON.parse(\n        fs.readFileSync(farmPath, { encoding: 'utf-8' })\n    );\n    if(!farmData.source) {\n        console.log(`No source found for Farm at ${ farmPath }`)\n        return;\n    }\n    delete farmData.source.wasm;\n    fs.writeFileSync(farmInterfacePath, JSON.stringify(farmData, null, 4));\n    console.log(`Extracted metadata for Farm to ${ farmInterfacePath }`)\n} else {\n    console.log(`No metadata found for Farm at ${ farmPath }`)\n}\nconst shardsPath = path.join(contractsV1Dir, \"shards.contract.json\");\nconst shardsInterfacePath = path.join(contractInterfacesV1Dir, \"shards.interface.json\");\nif(fs.existsSync(shardsPath)) {\n    const shardsData = JSON.parse(\n        fs.readFileSync(shardsPath, { encoding: 'utf-8' })\n    );\n    if(!shardsData.source) {\n        console.log(`No source found for Shards at ${ shardsPath }`)\n        return;\n    }\n    delete shardsData.source.wasm;\n    fs.writeFileSync(shardsInterfacePath, JSON.stringify(shardsData, null, 4));\n    console.log(`Extracted metadata for Shards to ${ shardsInterfacePath }`)\n} else {\n    console.log(`No metadata found for Shards at ${ shardsPath }`)\n}\nconst moltenGlassPath = path.join(contractsV1Dir, \"molten_glass.contract.json\");\nconst moltenGlassInterfacePath = path.join(contractInterfacesV1Dir, \"molten_glass.interface.json\");\nif(fs.existsSync(moltenGlassPath)) {\n    const moltenGlassData = JSON.parse(\n        fs.readFileSync(moltenGlassPath, { encoding: 'utf-8' })\n    );\n    if(!moltenGlassData.source) {\n        console.log(`No source found for Molten Glass at ${ moltenGlassPath }`)\n        return;\n    }\n    delete moltenGlassData.source.wasm;\n    fs.writeFileSync(moltenGlassInterfacePath, JSON.stringify(moltenGlassData, null, 4));\n    console.log(`Extracted metadata for Molten Glass to ${ moltenGlassInterfacePath }`)\n} else {\n    console.log(`No metadata found for Molten Glass at ${ moltenGlassPath }`)\n}\nconst prismPath = path.join(contractsV1Dir, \"prism.contract.json\");\nconst prismInterfacePath = path.join(contractInterfacesV1Dir, \"prism.interface.json\");\nif(fs.existsSync(prismPath)) {\n    const prismData = JSON.parse(\n        fs.readFileSync(prismPath, { encoding: 'utf-8' })\n    );\n    if(!prismData.source) {\n        console.log(`No source found for Prism at ${ prismPath }`)\n        return;\n    }\n    delete prismData.source.wasm;\n    fs.writeFileSync(prismInterfacePath, JSON.stringify(prismData, null, 4));\n    console.log(`Extracted metadata for Prism to ${ prismInterfacePath }`)\n} else {\n    console.log(`No metadata found for Prism at ${ prismPath }`)\n}\nconst sparklePath = path.join(contractsV1Dir, \"sparkle.contract.json\");\nconst sparkleInterfacePath = path.join(contractInterfacesV1Dir, \"sparkle.interface.json\");\nif(fs.existsSync(sparklePath)) {\n    const sparkleData = JSON.parse(\n        fs.readFileSync(sparklePath, { encoding: 'utf-8' })\n    );\n    if(!sparkleData.source) {\n        console.log(`No source found for Sparkle at ${ sparklePath }`)\n        return;\n    }\n    delete sparkleData.source.wasm;\n    fs.writeFileSync(sparkleInterfacePath, JSON.stringify(sparkleData, null, 4));\n    console.log(`Extracted metadata for Sparkle to ${ sparkleInterfacePath }`)\n} else {\n    console.log(`No metadata found for Sparkle at ${ sparklePath }`)\n}\nconst desertPath = path.join(contractsV1Dir, \"desert.contract.json\");\nconst desertInterfacePath = path.join(contractInterfacesV1Dir, \"desert.interface.json\");\nif(fs.existsSync(desertPath)) {\n    const desertData = JSON.parse(\n        fs.readFileSync(desertPath, { encoding: 'utf-8' })\n    );\n    if(!desertData.source) {\n        console.log(`No source found for Desert at ${ desertPath }`)\n        return;\n    }\n    delete desertData.source.wasm;\n    fs.writeFileSync(desertInterfacePath, JSON.stringify(desertData, null, 4));\n    console.log(`Extracted metadata for Desert to ${ desertInterfacePath }`)\n} else {\n    console.log(`No metadata found for Desert at ${ desertPath }`)\n}\nconst oasisPath = path.join(contractsV1Dir, \"oasis.contract.json\");\nconst oasisInterfacePath = path.join(contractInterfacesV1Dir, \"oasis.interface.json\");\nif(fs.existsSync(oasisPath)) {\n    const oasisData = JSON.parse(\n        fs.readFileSync(oasisPath, { encoding: 'utf-8' })\n    );\n    if(!oasisData.source) {\n        console.log(`No source found for Oasis at ${ oasisPath }`)\n        return;\n    }\n    delete oasisData.source.wasm;\n    fs.writeFileSync(oasisInterfacePath, JSON.stringify(oasisData, null, 4));\n    console.log(`Extracted metadata for Oasis to ${ oasisInterfacePath }`)\n} else {\n    console.log(`No metadata found for Oasis at ${ oasisPath }`)\n}\nconst miragePath = path.join(contractsV1Dir, \"mirage.contract.json\");\nconst mirageInterfacePath = path.join(contractInterfacesV1Dir, \"mirage.interface.json\");\nif(fs.existsSync(miragePath)) {\n    const mirageData = JSON.parse(\n        fs.readFileSync(miragePath, { encoding: 'utf-8' })\n    );\n    if(!mirageData.source) {\n        console.log(`No source found for Mirage at ${ miragePath }`)\n        return;\n    }\n    delete mirageData.source.wasm;\n    fs.writeFileSync(mirageInterfacePath, JSON.stringify(mirageData, null, 4));\n    console.log(`Extracted metadata for Mirage to ${ mirageInterfacePath }`)\n} else {\n    console.log(`No metadata found for Mirage at ${ miragePath }`)\n}\nconst sandDunePath = path.join(contractsV1Dir, \"sand_dune.contract.json\");\nconst sandDuneInterfacePath = path.join(contractInterfacesV1Dir, \"sand_dune.interface.json\");\nif(fs.existsSync(sandDunePath)) {\n    const sandDuneData = JSON.parse(\n        fs.readFileSync(sandDunePath, { encoding: 'utf-8' })\n    );\n    if(!sandDuneData.source) {\n        console.log(`No source found for Sand Dune at ${ sandDunePath }`)\n        return;\n    }\n    delete sandDuneData.source.wasm;\n    fs.writeFileSync(sandDuneInterfacePath, JSON.stringify(sandDuneData, null, 4));\n    console.log(`Extracted metadata for Sand Dune to ${ sandDuneInterfacePath }`)\n} else {\n    console.log(`No metadata found for Sand Dune at ${ sandDunePath }`)\n}\nconst damPath = path.join(contractsV1Dir, \"dam.contract.json\");\nconst damInterfacePath = path.join(contractInterfacesV1Dir, \"dam.interface.json\");\nif(fs.existsSync(damPath)) {\n    const damData = JSON.parse(\n        fs.readFileSync(damPath, { encoding: 'utf-8' })\n    );\n    if(!damData.source) {\n        console.log(`No source found for Dam at ${ damPath }`)\n        return;\n    }\n    delete damData.source.wasm;\n    fs.writeFileSync(damInterfacePath, JSON.stringify(damData, null, 4));\n    console.log(`Extracted metadata for Dam to ${ damInterfacePath }`)\n} else {\n    console.log(`No metadata found for Dam at ${ damPath }`)\n}\nconst firewallPath = path.join(contractsV1Dir, \"firewall.contract.json\");\nconst firewallInterfacePath = path.join(contractInterfacesV1Dir, \"firewall.interface.json\");\nif(fs.existsSync(firewallPath)) {\n    const firewallData = JSON.parse(\n        fs.readFileSync(firewallPath, { encoding: 'utf-8' })\n    );\n    if(!firewallData.source) {\n        console.log(`No source found for Firewall at ${ firewallPath }`)\n        return;\n    }\n    delete firewallData.source.wasm;\n    fs.writeFileSync(firewallInterfacePath, JSON.stringify(firewallData, null, 4));\n    console.log(`Extracted metadata for Firewall to ${ firewallInterfacePath }`)\n} else {\n    console.log(`No metadata found for Firewall at ${ firewallPath }`)\n}\nconst barricadePath = path.join(contractsV1Dir, \"barricade.contract.json\");\nconst barricadeInterfacePath = path.join(contractInterfacesV1Dir, \"barricade.interface.json\");\nif(fs.existsSync(barricadePath)) {\n    const barricadeData = JSON.parse(\n        fs.readFileSync(barricadePath, { encoding: 'utf-8' })\n    );\n    if(!barricadeData.source) {\n        console.log(`No source found for Barricade at ${ barricadePath }`)\n        return;\n    }\n    delete barricadeData.source.wasm;\n    fs.writeFileSync(barricadeInterfacePath, JSON.stringify(barricadeData, null, 4));\n    console.log(`Extracted metadata for Barricade to ${ barricadeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Barricade at ${ barricadePath }`)\n}\nconst plateauPath = path.join(contractsV1Dir, \"plateau.contract.json\");\nconst plateauInterfacePath = path.join(contractInterfacesV1Dir, \"plateau.interface.json\");\nif(fs.existsSync(plateauPath)) {\n    const plateauData = JSON.parse(\n        fs.readFileSync(plateauPath, { encoding: 'utf-8' })\n    );\n    if(!plateauData.source) {\n        console.log(`No source found for Plateau at ${ plateauPath }`)\n        return;\n    }\n    delete plateauData.source.wasm;\n    fs.writeFileSync(plateauInterfacePath, JSON.stringify(plateauData, null, 4));\n    console.log(`Extracted metadata for Plateau to ${ plateauInterfacePath }`)\n} else {\n    console.log(`No metadata found for Plateau at ${ plateauPath }`)\n}\nconst pondPath = path.join(contractsV1Dir, \"pond.contract.json\");\nconst pondInterfacePath = path.join(contractInterfacesV1Dir, \"pond.interface.json\");\nif(fs.existsSync(pondPath)) {\n    const pondData = JSON.parse(\n        fs.readFileSync(pondPath, { encoding: 'utf-8' })\n    );\n    if(!pondData.source) {\n        console.log(`No source found for Pond at ${ pondPath }`)\n        return;\n    }\n    delete pondData.source.wasm;\n    fs.writeFileSync(pondInterfacePath, JSON.stringify(pondData, null, 4));\n    console.log(`Extracted metadata for Pond to ${ pondInterfacePath }`)\n} else {\n    console.log(`No metadata found for Pond at ${ pondPath }`)\n}\nconst aromasPath = path.join(contractsV1Dir, \"aromas.contract.json\");\nconst aromasInterfacePath = path.join(contractInterfacesV1Dir, \"aromas.interface.json\");\nif(fs.existsSync(aromasPath)) {\n    const aromasData = JSON.parse(\n        fs.readFileSync(aromasPath, { encoding: 'utf-8' })\n    );\n    if(!aromasData.source) {\n        console.log(`No source found for Aromas at ${ aromasPath }`)\n        return;\n    }\n    delete aromasData.source.wasm;\n    fs.writeFileSync(aromasInterfacePath, JSON.stringify(aromasData, null, 4));\n    console.log(`Extracted metadata for Aromas to ${ aromasInterfacePath }`)\n} else {\n    console.log(`No metadata found for Aromas at ${ aromasPath }`)\n}\nconst flowerPath = path.join(contractsV1Dir, \"flower.contract.json\");\nconst flowerInterfacePath = path.join(contractInterfacesV1Dir, \"flower.interface.json\");\nif(fs.existsSync(flowerPath)) {\n    const flowerData = JSON.parse(\n        fs.readFileSync(flowerPath, { encoding: 'utf-8' })\n    );\n    if(!flowerData.source) {\n        console.log(`No source found for Flower at ${ flowerPath }`)\n        return;\n    }\n    delete flowerData.source.wasm;\n    fs.writeFileSync(flowerInterfacePath, JSON.stringify(flowerData, null, 4));\n    console.log(`Extracted metadata for Flower to ${ flowerInterfacePath }`)\n} else {\n    console.log(`No metadata found for Flower at ${ flowerPath }`)\n}\nconst sporePath = path.join(contractsV1Dir, \"spore.contract.json\");\nconst sporeInterfacePath = path.join(contractInterfacesV1Dir, \"spore.interface.json\");\nif(fs.existsSync(sporePath)) {\n    const sporeData = JSON.parse(\n        fs.readFileSync(sporePath, { encoding: 'utf-8' })\n    );\n    if(!sporeData.source) {\n        console.log(`No source found for Spore at ${ sporePath }`)\n        return;\n    }\n    delete sporeData.source.wasm;\n    fs.writeFileSync(sporeInterfacePath, JSON.stringify(sporeData, null, 4));\n    console.log(`Extracted metadata for Spore to ${ sporeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Spore at ${ sporePath }`)\n}\nconst spreadPath = path.join(contractsV1Dir, \"spread.contract.json\");\nconst spreadInterfacePath = path.join(contractInterfacesV1Dir, \"spread.interface.json\");\nif(fs.existsSync(spreadPath)) {\n    const spreadData = JSON.parse(\n        fs.readFileSync(spreadPath, { encoding: 'utf-8' })\n    );\n    if(!spreadData.source) {\n        console.log(`No source found for Spread at ${ spreadPath }`)\n        return;\n    }\n    delete spreadData.source.wasm;\n    fs.writeFileSync(spreadInterfacePath, JSON.stringify(spreadData, null, 4));\n    console.log(`Extracted metadata for Spread to ${ spreadInterfacePath }`)\n} else {\n    console.log(`No metadata found for Spread at ${ spreadPath }`)\n}\nconst fertileLandPath = path.join(contractsV1Dir, \"fertile_land.contract.json\");\nconst fertileLandInterfacePath = path.join(contractInterfacesV1Dir, \"fertile_land.interface.json\");\nif(fs.existsSync(fertileLandPath)) {\n    const fertileLandData = JSON.parse(\n        fs.readFileSync(fertileLandPath, { encoding: 'utf-8' })\n    );\n    if(!fertileLandData.source) {\n        console.log(`No source found for Fertile Land at ${ fertileLandPath }`)\n        return;\n    }\n    delete fertileLandData.source.wasm;\n    fs.writeFileSync(fertileLandInterfacePath, JSON.stringify(fertileLandData, null, 4));\n    console.log(`Extracted metadata for Fertile Land to ${ fertileLandInterfacePath }`)\n} else {\n    console.log(`No metadata found for Fertile Land at ${ fertileLandPath }`)\n}\nconst wetlandPath = path.join(contractsV1Dir, \"wetland.contract.json\");\nconst wetlandInterfacePath = path.join(contractInterfacesV1Dir, \"wetland.interface.json\");\nif(fs.existsSync(wetlandPath)) {\n    const wetlandData = JSON.parse(\n        fs.readFileSync(wetlandPath, { encoding: 'utf-8' })\n    );\n    if(!wetlandData.source) {\n        console.log(`No source found for Wetland at ${ wetlandPath }`)\n        return;\n    }\n    delete wetlandData.source.wasm;\n    fs.writeFileSync(wetlandInterfacePath, JSON.stringify(wetlandData, null, 4));\n    console.log(`Extracted metadata for Wetland to ${ wetlandInterfacePath }`)\n} else {\n    console.log(`No metadata found for Wetland at ${ wetlandPath }`)\n}\nconst peatPath = path.join(contractsV1Dir, \"peat.contract.json\");\nconst peatInterfacePath = path.join(contractInterfacesV1Dir, \"peat.interface.json\");\nif(fs.existsSync(peatPath)) {\n    const peatData = JSON.parse(\n        fs.readFileSync(peatPath, { encoding: 'utf-8' })\n    );\n    if(!peatData.source) {\n        console.log(`No source found for Peat at ${ peatPath }`)\n        return;\n    }\n    delete peatData.source.wasm;\n    fs.writeFileSync(peatInterfacePath, JSON.stringify(peatData, null, 4));\n    console.log(`Extracted metadata for Peat to ${ peatInterfacePath }`)\n} else {\n    console.log(`No metadata found for Peat at ${ peatPath }`)\n}\nconst reedsPath = path.join(contractsV1Dir, \"reeds.contract.json\");\nconst reedsInterfacePath = path.join(contractInterfacesV1Dir, \"reeds.interface.json\");\nif(fs.existsSync(reedsPath)) {\n    const reedsData = JSON.parse(\n        fs.readFileSync(reedsPath, { encoding: 'utf-8' })\n    );\n    if(!reedsData.source) {\n        console.log(`No source found for Reeds at ${ reedsPath }`)\n        return;\n    }\n    delete reedsData.source.wasm;\n    fs.writeFileSync(reedsInterfacePath, JSON.stringify(reedsData, null, 4));\n    console.log(`Extracted metadata for Reeds to ${ reedsInterfacePath }`)\n} else {\n    console.log(`No metadata found for Reeds at ${ reedsPath }`)\n}\nconst valleyPath = path.join(contractsV1Dir, \"valley.contract.json\");\nconst valleyInterfacePath = path.join(contractInterfacesV1Dir, \"valley.interface.json\");\nif(fs.existsSync(valleyPath)) {\n    const valleyData = JSON.parse(\n        fs.readFileSync(valleyPath, { encoding: 'utf-8' })\n    );\n    if(!valleyData.source) {\n        console.log(`No source found for Valley at ${ valleyPath }`)\n        return;\n    }\n    delete valleyData.source.wasm;\n    fs.writeFileSync(valleyInterfacePath, JSON.stringify(valleyData, null, 4));\n    console.log(`Extracted metadata for Valley to ${ valleyInterfacePath }`)\n} else {\n    console.log(`No metadata found for Valley at ${ valleyPath }`)\n}\nconst riverPath = path.join(contractsV1Dir, \"river.contract.json\");\nconst riverInterfacePath = path.join(contractInterfacesV1Dir, \"river.interface.json\");\nif(fs.existsSync(riverPath)) {\n    const riverData = JSON.parse(\n        fs.readFileSync(riverPath, { encoding: 'utf-8' })\n    );\n    if(!riverData.source) {\n        console.log(`No source found for River at ${ riverPath }`)\n        return;\n    }\n    delete riverData.source.wasm;\n    fs.writeFileSync(riverInterfacePath, JSON.stringify(riverData, null, 4));\n    console.log(`Extracted metadata for River to ${ riverInterfacePath }`)\n} else {\n    console.log(`No metadata found for River at ${ riverPath }`)\n}\nconst scorchedEarthPath = path.join(contractsV1Dir, \"scorched_earth.contract.json\");\nconst scorchedEarthInterfacePath = path.join(contractInterfacesV1Dir, \"scorched_earth.interface.json\");\nif(fs.existsSync(scorchedEarthPath)) {\n    const scorchedEarthData = JSON.parse(\n        fs.readFileSync(scorchedEarthPath, { encoding: 'utf-8' })\n    );\n    if(!scorchedEarthData.source) {\n        console.log(`No source found for Scorched Earth at ${ scorchedEarthPath }`)\n        return;\n    }\n    delete scorchedEarthData.source.wasm;\n    fs.writeFileSync(scorchedEarthInterfacePath, JSON.stringify(scorchedEarthData, null, 4));\n    console.log(`Extracted metadata for Scorched Earth to ${ scorchedEarthInterfacePath }`)\n} else {\n    console.log(`No metadata found for Scorched Earth at ${ scorchedEarthPath }`)\n}\nconst deltaPath = path.join(contractsV1Dir, \"delta.contract.json\");\nconst deltaInterfacePath = path.join(contractInterfacesV1Dir, \"delta.interface.json\");\nif(fs.existsSync(deltaPath)) {\n    const deltaData = JSON.parse(\n        fs.readFileSync(deltaPath, { encoding: 'utf-8' })\n    );\n    if(!deltaData.source) {\n        console.log(`No source found for Delta at ${ deltaPath }`)\n        return;\n    }\n    delete deltaData.source.wasm;\n    fs.writeFileSync(deltaInterfacePath, JSON.stringify(deltaData, null, 4));\n    console.log(`Extracted metadata for Delta to ${ deltaInterfacePath }`)\n} else {\n    console.log(`No metadata found for Delta at ${ deltaPath }`)\n}\nconst estuaryPath = path.join(contractsV1Dir, \"estuary.contract.json\");\nconst estuaryInterfacePath = path.join(contractInterfacesV1Dir, \"estuary.interface.json\");\nif(fs.existsSync(estuaryPath)) {\n    const estuaryData = JSON.parse(\n        fs.readFileSync(estuaryPath, { encoding: 'utf-8' })\n    );\n    if(!estuaryData.source) {\n        console.log(`No source found for Estuary at ${ estuaryPath }`)\n        return;\n    }\n    delete estuaryData.source.wasm;\n    fs.writeFileSync(estuaryInterfacePath, JSON.stringify(estuaryData, null, 4));\n    console.log(`Extracted metadata for Estuary to ${ estuaryInterfacePath }`)\n} else {\n    console.log(`No metadata found for Estuary at ${ estuaryPath }`)\n}\nconst fireSwampPath = path.join(contractsV1Dir, \"fire_swamp.contract.json\");\nconst fireSwampInterfacePath = path.join(contractInterfacesV1Dir, \"fire_swamp.interface.json\");\nif(fs.existsSync(fireSwampPath)) {\n    const fireSwampData = JSON.parse(\n        fs.readFileSync(fireSwampPath, { encoding: 'utf-8' })\n    );\n    if(!fireSwampData.source) {\n        console.log(`No source found for Fire Swamp at ${ fireSwampPath }`)\n        return;\n    }\n    delete fireSwampData.source.wasm;\n    fs.writeFileSync(fireSwampInterfacePath, JSON.stringify(fireSwampData, null, 4));\n    console.log(`Extracted metadata for Fire Swamp to ${ fireSwampInterfacePath }`)\n} else {\n    console.log(`No metadata found for Fire Swamp at ${ fireSwampPath }`)\n}\nconst riverbankPath = path.join(contractsV1Dir, \"riverbank.contract.json\");\nconst riverbankInterfacePath = path.join(contractInterfacesV1Dir, \"riverbank.interface.json\");\nif(fs.existsSync(riverbankPath)) {\n    const riverbankData = JSON.parse(\n        fs.readFileSync(riverbankPath, { encoding: 'utf-8' })\n    );\n    if(!riverbankData.source) {\n        console.log(`No source found for Riverbank at ${ riverbankPath }`)\n        return;\n    }\n    delete riverbankData.source.wasm;\n    fs.writeFileSync(riverbankInterfacePath, JSON.stringify(riverbankData, null, 4));\n    console.log(`Extracted metadata for Riverbank to ${ riverbankInterfacePath }`)\n} else {\n    console.log(`No metadata found for Riverbank at ${ riverbankPath }`)\n}\nconst ravinePath = path.join(contractsV1Dir, \"ravine.contract.json\");\nconst ravineInterfacePath = path.join(contractInterfacesV1Dir, \"ravine.interface.json\");\nif(fs.existsSync(ravinePath)) {\n    const ravineData = JSON.parse(\n        fs.readFileSync(ravinePath, { encoding: 'utf-8' })\n    );\n    if(!ravineData.source) {\n        console.log(`No source found for Ravine at ${ ravinePath }`)\n        return;\n    }\n    delete ravineData.source.wasm;\n    fs.writeFileSync(ravineInterfacePath, JSON.stringify(ravineData, null, 4));\n    console.log(`Extracted metadata for Ravine to ${ ravineInterfacePath }`)\n} else {\n    console.log(`No metadata found for Ravine at ${ ravinePath }`)\n}\nconst gorgePath = path.join(contractsV1Dir, \"gorge.contract.json\");\nconst gorgeInterfacePath = path.join(contractInterfacesV1Dir, \"gorge.interface.json\");\nif(fs.existsSync(gorgePath)) {\n    const gorgeData = JSON.parse(\n        fs.readFileSync(gorgePath, { encoding: 'utf-8' })\n    );\n    if(!gorgeData.source) {\n        console.log(`No source found for Gorge at ${ gorgePath }`)\n        return;\n    }\n    delete gorgeData.source.wasm;\n    fs.writeFileSync(gorgeInterfacePath, JSON.stringify(gorgeData, null, 4));\n    console.log(`Extracted metadata for Gorge to ${ gorgeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Gorge at ${ gorgePath }`)\n}\nconst charredRavinePath = path.join(contractsV1Dir, \"charred_ravine.contract.json\");\nconst charredRavineInterfacePath = path.join(contractInterfacesV1Dir, \"charred_ravine.interface.json\");\nif(fs.existsSync(charredRavinePath)) {\n    const charredRavineData = JSON.parse(\n        fs.readFileSync(charredRavinePath, { encoding: 'utf-8' })\n    );\n    if(!charredRavineData.source) {\n        console.log(`No source found for Charred Ravine at ${ charredRavinePath }`)\n        return;\n    }\n    delete charredRavineData.source.wasm;\n    fs.writeFileSync(charredRavineInterfacePath, JSON.stringify(charredRavineData, null, 4));\n    console.log(`Extracted metadata for Charred Ravine to ${ charredRavineInterfacePath }`)\n} else {\n    console.log(`No metadata found for Charred Ravine at ${ charredRavinePath }`)\n}\nconst echoPath = path.join(contractsV1Dir, \"echo.contract.json\");\nconst echoInterfacePath = path.join(contractInterfacesV1Dir, \"echo.interface.json\");\nif(fs.existsSync(echoPath)) {\n    const echoData = JSON.parse(\n        fs.readFileSync(echoPath, { encoding: 'utf-8' })\n    );\n    if(!echoData.source) {\n        console.log(`No source found for Echo at ${ echoPath }`)\n        return;\n    }\n    delete echoData.source.wasm;\n    fs.writeFileSync(echoInterfacePath, JSON.stringify(echoData, null, 4));\n    console.log(`Extracted metadata for Echo to ${ echoInterfacePath }`)\n} else {\n    console.log(`No metadata found for Echo at ${ echoPath }`)\n}\nconst cavePath = path.join(contractsV1Dir, \"cave.contract.json\");\nconst caveInterfacePath = path.join(contractInterfacesV1Dir, \"cave.interface.json\");\nif(fs.existsSync(cavePath)) {\n    const caveData = JSON.parse(\n        fs.readFileSync(cavePath, { encoding: 'utf-8' })\n    );\n    if(!caveData.source) {\n        console.log(`No source found for Cave at ${ cavePath }`)\n        return;\n    }\n    delete caveData.source.wasm;\n    fs.writeFileSync(caveInterfacePath, JSON.stringify(caveData, null, 4));\n    console.log(`Extracted metadata for Cave to ${ caveInterfacePath }`)\n} else {\n    console.log(`No metadata found for Cave at ${ cavePath }`)\n}\nconst undergroundLakePath = path.join(contractsV1Dir, \"underground_lake.contract.json\");\nconst undergroundLakeInterfacePath = path.join(contractInterfacesV1Dir, \"underground_lake.interface.json\");\nif(fs.existsSync(undergroundLakePath)) {\n    const undergroundLakeData = JSON.parse(\n        fs.readFileSync(undergroundLakePath, { encoding: 'utf-8' })\n    );\n    if(!undergroundLakeData.source) {\n        console.log(`No source found for Underground Lake at ${ undergroundLakePath }`)\n        return;\n    }\n    delete undergroundLakeData.source.wasm;\n    fs.writeFileSync(undergroundLakeInterfacePath, JSON.stringify(undergroundLakeData, null, 4));\n    console.log(`Extracted metadata for Underground Lake to ${ undergroundLakeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Underground Lake at ${ undergroundLakePath }`)\n}\nconst lavaCavePath = path.join(contractsV1Dir, \"lava_cave.contract.json\");\nconst lavaCaveInterfacePath = path.join(contractInterfacesV1Dir, \"lava_cave.interface.json\");\nif(fs.existsSync(lavaCavePath)) {\n    const lavaCaveData = JSON.parse(\n        fs.readFileSync(lavaCavePath, { encoding: 'utf-8' })\n    );\n    if(!lavaCaveData.source) {\n        console.log(`No source found for Lava Cave at ${ lavaCavePath }`)\n        return;\n    }\n    delete lavaCaveData.source.wasm;\n    fs.writeFileSync(lavaCaveInterfacePath, JSON.stringify(lavaCaveData, null, 4));\n    console.log(`Extracted metadata for Lava Cave to ${ lavaCaveInterfacePath }`)\n} else {\n    console.log(`No metadata found for Lava Cave at ${ lavaCavePath }`)\n}\nconst whisperingCavePath = path.join(contractsV1Dir, \"whispering_cave.contract.json\");\nconst whisperingCaveInterfacePath = path.join(contractInterfacesV1Dir, \"whispering_cave.interface.json\");\nif(fs.existsSync(whisperingCavePath)) {\n    const whisperingCaveData = JSON.parse(\n        fs.readFileSync(whisperingCavePath, { encoding: 'utf-8' })\n    );\n    if(!whisperingCaveData.source) {\n        console.log(`No source found for Whispering Cave at ${ whisperingCavePath }`)\n        return;\n    }\n    delete whisperingCaveData.source.wasm;\n    fs.writeFileSync(whisperingCaveInterfacePath, JSON.stringify(whisperingCaveData, null, 4));\n    console.log(`Extracted metadata for Whispering Cave to ${ whisperingCaveInterfacePath }`)\n} else {\n    console.log(`No metadata found for Whispering Cave at ${ whisperingCavePath }`)\n}\nconst subterraneanPoolPath = path.join(contractsV1Dir, \"subterranean_pool.contract.json\");\nconst subterraneanPoolInterfacePath = path.join(contractInterfacesV1Dir, \"subterranean_pool.interface.json\");\nif(fs.existsSync(subterraneanPoolPath)) {\n    const subterraneanPoolData = JSON.parse(\n        fs.readFileSync(subterraneanPoolPath, { encoding: 'utf-8' })\n    );\n    if(!subterraneanPoolData.source) {\n        console.log(`No source found for Subterranean Pool at ${ subterraneanPoolPath }`)\n        return;\n    }\n    delete subterraneanPoolData.source.wasm;\n    fs.writeFileSync(subterraneanPoolInterfacePath, JSON.stringify(subterraneanPoolData, null, 4));\n    console.log(`Extracted metadata for Subterranean Pool to ${ subterraneanPoolInterfacePath }`)\n} else {\n    console.log(`No metadata found for Subterranean Pool at ${ subterraneanPoolPath }`)\n}\nconst springPath = path.join(contractsV1Dir, \"spring.contract.json\");\nconst springInterfacePath = path.join(contractInterfacesV1Dir, \"spring.interface.json\");\nif(fs.existsSync(springPath)) {\n    const springData = JSON.parse(\n        fs.readFileSync(springPath, { encoding: 'utf-8' })\n    );\n    if(!springData.source) {\n        console.log(`No source found for Spring at ${ springPath }`)\n        return;\n    }\n    delete springData.source.wasm;\n    fs.writeFileSync(springInterfacePath, JSON.stringify(springData, null, 4));\n    console.log(`Extracted metadata for Spring to ${ springInterfacePath }`)\n} else {\n    console.log(`No metadata found for Spring at ${ springPath }`)\n}\nconst hotSpringPath = path.join(contractsV1Dir, \"hot_spring.contract.json\");\nconst hotSpringInterfacePath = path.join(contractInterfacesV1Dir, \"hot_spring.interface.json\");\nif(fs.existsSync(hotSpringPath)) {\n    const hotSpringData = JSON.parse(\n        fs.readFileSync(hotSpringPath, { encoding: 'utf-8' })\n    );\n    if(!hotSpringData.source) {\n        console.log(`No source found for Hot Spring at ${ hotSpringPath }`)\n        return;\n    }\n    delete hotSpringData.source.wasm;\n    fs.writeFileSync(hotSpringInterfacePath, JSON.stringify(hotSpringData, null, 4));\n    console.log(`Extracted metadata for Hot Spring to ${ hotSpringInterfacePath }`)\n} else {\n    console.log(`No metadata found for Hot Spring at ${ hotSpringPath }`)\n}\nconst grottoPath = path.join(contractsV1Dir, \"grotto.contract.json\");\nconst grottoInterfacePath = path.join(contractInterfacesV1Dir, \"grotto.interface.json\");\nif(fs.existsSync(grottoPath)) {\n    const grottoData = JSON.parse(\n        fs.readFileSync(grottoPath, { encoding: 'utf-8' })\n    );\n    if(!grottoData.source) {\n        console.log(`No source found for Grotto at ${ grottoPath }`)\n        return;\n    }\n    delete grottoData.source.wasm;\n    fs.writeFileSync(grottoInterfacePath, JSON.stringify(grottoData, null, 4));\n    console.log(`Extracted metadata for Grotto to ${ grottoInterfacePath }`)\n} else {\n    console.log(`No metadata found for Grotto at ${ grottoPath }`)\n}\nconst fountainPath = path.join(contractsV1Dir, \"fountain.contract.json\");\nconst fountainInterfacePath = path.join(contractInterfacesV1Dir, \"fountain.interface.json\");\nif(fs.existsSync(fountainPath)) {\n    const fountainData = JSON.parse(\n        fs.readFileSync(fountainPath, { encoding: 'utf-8' })\n    );\n    if(!fountainData.source) {\n        console.log(`No source found for Fountain at ${ fountainPath }`)\n        return;\n    }\n    delete fountainData.source.wasm;\n    fs.writeFileSync(fountainInterfacePath, JSON.stringify(fountainData, null, 4));\n    console.log(`Extracted metadata for Fountain to ${ fountainInterfacePath }`)\n} else {\n    console.log(`No metadata found for Fountain at ${ fountainPath }`)\n}\nconst steamVentPath = path.join(contractsV1Dir, \"steam_vent.contract.json\");\nconst steamVentInterfacePath = path.join(contractInterfacesV1Dir, \"steam_vent.interface.json\");\nif(fs.existsSync(steamVentPath)) {\n    const steamVentData = JSON.parse(\n        fs.readFileSync(steamVentPath, { encoding: 'utf-8' })\n    );\n    if(!steamVentData.source) {\n        console.log(`No source found for Steam Vent at ${ steamVentPath }`)\n        return;\n    }\n    delete steamVentData.source.wasm;\n    fs.writeFileSync(steamVentInterfacePath, JSON.stringify(steamVentData, null, 4));\n    console.log(`Extracted metadata for Steam Vent to ${ steamVentInterfacePath }`)\n} else {\n    console.log(`No metadata found for Steam Vent at ${ steamVentPath }`)\n}\nconst coolBreezePath = path.join(contractsV1Dir, \"cool_breeze.contract.json\");\nconst coolBreezeInterfacePath = path.join(contractInterfacesV1Dir, \"cool_breeze.interface.json\");\nif(fs.existsSync(coolBreezePath)) {\n    const coolBreezeData = JSON.parse(\n        fs.readFileSync(coolBreezePath, { encoding: 'utf-8' })\n    );\n    if(!coolBreezeData.source) {\n        console.log(`No source found for Cool Breeze at ${ coolBreezePath }`)\n        return;\n    }\n    delete coolBreezeData.source.wasm;\n    fs.writeFileSync(coolBreezeInterfacePath, JSON.stringify(coolBreezeData, null, 4));\n    console.log(`Extracted metadata for Cool Breeze to ${ coolBreezeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Cool Breeze at ${ coolBreezePath }`)\n}\nconst monumentPath = path.join(contractsV1Dir, \"monument.contract.json\");\nconst monumentInterfacePath = path.join(contractInterfacesV1Dir, \"monument.interface.json\");\nif(fs.existsSync(monumentPath)) {\n    const monumentData = JSON.parse(\n        fs.readFileSync(monumentPath, { encoding: 'utf-8' })\n    );\n    if(!monumentData.source) {\n        console.log(`No source found for Monument at ${ monumentPath }`)\n        return;\n    }\n    delete monumentData.source.wasm;\n    fs.writeFileSync(monumentInterfacePath, JSON.stringify(monumentData, null, 4));\n    console.log(`Extracted metadata for Monument to ${ monumentInterfacePath }`)\n} else {\n    console.log(`No metadata found for Monument at ${ monumentPath }`)\n}\nconst waterfallPath = path.join(contractsV1Dir, \"waterfall.contract.json\");\nconst waterfallInterfacePath = path.join(contractInterfacesV1Dir, \"waterfall.interface.json\");\nif(fs.existsSync(waterfallPath)) {\n    const waterfallData = JSON.parse(\n        fs.readFileSync(waterfallPath, { encoding: 'utf-8' })\n    );\n    if(!waterfallData.source) {\n        console.log(`No source found for Waterfall at ${ waterfallPath }`)\n        return;\n    }\n    delete waterfallData.source.wasm;\n    fs.writeFileSync(waterfallInterfacePath, JSON.stringify(waterfallData, null, 4));\n    console.log(`Extracted metadata for Waterfall to ${ waterfallInterfacePath }`)\n} else {\n    console.log(`No metadata found for Waterfall at ${ waterfallPath }`)\n}\nconst eternalFlamePath = path.join(contractsV1Dir, \"eternal_flame.contract.json\");\nconst eternalFlameInterfacePath = path.join(contractInterfacesV1Dir, \"eternal_flame.interface.json\");\nif(fs.existsSync(eternalFlamePath)) {\n    const eternalFlameData = JSON.parse(\n        fs.readFileSync(eternalFlamePath, { encoding: 'utf-8' })\n    );\n    if(!eternalFlameData.source) {\n        console.log(`No source found for Eternal Flame at ${ eternalFlamePath }`)\n        return;\n    }\n    delete eternalFlameData.source.wasm;\n    fs.writeFileSync(eternalFlameInterfacePath, JSON.stringify(eternalFlameData, null, 4));\n    console.log(`Extracted metadata for Eternal Flame to ${ eternalFlameInterfacePath }`)\n} else {\n    console.log(`No metadata found for Eternal Flame at ${ eternalFlamePath }`)\n}\nconst pillarOfWindPath = path.join(contractsV1Dir, \"pillar_of_wind.contract.json\");\nconst pillarOfWindInterfacePath = path.join(contractInterfacesV1Dir, \"pillar_of_wind.interface.json\");\nif(fs.existsSync(pillarOfWindPath)) {\n    const pillarOfWindData = JSON.parse(\n        fs.readFileSync(pillarOfWindPath, { encoding: 'utf-8' })\n    );\n    if(!pillarOfWindData.source) {\n        console.log(`No source found for Pillar of Wind at ${ pillarOfWindPath }`)\n        return;\n    }\n    delete pillarOfWindData.source.wasm;\n    fs.writeFileSync(pillarOfWindInterfacePath, JSON.stringify(pillarOfWindData, null, 4));\n    console.log(`Extracted metadata for Pillar of Wind to ${ pillarOfWindInterfacePath }`)\n} else {\n    console.log(`No metadata found for Pillar of Wind at ${ pillarOfWindPath }`)\n}\nconst streamPath = path.join(contractsV1Dir, \"stream.contract.json\");\nconst streamInterfacePath = path.join(contractInterfacesV1Dir, \"stream.interface.json\");\nif(fs.existsSync(streamPath)) {\n    const streamData = JSON.parse(\n        fs.readFileSync(streamPath, { encoding: 'utf-8' })\n    );\n    if(!streamData.source) {\n        console.log(`No source found for Stream at ${ streamPath }`)\n        return;\n    }\n    delete streamData.source.wasm;\n    fs.writeFileSync(streamInterfacePath, JSON.stringify(streamData, null, 4));\n    console.log(`Extracted metadata for Stream to ${ streamInterfacePath }`)\n} else {\n    console.log(`No metadata found for Stream at ${ streamPath }`)\n}\nconst zephyrPath = path.join(contractsV1Dir, \"zephyr.contract.json\");\nconst zephyrInterfacePath = path.join(contractInterfacesV1Dir, \"zephyr.interface.json\");\nif(fs.existsSync(zephyrPath)) {\n    const zephyrData = JSON.parse(\n        fs.readFileSync(zephyrPath, { encoding: 'utf-8' })\n    );\n    if(!zephyrData.source) {\n        console.log(`No source found for Zephyr at ${ zephyrPath }`)\n        return;\n    }\n    delete zephyrData.source.wasm;\n    fs.writeFileSync(zephyrInterfacePath, JSON.stringify(zephyrData, null, 4));\n    console.log(`Extracted metadata for Zephyr to ${ zephyrInterfacePath }`)\n} else {\n    console.log(`No metadata found for Zephyr at ${ zephyrPath }`)\n}\nconst creekPath = path.join(contractsV1Dir, \"creek.contract.json\");\nconst creekInterfacePath = path.join(contractInterfacesV1Dir, \"creek.interface.json\");\nif(fs.existsSync(creekPath)) {\n    const creekData = JSON.parse(\n        fs.readFileSync(creekPath, { encoding: 'utf-8' })\n    );\n    if(!creekData.source) {\n        console.log(`No source found for Creek at ${ creekPath }`)\n        return;\n    }\n    delete creekData.source.wasm;\n    fs.writeFileSync(creekInterfacePath, JSON.stringify(creekData, null, 4));\n    console.log(`Extracted metadata for Creek to ${ creekInterfacePath }`)\n} else {\n    console.log(`No metadata found for Creek at ${ creekPath }`)\n}\nconst brookPath = path.join(contractsV1Dir, \"brook.contract.json\");\nconst brookInterfacePath = path.join(contractInterfacesV1Dir, \"brook.interface.json\");\nif(fs.existsSync(brookPath)) {\n    const brookData = JSON.parse(\n        fs.readFileSync(brookPath, { encoding: 'utf-8' })\n    );\n    if(!brookData.source) {\n        console.log(`No source found for Brook at ${ brookPath }`)\n        return;\n    }\n    delete brookData.source.wasm;\n    fs.writeFileSync(brookInterfacePath, JSON.stringify(brookData, null, 4));\n    console.log(`Extracted metadata for Brook to ${ brookInterfacePath }`)\n} else {\n    console.log(`No metadata found for Brook at ${ brookPath }`)\n}\nconst whisperPath = path.join(contractsV1Dir, \"whisper.contract.json\");\nconst whisperInterfacePath = path.join(contractInterfacesV1Dir, \"whisper.interface.json\");\nif(fs.existsSync(whisperPath)) {\n    const whisperData = JSON.parse(\n        fs.readFileSync(whisperPath, { encoding: 'utf-8' })\n    );\n    if(!whisperData.source) {\n        console.log(`No source found for Whisper at ${ whisperPath }`)\n        return;\n    }\n    delete whisperData.source.wasm;\n    fs.writeFileSync(whisperInterfacePath, JSON.stringify(whisperData, null, 4));\n    console.log(`Extracted metadata for Whisper to ${ whisperInterfacePath }`)\n} else {\n    console.log(`No metadata found for Whisper at ${ whisperPath }`)\n}\nconst rivuletPath = path.join(contractsV1Dir, \"rivulet.contract.json\");\nconst rivuletInterfacePath = path.join(contractInterfacesV1Dir, \"rivulet.interface.json\");\nif(fs.existsSync(rivuletPath)) {\n    const rivuletData = JSON.parse(\n        fs.readFileSync(rivuletPath, { encoding: 'utf-8' })\n    );\n    if(!rivuletData.source) {\n        console.log(`No source found for Rivulet at ${ rivuletPath }`)\n        return;\n    }\n    delete rivuletData.source.wasm;\n    fs.writeFileSync(rivuletInterfacePath, JSON.stringify(rivuletData, null, 4));\n    console.log(`Extracted metadata for Rivulet to ${ rivuletInterfacePath }`)\n} else {\n    console.log(`No metadata found for Rivulet at ${ rivuletPath }`)\n}\nconst tributaryPath = path.join(contractsV1Dir, \"tributary.contract.json\");\nconst tributaryInterfacePath = path.join(contractInterfacesV1Dir, \"tributary.interface.json\");\nif(fs.existsSync(tributaryPath)) {\n    const tributaryData = JSON.parse(\n        fs.readFileSync(tributaryPath, { encoding: 'utf-8' })\n    );\n    if(!tributaryData.source) {\n        console.log(`No source found for Tributary at ${ tributaryPath }`)\n        return;\n    }\n    delete tributaryData.source.wasm;\n    fs.writeFileSync(tributaryInterfacePath, JSON.stringify(tributaryData, null, 4));\n    console.log(`Extracted metadata for Tributary to ${ tributaryInterfacePath }`)\n} else {\n    console.log(`No metadata found for Tributary at ${ tributaryPath }`)\n}\nconst murmurPath = path.join(contractsV1Dir, \"murmur.contract.json\");\nconst murmurInterfacePath = path.join(contractInterfacesV1Dir, \"murmur.interface.json\");\nif(fs.existsSync(murmurPath)) {\n    const murmurData = JSON.parse(\n        fs.readFileSync(murmurPath, { encoding: 'utf-8' })\n    );\n    if(!murmurData.source) {\n        console.log(`No source found for Murmur at ${ murmurPath }`)\n        return;\n    }\n    delete murmurData.source.wasm;\n    fs.writeFileSync(murmurInterfacePath, JSON.stringify(murmurData, null, 4));\n    console.log(`Extracted metadata for Murmur to ${ murmurInterfacePath }`)\n} else {\n    console.log(`No metadata found for Murmur at ${ murmurPath }`)\n}\nconst watershedPath = path.join(contractsV1Dir, \"watershed.contract.json\");\nconst watershedInterfacePath = path.join(contractInterfacesV1Dir, \"watershed.interface.json\");\nif(fs.existsSync(watershedPath)) {\n    const watershedData = JSON.parse(\n        fs.readFileSync(watershedPath, { encoding: 'utf-8' })\n    );\n    if(!watershedData.source) {\n        console.log(`No source found for Watershed at ${ watershedPath }`)\n        return;\n    }\n    delete watershedData.source.wasm;\n    fs.writeFileSync(watershedInterfacePath, JSON.stringify(watershedData, null, 4));\n    console.log(`Extracted metadata for Watershed to ${ watershedInterfacePath }`)\n} else {\n    console.log(`No metadata found for Watershed at ${ watershedPath }`)\n}\nconst aquiferPath = path.join(contractsV1Dir, \"aquifer.contract.json\");\nconst aquiferInterfacePath = path.join(contractInterfacesV1Dir, \"aquifer.interface.json\");\nif(fs.existsSync(aquiferPath)) {\n    const aquiferData = JSON.parse(\n        fs.readFileSync(aquiferPath, { encoding: 'utf-8' })\n    );\n    if(!aquiferData.source) {\n        console.log(`No source found for Aquifer at ${ aquiferPath }`)\n        return;\n    }\n    delete aquiferData.source.wasm;\n    fs.writeFileSync(aquiferInterfacePath, JSON.stringify(aquiferData, null, 4));\n    console.log(`Extracted metadata for Aquifer to ${ aquiferInterfacePath }`)\n} else {\n    console.log(`No metadata found for Aquifer at ${ aquiferPath }`)\n}\nconst parchedEarthPath = path.join(contractsV1Dir, \"parched_earth.contract.json\");\nconst parchedEarthInterfacePath = path.join(contractInterfacesV1Dir, \"parched_earth.interface.json\");\nif(fs.existsSync(parchedEarthPath)) {\n    const parchedEarthData = JSON.parse(\n        fs.readFileSync(parchedEarthPath, { encoding: 'utf-8' })\n    );\n    if(!parchedEarthData.source) {\n        console.log(`No source found for Parched Earth at ${ parchedEarthPath }`)\n        return;\n    }\n    delete parchedEarthData.source.wasm;\n    fs.writeFileSync(parchedEarthInterfacePath, JSON.stringify(parchedEarthData, null, 4));\n    console.log(`Extracted metadata for Parched Earth to ${ parchedEarthInterfacePath }`)\n} else {\n    console.log(`No metadata found for Parched Earth at ${ parchedEarthPath }`)\n}\nconst freshBreezePath = path.join(contractsV1Dir, \"fresh_breeze.contract.json\");\nconst freshBreezeInterfacePath = path.join(contractInterfacesV1Dir, \"fresh_breeze.interface.json\");\nif(fs.existsSync(freshBreezePath)) {\n    const freshBreezeData = JSON.parse(\n        fs.readFileSync(freshBreezePath, { encoding: 'utf-8' })\n    );\n    if(!freshBreezeData.source) {\n        console.log(`No source found for Fresh Breeze at ${ freshBreezePath }`)\n        return;\n    }\n    delete freshBreezeData.source.wasm;\n    fs.writeFileSync(freshBreezeInterfacePath, JSON.stringify(freshBreezeData, null, 4));\n    console.log(`Extracted metadata for Fresh Breeze to ${ freshBreezeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Fresh Breeze at ${ freshBreezePath }`)\n}\nconst groundwaterPath = path.join(contractsV1Dir, \"groundwater.contract.json\");\nconst groundwaterInterfacePath = path.join(contractInterfacesV1Dir, \"groundwater.interface.json\");\nif(fs.existsSync(groundwaterPath)) {\n    const groundwaterData = JSON.parse(\n        fs.readFileSync(groundwaterPath, { encoding: 'utf-8' })\n    );\n    if(!groundwaterData.source) {\n        console.log(`No source found for Groundwater at ${ groundwaterPath }`)\n        return;\n    }\n    delete groundwaterData.source.wasm;\n    fs.writeFileSync(groundwaterInterfacePath, JSON.stringify(groundwaterData, null, 4));\n    console.log(`Extracted metadata for Groundwater to ${ groundwaterInterfacePath }`)\n} else {\n    console.log(`No metadata found for Groundwater at ${ groundwaterPath }`)\n}\nconst reservoirPath = path.join(contractsV1Dir, \"reservoir.contract.json\");\nconst reservoirInterfacePath = path.join(contractInterfacesV1Dir, \"reservoir.interface.json\");\nif(fs.existsSync(reservoirPath)) {\n    const reservoirData = JSON.parse(\n        fs.readFileSync(reservoirPath, { encoding: 'utf-8' })\n    );\n    if(!reservoirData.source) {\n        console.log(`No source found for Reservoir at ${ reservoirPath }`)\n        return;\n    }\n    delete reservoirData.source.wasm;\n    fs.writeFileSync(reservoirInterfacePath, JSON.stringify(reservoirData, null, 4));\n    console.log(`Extracted metadata for Reservoir to ${ reservoirInterfacePath }`)\n} else {\n    console.log(`No metadata found for Reservoir at ${ reservoirPath }`)\n}\nconst geothermalSpringPath = path.join(contractsV1Dir, \"geothermal_spring.contract.json\");\nconst geothermalSpringInterfacePath = path.join(contractInterfacesV1Dir, \"geothermal_spring.interface.json\");\nif(fs.existsSync(geothermalSpringPath)) {\n    const geothermalSpringData = JSON.parse(\n        fs.readFileSync(geothermalSpringPath, { encoding: 'utf-8' })\n    );\n    if(!geothermalSpringData.source) {\n        console.log(`No source found for Geothermal Spring at ${ geothermalSpringPath }`)\n        return;\n    }\n    delete geothermalSpringData.source.wasm;\n    fs.writeFileSync(geothermalSpringInterfacePath, JSON.stringify(geothermalSpringData, null, 4));\n    console.log(`Extracted metadata for Geothermal Spring to ${ geothermalSpringInterfacePath }`)\n} else {\n    console.log(`No metadata found for Geothermal Spring at ${ geothermalSpringPath }`)\n}\nconst artesianWellPath = path.join(contractsV1Dir, \"artesian_well.contract.json\");\nconst artesianWellInterfacePath = path.join(contractInterfacesV1Dir, \"artesian_well.interface.json\");\nif(fs.existsSync(artesianWellPath)) {\n    const artesianWellData = JSON.parse(\n        fs.readFileSync(artesianWellPath, { encoding: 'utf-8' })\n    );\n    if(!artesianWellData.source) {\n        console.log(`No source found for Artesian Well at ${ artesianWellPath }`)\n        return;\n    }\n    delete artesianWellData.source.wasm;\n    fs.writeFileSync(artesianWellInterfacePath, JSON.stringify(artesianWellData, null, 4));\n    console.log(`Extracted metadata for Artesian Well to ${ artesianWellInterfacePath }`)\n} else {\n    console.log(`No metadata found for Artesian Well at ${ artesianWellPath }`)\n}\nconst basinPath = path.join(contractsV1Dir, \"basin.contract.json\");\nconst basinInterfacePath = path.join(contractInterfacesV1Dir, \"basin.interface.json\");\nif(fs.existsSync(basinPath)) {\n    const basinData = JSON.parse(\n        fs.readFileSync(basinPath, { encoding: 'utf-8' })\n    );\n    if(!basinData.source) {\n        console.log(`No source found for Basin at ${ basinPath }`)\n        return;\n    }\n    delete basinData.source.wasm;\n    fs.writeFileSync(basinInterfacePath, JSON.stringify(basinData, null, 4));\n    console.log(`Extracted metadata for Basin to ${ basinInterfacePath }`)\n} else {\n    console.log(`No metadata found for Basin at ${ basinPath }`)\n}\nconst lakePath = path.join(contractsV1Dir, \"lake.contract.json\");\nconst lakeInterfacePath = path.join(contractInterfacesV1Dir, \"lake.interface.json\");\nif(fs.existsSync(lakePath)) {\n    const lakeData = JSON.parse(\n        fs.readFileSync(lakePath, { encoding: 'utf-8' })\n    );\n    if(!lakeData.source) {\n        console.log(`No source found for Lake at ${ lakePath }`)\n        return;\n    }\n    delete lakeData.source.wasm;\n    fs.writeFileSync(lakeInterfacePath, JSON.stringify(lakeData, null, 4));\n    console.log(`Extracted metadata for Lake to ${ lakeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Lake at ${ lakePath }`)\n}\nconst dryBasinPath = path.join(contractsV1Dir, \"dry_basin.contract.json\");\nconst dryBasinInterfacePath = path.join(contractInterfacesV1Dir, \"dry_basin.interface.json\");\nif(fs.existsSync(dryBasinPath)) {\n    const dryBasinData = JSON.parse(\n        fs.readFileSync(dryBasinPath, { encoding: 'utf-8' })\n    );\n    if(!dryBasinData.source) {\n        console.log(`No source found for Dry Basin at ${ dryBasinPath }`)\n        return;\n    }\n    delete dryBasinData.source.wasm;\n    fs.writeFileSync(dryBasinInterfacePath, JSON.stringify(dryBasinData, null, 4));\n    console.log(`Extracted metadata for Dry Basin to ${ dryBasinInterfacePath }`)\n} else {\n    console.log(`No metadata found for Dry Basin at ${ dryBasinPath }`)\n}\nconst depressionPath = path.join(contractsV1Dir, \"depression.contract.json\");\nconst depressionInterfacePath = path.join(contractInterfacesV1Dir, \"depression.interface.json\");\nif(fs.existsSync(depressionPath)) {\n    const depressionData = JSON.parse(\n        fs.readFileSync(depressionPath, { encoding: 'utf-8' })\n    );\n    if(!depressionData.source) {\n        console.log(`No source found for Depression at ${ depressionPath }`)\n        return;\n    }\n    delete depressionData.source.wasm;\n    fs.writeFileSync(depressionInterfacePath, JSON.stringify(depressionData, null, 4));\n    console.log(`Extracted metadata for Depression to ${ depressionInterfacePath }`)\n} else {\n    console.log(`No metadata found for Depression at ${ depressionPath }`)\n}\nconst islandPath = path.join(contractsV1Dir, \"island.contract.json\");\nconst islandInterfacePath = path.join(contractInterfacesV1Dir, \"island.interface.json\");\nif(fs.existsSync(islandPath)) {\n    const islandData = JSON.parse(\n        fs.readFileSync(islandPath, { encoding: 'utf-8' })\n    );\n    if(!islandData.source) {\n        console.log(`No source found for Island at ${ islandPath }`)\n        return;\n    }\n    delete islandData.source.wasm;\n    fs.writeFileSync(islandInterfacePath, JSON.stringify(islandData, null, 4));\n    console.log(`Extracted metadata for Island to ${ islandInterfacePath }`)\n} else {\n    console.log(`No metadata found for Island at ${ islandPath }`)\n}\nconst lagoonPath = path.join(contractsV1Dir, \"lagoon.contract.json\");\nconst lagoonInterfacePath = path.join(contractInterfacesV1Dir, \"lagoon.interface.json\");\nif(fs.existsSync(lagoonPath)) {\n    const lagoonData = JSON.parse(\n        fs.readFileSync(lagoonPath, { encoding: 'utf-8' })\n    );\n    if(!lagoonData.source) {\n        console.log(`No source found for Lagoon at ${ lagoonPath }`)\n        return;\n    }\n    delete lagoonData.source.wasm;\n    fs.writeFileSync(lagoonInterfacePath, JSON.stringify(lagoonData, null, 4));\n    console.log(`Extracted metadata for Lagoon to ${ lagoonInterfacePath }`)\n} else {\n    console.log(`No metadata found for Lagoon at ${ lagoonPath }`)\n}\nconst wavePath = path.join(contractsV1Dir, \"wave.contract.json\");\nconst waveInterfacePath = path.join(contractInterfacesV1Dir, \"wave.interface.json\");\nif(fs.existsSync(wavePath)) {\n    const waveData = JSON.parse(\n        fs.readFileSync(wavePath, { encoding: 'utf-8' })\n    );\n    if(!waveData.source) {\n        console.log(`No source found for Wave at ${ wavePath }`)\n        return;\n    }\n    delete waveData.source.wasm;\n    fs.writeFileSync(waveInterfacePath, JSON.stringify(waveData, null, 4));\n    console.log(`Extracted metadata for Wave to ${ waveInterfacePath }`)\n} else {\n    console.log(`No metadata found for Wave at ${ wavePath }`)\n}\nconst reefPath = path.join(contractsV1Dir, \"reef.contract.json\");\nconst reefInterfacePath = path.join(contractInterfacesV1Dir, \"reef.interface.json\");\nif(fs.existsSync(reefPath)) {\n    const reefData = JSON.parse(\n        fs.readFileSync(reefPath, { encoding: 'utf-8' })\n    );\n    if(!reefData.source) {\n        console.log(`No source found for Reef at ${ reefPath }`)\n        return;\n    }\n    delete reefData.source.wasm;\n    fs.writeFileSync(reefInterfacePath, JSON.stringify(reefData, null, 4));\n    console.log(`Extracted metadata for Reef to ${ reefInterfacePath }`)\n} else {\n    console.log(`No metadata found for Reef at ${ reefPath }`)\n}\nconst coralPath = path.join(contractsV1Dir, \"coral.contract.json\");\nconst coralInterfacePath = path.join(contractInterfacesV1Dir, \"coral.interface.json\");\nif(fs.existsSync(coralPath)) {\n    const coralData = JSON.parse(\n        fs.readFileSync(coralPath, { encoding: 'utf-8' })\n    );\n    if(!coralData.source) {\n        console.log(`No source found for Coral at ${ coralPath }`)\n        return;\n    }\n    delete coralData.source.wasm;\n    fs.writeFileSync(coralInterfacePath, JSON.stringify(coralData, null, 4));\n    console.log(`Extracted metadata for Coral to ${ coralInterfacePath }`)\n} else {\n    console.log(`No metadata found for Coral at ${ coralPath }`)\n}\nconst whirlPath = path.join(contractsV1Dir, \"whirl.contract.json\");\nconst whirlInterfacePath = path.join(contractInterfacesV1Dir, \"whirl.interface.json\");\nif(fs.existsSync(whirlPath)) {\n    const whirlData = JSON.parse(\n        fs.readFileSync(whirlPath, { encoding: 'utf-8' })\n    );\n    if(!whirlData.source) {\n        console.log(`No source found for Whirl at ${ whirlPath }`)\n        return;\n    }\n    delete whirlData.source.wasm;\n    fs.writeFileSync(whirlInterfacePath, JSON.stringify(whirlData, null, 4));\n    console.log(`Extracted metadata for Whirl to ${ whirlInterfacePath }`)\n} else {\n    console.log(`No metadata found for Whirl at ${ whirlPath }`)\n}\nconst limestonePath = path.join(contractsV1Dir, \"limestone.contract.json\");\nconst limestoneInterfacePath = path.join(contractInterfacesV1Dir, \"limestone.interface.json\");\nif(fs.existsSync(limestonePath)) {\n    const limestoneData = JSON.parse(\n        fs.readFileSync(limestonePath, { encoding: 'utf-8' })\n    );\n    if(!limestoneData.source) {\n        console.log(`No source found for Limestone at ${ limestonePath }`)\n        return;\n    }\n    delete limestoneData.source.wasm;\n    fs.writeFileSync(limestoneInterfacePath, JSON.stringify(limestoneData, null, 4));\n    console.log(`Extracted metadata for Limestone to ${ limestoneInterfacePath }`)\n} else {\n    console.log(`No metadata found for Limestone at ${ limestonePath }`)\n}\nconst karstPath = path.join(contractsV1Dir, \"karst.contract.json\");\nconst karstInterfacePath = path.join(contractInterfacesV1Dir, \"karst.interface.json\");\nif(fs.existsSync(karstPath)) {\n    const karstData = JSON.parse(\n        fs.readFileSync(karstPath, { encoding: 'utf-8' })\n    );\n    if(!karstData.source) {\n        console.log(`No source found for Karst at ${ karstPath }`)\n        return;\n    }\n    delete karstData.source.wasm;\n    fs.writeFileSync(karstInterfacePath, JSON.stringify(karstData, null, 4));\n    console.log(`Extracted metadata for Karst to ${ karstInterfacePath }`)\n} else {\n    console.log(`No metadata found for Karst at ${ karstPath }`)\n}\nconst quicklimePath = path.join(contractsV1Dir, \"quicklime.contract.json\");\nconst quicklimeInterfacePath = path.join(contractInterfacesV1Dir, \"quicklime.interface.json\");\nif(fs.existsSync(quicklimePath)) {\n    const quicklimeData = JSON.parse(\n        fs.readFileSync(quicklimePath, { encoding: 'utf-8' })\n    );\n    if(!quicklimeData.source) {\n        console.log(`No source found for Quicklime at ${ quicklimePath }`)\n        return;\n    }\n    delete quicklimeData.source.wasm;\n    fs.writeFileSync(quicklimeInterfacePath, JSON.stringify(quicklimeData, null, 4));\n    console.log(`Extracted metadata for Quicklime to ${ quicklimeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Quicklime at ${ quicklimePath }`)\n}\nconst blowholePath = path.join(contractsV1Dir, \"blowhole.contract.json\");\nconst blowholeInterfacePath = path.join(contractInterfacesV1Dir, \"blowhole.interface.json\");\nif(fs.existsSync(blowholePath)) {\n    const blowholeData = JSON.parse(\n        fs.readFileSync(blowholePath, { encoding: 'utf-8' })\n    );\n    if(!blowholeData.source) {\n        console.log(`No source found for Blowhole at ${ blowholePath }`)\n        return;\n    }\n    delete blowholeData.source.wasm;\n    fs.writeFileSync(blowholeInterfacePath, JSON.stringify(blowholeData, null, 4));\n    console.log(`Extracted metadata for Blowhole to ${ blowholeInterfacePath }`)\n} else {\n    console.log(`No metadata found for Blowhole at ${ blowholePath }`)\n}\n\nconst unifiersPath = path.join(contractsV1Dir, \"unifiers.contract.json\");\nconst unifiersInterfacePath = path.join(contractInterfacesV1Dir, \"unifiers.interface.json\");\nif(fs.existsSync(unifiersPath)) {\n    const unifiersData = JSON.parse(\n        fs.readFileSync(unifiersPath, { encoding: 'utf-8' })\n    );\n    if(!unifiersData.source) {\n        console.log(`No source found for unifiers at ${ unifiersPath }`)\n        return;\n    }\n    delete unifiersData.source.wasm;\n    fs.writeFileSync(unifiersInterfacePath, JSON.stringify(unifiersData, null, 4));\n    console.log(`Extracted metadata for unifiers to ${ unifiersInterfacePath }`)\n} else {\n    console.log(`No metadata found for unifiers at ${ unifiersPath }`)\n}\n",
      "contentHash": "3f306beeb1c725720baeeb2e6ee1e60dd91ec893fd1c6230524a833119605c95",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/deployer/src/game.ts",
      "content": "import UNIFIERS_CONTRACT from \"../../../contracts.v1/artifacts/unifiers.contract.json\";\nimport ELEMENT_MONKEY_CONTRACT from \"../../../contracts.v1/artifacts/monkey.contract.json\";\nimport ELEMENT_GIRAFFE_CONTRACT from \"../../../contracts.v1/artifacts/giraffe.contract.json\";\nimport ELEMENT_BEE_CONTRACT from \"../../../contracts.v1/artifacts/bee.contract.json\";\nimport ELEMENT_COIN_CONTRACT from \"../../../contracts.v1/artifacts/coin.contract.json\";\nimport ELEMENT_SWARM_CONTRACT from \"../../../contracts.v1/artifacts/swarm.contract.json\";\nimport ELEMENT_HYDRA_CONTRACT from \"../../../contracts.v1/artifacts/hydra.contract.json\";\nimport ELEMENT_MONKEY_BRANCH_CONTRACT from \"../../../contracts.v1/artifacts/monkey_branch.contract.json\";\nimport ELEMENT_BRIDGE_CONTRACT from \"../../../contracts.v1/artifacts/bridge.contract.json\";\nimport ELEMENT_GOLDEN_GATE_CONTRACT from \"../../../contracts.v1/artifacts/golden_gate.contract.json\";\nimport ELEMENT_GOLD_CONTRACT from \"../../../contracts.v1/artifacts/gold.contract.json\";\nimport ELEMENT_SILVER_CONTRACT from \"../../../contracts.v1/artifacts/silver.contract.json\";\nimport ELEMENT_RHODIUM_CONTRACT from \"../../../contracts.v1/artifacts/rhodium.contract.json\";\nimport ELEMENT_HIVE_CONTRACT from \"../../../contracts.v1/artifacts/hive.contract.json\";\nimport ELEMENT_TRANSACTION_CONTRACT from \"../../../contracts.v1/artifacts/transaction.contract.json\";\nimport ELEMENT_BLOCK_CONTRACT from \"../../../contracts.v1/artifacts/block.contract.json\";\nimport ELEMENT_BLOCKCHAIN_CONTRACT from \"../../../contracts.v1/artifacts/blockchain.contract.json\";\nimport ELEMENT_POLKADOT_CONTRACT from \"../../../contracts.v1/artifacts/polkadot.contract.json\";\nimport ELEMENT_PEER_REVIEW_CONTRACT from \"../../../contracts.v1/artifacts/peer_review.contract.json\";\nimport ELEMENT_CARDANO_CONTRACT from \"../../../contracts.v1/artifacts/cardano.contract.json\";\nimport ELEMENT_BEAR_CONTRACT from \"../../../contracts.v1/artifacts/bear.contract.json\";\nimport ELEMENT_BEER_CONTRACT from \"../../../contracts.v1/artifacts/beer.contract.json\";\nimport ELEMENT_LOCK_CONTRACT from \"../../../contracts.v1/artifacts/lock.contract.json\";\nimport ELEMENT_MARMALADE_CONTRACT from \"../../../contracts.v1/artifacts/marmalade.contract.json\";\nimport ELEMENT_SUPER_MARMALADE_CONTRACT from \"../../../contracts.v1/artifacts/super_marmalade.contract.json\";\nimport ELEMENT_HYPER_MARMALADE_CONTRACT from \"../../../contracts.v1/artifacts/hyper_marmalade.contract.json\";\nimport ELEMENT_WATER_CONTRACT from \"../../../contracts.v1/artifacts/water.contract.json\";\nimport ELEMENT_FIRE_CONTRACT from \"../../../contracts.v1/artifacts/fire.contract.json\";\nimport ELEMENT_STEAM_CONTRACT from \"../../../contracts.v1/artifacts/steam.contract.json\";\nimport ELEMENT_EARTH_CONTRACT from \"../../../contracts.v1/artifacts/earth.contract.json\";\nimport ELEMENT_MUD_CONTRACT from \"../../../contracts.v1/artifacts/mud.contract.json\";\nimport ELEMENT_LAVA_CONTRACT from \"../../../contracts.v1/artifacts/lava.contract.json\";\nimport ELEMENT_WIND_CONTRACT from \"../../../contracts.v1/artifacts/wind.contract.json\";\nimport ELEMENT_DUST_CONTRACT from \"../../../contracts.v1/artifacts/dust.contract.json\";\nimport ELEMENT_RAIN_CONTRACT from \"../../../contracts.v1/artifacts/rain.contract.json\";\nimport ELEMENT_SMOKE_CONTRACT from \"../../../contracts.v1/artifacts/smoke.contract.json\";\nimport ELEMENT_GEYSER_CONTRACT from \"../../../contracts.v1/artifacts/geyser.contract.json\";\nimport ELEMENT_CLAY_CONTRACT from \"../../../contracts.v1/artifacts/clay.contract.json\";\nimport ELEMENT_SAND_CONTRACT from \"../../../contracts.v1/artifacts/sand.contract.json\";\nimport ELEMENT_PLANT_CONTRACT from \"../../../contracts.v1/artifacts/plant.contract.json\";\nimport ELEMENT_RAINBOW_CONTRACT from \"../../../contracts.v1/artifacts/rainbow.contract.json\";\nimport ELEMENT_STORM_CONTRACT from \"../../../contracts.v1/artifacts/storm.contract.json\";\nimport ELEMENT_OBSIDIAN_CONTRACT from \"../../../contracts.v1/artifacts/obsidian.contract.json\";\nimport ELEMENT_ASH_CONTRACT from \"../../../contracts.v1/artifacts/ash.contract.json\";\nimport ELEMENT_VOLCANO_CONTRACT from \"../../../contracts.v1/artifacts/volcano.contract.json\";\nimport ELEMENT_SANDSTORM_CONTRACT from \"../../../contracts.v1/artifacts/sandstorm.contract.json\";\nimport ELEMENT_CLOUD_CONTRACT from \"../../../contracts.v1/artifacts/cloud.contract.json\";\nimport ELEMENT_FOG_CONTRACT from \"../../../contracts.v1/artifacts/fog.contract.json\";\nimport ELEMENT_TREE_CONTRACT from \"../../../contracts.v1/artifacts/tree.contract.json\";\nimport ELEMENT_FOREST_CONTRACT from \"../../../contracts.v1/artifacts/forest.contract.json\";\nimport ELEMENT_SEEDS_CONTRACT from \"../../../contracts.v1/artifacts/seeds.contract.json\";\nimport ELEMENT_POTTERY_CONTRACT from \"../../../contracts.v1/artifacts/pottery.contract.json\";\nimport ELEMENT_BRICK_CONTRACT from \"../../../contracts.v1/artifacts/brick.contract.json\";\nimport ELEMENT_QUICKSAND_CONTRACT from \"../../../contracts.v1/artifacts/quicksand.contract.json\";\nimport ELEMENT_GLASS_CONTRACT from \"../../../contracts.v1/artifacts/glass.contract.json\";\nimport ELEMENT_DUNE_CONTRACT from \"../../../contracts.v1/artifacts/dune.contract.json\";\nimport ELEMENT_CHARCOAL_CONTRACT from \"../../../contracts.v1/artifacts/charcoal.contract.json\";\nimport ELEMENT_LEAVES_CONTRACT from \"../../../contracts.v1/artifacts/leaves.contract.json\";\nimport ELEMENT_WILDFIRE_CONTRACT from \"../../../contracts.v1/artifacts/wildfire.contract.json\";\nimport ELEMENT_JUNGLE_CONTRACT from \"../../../contracts.v1/artifacts/jungle.contract.json\";\nimport ELEMENT_FROSTED_GLASS_CONTRACT from \"../../../contracts.v1/artifacts/frosted_glass.contract.json\";\nimport ELEMENT_CRYSTAL_CONTRACT from \"../../../contracts.v1/artifacts/crystal.contract.json\";\nimport ELEMENT_MAGMA_CONTRACT from \"../../../contracts.v1/artifacts/magma.contract.json\";\nimport ELEMENT_ROCK_CONTRACT from \"../../../contracts.v1/artifacts/rock.contract.json\";\nimport ELEMENT_SHARD_CONTRACT from \"../../../contracts.v1/artifacts/shard.contract.json\";\nimport ELEMENT_PEBBLE_CONTRACT from \"../../../contracts.v1/artifacts/pebble.contract.json\";\nimport ELEMENT_MOUNTAIN_CONTRACT from \"../../../contracts.v1/artifacts/mountain.contract.json\";\nimport ELEMENT_FERTILIZER_CONTRACT from \"../../../contracts.v1/artifacts/fertilizer.contract.json\";\nimport ELEMENT_SOOT_CONTRACT from \"../../../contracts.v1/artifacts/soot.contract.json\";\nimport ELEMENT_LIGHTNING_CONTRACT from \"../../../contracts.v1/artifacts/lightning.contract.json\";\nimport ELEMENT_MIST_CONTRACT from \"../../../contracts.v1/artifacts/mist.contract.json\";\nimport ELEMENT_HAZE_CONTRACT from \"../../../contracts.v1/artifacts/haze.contract.json\";\nimport ELEMENT_FLOOD_CONTRACT from \"../../../contracts.v1/artifacts/flood.contract.json\";\nimport ELEMENT_LANDSLIDE_CONTRACT from \"../../../contracts.v1/artifacts/landslide.contract.json\";\nimport ELEMENT_THUNDER_CONTRACT from \"../../../contracts.v1/artifacts/thunder.contract.json\";\nimport ELEMENT_TORNADO_CONTRACT from \"../../../contracts.v1/artifacts/tornado.contract.json\";\nimport ELEMENT_GARDEN_CONTRACT from \"../../../contracts.v1/artifacts/garden.contract.json\";\nimport ELEMENT_EMBER_CONTRACT from \"../../../contracts.v1/artifacts/ember.contract.json\";\nimport ELEMENT_KILN_CONTRACT from \"../../../contracts.v1/artifacts/kiln.contract.json\";\nimport ELEMENT_POLLINATION_CONTRACT from \"../../../contracts.v1/artifacts/pollination.contract.json\";\nimport ELEMENT_SINKHOLE_CONTRACT from \"../../../contracts.v1/artifacts/sinkhole.contract.json\";\nimport ELEMENT_BEACH_CONTRACT from \"../../../contracts.v1/artifacts/beach.contract.json\";\nimport ELEMENT_WETSTONE_CONTRACT from \"../../../contracts.v1/artifacts/wetstone.contract.json\";\nimport ELEMENT_EROSION_CONTRACT from \"../../../contracts.v1/artifacts/erosion.contract.json\";\nimport ELEMENT_BASALT_CONTRACT from \"../../../contracts.v1/artifacts/basalt.contract.json\";\nimport ELEMENT_MAGMA_CHAMBER_CONTRACT from \"../../../contracts.v1/artifacts/magma_chamber.contract.json\";\nimport ELEMENT_BREEZE_CONTRACT from \"../../../contracts.v1/artifacts/breeze.contract.json\";\nimport ELEMENT_WARM_BREEZE_CONTRACT from \"../../../contracts.v1/artifacts/warm_breeze.contract.json\";\nimport ELEMENT_SOIL_CONTRACT from \"../../../contracts.v1/artifacts/soil.contract.json\";\nimport ELEMENT_CANYON_CONTRACT from \"../../../contracts.v1/artifacts/canyon.contract.json\";\nimport ELEMENT_WINDMILL_CONTRACT from \"../../../contracts.v1/artifacts/windmill.contract.json\";\nimport ELEMENT_ADOBE_CONTRACT from \"../../../contracts.v1/artifacts/adobe.contract.json\";\nimport ELEMENT_WALL_CONTRACT from \"../../../contracts.v1/artifacts/wall.contract.json\";\nimport ELEMENT_PUMICE_CONTRACT from \"../../../contracts.v1/artifacts/pumice.contract.json\";\nimport ELEMENT_BARBECUE_CONTRACT from \"../../../contracts.v1/artifacts/barbecue.contract.json\";\nimport ELEMENT_FARM_CONTRACT from \"../../../contracts.v1/artifacts/farm.contract.json\";\nimport ELEMENT_SHARDS_CONTRACT from \"../../../contracts.v1/artifacts/shards.contract.json\";\nimport ELEMENT_MOLTEN_GLASS_CONTRACT from \"../../../contracts.v1/artifacts/molten_glass.contract.json\";\nimport ELEMENT_PRISM_CONTRACT from \"../../../contracts.v1/artifacts/prism.contract.json\";\nimport ELEMENT_SPARKLE_CONTRACT from \"../../../contracts.v1/artifacts/sparkle.contract.json\";\nimport ELEMENT_DESERT_CONTRACT from \"../../../contracts.v1/artifacts/desert.contract.json\";\nimport ELEMENT_OASIS_CONTRACT from \"../../../contracts.v1/artifacts/oasis.contract.json\";\nimport ELEMENT_MIRAGE_CONTRACT from \"../../../contracts.v1/artifacts/mirage.contract.json\";\nimport ELEMENT_SAND_DUNE_CONTRACT from \"../../../contracts.v1/artifacts/sand_dune.contract.json\";\nimport ELEMENT_DAM_CONTRACT from \"../../../contracts.v1/artifacts/dam.contract.json\";\nimport ELEMENT_FIREWALL_CONTRACT from \"../../../contracts.v1/artifacts/firewall.contract.json\";\nimport ELEMENT_BARRICADE_CONTRACT from \"../../../contracts.v1/artifacts/barricade.contract.json\";\nimport ELEMENT_PLATEAU_CONTRACT from \"../../../contracts.v1/artifacts/plateau.contract.json\";\nimport ELEMENT_POND_CONTRACT from \"../../../contracts.v1/artifacts/pond.contract.json\";\nimport ELEMENT_AROMAS_CONTRACT from \"../../../contracts.v1/artifacts/aromas.contract.json\";\nimport ELEMENT_FLOWER_CONTRACT from \"../../../contracts.v1/artifacts/flower.contract.json\";\nimport ELEMENT_SPORE_CONTRACT from \"../../../contracts.v1/artifacts/spore.contract.json\";\nimport ELEMENT_SPREAD_CONTRACT from \"../../../contracts.v1/artifacts/spread.contract.json\";\nimport ELEMENT_FERTILE_LAND_CONTRACT from \"../../../contracts.v1/artifacts/fertile_land.contract.json\";\nimport ELEMENT_WETLAND_CONTRACT from \"../../../contracts.v1/artifacts/wetland.contract.json\";\nimport ELEMENT_PEAT_CONTRACT from \"../../../contracts.v1/artifacts/peat.contract.json\";\nimport ELEMENT_REEDS_CONTRACT from \"../../../contracts.v1/artifacts/reeds.contract.json\";\nimport ELEMENT_VALLEY_CONTRACT from \"../../../contracts.v1/artifacts/valley.contract.json\";\nimport ELEMENT_RIVER_CONTRACT from \"../../../contracts.v1/artifacts/river.contract.json\";\nimport ELEMENT_SCORCHED_EARTH_CONTRACT from \"../../../contracts.v1/artifacts/scorched_earth.contract.json\";\nimport ELEMENT_DELTA_CONTRACT from \"../../../contracts.v1/artifacts/delta.contract.json\";\nimport ELEMENT_ESTUARY_CONTRACT from \"../../../contracts.v1/artifacts/estuary.contract.json\";\nimport ELEMENT_FIRE_SWAMP_CONTRACT from \"../../../contracts.v1/artifacts/fire_swamp.contract.json\";\nimport ELEMENT_RIVERBANK_CONTRACT from \"../../../contracts.v1/artifacts/riverbank.contract.json\";\nimport ELEMENT_RAVINE_CONTRACT from \"../../../contracts.v1/artifacts/ravine.contract.json\";\nimport ELEMENT_GORGE_CONTRACT from \"../../../contracts.v1/artifacts/gorge.contract.json\";\nimport ELEMENT_CHARRED_RAVINE_CONTRACT from \"../../../contracts.v1/artifacts/charred_ravine.contract.json\";\nimport ELEMENT_ECHO_CONTRACT from \"../../../contracts.v1/artifacts/echo.contract.json\";\nimport ELEMENT_CAVE_CONTRACT from \"../../../contracts.v1/artifacts/cave.contract.json\";\nimport ELEMENT_UNDERGROUND_LAKE_CONTRACT from \"../../../contracts.v1/artifacts/underground_lake.contract.json\";\nimport ELEMENT_LAVA_CAVE_CONTRACT from \"../../../contracts.v1/artifacts/lava_cave.contract.json\";\nimport ELEMENT_WHISPERING_CAVE_CONTRACT from \"../../../contracts.v1/artifacts/whispering_cave.contract.json\";\nimport ELEMENT_SUBTERRANEAN_POOL_CONTRACT from \"../../../contracts.v1/artifacts/subterranean_pool.contract.json\";\nimport ELEMENT_SPRING_CONTRACT from \"../../../contracts.v1/artifacts/spring.contract.json\";\nimport ELEMENT_HOT_SPRING_CONTRACT from \"../../../contracts.v1/artifacts/hot_spring.contract.json\";\nimport ELEMENT_GROTTO_CONTRACT from \"../../../contracts.v1/artifacts/grotto.contract.json\";\nimport ELEMENT_FOUNTAIN_CONTRACT from \"../../../contracts.v1/artifacts/fountain.contract.json\";\nimport ELEMENT_STEAM_VENT_CONTRACT from \"../../../contracts.v1/artifacts/steam_vent.contract.json\";\nimport ELEMENT_COOL_BREEZE_CONTRACT from \"../../../contracts.v1/artifacts/cool_breeze.contract.json\";\nimport ELEMENT_MONUMENT_CONTRACT from \"../../../contracts.v1/artifacts/monument.contract.json\";\nimport ELEMENT_WATERFALL_CONTRACT from \"../../../contracts.v1/artifacts/waterfall.contract.json\";\nimport ELEMENT_ETERNAL_FLAME_CONTRACT from \"../../../contracts.v1/artifacts/eternal_flame.contract.json\";\nimport ELEMENT_PILLAR_OF_WIND_CONTRACT from \"../../../contracts.v1/artifacts/pillar_of_wind.contract.json\";\nimport ELEMENT_STREAM_CONTRACT from \"../../../contracts.v1/artifacts/stream.contract.json\";\nimport ELEMENT_ZEPHYR_CONTRACT from \"../../../contracts.v1/artifacts/zephyr.contract.json\";\nimport ELEMENT_CREEK_CONTRACT from \"../../../contracts.v1/artifacts/creek.contract.json\";\nimport ELEMENT_BROOK_CONTRACT from \"../../../contracts.v1/artifacts/brook.contract.json\";\nimport ELEMENT_WHISPER_CONTRACT from \"../../../contracts.v1/artifacts/whisper.contract.json\";\nimport ELEMENT_RIVULET_CONTRACT from \"../../../contracts.v1/artifacts/rivulet.contract.json\";\nimport ELEMENT_TRIBUTARY_CONTRACT from \"../../../contracts.v1/artifacts/tributary.contract.json\";\nimport ELEMENT_MURMUR_CONTRACT from \"../../../contracts.v1/artifacts/murmur.contract.json\";\nimport ELEMENT_WATERSHED_CONTRACT from \"../../../contracts.v1/artifacts/watershed.contract.json\";\nimport ELEMENT_AQUIFER_CONTRACT from \"../../../contracts.v1/artifacts/aquifer.contract.json\";\nimport ELEMENT_PARCHED_EARTH_CONTRACT from \"../../../contracts.v1/artifacts/parched_earth.contract.json\";\nimport ELEMENT_FRESH_BREEZE_CONTRACT from \"../../../contracts.v1/artifacts/fresh_breeze.contract.json\";\nimport ELEMENT_GROUNDWATER_CONTRACT from \"../../../contracts.v1/artifacts/groundwater.contract.json\";\nimport ELEMENT_RESERVOIR_CONTRACT from \"../../../contracts.v1/artifacts/reservoir.contract.json\";\nimport ELEMENT_GEOTHERMAL_SPRING_CONTRACT from \"../../../contracts.v1/artifacts/geothermal_spring.contract.json\";\nimport ELEMENT_ARTESIAN_WELL_CONTRACT from \"../../../contracts.v1/artifacts/artesian_well.contract.json\";\nimport ELEMENT_BASIN_CONTRACT from \"../../../contracts.v1/artifacts/basin.contract.json\";\nimport ELEMENT_LAKE_CONTRACT from \"../../../contracts.v1/artifacts/lake.contract.json\";\nimport ELEMENT_DRY_BASIN_CONTRACT from \"../../../contracts.v1/artifacts/dry_basin.contract.json\";\nimport ELEMENT_DEPRESSION_CONTRACT from \"../../../contracts.v1/artifacts/depression.contract.json\";\nimport ELEMENT_ISLAND_CONTRACT from \"../../../contracts.v1/artifacts/island.contract.json\";\nimport ELEMENT_LAGOON_CONTRACT from \"../../../contracts.v1/artifacts/lagoon.contract.json\";\nimport ELEMENT_WAVE_CONTRACT from \"../../../contracts.v1/artifacts/wave.contract.json\";\nimport ELEMENT_REEF_CONTRACT from \"../../../contracts.v1/artifacts/reef.contract.json\";\nimport ELEMENT_CORAL_CONTRACT from \"../../../contracts.v1/artifacts/coral.contract.json\";\nimport ELEMENT_WHIRL_CONTRACT from \"../../../contracts.v1/artifacts/whirl.contract.json\";\nimport ELEMENT_LIMESTONE_CONTRACT from \"../../../contracts.v1/artifacts/limestone.contract.json\";\nimport ELEMENT_KARST_CONTRACT from \"../../../contracts.v1/artifacts/karst.contract.json\";\nimport ELEMENT_QUICKLIME_CONTRACT from \"../../../contracts.v1/artifacts/quicklime.contract.json\";\nimport ELEMENT_BLOWHOLE_CONTRACT from \"../../../contracts.v1/artifacts/blowhole.contract.json\";\nimport { IDeployableGame } from \"./IDeployableGame\";\nimport { IDeployableElement } from \"./IDeployableElement\";\n\nexport const DEPLOYABLE_ELEMENTS: Array<IDeployableElement> = [\n    {\n        name: \"Monkey\",\n        description: \"We need a description here\",\n        contract: ELEMENT_MONKEY_CONTRACT,\n        id: 0,\n    },\n    {\n        name: \"Giraffe\",\n        description: \"We need a description here\",\n        contract: ELEMENT_GIRAFFE_CONTRACT,\n        id: 1,\n    },\n    {\n        name: \"Bee\",\n        description: \"We need a description here\",\n        contract: ELEMENT_BEE_CONTRACT,\n        id: 2,\n    },\n    {\n        name: \"Coin\",\n        description: \"We need a description here\",\n        contract: ELEMENT_COIN_CONTRACT,\n        id: 3,\n    },\n    {\n        name: \"Swarm\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SWARM_CONTRACT,\n        id: 4,\n    },\n    {\n        name: \"Hydra\",\n        description: \"We need a description here\",\n        contract: ELEMENT_HYDRA_CONTRACT,\n        id: 5,\n    },\n    {\n        name: \"Monkey Branch\",\n        description: \"We need a description here\",\n        contract: ELEMENT_MONKEY_BRANCH_CONTRACT,\n        id: 6,\n    },\n    {\n        name: \"Bridge\",\n        description: \"We need a description here\",\n        contract: ELEMENT_BRIDGE_CONTRACT,\n        id: 7,\n    },\n    {\n        name: \"Golden Gate\",\n        description: \"We need a description here\",\n        contract: ELEMENT_GOLDEN_GATE_CONTRACT,\n        id: 8,\n    },\n    {\n        name: \"Gold\",\n        description: \"We need a description here\",\n        contract: ELEMENT_GOLD_CONTRACT,\n        id: 9,\n    },\n    {\n        name: \"Silver\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SILVER_CONTRACT,\n        id: 10,\n    },\n    {\n        name: \"Rhodium\",\n        description: \"We need a description here\",\n        contract: ELEMENT_RHODIUM_CONTRACT,\n        id: 11,\n    },\n    {\n        name: \"Hive\",\n        description: \"We need a description here\",\n        contract: ELEMENT_HIVE_CONTRACT,\n        id: 12,\n    },\n    {\n        name: \"Transaction\",\n        description: \"We need a description here\",\n        contract: ELEMENT_TRANSACTION_CONTRACT,\n        id: 13,\n    },\n    {\n        name: \"Block\",\n        description: \"We need a description here\",\n        contract: ELEMENT_BLOCK_CONTRACT,\n        id: 14,\n    },\n    {\n        name: \"Blockchain\",\n        description: \"We need a description here\",\n        contract: ELEMENT_BLOCKCHAIN_CONTRACT,\n        id: 15,\n    },\n    {\n        name: \"Polkadot\",\n        description: \"We need a description here\",\n        contract: ELEMENT_POLKADOT_CONTRACT,\n        id: 16,\n    },\n    {\n        name: \"Peer Review\",\n        description: \"We need a description here\",\n        contract: ELEMENT_PEER_REVIEW_CONTRACT,\n        id: 17,\n    },\n    {\n        name: \"Cardano\",\n        description: \"We need a description here\",\n        contract: ELEMENT_CARDANO_CONTRACT,\n        id: 18,\n    },\n    {\n        name: \"Bear\",\n        description: \"We need a description here\",\n        contract: ELEMENT_BEAR_CONTRACT,\n        id: 19,\n    },\n    {\n        name: \"Beer\",\n        description: \"We need a description here\",\n        contract: ELEMENT_BEER_CONTRACT,\n        id: 20,\n    },\n    {\n        name: \"Lock\",\n        description: \"We need a description here\",\n        contract: ELEMENT_LOCK_CONTRACT,\n        id: 21,\n    },\n    {\n        name: \"Marmalade\",\n        description: \"We need a description here\",\n        contract: ELEMENT_MARMALADE_CONTRACT,\n        id: 22,\n    },\n    {\n        name: \"Super Marmalade\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SUPER_MARMALADE_CONTRACT,\n        id: 23,\n    },\n    {\n        name: \"Hyper Marmalade\",\n        description: \"We need a description here\",\n        contract: ELEMENT_HYPER_MARMALADE_CONTRACT,\n        id: 24,\n    },\n    {\n        name: \"Water\",\n        description: \"We need a description here\",\n        contract: ELEMENT_WATER_CONTRACT,\n        id: 25,\n    },\n    {\n        name: \"Fire\",\n        description: \"We need a description here\",\n        contract: ELEMENT_FIRE_CONTRACT,\n        id: 26,\n    },\n    {\n        name: \"Steam\",\n        description: \"We need a description here\",\n        contract: ELEMENT_STEAM_CONTRACT,\n        id: 27,\n    },\n    {\n        name: \"Earth\",\n        description: \"We need a description here\",\n        contract: ELEMENT_EARTH_CONTRACT,\n        id: 28,\n    },\n    {\n        name: \"Mud\",\n        description: \"We need a description here\",\n        contract: ELEMENT_MUD_CONTRACT,\n        id: 29,\n    },\n    {\n        name: \"Lava\",\n        description: \"We need a description here\",\n        contract: ELEMENT_LAVA_CONTRACT,\n        id: 30,\n    },\n    {\n        name: \"Wind\",\n        description: \"We need a description here\",\n        contract: ELEMENT_WIND_CONTRACT,\n        id: 31,\n    },\n    {\n        name: \"Dust\",\n        description: \"We need a description here\",\n        contract: ELEMENT_DUST_CONTRACT,\n        id: 32,\n    },\n    {\n        name: \"Rain\",\n        description: \"We need a description here\",\n        contract: ELEMENT_RAIN_CONTRACT,\n        id: 33,\n    },\n    {\n        name: \"Smoke\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SMOKE_CONTRACT,\n        id: 34,\n    },\n    {\n        name: \"Geyser\",\n        description: \"We need a description here\",\n        contract: ELEMENT_GEYSER_CONTRACT,\n        id: 35,\n    },\n    {\n        name: \"Clay\",\n        description: \"We need a description here\",\n        contract: ELEMENT_CLAY_CONTRACT,\n        id: 36,\n    },\n    {\n        name: \"Sand\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SAND_CONTRACT,\n        id: 37,\n    },\n    {\n        name: \"Plant\",\n        description: \"We need a description here\",\n        contract: ELEMENT_PLANT_CONTRACT,\n        id: 38,\n    },\n    {\n        name: \"Rainbow\",\n        description: \"We need a description here\",\n        contract: ELEMENT_RAINBOW_CONTRACT,\n        id: 39,\n    },\n    {\n        name: \"Storm\",\n        description: \"We need a description here\",\n        contract: ELEMENT_STORM_CONTRACT,\n        id: 40,\n    },\n    {\n        name: \"Obsidian\",\n        description: \"We need a description here\",\n        contract: ELEMENT_OBSIDIAN_CONTRACT,\n        id: 41,\n    },\n    {\n        name: \"Ash\",\n        description: \"We need a description here\",\n        contract: ELEMENT_ASH_CONTRACT,\n        id: 42,\n    },\n    {\n        name: \"Volcano\",\n        description: \"We need a description here\",\n        contract: ELEMENT_VOLCANO_CONTRACT,\n        id: 43,\n    },\n    {\n        name: \"Sandstorm\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SANDSTORM_CONTRACT,\n        id: 44,\n    },\n    {\n        name: \"Cloud\",\n        description: \"We need a description here\",\n        contract: ELEMENT_CLOUD_CONTRACT,\n        id: 45,\n    },\n    {\n        name: \"Fog\",\n        description: \"We need a description here\",\n        contract: ELEMENT_FOG_CONTRACT,\n        id: 46,\n    },\n    {\n        name: \"Tree\",\n        description: \"We need a description here\",\n        contract: ELEMENT_TREE_CONTRACT,\n        id: 47,\n    },\n    {\n        name: \"Forest\",\n        description: \"We need a description here\",\n        contract: ELEMENT_FOREST_CONTRACT,\n        id: 48,\n    },\n    {\n        name: \"Seeds\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SEEDS_CONTRACT,\n        id: 49,\n    },\n    {\n        name: \"Pottery\",\n        description: \"We need a description here\",\n        contract: ELEMENT_POTTERY_CONTRACT,\n        id: 50,\n    },\n    {\n        name: \"Brick\",\n        description: \"We need a description here\",\n        contract: ELEMENT_BRICK_CONTRACT,\n        id: 51,\n    },\n    {\n        name: \"Quicksand\",\n        description: \"We need a description here\",\n        contract: ELEMENT_QUICKSAND_CONTRACT,\n        id: 52,\n    },\n    {\n        name: \"Glass\",\n        description: \"We need a description here\",\n        contract: ELEMENT_GLASS_CONTRACT,\n        id: 53,\n    },\n    {\n        name: \"Dune\",\n        description: \"We need a description here\",\n        contract: ELEMENT_DUNE_CONTRACT,\n        id: 54,\n    },\n    {\n        name: \"Charcoal\",\n        description: \"We need a description here\",\n        contract: ELEMENT_CHARCOAL_CONTRACT,\n        id: 55,\n    },\n    {\n        name: \"Leaves\",\n        description: \"We need a description here\",\n        contract: ELEMENT_LEAVES_CONTRACT,\n        id: 56,\n    },\n    {\n        name: \"Wildfire\",\n        description: \"We need a description here\",\n        contract: ELEMENT_WILDFIRE_CONTRACT,\n        id: 57,\n    },\n    {\n        name: \"Jungle\",\n        description: \"We need a description here\",\n        contract: ELEMENT_JUNGLE_CONTRACT,\n        id: 58,\n    },\n    {\n        name: \"Frosted Glass\",\n        description: \"We need a description here\",\n        contract: ELEMENT_FROSTED_GLASS_CONTRACT,\n        id: 59,\n    },\n    {\n        name: \"Crystal\",\n        description: \"We need a description here\",\n        contract: ELEMENT_CRYSTAL_CONTRACT,\n        id: 60,\n    },\n    {\n        name: \"Magma\",\n        description: \"We need a description here\",\n        contract: ELEMENT_MAGMA_CONTRACT,\n        id: 61,\n    },\n    {\n        name: \"Rock\",\n        description: \"We need a description here\",\n        contract: ELEMENT_ROCK_CONTRACT,\n        id: 62,\n    },\n    {\n        name: \"Shard\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SHARD_CONTRACT,\n        id: 63,\n    },\n    {\n        name: \"Pebble\",\n        description: \"We need a description here\",\n        contract: ELEMENT_PEBBLE_CONTRACT,\n        id: 64,\n    },\n    {\n        name: \"Mountain\",\n        description: \"We need a description here\",\n        contract: ELEMENT_MOUNTAIN_CONTRACT,\n        id: 65,\n    },\n    {\n        name: \"Fertilizer\",\n        description: \"We need a description here\",\n        contract: ELEMENT_FERTILIZER_CONTRACT,\n        id: 66,\n    },\n    {\n        name: \"Soot\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SOOT_CONTRACT,\n        id: 67,\n    },\n    {\n        name: \"Lightning\",\n        description: \"We need a description here\",\n        contract: ELEMENT_LIGHTNING_CONTRACT,\n        id: 68,\n    },\n    {\n        name: \"Mist\",\n        description: \"We need a description here\",\n        contract: ELEMENT_MIST_CONTRACT,\n        id: 69,\n    },\n    {\n        name: \"Haze\",\n        description: \"We need a description here\",\n        contract: ELEMENT_HAZE_CONTRACT,\n        id: 70,\n    },\n    {\n        name: \"Flood\",\n        description: \"We need a description here\",\n        contract: ELEMENT_FLOOD_CONTRACT,\n        id: 71,\n    },\n    {\n        name: \"Landslide\",\n        description: \"We need a description here\",\n        contract: ELEMENT_LANDSLIDE_CONTRACT,\n        id: 72,\n    },\n    {\n        name: \"Thunder\",\n        description: \"We need a description here\",\n        contract: ELEMENT_THUNDER_CONTRACT,\n        id: 73,\n    },\n    {\n        name: \"Tornado\",\n        description: \"We need a description here\",\n        contract: ELEMENT_TORNADO_CONTRACT,\n        id: 74,\n    },\n    {\n        name: \"Garden\",\n        description: \"We need a description here\",\n        contract: ELEMENT_GARDEN_CONTRACT,\n        id: 75,\n    },\n    {\n        name: \"Ember\",\n        description: \"We need a description here\",\n        contract: ELEMENT_EMBER_CONTRACT,\n        id: 76,\n    },\n    {\n        name: \"Kiln\",\n        description: \"We need a description here\",\n        contract: ELEMENT_KILN_CONTRACT,\n        id: 77,\n    },\n    {\n        name: \"Pollination\",\n        description: \"We need a description here\",\n        contract: ELEMENT_POLLINATION_CONTRACT,\n        id: 78,\n    },\n    {\n        name: \"Sinkhole\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SINKHOLE_CONTRACT,\n        id: 79,\n    },\n    {\n        name: \"Beach\",\n        description: \"We need a description here\",\n        contract: ELEMENT_BEACH_CONTRACT,\n        id: 80,\n    },\n    {\n        name: \"Wetstone\",\n        description: \"We need a description here\",\n        contract: ELEMENT_WETSTONE_CONTRACT,\n        id: 81,\n    },\n    {\n        name: \"Erosion\",\n        description: \"We need a description here\",\n        contract: ELEMENT_EROSION_CONTRACT,\n        id: 82,\n    },\n    {\n        name: \"Basalt\",\n        description: \"We need a description here\",\n        contract: ELEMENT_BASALT_CONTRACT,\n        id: 83,\n    },\n    {\n        name: \"Magma Chamber\",\n        description: \"We need a description here\",\n        contract: ELEMENT_MAGMA_CHAMBER_CONTRACT,\n        id: 84,\n    },\n    {\n        name: \"Breeze\",\n        description: \"We need a description here\",\n        contract: ELEMENT_BREEZE_CONTRACT,\n        id: 85,\n    },\n    {\n        name: \"Warm Breeze\",\n        description: \"We need a description here\",\n        contract: ELEMENT_WARM_BREEZE_CONTRACT,\n        id: 86,\n    },\n    {\n        name: \"Soil\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SOIL_CONTRACT,\n        id: 87,\n    },\n    {\n        name: \"Canyon\",\n        description: \"We need a description here\",\n        contract: ELEMENT_CANYON_CONTRACT,\n        id: 88,\n    },\n    {\n        name: \"Windmill\",\n        description: \"We need a description here\",\n        contract: ELEMENT_WINDMILL_CONTRACT,\n        id: 89,\n    },\n    {\n        name: \"Adobe\",\n        description: \"We need a description here\",\n        contract: ELEMENT_ADOBE_CONTRACT,\n        id: 90,\n    },\n    {\n        name: \"Wall\",\n        description: \"We need a description here\",\n        contract: ELEMENT_WALL_CONTRACT,\n        id: 91,\n    },\n    {\n        name: \"Pumice\",\n        description: \"We need a description here\",\n        contract: ELEMENT_PUMICE_CONTRACT,\n        id: 92,\n    },\n    {\n        name: \"Barbecue\",\n        description: \"We need a description here\",\n        contract: ELEMENT_BARBECUE_CONTRACT,\n        id: 93,\n    },\n    {\n        name: \"Farm\",\n        description: \"We need a description here\",\n        contract: ELEMENT_FARM_CONTRACT,\n        id: 94,\n    },\n    {\n        name: \"Shards\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SHARDS_CONTRACT,\n        id: 95,\n    },\n    {\n        name: \"Molten Glass\",\n        description: \"We need a description here\",\n        contract: ELEMENT_MOLTEN_GLASS_CONTRACT,\n        id: 96,\n    },\n    {\n        name: \"Prism\",\n        description: \"We need a description here\",\n        contract: ELEMENT_PRISM_CONTRACT,\n        id: 97,\n    },\n    {\n        name: \"Sparkle\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SPARKLE_CONTRACT,\n        id: 98,\n    },\n    {\n        name: \"Desert\",\n        description: \"We need a description here\",\n        contract: ELEMENT_DESERT_CONTRACT,\n        id: 99,\n    },\n    {\n        name: \"Oasis\",\n        description: \"We need a description here\",\n        contract: ELEMENT_OASIS_CONTRACT,\n        id: 100,\n    },\n    {\n        name: \"Mirage\",\n        description: \"We need a description here\",\n        contract: ELEMENT_MIRAGE_CONTRACT,\n        id: 101,\n    },\n    {\n        name: \"Sand Dune\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SAND_DUNE_CONTRACT,\n        id: 102,\n    },\n    {\n        name: \"Dam\",\n        description: \"We need a description here\",\n        contract: ELEMENT_DAM_CONTRACT,\n        id: 103,\n    },\n    {\n        name: \"Firewall\",\n        description: \"We need a description here\",\n        contract: ELEMENT_FIREWALL_CONTRACT,\n        id: 104,\n    },\n    {\n        name: \"Barricade\",\n        description: \"We need a description here\",\n        contract: ELEMENT_BARRICADE_CONTRACT,\n        id: 105,\n    },\n    {\n        name: \"Plateau\",\n        description: \"We need a description here\",\n        contract: ELEMENT_PLATEAU_CONTRACT,\n        id: 106,\n    },\n    {\n        name: \"Pond\",\n        description: \"We need a description here\",\n        contract: ELEMENT_POND_CONTRACT,\n        id: 107,\n    },\n    {\n        name: \"Aromas\",\n        description: \"We need a description here\",\n        contract: ELEMENT_AROMAS_CONTRACT,\n        id: 108,\n    },\n    {\n        name: \"Flower\",\n        description: \"We need a description here\",\n        contract: ELEMENT_FLOWER_CONTRACT,\n        id: 109,\n    },\n    {\n        name: \"Spore\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SPORE_CONTRACT,\n        id: 110,\n    },\n    {\n        name: \"Spread\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SPREAD_CONTRACT,\n        id: 111,\n    },\n    {\n        name: \"Fertile Land\",\n        description: \"We need a description here\",\n        contract: ELEMENT_FERTILE_LAND_CONTRACT,\n        id: 112,\n    },\n    {\n        name: \"Wetland\",\n        description: \"We need a description here\",\n        contract: ELEMENT_WETLAND_CONTRACT,\n        id: 113,\n    },\n    {\n        name: \"Peat\",\n        description: \"We need a description here\",\n        contract: ELEMENT_PEAT_CONTRACT,\n        id: 114,\n    },\n    {\n        name: \"Reeds\",\n        description: \"We need a description here\",\n        contract: ELEMENT_REEDS_CONTRACT,\n        id: 115,\n    },\n    {\n        name: \"Valley\",\n        description: \"We need a description here\",\n        contract: ELEMENT_VALLEY_CONTRACT,\n        id: 116,\n    },\n    {\n        name: \"River\",\n        description: \"We need a description here\",\n        contract: ELEMENT_RIVER_CONTRACT,\n        id: 117,\n    },\n    {\n        name: \"Scorched Earth\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SCORCHED_EARTH_CONTRACT,\n        id: 118,\n    },\n    {\n        name: \"Delta\",\n        description: \"We need a description here\",\n        contract: ELEMENT_DELTA_CONTRACT,\n        id: 119,\n    },\n    {\n        name: \"Estuary\",\n        description: \"We need a description here\",\n        contract: ELEMENT_ESTUARY_CONTRACT,\n        id: 120,\n    },\n    {\n        name: \"Fire Swamp\",\n        description: \"We need a description here\",\n        contract: ELEMENT_FIRE_SWAMP_CONTRACT,\n        id: 121,\n    },\n    {\n        name: \"Riverbank\",\n        description: \"We need a description here\",\n        contract: ELEMENT_RIVERBANK_CONTRACT,\n        id: 122,\n    },\n    {\n        name: \"Ravine\",\n        description: \"We need a description here\",\n        contract: ELEMENT_RAVINE_CONTRACT,\n        id: 123,\n    },\n    {\n        name: \"Gorge\",\n        description: \"We need a description here\",\n        contract: ELEMENT_GORGE_CONTRACT,\n        id: 124,\n    },\n    {\n        name: \"Charred Ravine\",\n        description: \"We need a description here\",\n        contract: ELEMENT_CHARRED_RAVINE_CONTRACT,\n        id: 125,\n    },\n    {\n        name: \"Echo\",\n        description: \"We need a description here\",\n        contract: ELEMENT_ECHO_CONTRACT,\n        id: 126,\n    },\n    {\n        name: \"Cave\",\n        description: \"We need a description here\",\n        contract: ELEMENT_CAVE_CONTRACT,\n        id: 127,\n    },\n    {\n        name: \"Underground Lake\",\n        description: \"We need a description here\",\n        contract: ELEMENT_UNDERGROUND_LAKE_CONTRACT,\n        id: 128,\n    },\n    {\n        name: \"Lava Cave\",\n        description: \"We need a description here\",\n        contract: ELEMENT_LAVA_CAVE_CONTRACT,\n        id: 129,\n    },\n    {\n        name: \"Whispering Cave\",\n        description: \"We need a description here\",\n        contract: ELEMENT_WHISPERING_CAVE_CONTRACT,\n        id: 130,\n    },\n    {\n        name: \"Subterranean Pool\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SUBTERRANEAN_POOL_CONTRACT,\n        id: 131,\n    },\n    {\n        name: \"Spring\",\n        description: \"We need a description here\",\n        contract: ELEMENT_SPRING_CONTRACT,\n        id: 132,\n    },\n    {\n        name: \"Hot Spring\",\n        description: \"We need a description here\",\n        contract: ELEMENT_HOT_SPRING_CONTRACT,\n        id: 133,\n    },\n    {\n        name: \"Grotto\",\n        description: \"We need a description here\",\n        contract: ELEMENT_GROTTO_CONTRACT,\n        id: 134,\n    },\n    {\n        name: \"Fountain\",\n        description: \"We need a description here\",\n        contract: ELEMENT_FOUNTAIN_CONTRACT,\n        id: 135,\n    },\n    {\n        name: \"Steam Vent\",\n        description: \"We need a description here\",\n        contract: ELEMENT_STEAM_VENT_CONTRACT,\n        id: 136,\n    },\n    {\n        name: \"Cool Breeze\",\n        description: \"We need a description here\",\n        contract: ELEMENT_COOL_BREEZE_CONTRACT,\n        id: 137,\n    },\n    {\n        name: \"Monument\",\n        description: \"We need a description here\",\n        contract: ELEMENT_MONUMENT_CONTRACT,\n        id: 138,\n    },\n    {\n        name: \"Waterfall\",\n        description: \"We need a description here\",\n        contract: ELEMENT_WATERFALL_CONTRACT,\n        id: 139,\n    },\n    {\n        name: \"Eternal Flame\",\n        description: \"We need a description here\",\n        contract: ELEMENT_ETERNAL_FLAME_CONTRACT,\n        id: 140,\n    },\n    {\n        name: \"Pillar Of Wind\",\n        description: \"We need a description here\",\n        contract: ELEMENT_PILLAR_OF_WIND_CONTRACT,\n        id: 141,\n    },\n    {\n        name: \"Stream\",\n        description: \"We need a description here\",\n        contract: ELEMENT_STREAM_CONTRACT,\n        id: 142,\n    },\n    {\n        name: \"Zephyr\",\n        description: \"We need a description here\",\n        contract: ELEMENT_ZEPHYR_CONTRACT,\n        id: 143,\n    },\n    {\n        name: \"Creek\",\n        description: \"We need a description here\",\n        contract: ELEMENT_CREEK_CONTRACT,\n        id: 144,\n    },\n    {\n        name: \"Brook\",\n        description: \"We need a description here\",\n        contract: ELEMENT_BROOK_CONTRACT,\n        id: 145,\n    },\n    {\n        name: \"Whisper\",\n        description: \"We need a description here\",\n        contract: ELEMENT_WHISPER_CONTRACT,\n        id: 146,\n    },\n    {\n        name: \"Rivulet\",\n        description: \"We need a description here\",\n        contract: ELEMENT_RIVULET_CONTRACT,\n        id: 147,\n    },\n    {\n        name: \"Tributary\",\n        description: \"We need a description here\",\n        contract: ELEMENT_TRIBUTARY_CONTRACT,\n        id: 148,\n    },\n    {\n        name: \"Murmur\",\n        description: \"We need a description here\",\n        contract: ELEMENT_MURMUR_CONTRACT,\n        id: 149,\n    },\n    {\n        name: \"Watershed\",\n        description: \"We need a description here\",\n        contract: ELEMENT_WATERSHED_CONTRACT,\n        id: 150,\n    },\n    {\n        name: \"Aquifer\",\n        description: \"We need a description here\",\n        contract: ELEMENT_AQUIFER_CONTRACT,\n        id: 151,\n    },\n    {\n        name: \"Parched Earth\",\n        description: \"We need a description here\",\n        contract: ELEMENT_PARCHED_EARTH_CONTRACT,\n        id: 152,\n    },\n    {\n        name: \"Fresh Breeze\",\n        description: \"We need a description here\",\n        contract: ELEMENT_FRESH_BREEZE_CONTRACT,\n        id: 153,\n    },\n    {\n        name: \"Groundwater\",\n        description: \"We need a description here\",\n        contract: ELEMENT_GROUNDWATER_CONTRACT,\n        id: 154,\n    },\n    {\n        name: \"Reservoir\",\n        description: \"We need a description here\",\n        contract: ELEMENT_RESERVOIR_CONTRACT,\n        id: 155,\n    },\n    {\n        name: \"Geothermal Spring\",\n        description: \"We need a description here\",\n        contract: ELEMENT_GEOTHERMAL_SPRING_CONTRACT,\n        id: 156,\n    },\n    {\n        name: \"Artesian Well\",\n        description: \"We need a description here\",\n        contract: ELEMENT_ARTESIAN_WELL_CONTRACT,\n        id: 157,\n    },\n    {\n        name: \"Basin\",\n        description: \"We need a description here\",\n        contract: ELEMENT_BASIN_CONTRACT,\n        id: 158,\n    },\n    {\n        name: \"Lake\",\n        description: \"We need a description here\",\n        contract: ELEMENT_LAKE_CONTRACT,\n        id: 159,\n    },\n    {\n        name: \"Dry Basin\",\n        description: \"We need a description here\",\n        contract: ELEMENT_DRY_BASIN_CONTRACT,\n        id: 160,\n    },\n    {\n        name: \"Depression\",\n        description: \"We need a description here\",\n        contract: ELEMENT_DEPRESSION_CONTRACT,\n        id: 161,\n    },\n    {\n        name: \"Island\",\n        description: \"We need a description here\",\n        contract: ELEMENT_ISLAND_CONTRACT,\n        id: 162,\n    },\n    {\n        name: \"Lagoon\",\n        description: \"We need a description here\",\n        contract: ELEMENT_LAGOON_CONTRACT,\n        id: 163,\n    },\n    {\n        name: \"Wave\",\n        description: \"We need a description here\",\n        contract: ELEMENT_WAVE_CONTRACT,\n        id: 164,\n    },\n    {\n        name: \"Reef\",\n        description: \"We need a description here\",\n        contract: ELEMENT_REEF_CONTRACT,\n        id: 165,\n    },\n    {\n        name: \"Coral\",\n        description: \"We need a description here\",\n        contract: ELEMENT_CORAL_CONTRACT,\n        id: 166,\n    },\n    {\n        name: \"Whirl\",\n        description: \"We need a description here\",\n        contract: ELEMENT_WHIRL_CONTRACT,\n        id: 167,\n    },\n    {\n        name: \"Limestone\",\n        description: \"We need a description here\",\n        contract: ELEMENT_LIMESTONE_CONTRACT,\n        id: 168,\n    },\n    {\n        name: \"Karst\",\n        description: \"We need a description here\",\n        contract: ELEMENT_KARST_CONTRACT,\n        id: 169,\n    },\n    {\n        name: \"Quicklime\",\n        description: \"We need a description here\",\n        contract: ELEMENT_QUICKLIME_CONTRACT,\n        id: 170,\n    },\n    {\n        name: \"Blowhole\",\n        description: \"We need a description here\",\n        contract: ELEMENT_BLOWHOLE_CONTRACT,\n        id: 171,\n    },\n];\n\nconst UNIFIERS_ELEMENT_CONTRACTS: Record<number, any> = {\n    [0]: ELEMENT_MONKEY_CONTRACT,\n    [1]: ELEMENT_GIRAFFE_CONTRACT,\n    [2]: ELEMENT_BEE_CONTRACT,\n    [3]: ELEMENT_COIN_CONTRACT,\n    [4]: ELEMENT_SWARM_CONTRACT,\n    [5]: ELEMENT_HYDRA_CONTRACT,\n    [6]: ELEMENT_MONKEY_BRANCH_CONTRACT,\n    [7]: ELEMENT_BRIDGE_CONTRACT,\n    [8]: ELEMENT_GOLDEN_GATE_CONTRACT,\n    [9]: ELEMENT_GOLD_CONTRACT,\n    [10]: ELEMENT_SILVER_CONTRACT,\n    [11]: ELEMENT_RHODIUM_CONTRACT,\n    [12]: ELEMENT_HIVE_CONTRACT,\n    [13]: ELEMENT_TRANSACTION_CONTRACT,\n    [14]: ELEMENT_BLOCK_CONTRACT,\n    [15]: ELEMENT_BLOCKCHAIN_CONTRACT,\n    [16]: ELEMENT_POLKADOT_CONTRACT,\n    [17]: ELEMENT_PEER_REVIEW_CONTRACT,\n    [18]: ELEMENT_CARDANO_CONTRACT,\n    [19]: ELEMENT_BEAR_CONTRACT,\n    [20]: ELEMENT_BEER_CONTRACT,\n    [21]: ELEMENT_LOCK_CONTRACT,\n    [22]: ELEMENT_MARMALADE_CONTRACT,\n    [23]: ELEMENT_SUPER_MARMALADE_CONTRACT,\n    [24]: ELEMENT_HYPER_MARMALADE_CONTRACT,\n};\n\nexport const DEPLOYABLE_UNIFIERS: IDeployableGame = {\n    name: \"Unifiers\",\n    description: \"A game created with the help of the Unifiers group\",\n    gameContract: UNIFIERS_CONTRACT,\n    elementContracts: UNIFIERS_ELEMENT_CONTRACTS,\n    otherNames: {\n        camelCase: \"unifiers\",\n        snakeCase: \"unifiers\",\n        kebabCase: \"unifiers\",\n        pascalCase: \"Unifiers\",\n        constantCase: \"UNIFIERS\",\n    }\n};\nexport const DEPLOYABLE_GAMES: Array<IDeployableGame> = [\n    DEPLOYABLE_UNIFIERS,\n];",
      "contentHash": "c7e9493885d23891cd9b12c9c14a4c6e467eb37c5603dd1bb58f210e6832af04",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements.md",
      "content": "# Elements\n\nIn _Not a Bird_ players own **elements**. Elements are full-fledged [cryptocurrencies](https://en.wikipedia.org/wiki/Cryptocurrency). They are created via _Smart Contracts_ deployed to a blockchain, and they support the [PSP-22 interface](https://github.com/w3f/PSPs/blob/master/PSPs/psp-22.md).\n\n## Tier number\n\nEach element has a **tier number**.\n\nThe _tier number_ is used when calculating the _buy price_ of elements. The game contract defines a so-called _buy offer_, which looks like this:\n\n```json\n{\n    \"nativeTokens\": \"1234.12345678\",\n    \"rewardTierPoints\": \"100\"\n}\n```\n\nThis means, that for `1234.12345678` of the _native token_ (the cryptocurrency you use to play the game), you can buy `100` _tier points_. You can convert these tier points in the buy transaction to _any element_.\n\nWhen you buy from the game contract, you will receive `floor(bought_tier_points / element_tier)` elements of the chosen element.\n\nYou must always pay an _integer multiple_ of the `nativeTokens` in the _buy offer_, because you will only get `floor(paid_tier_points / buy_offer_native_tokens) * buy_offer_reward_tier_points` tier points.\n\nElements, that cannot be crafted are \"_base elements_\", so we assign the _tier number_ `1` to them. Every other element has a tier number of `A + B + C`, where `A` and `B` are the tier numbers of the elements required to craft it, and `C` is a constant greater than zero.\n\n## List of elements\n\n* [Monkey](/wiki/elements/monkey)\n* [Giraffe](/wiki/elements/giraffe)\n* [Bee](/wiki/elements/bee)\n* [Coin](/wiki/elements/coin)\n* [Swarm](/wiki/elements/swarm)\n* [Hydra](/wiki/elements/hydra)\n* [Monkey Branch](/wiki/elements/monkey-branch)\n* [Bridge](/wiki/elements/bridge)\n* [Golden Gate](/wiki/elements/golden-gate)\n* [Gold](/wiki/elements/gold)\n* [Silver](/wiki/elements/silver)\n* [Rhodium](/wiki/elements/rhodium)\n* [Hive](/wiki/elements/hive)\n* [Transaction](/wiki/elements/transaction)\n* [Block](/wiki/elements/block)\n* [Blockchain](/wiki/elements/blockchain)\n* [Polkadot](/wiki/elements/polkadot)\n* [Peer Review](/wiki/elements/peer-review)\n* [Cardano](/wiki/elements/cardano)\n* [Bear](/wiki/elements/bear)\n* [Beer](/wiki/elements/beer)\n* [Lock](/wiki/elements/lock)\n* [Marmalade](/wiki/elements/marmalade)\n* [Super Marmalade](/wiki/elements/super-marmalade)\n* [Hyper Marmalade](/wiki/elements/hyper-marmalade)\n* [Water](/wiki/elements/water)\n* [Fire](/wiki/elements/fire)\n* [Steam](/wiki/elements/steam)\n* [Earth](/wiki/elements/earth)\n* [Mud](/wiki/elements/mud)\n* [Lava](/wiki/elements/lava)\n* [Wind](/wiki/elements/wind)\n* [Dust](/wiki/elements/dust)\n* [Rain](/wiki/elements/rain)\n* [Smoke](/wiki/elements/smoke)\n* [Geyser](/wiki/elements/geyser)\n* [Clay](/wiki/elements/clay)\n* [Sand](/wiki/elements/sand)\n* [Plant](/wiki/elements/plant)\n* [Rainbow](/wiki/elements/rainbow)\n* [Storm](/wiki/elements/storm)\n* [Obsidian](/wiki/elements/obsidian)\n* [Ash](/wiki/elements/ash)\n* [Volcano](/wiki/elements/volcano)\n* [Sandstorm](/wiki/elements/sandstorm)\n* [Cloud](/wiki/elements/cloud)\n* [Fog](/wiki/elements/fog)\n* [Tree](/wiki/elements/tree)\n* [Forest](/wiki/elements/forest)\n* [Seeds](/wiki/elements/seeds)\n* [Pottery](/wiki/elements/pottery)\n* [Brick](/wiki/elements/brick)\n* [Quicksand](/wiki/elements/quicksand)\n* [Glass](/wiki/elements/glass)\n* [Dune](/wiki/elements/dune)\n* [Charcoal](/wiki/elements/charcoal)\n* [Leaves](/wiki/elements/leaves)\n* [Wildfire](/wiki/elements/wildfire)\n* [Jungle](/wiki/elements/jungle)\n* [Frosted Glass](/wiki/elements/frosted-glass)\n* [Crystal](/wiki/elements/crystal)\n* [Magma](/wiki/elements/magma)\n* [Rock](/wiki/elements/rock)\n* [Shard](/wiki/elements/shard)\n* [Pebble](/wiki/elements/pebble)\n* [Mountain](/wiki/elements/mountain)\n* [Fertilizer](/wiki/elements/fertilizer)\n* [Soot](/wiki/elements/soot)\n* [Lightning](/wiki/elements/lightning)\n* [Mist](/wiki/elements/mist)\n* [Haze](/wiki/elements/haze)\n* [Flood](/wiki/elements/flood)\n* [Landslide](/wiki/elements/landslide)\n* [Thunder](/wiki/elements/thunder)\n* [Tornado](/wiki/elements/tornado)\n* [Garden](/wiki/elements/garden)\n* [Ember](/wiki/elements/ember)\n* [Kiln](/wiki/elements/kiln)\n* [Pollination](/wiki/elements/pollination)\n* [Sinkhole](/wiki/elements/sinkhole)\n* [Beach](/wiki/elements/beach)\n* [Wetstone](/wiki/elements/wetstone)\n* [Erosion](/wiki/elements/erosion)\n* [Basalt](/wiki/elements/basalt)\n* [Magma Chamber](/wiki/elements/magma-chamber)\n* [Breeze](/wiki/elements/breeze)\n* [Warm Breeze](/wiki/elements/warm-breeze)\n* [Soil](/wiki/elements/soil)\n* [Canyon](/wiki/elements/canyon)\n* [Windmill](/wiki/elements/windmill)\n* [Adobe](/wiki/elements/adobe)\n* [Wall](/wiki/elements/wall)\n* [Pumice](/wiki/elements/pumice)\n* [Barbecue](/wiki/elements/barbecue)\n* [Farm](/wiki/elements/farm)\n* [Shards](/wiki/elements/shards)\n* [Molten Glass](/wiki/elements/molten-glass)\n* [Prism](/wiki/elements/prism)\n* [Sparkle](/wiki/elements/sparkle)\n* [Desert](/wiki/elements/desert)\n* [Oasis](/wiki/elements/oasis)\n* [Mirage](/wiki/elements/mirage)\n* [Sand Dune](/wiki/elements/sand-dune)\n* [Dam](/wiki/elements/dam)\n* [Firewall](/wiki/elements/firewall)\n* [Barricade](/wiki/elements/barricade)\n* [Plateau](/wiki/elements/plateau)\n* [Pond](/wiki/elements/pond)\n* [Aromas](/wiki/elements/aromas)\n* [Flower](/wiki/elements/flower)\n* [Spore](/wiki/elements/spore)\n* [Spread](/wiki/elements/spread)\n* [Fertile Land](/wiki/elements/fertile-land)\n* [Wetland](/wiki/elements/wetland)\n* [Peat](/wiki/elements/peat)\n* [Reeds](/wiki/elements/reeds)\n* [Valley](/wiki/elements/valley)\n* [River](/wiki/elements/river)\n* [Scorched Earth](/wiki/elements/scorched-earth)\n* [Delta](/wiki/elements/delta)\n* [Estuary](/wiki/elements/estuary)\n* [Fire Swamp](/wiki/elements/fire-swamp)\n* [Riverbank](/wiki/elements/riverbank)\n* [Ravine](/wiki/elements/ravine)\n* [Gorge](/wiki/elements/gorge)\n* [Charred Ravine](/wiki/elements/charred-ravine)\n* [Echo](/wiki/elements/echo)\n* [Cave](/wiki/elements/cave)\n* [Underground Lake](/wiki/elements/underground-lake)\n* [Lava Cave](/wiki/elements/lava-cave)\n* [Whispering Cave](/wiki/elements/whispering-cave)\n* [Subterranean Pool](/wiki/elements/subterranean-pool)\n* [Spring](/wiki/elements/spring)\n* [Hot Spring](/wiki/elements/hot-spring)\n* [Grotto](/wiki/elements/grotto)\n* [Fountain](/wiki/elements/fountain)\n* [Steam Vent](/wiki/elements/steam-vent)\n* [Cool Breeze](/wiki/elements/cool-breeze)\n* [Monument](/wiki/elements/monument)\n* [Waterfall](/wiki/elements/waterfall)\n* [Eternal Flame](/wiki/elements/eternal-flame)\n* [Pillar Of Wind](/wiki/elements/pillar-of-wind)\n* [Stream](/wiki/elements/stream)\n* [Zephyr](/wiki/elements/zephyr)\n* [Creek](/wiki/elements/creek)\n* [Brook](/wiki/elements/brook)\n* [Whisper](/wiki/elements/whisper)\n* [Rivulet](/wiki/elements/rivulet)\n* [Tributary](/wiki/elements/tributary)\n* [Murmur](/wiki/elements/murmur)\n* [Watershed](/wiki/elements/watershed)\n* [Aquifer](/wiki/elements/aquifer)\n* [Parched Earth](/wiki/elements/parched-earth)\n* [Fresh Breeze](/wiki/elements/fresh-breeze)\n* [Groundwater](/wiki/elements/groundwater)\n* [Reservoir](/wiki/elements/reservoir)\n* [Geothermal Spring](/wiki/elements/geothermal-spring)\n* [Artesian Well](/wiki/elements/artesian-well)\n* [Basin](/wiki/elements/basin)\n* [Lake](/wiki/elements/lake)\n* [Dry Basin](/wiki/elements/dry-basin)\n* [Depression](/wiki/elements/depression)\n* [Island](/wiki/elements/island)\n* [Lagoon](/wiki/elements/lagoon)\n* [Wave](/wiki/elements/wave)\n* [Reef](/wiki/elements/reef)\n* [Coral](/wiki/elements/coral)\n* [Whirl](/wiki/elements/whirl)\n* [Limestone](/wiki/elements/limestone)\n* [Karst](/wiki/elements/karst)\n* [Quicklime](/wiki/elements/quicklime)\n* [Blowhole](/wiki/elements/blowhole)\n\nSee also:\n\n* [Games](/wiki/games)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "5f95db7dea0979ea718ab54d7476797914c8d8a6af4a281daefb6b6fb86a3a3d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/adobe.md",
      "content": "# Adobe\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "322bf9581ed83ef5b101958bee2554ae903be5b5aedee32b87aec757d80208bc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/aquifer.md",
      "content": "# Aquifer\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "7f2cbf95eb86f9671caa5d7b480a857238522cb5fdbdc7fcebb6e3911e92de94",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/aromas.md",
      "content": "# Aromas\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "14b73f5bbc95649411c1a30c5bae445ea1dd441066ea63234fc6bc6184f05cf5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/artesian-well.md",
      "content": "# Artesian Well\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "a013821890fedbc13a0997d3fdb7845fd71ff4f608208c2c932d330c006c7213",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/ash.md",
      "content": "# Ash\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "76957240e6dfefb4fc6b301b1b44c2efda1fa5a714f867b11986a47416e4993d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/barbecue.md",
      "content": "# Barbecue\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "ad18171a6e0c3c4eff730cf64555f6cebb6042371bb750ccbed7497a57d7f764",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/barricade.md",
      "content": "# Barricade\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "2e0d9d637cbe3ddf5ab0064610c7fdab70c16d96d053e9d55e2b36e3b466310b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/basalt.md",
      "content": "# Basalt\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "735ef985ef46796dca5e1d05e52f6a5ddfc7add0ddbedb137349a2d2db8a1843",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/basin.md",
      "content": "# Basin\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "149b6ecd0ed218b6062d19341c9678f085dee658418efd88b898dfb6406449a9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/beach.md",
      "content": "# Beach\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "8783ae398fbe71e35642cf3ea304ad5a6d7696359d5f8f31419c99b3a214ade0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/bear.md",
      "content": "# Bear\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "fe85213617bb23e91ef75ce2e9eadd100248ab6da041b070ff582e49bf2c34b4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/bee.md",
      "content": "# Bee\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "e47bd854ca3e985e1a9c20105a3ce04217cef78227c3b8f876f07a4d475d6b1f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/beer.md",
      "content": "# Beer\n\n**Tier**: 2\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "a199b85100a319b72829139bd085741e3379fdb6583e2d22596be15b3cbf0ce7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/block.md",
      "content": "# Block\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "b00ce34a2ef9fb492849cd59b6a3d11b144b0416c9a9d0da8352b9622423bbe7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/blockchain.md",
      "content": "# Blockchain\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "6a403f64f336eccb4f88acb49d4dde455513ba57e9fce435a328e815d79eda60",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/blowhole.md",
      "content": "# Blowhole\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "c5da4b904e4b3e478d6250224adf10124b8d98bc72de707d368fa2d85cae5df1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/breeze.md",
      "content": "# Breeze\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "cf7fd858aa94480ca66869dda10795d1feb26e9057d5e5672851385471f88dbd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/brick.md",
      "content": "# Brick\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "c8380894bd60f4727c55b08f9121adc3d2d48bd13073bab5a87a3f53348b0199",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/bridge.md",
      "content": "# Bridge\n\n**Tier**: 2\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "43961578c1427cba7817c963b9b980f50203d81dd17f7fb9a2eeb2d1d784b922",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/brook.md",
      "content": "# Brook\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "0b660003539b89b6d67869a413900d7c506d1cefebcd2c1d46bfc11ba39aca2f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/canyon.md",
      "content": "# Canyon\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "70bb41d170e9fcffd0b67dd4be67139c7c22dab9d1fd75bde30bb22dc9d6c559",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/cardano.md",
      "content": "# Cardano\n\n**Tier**: 2\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "9c66ce56a76e63e6a510b55f1102899fbb02db26542709969c502e9d345cb085",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/cave.md",
      "content": "# Cave\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "930a1cbaf70b75d0a763a61a6b3e2ad0d5b67dbe10d30cb7b453f6dba8e35034",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/charcoal.md",
      "content": "# Charcoal\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "fad8d9d22c1d566a8ac3752ae27cac67822632417a3d93b549e4e1c9c423c401",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/charred-ravine.md",
      "content": "# Charred Ravine\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "73e0d37428ba07f95e9d92c8c69e608ddc0c157f4025e3722fc13349ce650c2a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/clay.md",
      "content": "# Clay\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "7d71b6ec1a0da89daa608953b9e076f9621773b2c3325b48433388859af5ddfe",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/cloud.md",
      "content": "# Cloud\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "7a5aa46c38b19aeec67b0c964170895fb6ed62b50444d4dbee27820c851ec16a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/coin.md",
      "content": "# Coin\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "f9f4cc17124735132c4c64d179f7ffeec9d5a3403909069ca8bbc886d1ac8956",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/cool-breeze.md",
      "content": "# Cool Breeze\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "74b5145d61fe690b921c8e3d3be1147ffa1838aae6ff1a5c7dd08f3165ae4d6c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/coral.md",
      "content": "# Coral\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "8f84bf21f1288e2eeeb8790eb5f29c9eb70e0d009719eddbd76118c1bc48dffb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/creek.md",
      "content": "# Creek\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "54d3f40da4a57f317b38853ce08d1c86afccf0e396355bf0abb9ecc6c8b65040",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/crystal.md",
      "content": "# Crystal\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "aa58483089ea4f884f0dc4c4f9947f3aae7cdf259cdc2f49cae205ca7da89d59",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/dam.md",
      "content": "# Dam\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "cd063e5d9c312aa119fdc1936a9ff166837e9a80da4146802cd27735968d56fb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/delta.md",
      "content": "# Delta\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "f91dd7ad6a73acb172f0486a774bcf743ed1ef13889956eb28eb4860f33e53db",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/depression.md",
      "content": "# Depression\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "3be7fd5b1733e81d8946238c74530c7464d0ab4149971baa0d4fe3df0887ce42",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/desert.md",
      "content": "# Desert\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "cd1a5ff7f9557bc55ee48ea29593f1b3ec6a27aae898ae24500f3e9189695ace",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/dry-basin.md",
      "content": "# Dry Basin\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "28309b0331de7a9bae0c5566f907a58c0b7d0004db055c4cb3b644eb5fddf65c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/dune.md",
      "content": "# Dune\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "888f71989e62a06fa1ea92d5d84428a7fad8c7514336239f71983cb38fc727f9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/dust.md",
      "content": "# Dust\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "9db888afe46b7e401d1d8f3de0bd7d4bde336cddde45333013f5fb0ebad6afb4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/earth.md",
      "content": "# Earth\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "d055b693f12ae1a66c984946bde860feb686f8fa2d7f11c10f79857888565737",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/echo.md",
      "content": "# Echo\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "08e3eba9a95bacb6d5209c2a1dbeaaa765df8249d66df9335544fc704a8f2e2f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/ember.md",
      "content": "# Ember\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "cb23bf7f61f760d5826fd5d6a8ca84939d8f94964ba3f5611032ef32c23e897c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/erosion.md",
      "content": "# Erosion\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "ab70d14d3e2c8e548080e01cd052fb009fafa5803938b891dc7eb239ee9b2ccc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/estuary.md",
      "content": "# Estuary\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "0c29dc0cbf4cd5b2e18737ac030b4e50284dd8bd471a6ba867a7cd736a08bf94",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/eternal-flame.md",
      "content": "# Eternal Flame\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "620271af2517b84a57093575de63451182b5841f6eec96fcfa9dd72222bcfcac",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/farm.md",
      "content": "# Farm\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "b9b59e735619f16962db71fb4d4407c2b263550e266e8ff3a4e7e6dde2af4dfb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/fertile-land.md",
      "content": "# Fertile Land\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "b3a5b76e16461e8a59c7a6c17f23915c496340152b20de999cb4b83679a9b8b4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/fertilizer.md",
      "content": "# Fertilizer\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "ffa31f00fe4e88edea600cf008d5304a143ba9bf3b369709d61184b03ee46a50",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/fire-swamp.md",
      "content": "# Fire Swamp\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "3db95903b17c8cd38ae23784bb13e8460c5243298a0ebe1c8fd17dbbc7d6d855",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/fire.md",
      "content": "# Fire\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "ff6042b6f6ee58f41dcffe63a3420637a34f89366a3fecd5fecf3791040035a2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/firewall.md",
      "content": "# Firewall\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "c24c8cdd62fa390b53ebc9ad606b9693b0b1c62250a15803bb496d1ef4d46ca0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/flood.md",
      "content": "# Flood\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "673d0c0512b9c4cb0ca0a465ba773ed5c8eb19388d2065e0ef6cfe1aac9497ab",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/flower.md",
      "content": "# Flower\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "db2bb38a8ea774022f5291ffbfab6f2a27e42c470e4cac92f3cda600758b4516",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/fog.md",
      "content": "# Fog\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "7c1c62c41a3f40f700d27cd3492d5de52e6c6afaee805615362209d9f38c16cd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/forest.md",
      "content": "# Forest\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "7d96a69c5c92517ef5c3a95007d0f0f62af5bc4b59c5404450716f0a3d57d3a6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/fountain.md",
      "content": "# Fountain\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "e65b06a05bf674659d42a8dac0295f5c59767d43e140cacc283404ceab4deafa",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/fresh-breeze.md",
      "content": "# Fresh Breeze\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "1edee0f0a9842c0fd799eb2cdb88318cb4a9dde8f24461691759de0098a291e7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/frosted-glass.md",
      "content": "# Frosted Glass\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "34e59f74b7b3967bd1de2dd8ab651ba1f4df3bc09492203ac65e9314d5e7af16",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/garden.md",
      "content": "# Garden\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "e84b94ff5ad6db9373c7cd25987566b8c24ad02709d8c9c4c4c3aeceed3a403a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/geothermal-spring.md",
      "content": "# Geothermal Spring\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "ee246397bf41f5c126d6bc0c7bdba70c201ac927c2648d27d563985c09c3202f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/geyser.md",
      "content": "# Geyser\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "688bf27d5ec0648890b32f009c2a9973b77487cc31a68887f93a4d847e8e5ee8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/giraffe.md",
      "content": "# Giraffe\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "e04d1b017a426202a1edb53ba708645d40c92dac6a01d4b1d35aff0a5d427d29",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/glass.md",
      "content": "# Glass\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "3786c7c2eae3ca4057d5df7ceb7466b2061edd61001ea0d99790d2b41225ffd4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/gold.md",
      "content": "# Gold\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "a2126eaf6d71d71c4ea70eec0ae08ad32c129eb005fadf615e16c4613dca31c9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/golden-gate.md",
      "content": "# Golden Gate\n\n**Tier**: 2\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "32af756bcb5fad04e24df210be68663016523909167c5ad83cb61fc9c6868dac",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/gorge.md",
      "content": "# Gorge\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "e3d03bb5cf57bb823a4d9f9dc5ecdc1dc7efc01da582080bca73335e3cbd0d2a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/grotto.md",
      "content": "# Grotto\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "b87cfbb68d177f11563d5deb582f1c024c2635b1540eade7c3ee4ec8535fbcd2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/groundwater.md",
      "content": "# Groundwater\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "e3cf0063b5130584e820ab6dfc1289c1735e1d587d16b5df224c80f9c6081122",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/haze.md",
      "content": "# Haze\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "99e13b755a59922f677638b7926a40812512cd7cb0379ad7806835a3199ffce3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/hive.md",
      "content": "# Hive\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "3f45d3e3c0c592ada84181487c536f9b2c7c517e94249a3ca96271e2d204186b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/hot-spring.md",
      "content": "# Hot Spring\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "0742e186e1d6446217ef73bde38141c9f341fae033d00f669778d007359bb694",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/hydra.md",
      "content": "# Hydra\n\n**Tier**: 2\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "9a1e13604b57456479aa14884a50af2f75ee8c9f873e08e319b83f74fede9205",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/hyper-marmalade.md",
      "content": "# Hyper Marmalade\n\n**Tier**: 2\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "c68c829408a2fd31a53eabc7a8033107f6a1b4fb9f39e49677ae4ba0b58ba5db",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/island.md",
      "content": "# Island\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "6d2c28f7c026af1399c0b13b8a18bdb36d5fcb31f644e8c13e2198f9b9902e68",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/jungle.md",
      "content": "# Jungle\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "3ddf7280a2849ddfbef8d9e9f379d320e71ff3bcdb4a8dec65051f10e09b13d6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/karst.md",
      "content": "# Karst\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "e7ff789b3129ff23cf1766cdfbbd37793f6d857373219436527f74ac2ad68bbd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/kiln.md",
      "content": "# Kiln\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "7f0531dc5016ccf77bffa3dd92c3a7dd338ceee2acf3dc54ce6e597925edc9e6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/lagoon.md",
      "content": "# Lagoon\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "7289f77e4874be903cd6dc1c4bfd39fdaeeda48c321fbc1364c75efd01db619e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/lake.md",
      "content": "# Lake\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "60edd978ff7ef9a97b90b9af78c566dab33962d8cce42da524e1ad0b49899885",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/landslide.md",
      "content": "# Landslide\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "99886ea420b27ac027fa844b3208fe00ab5c7fe780a8d982ee823e35a677a96e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/lava-cave.md",
      "content": "# Lava Cave\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "4007625adb930382d759a5a1b95508d15770c9254b59d6004deae7bde7274106",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/lava.md",
      "content": "# Lava\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "c9ad36fd4d38551615786078cc5b0848b69cddeccc9dbe37a9c8cb8fda0b2617",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/leaves.md",
      "content": "# Leaves\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "09ea730743b9056d78642f5368033a232afd6e0c36ef2dd73f3f277706f06f92",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/lightning.md",
      "content": "# Lightning\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "8ef3f9c229187533e8c6eb9745fa2f52637ee2157a97e7a74d7ccdac67ca6056",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/limestone.md",
      "content": "# Limestone\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "c913ee7cfb04c0d94b547dafa00cbb29eca2591875c1aa63e489d17a283311bc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/lock.md",
      "content": "# Lock\n\n**Tier**: 2\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "04cd697ecdd68945ce61231c38b36af3171d40e42905c6e87a5a99e2a6c651b2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/magma-chamber.md",
      "content": "# Magma Chamber\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "c3588f908ab2e05f68d2b2d1f4c08635522316c90992aec6a17b0dd19d4a966c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/magma.md",
      "content": "# Magma\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "d7f18fafaa01b6f90c338fb36279ef525da1fec19d133a7f71070551c6829d88",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/marmalade.md",
      "content": "# Marmalade\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "42388abc33cfd35dc32d6ee22ba4fc99ca502a1066e8f2569addd386964f1048",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/mirage.md",
      "content": "# Mirage\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "0835a96997593368b14132aad3909d7acdb6f4998b65c46a8c155cb2dd7527b6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/mist.md",
      "content": "# Mist\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "40715eba4cdddc4bf7eea7f82bcc61b268fc657974120cc0b7db5ab09e184130",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/molten-glass.md",
      "content": "# Molten Glass\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "4412ba481ab36512b7c5e05b9e58476c1cd4d241c793c78bac1dd0a8ca1400a0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/monkey-branch.md",
      "content": "# Monkey Branch\n\n**Tier**: 2\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "553741cee4735dc9b3dee47c435058c0b9471f89e052c30df211e4cb04f97313",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/monkey.md",
      "content": "# Monkey\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "451fd384bbb60bc27c936517e0526c25688c839aee3bd5dba45de1cd3d97475a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/monument.md",
      "content": "# Monument\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "ffdbce4e21a7b7c680811afbe32223256f9a75a28b4e794dc8a6663405d3df76",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/mountain.md",
      "content": "# Mountain\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "5abcf960f01410ef6cf42ea75e8fdd9df33cf368f63cf94044819950a93d645a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/mud.md",
      "content": "# Mud\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "1d2c2da21d54b8f1be048500952602f3f407e320e20b4a5e74de72dad978cc3c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/murmur.md",
      "content": "# Murmur\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "6551fbad3819d52b81e0ee52f27dba54989b5c21bca1f7df5d45119e96084152",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/oasis.md",
      "content": "# Oasis\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "7e971a40cab8be807c2eba34398ed54db5cad33309120f3f8a898d46fc8c461d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/obsidian.md",
      "content": "# Obsidian\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "dca0f23ebea6d077083a55f9d1a428007610e965d1244f05208ab67762e3798e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/parched-earth.md",
      "content": "# Parched Earth\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "b8d1c4f4aa3b70f52c7d89c482096fb5a7c9c3705e4fbea83a5aaaf76877ca3d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/peat.md",
      "content": "# Peat\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "341ee288cd2a2c00e63f882b2b31824511104770e09ce94b0af26b02eefd36e6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/pebble.md",
      "content": "# Pebble\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "7f54ef4b8c3c2aeece2085f9dd62676a6238593a61d5ad2ea07eedc3ccf2d112",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/peer-review.md",
      "content": "# Peer Review\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "4a7583b4904a53fb128ae03015e8576cb84d8c5261115b6fdd59df12f2643855",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/pillar-of-wind.md",
      "content": "# Pillar Of Wind\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "21e43d19e80e0829167c587202c52e2c5b27cac68e9dd3caeb65310919dd8a31",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/plant.md",
      "content": "# Plant\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "2ca424d4b67efbe512cc9dad94633419b90e0f37addb9e50659189f9cd6c7de5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/plateau.md",
      "content": "# Plateau\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "59275f30eb1a1acad198e3aa122c529d98d1b48d8ec931698555e6d06e2165d2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/polkadot.md",
      "content": "# Polkadot\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "0b41b25d2c86bb67584bbec587907c84edea7a3a287421f5f2dc4c33b897973c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/pollination.md",
      "content": "# Pollination\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "f07480043ad4d19ac10844b7db3849d7b37128c053c3564a68961854bbc649c5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/pond.md",
      "content": "# Pond\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "73729953dfdc1154f8aae935a53302e15498d0ca784016763f9b4c1ae3e28eb5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/pottery.md",
      "content": "# Pottery\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "cae4169f3987119d4dd0b984fc7ec1ff7eddffba6267bb3662c30519ab6ec98b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/prism.md",
      "content": "# Prism\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "531b41676b4e749f1ec9aa36ce1c0dad103a27158bcdc4cdb75fbb376a046a02",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/pumice.md",
      "content": "# Pumice\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "f7ea112dd03d2754dc11a418a263fe4daf5254306cb932cdb7703fc3e10fd082",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/quicklime.md",
      "content": "# Quicklime\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "7815ce578823032ea2e1821dc7ac8b4e0531a34ece0a92be16154f5030ec6b6f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/quicksand.md",
      "content": "# Quicksand\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "22421328491211fa97eb256f9d76659b904da69c232516f7302cf99cc718bb14",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/rain.md",
      "content": "# Rain\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "fb7b144f1e64f5e04147055439c3ea6932cfef24a0b51f42f68a6c33644fb14f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/rainbow.md",
      "content": "# Rainbow\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "3a46822c619bbdd9073b28d1fb3cb601f016ca3c229ec6f16dbb4d9c45e928b1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/ravine.md",
      "content": "# Ravine\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "4575f67ded36e67157fb8c6128f447a32854bf57800e8ce0e688ac4c352aa756",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/reeds.md",
      "content": "# Reeds\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "ff955e00357f6611062c6d76c1bfaec5fa03ddcfc27adb760b87ce7fb266a059",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/reef.md",
      "content": "# Reef\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "7f6fb795d81d9dbd0e78f91cae32413138dc3ff6b4df081c43acad1ae9e7054b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/reservoir.md",
      "content": "# Reservoir\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "1d321b3a79e359c4d06dab9e4a3386841d0b88b48709527ff4ff3a79f6eccdac",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/rhodium.md",
      "content": "# Rhodium\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "fce3d9b7303b63c474a9eb48f5c7ee39d3683ee186c80e6dc4e8fd6fe60a9af3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/river.md",
      "content": "# River\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "b1a01d7f8c1b88a898f9ee7a0e98bf460ad001a449fe9f7c4a3c18c65ca96af6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/riverbank.md",
      "content": "# Riverbank\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "dcc36451c6f877eee36ce3d795fab37febcabf2ecab570f8925410051988b26d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/rivulet.md",
      "content": "# Rivulet\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "5a5286ed0ce072731c016eead282538a44ea53fb4a8e8ffc4a1e11c15e2a8c8b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/rock.md",
      "content": "# Rock\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "d9e16d33d53611a014eb1bf30d67af08d4566fc4f00036ce6313a644bdcbab29",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/sand-dune.md",
      "content": "# Sand Dune\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "2456e2517fb96be84451adfa4ef69dc1e87f49dbbe9871027aaf67222c0cff7e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/sand.md",
      "content": "# Sand\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "3c6c1ab798cd9c85fa192eedba51e624337a42084663a0fe57d7d1989c41953c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/sandstorm.md",
      "content": "# Sandstorm\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "73f1a743eb9e01f95b89daf2cde3574ce3b43b1ce0996dbaaf98e43ee294cd1b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/scorched-earth.md",
      "content": "# Scorched Earth\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "4558a6be3f848e271ca78385abdeff2373689c269b3693b0f7cd891a25020508",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/seeds.md",
      "content": "# Seeds\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "c639421fe6cd62696873bb5afe985f6a2088d95c90d4b35301cb4f5d20e3dcdc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/shard.md",
      "content": "# Shard\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "70e5b70bc7cd00272457f7c724ead75ddf09834acf0964171aa26e7dd2f541e8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/shards.md",
      "content": "# Shards\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "365d2ebe67a30d7fef3bddbb9406eb8de589b454856d29253e73b50b5fb8ce39",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/silver.md",
      "content": "# Silver\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "15842b22a2149655dd9a45dfbb483e4ee065de8b9563ca68808d7e9b5d0ae207",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/sinkhole.md",
      "content": "# Sinkhole\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "1a505c03b819e9d4b94332b9d70ff796ee2473b7203cae874d19e5ac8a9ca458",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/smoke.md",
      "content": "# Smoke\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "24655e59d727456a545195aa1b540b1a615e845bc1debac7cb29fdb21e513bb4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/soil.md",
      "content": "# Soil\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "306cfe17d1ae572fc7e0a23a256e56797dce14c9adac90ac359b55a75c5dd419",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/soot.md",
      "content": "# Soot\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "fe7ed1a601a60b9061e443ea93694a13d737cda16137cf530e212ce820280309",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/sparkle.md",
      "content": "# Sparkle\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "4cf691022b5e37dca3690d0827cbe7e049305aaa2779591a609671874bc786e5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/spore.md",
      "content": "# Spore\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "884253e67090507a4a6c33c4e27f1c6db7c3d4e9b5072e22097799237b6acc2c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/spread.md",
      "content": "# Spread\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "0c2378d01682ce578d63956ec60119da1dadb01bb70dbf47bb487da814f0a261",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/spring.md",
      "content": "# Spring\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "bdbe941ddf1f11e3cddebd8c870f8106c14d9cf3f6667cd2b5d6e242587228bb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/steam-vent.md",
      "content": "# Steam Vent\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "796c6a934f487d2e3dfdd5c1176f3a80725575083a040fb4a8f47462f7c0cbe6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/steam.md",
      "content": "# Steam\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "ea5c3489d66ee0197b6ccedb24b5d1fc62141b82560f0d739493b2949c3c2c6e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/storm.md",
      "content": "# Storm\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "82e3fa43eb65a90f3d8fb6d3277a32cc3f9eab76b5bf1c5b584c54912b962dca",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/stream.md",
      "content": "# Stream\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "6c89f9b0745e2cb2adaac2b89dc7b5d7099236c6d2f79cb15fbab1e5e4335d15",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/subterranean-pool.md",
      "content": "# Subterranean Pool\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "e888ccab34a9e18315c3c11e31540b4a2b7af555a63e2260e3dcaf1f669ed93c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/super-marmalade.md",
      "content": "# Super Marmalade\n\n**Tier**: 2\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "2fd2c25adb7cd781772d13e476fcef316d91c4e73145bdfc9d8657946bba727e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/swarm.md",
      "content": "# Swarm\n\n**Tier**: 2\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "1a8fc1a038bef00e32539d35b6c208aeefeea64428ab98885907a3b02324d900",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/thunder.md",
      "content": "# Thunder\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "5c0049e47631f7e0497a234ca24f13c437a42a9bd7479836f024741f5bad27cf",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/tornado.md",
      "content": "# Tornado\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "33db7963d0c7e91a49ba0258d86e2ed93f4efd5e091f8ada690317b093ee7d04",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/transaction.md",
      "content": "# Transaction\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "b25a70da6566ee8115a756379152d7b76aa9cb32b31aea5b3feb882d78985820",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/tree.md",
      "content": "# Tree\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "5bd179e9bd5f2d002f409e337c7efcb9eba4a919b6fd1e865324108acd3ba2bd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/tributary.md",
      "content": "# Tributary\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "c3321e629a79a0f8fddbc2d179216c05a1cfdd6c7ee47da209c37ed301a51d7e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/underground-lake.md",
      "content": "# Underground Lake\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "fb270b360aca0d0ce88efc94389b3a8d6161b7514b678c762c9eea0a013f405e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/valley.md",
      "content": "# Valley\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "552e8f58096f5c2662a30be3c7a4264e4fa9a2c1381498e7d53c6f1a2f7ad49f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/volcano.md",
      "content": "# Volcano\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "41525fbaca3a36d6bfeaa5312495b4ce74846a459297fccfab96c1f2838e5457",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/wall.md",
      "content": "# Wall\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "af56644885a81e9925ab89087cb7cfd11372a63a45d322ac515f4c0d3f8970d3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/warm-breeze.md",
      "content": "# Warm Breeze\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "da3ddc0de2313737b2c865bff2d846cd64e151b5db379642e7787336d4da3e31",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/water.md",
      "content": "# Water\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "19b10125b33a0d8b1b4541e4317c78106755d711d48c3e3a3782e29c97ebd77f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/waterfall.md",
      "content": "# Waterfall\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "6c637d6f8c423632716202bee1b67ee273e185166d2724f44f3521cb7bd4e085",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/watershed.md",
      "content": "# Watershed\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "8299d8e80b91c2803f85dac83206172c3ca43f1b8d695376aa68a8bf94d11514",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/wave.md",
      "content": "# Wave\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "e6e3e14fdab8824547465f521755d965f1ee9e18a90f31d1f169cd823152d02c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/wetland.md",
      "content": "# Wetland\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "653df05a34fe333a040682f5354b7594d5421a1272613439e98c1dac788550c4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/wetstone.md",
      "content": "# Wetstone\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "f56d069841ead82b48cb5f1ea8576354171dd32bf99305d7ad61c378f284a9c1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/whirl.md",
      "content": "# Whirl\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "93a9bbe933f7e08a15e111cfe1454a5b66e9c149303966b242e518498ca80a99",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/whisper.md",
      "content": "# Whisper\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "2c1b8aa3fae5137c913aa0be334ad2c7898136576210286a586a2c806df2bc96",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/whispering-cave.md",
      "content": "# Whispering Cave\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "cbfe660f6c1f65dd9eda80e8e027414b1f95ab08085b291222cf8919b6283ca8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/wildfire.md",
      "content": "# Wildfire\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "2073fd37c2d86938e7d8fbfe04dece03f00f5e5eae98f47fb2b270cb90602f11",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/wind.md",
      "content": "# Wind\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "6e9903068cc9f528a6a78957bb3e687264443eb20709655161c612cc4176d151",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/windmill.md",
      "content": "# Windmill\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "439f057fb568f79633a4c7e45c55a5914493e9237cd3044c3d1928cbd312f39d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/elements/zephyr.md",
      "content": "# Zephyr\n\n**Tier**: 1\n\nWe need a description here\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "a793666b19f1c1223bedc09c606fee2f7b9d6e1dddedd74d0ff0022899a281c6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/games.md",
      "content": "# Games\n\n_Not a bird_ contains multiple **games**. Each game is a set of [elements](/wiki/elements) and [recipes](/wiki/recipes).\n\n## List of games\n\n* [Unifiers](/wiki/games/unifiers)\n\nSee also:\n\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "ddccf475d108f4b2f6ece9f1611778580fbdeb37babe66625ba8389610ef8d5b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/games/unifiers.md",
      "content": "# Unifiers\n\nA game created with the help of the Unifiers group\n\n## Elements\n\n**Unifiers** has the following elements:\n\n* [Monkey](/wiki/elements/monkey)\n* [Giraffe](/wiki/elements/giraffe)\n* [Bee](/wiki/elements/bee)\n* [Coin](/wiki/elements/coin)\n* [Swarm](/wiki/elements/swarm)\n* [Hydra](/wiki/elements/hydra)\n* [Monkey Branch](/wiki/elements/monkey-branch)\n* [Bridge](/wiki/elements/bridge)\n* [Golden Gate](/wiki/elements/golden-gate)\n* [Gold](/wiki/elements/gold)\n* [Silver](/wiki/elements/silver)\n* [Rhodium](/wiki/elements/rhodium)\n* [Hive](/wiki/elements/hive)\n* [Transaction](/wiki/elements/transaction)\n* [Block](/wiki/elements/block)\n* [Blockchain](/wiki/elements/blockchain)\n* [Polkadot](/wiki/elements/polkadot)\n* [Peer Review](/wiki/elements/peer-review)\n* [Cardano](/wiki/elements/cardano)\n* [Bear](/wiki/elements/bear)\n* [Beer](/wiki/elements/beer)\n* [Lock](/wiki/elements/lock)\n* [Marmalade](/wiki/elements/marmalade)\n* [Super Marmalade](/wiki/elements/super-marmalade)\n* [Hyper Marmalade](/wiki/elements/hyper-marmalade)\n\n## Recipes\n\n**Unifiers** has the following recipes:\n\n* [Make Swarm](/wiki/recipes/make-swarm)\n* [Make Hydra](/wiki/recipes/make-hydra)\n* [Make Monkeybranch](/wiki/recipes/make-monkeybranch)\n* [Make Bridge](/wiki/recipes/make-bridge)\n* [Make Goldengate](/wiki/recipes/make-goldengate)\n* [Make Cardano](/wiki/recipes/make-cardano)\n* [Make Beer](/wiki/recipes/make-beer)\n* [Make Lock](/wiki/recipes/make-lock)\n* [Make Supermarmalade](/wiki/recipes/make-supermarmalade)\n* [Make Hypermarmalade](/wiki/recipes/make-hypermarmalade)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "cc4eb2d42aeabb851eeebe3e697313a8eadf53c7722a123b6697d6c9d6fd5831",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes.md",
      "content": "# Recipes\n\nIn _Not a Bird_ players can combine [elements](/wiki/elements) via **recipes**. Each recipe has a format of `A + B = C`, where `A`, `B` and `C` are elements.\n\n## List of recipes\n\n* [Make Swarm](/wiki/recipes/make-swarm)\n* [Make Hydra](/wiki/recipes/make-hydra)\n* [Make Monkeybranch](/wiki/recipes/make-monkeybranch)\n* [Make Bridge](/wiki/recipes/make-bridge)\n* [Make Goldengate](/wiki/recipes/make-goldengate)\n* [Make Cardano](/wiki/recipes/make-cardano)\n* [Make Beer](/wiki/recipes/make-beer)\n* [Make Lock](/wiki/recipes/make-lock)\n* [Make Supermarmalade](/wiki/recipes/make-supermarmalade)\n* [Make Hypermarmalade](/wiki/recipes/make-hypermarmalade)\n\nSee also:\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "0250eadc74b426af35f3483f0bd63d3aa75f041f8b9be952df3424c810e33721",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-beer.md",
      "content": "# Make Beer\n\n\n\n## Ingredients\n\n* [Bee](/wiki/elements/bee)\n* [Bear](/wiki/elements/bear)\n\n## Result\n\n* [Beer](/wiki/elements/beer)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "0073cfd7a4f82313eb7298401386a13f7cba0deb2c9d83a39ea33da10976a2bd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-bridge.md",
      "content": "# Make Bridge\n\n\n\n## Ingredients\n\n* [Monkey Branch](/wiki/elements/monkey-branch)\n* [Monkey Branch](/wiki/elements/monkey-branch)\n\n## Result\n\n* [Bridge](/wiki/elements/bridge)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "3631d6fc9dc6e5ce2bc35aa223fcad862a0cbb409b61c69ce7d6068c19508d18",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-cardano.md",
      "content": "# Make Cardano\n\n\n\n## Ingredients\n\n* [Blockchain](/wiki/elements/blockchain)\n* [Peer Review](/wiki/elements/peer-review)\n\n## Result\n\n* [Cardano](/wiki/elements/cardano)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "77ce6bb64a53bc4c0f627182a00b94e621b236f761867e8adf2581c4f50b14b1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-goldengate.md",
      "content": "# Make Goldengate\n\n\n\n## Ingredients\n\n* [Coin](/wiki/elements/coin)\n* [Bridge](/wiki/elements/bridge)\n\n## Result\n\n* [Golden Gate](/wiki/elements/golden-gate)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "c8ea6e047cab9eb554e18ce6a31180891898b16d17d351619fa80de04e61729f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-hydra.md",
      "content": "# Make Hydra\n\n\n\n## Ingredients\n\n* [Giraffe](/wiki/elements/giraffe)\n* [Giraffe](/wiki/elements/giraffe)\n\n## Result\n\n* [Hydra](/wiki/elements/hydra)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "7c232238ded8534d56238a76696943ec8ed573690021445333042bed2b42ca00",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-hypermarmalade.md",
      "content": "# Make Hypermarmalade\n\n\n\n## Ingredients\n\n* [Super Marmalade](/wiki/elements/super-marmalade)\n* [Super Marmalade](/wiki/elements/super-marmalade)\n\n## Result\n\n* [Hyper Marmalade](/wiki/elements/hyper-marmalade)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "1c8bb95ff34bdf70a4106e3c66b7aee323e6a8a59cd2cdfaf40ccecb97e3bc2e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-lock.md",
      "content": "# Make Lock\n\n\n\n## Ingredients\n\n* [Silver](/wiki/elements/silver)\n* [Silver](/wiki/elements/silver)\n\n## Result\n\n* [Lock](/wiki/elements/lock)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "119d12f030ed5fc31ed9f3fe5fa10c08bc75e39ac3ee1597e122e712a6d74db0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-monkeybranch.md",
      "content": "# Make Monkeybranch\n\n\n\n## Ingredients\n\n* [Monkey](/wiki/elements/monkey)\n* [Hydra](/wiki/elements/hydra)\n\n## Result\n\n* [Monkey Branch](/wiki/elements/monkey-branch)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "99dad9c62f0423aa70d9a2f77b9c370bce2cd4e4ac32b3fbeb2a002de5309b38",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-supermarmalade.md",
      "content": "# Make Supermarmalade\n\n\n\n## Ingredients\n\n* [Marmalade](/wiki/elements/marmalade)\n* [Marmalade](/wiki/elements/marmalade)\n\n## Result\n\n* [Super Marmalade](/wiki/elements/super-marmalade)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "eda916c07bc22c78f1aba1937e9c5ddeb94d916130395ce0f9f0ecac3b51f897",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/docs/wiki/recipes/make-swarm.md",
      "content": "# Make Swarm\n\n\n\n## Ingredients\n\n* [Bee](/wiki/elements/bee)\n* [Bee](/wiki/elements/bee)\n\n## Result\n\n* [Swarm](/wiki/elements/swarm)\n\n## See also\n\n* [Games](/wiki/games)\n* [Elements](/wiki/elements)\n* [Recipes](/wiki/recipes)\n* [Wiki](/wiki/index)\n* [Learn](/learn/index)",
      "contentHash": "36c83f13de262a9a1e3f18158717e789bc30591b47bf9af5e41c48b41b17b9c3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/model/src/items.ts",
      "content": "import { IItem } from './IItem';\nimport { IRecipe } from './IRecipe';\nimport { IGameContent } from './IGameContent';\n\nimport ITEM_MONKEY_CONTRACT_ABI from \"../../../contracts.v1/interfaces/monkey.interface.json\";\nimport ITEM_GIRAFFE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/giraffe.interface.json\";\nimport ITEM_BEE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/bee.interface.json\";\nimport ITEM_COIN_CONTRACT_ABI from \"../../../contracts.v1/interfaces/coin.interface.json\";\nimport ITEM_SWARM_CONTRACT_ABI from \"../../../contracts.v1/interfaces/swarm.interface.json\";\nimport ITEM_HYDRA_CONTRACT_ABI from \"../../../contracts.v1/interfaces/hydra.interface.json\";\nimport ITEM_MONKEY_BRANCH_CONTRACT_ABI from \"../../../contracts.v1/interfaces/monkey_branch.interface.json\";\nimport ITEM_BRIDGE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/bridge.interface.json\";\nimport ITEM_GOLDEN_GATE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/golden_gate.interface.json\";\nimport ITEM_GOLD_CONTRACT_ABI from \"../../../contracts.v1/interfaces/gold.interface.json\";\nimport ITEM_SILVER_CONTRACT_ABI from \"../../../contracts.v1/interfaces/silver.interface.json\";\nimport ITEM_RHODIUM_CONTRACT_ABI from \"../../../contracts.v1/interfaces/rhodium.interface.json\";\nimport ITEM_HIVE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/hive.interface.json\";\nimport ITEM_TRANSACTION_CONTRACT_ABI from \"../../../contracts.v1/interfaces/transaction.interface.json\";\nimport ITEM_BLOCK_CONTRACT_ABI from \"../../../contracts.v1/interfaces/block.interface.json\";\nimport ITEM_BLOCKCHAIN_CONTRACT_ABI from \"../../../contracts.v1/interfaces/blockchain.interface.json\";\nimport ITEM_POLKADOT_CONTRACT_ABI from \"../../../contracts.v1/interfaces/polkadot.interface.json\";\nimport ITEM_PEER_REVIEW_CONTRACT_ABI from \"../../../contracts.v1/interfaces/peer_review.interface.json\";\nimport ITEM_CARDANO_CONTRACT_ABI from \"../../../contracts.v1/interfaces/cardano.interface.json\";\nimport ITEM_BEAR_CONTRACT_ABI from \"../../../contracts.v1/interfaces/bear.interface.json\";\nimport ITEM_BEER_CONTRACT_ABI from \"../../../contracts.v1/interfaces/beer.interface.json\";\nimport ITEM_LOCK_CONTRACT_ABI from \"../../../contracts.v1/interfaces/lock.interface.json\";\nimport ITEM_MARMALADE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/marmalade.interface.json\";\nimport ITEM_SUPER_MARMALADE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/super_marmalade.interface.json\";\nimport ITEM_HYPER_MARMALADE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/hyper_marmalade.interface.json\";\nimport ITEM_WATER_CONTRACT_ABI from \"../../../contracts.v1/interfaces/water.interface.json\";\nimport ITEM_FIRE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/fire.interface.json\";\nimport ITEM_STEAM_CONTRACT_ABI from \"../../../contracts.v1/interfaces/steam.interface.json\";\nimport ITEM_EARTH_CONTRACT_ABI from \"../../../contracts.v1/interfaces/earth.interface.json\";\nimport ITEM_MUD_CONTRACT_ABI from \"../../../contracts.v1/interfaces/mud.interface.json\";\nimport ITEM_LAVA_CONTRACT_ABI from \"../../../contracts.v1/interfaces/lava.interface.json\";\nimport ITEM_WIND_CONTRACT_ABI from \"../../../contracts.v1/interfaces/wind.interface.json\";\nimport ITEM_DUST_CONTRACT_ABI from \"../../../contracts.v1/interfaces/dust.interface.json\";\nimport ITEM_RAIN_CONTRACT_ABI from \"../../../contracts.v1/interfaces/rain.interface.json\";\nimport ITEM_SMOKE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/smoke.interface.json\";\nimport ITEM_GEYSER_CONTRACT_ABI from \"../../../contracts.v1/interfaces/geyser.interface.json\";\nimport ITEM_CLAY_CONTRACT_ABI from \"../../../contracts.v1/interfaces/clay.interface.json\";\nimport ITEM_SAND_CONTRACT_ABI from \"../../../contracts.v1/interfaces/sand.interface.json\";\nimport ITEM_PLANT_CONTRACT_ABI from \"../../../contracts.v1/interfaces/plant.interface.json\";\nimport ITEM_RAINBOW_CONTRACT_ABI from \"../../../contracts.v1/interfaces/rainbow.interface.json\";\nimport ITEM_STORM_CONTRACT_ABI from \"../../../contracts.v1/interfaces/storm.interface.json\";\nimport ITEM_OBSIDIAN_CONTRACT_ABI from \"../../../contracts.v1/interfaces/obsidian.interface.json\";\nimport ITEM_ASH_CONTRACT_ABI from \"../../../contracts.v1/interfaces/ash.interface.json\";\nimport ITEM_VOLCANO_CONTRACT_ABI from \"../../../contracts.v1/interfaces/volcano.interface.json\";\nimport ITEM_SANDSTORM_CONTRACT_ABI from \"../../../contracts.v1/interfaces/sandstorm.interface.json\";\nimport ITEM_CLOUD_CONTRACT_ABI from \"../../../contracts.v1/interfaces/cloud.interface.json\";\nimport ITEM_FOG_CONTRACT_ABI from \"../../../contracts.v1/interfaces/fog.interface.json\";\nimport ITEM_TREE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/tree.interface.json\";\nimport ITEM_FOREST_CONTRACT_ABI from \"../../../contracts.v1/interfaces/forest.interface.json\";\nimport ITEM_SEEDS_CONTRACT_ABI from \"../../../contracts.v1/interfaces/seeds.interface.json\";\nimport ITEM_POTTERY_CONTRACT_ABI from \"../../../contracts.v1/interfaces/pottery.interface.json\";\nimport ITEM_BRICK_CONTRACT_ABI from \"../../../contracts.v1/interfaces/brick.interface.json\";\nimport ITEM_QUICKSAND_CONTRACT_ABI from \"../../../contracts.v1/interfaces/quicksand.interface.json\";\nimport ITEM_GLASS_CONTRACT_ABI from \"../../../contracts.v1/interfaces/glass.interface.json\";\nimport ITEM_DUNE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/dune.interface.json\";\nimport ITEM_CHARCOAL_CONTRACT_ABI from \"../../../contracts.v1/interfaces/charcoal.interface.json\";\nimport ITEM_LEAVES_CONTRACT_ABI from \"../../../contracts.v1/interfaces/leaves.interface.json\";\nimport ITEM_WILDFIRE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/wildfire.interface.json\";\nimport ITEM_JUNGLE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/jungle.interface.json\";\nimport ITEM_FROSTED_GLASS_CONTRACT_ABI from \"../../../contracts.v1/interfaces/frosted_glass.interface.json\";\nimport ITEM_CRYSTAL_CONTRACT_ABI from \"../../../contracts.v1/interfaces/crystal.interface.json\";\nimport ITEM_MAGMA_CONTRACT_ABI from \"../../../contracts.v1/interfaces/magma.interface.json\";\nimport ITEM_ROCK_CONTRACT_ABI from \"../../../contracts.v1/interfaces/rock.interface.json\";\nimport ITEM_SHARD_CONTRACT_ABI from \"../../../contracts.v1/interfaces/shard.interface.json\";\nimport ITEM_PEBBLE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/pebble.interface.json\";\nimport ITEM_MOUNTAIN_CONTRACT_ABI from \"../../../contracts.v1/interfaces/mountain.interface.json\";\nimport ITEM_FERTILIZER_CONTRACT_ABI from \"../../../contracts.v1/interfaces/fertilizer.interface.json\";\nimport ITEM_SOOT_CONTRACT_ABI from \"../../../contracts.v1/interfaces/soot.interface.json\";\nimport ITEM_LIGHTNING_CONTRACT_ABI from \"../../../contracts.v1/interfaces/lightning.interface.json\";\nimport ITEM_MIST_CONTRACT_ABI from \"../../../contracts.v1/interfaces/mist.interface.json\";\nimport ITEM_HAZE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/haze.interface.json\";\nimport ITEM_FLOOD_CONTRACT_ABI from \"../../../contracts.v1/interfaces/flood.interface.json\";\nimport ITEM_LANDSLIDE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/landslide.interface.json\";\nimport ITEM_THUNDER_CONTRACT_ABI from \"../../../contracts.v1/interfaces/thunder.interface.json\";\nimport ITEM_TORNADO_CONTRACT_ABI from \"../../../contracts.v1/interfaces/tornado.interface.json\";\nimport ITEM_GARDEN_CONTRACT_ABI from \"../../../contracts.v1/interfaces/garden.interface.json\";\nimport ITEM_EMBER_CONTRACT_ABI from \"../../../contracts.v1/interfaces/ember.interface.json\";\nimport ITEM_KILN_CONTRACT_ABI from \"../../../contracts.v1/interfaces/kiln.interface.json\";\nimport ITEM_POLLINATION_CONTRACT_ABI from \"../../../contracts.v1/interfaces/pollination.interface.json\";\nimport ITEM_SINKHOLE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/sinkhole.interface.json\";\nimport ITEM_BEACH_CONTRACT_ABI from \"../../../contracts.v1/interfaces/beach.interface.json\";\nimport ITEM_WETSTONE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/wetstone.interface.json\";\nimport ITEM_EROSION_CONTRACT_ABI from \"../../../contracts.v1/interfaces/erosion.interface.json\";\nimport ITEM_BASALT_CONTRACT_ABI from \"../../../contracts.v1/interfaces/basalt.interface.json\";\nimport ITEM_MAGMA_CHAMBER_CONTRACT_ABI from \"../../../contracts.v1/interfaces/magma_chamber.interface.json\";\nimport ITEM_BREEZE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/breeze.interface.json\";\nimport ITEM_WARM_BREEZE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/warm_breeze.interface.json\";\nimport ITEM_SOIL_CONTRACT_ABI from \"../../../contracts.v1/interfaces/soil.interface.json\";\nimport ITEM_CANYON_CONTRACT_ABI from \"../../../contracts.v1/interfaces/canyon.interface.json\";\nimport ITEM_WINDMILL_CONTRACT_ABI from \"../../../contracts.v1/interfaces/windmill.interface.json\";\nimport ITEM_ADOBE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/adobe.interface.json\";\nimport ITEM_WALL_CONTRACT_ABI from \"../../../contracts.v1/interfaces/wall.interface.json\";\nimport ITEM_PUMICE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/pumice.interface.json\";\nimport ITEM_BARBECUE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/barbecue.interface.json\";\nimport ITEM_FARM_CONTRACT_ABI from \"../../../contracts.v1/interfaces/farm.interface.json\";\nimport ITEM_SHARDS_CONTRACT_ABI from \"../../../contracts.v1/interfaces/shards.interface.json\";\nimport ITEM_MOLTEN_GLASS_CONTRACT_ABI from \"../../../contracts.v1/interfaces/molten_glass.interface.json\";\nimport ITEM_PRISM_CONTRACT_ABI from \"../../../contracts.v1/interfaces/prism.interface.json\";\nimport ITEM_SPARKLE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/sparkle.interface.json\";\nimport ITEM_DESERT_CONTRACT_ABI from \"../../../contracts.v1/interfaces/desert.interface.json\";\nimport ITEM_OASIS_CONTRACT_ABI from \"../../../contracts.v1/interfaces/oasis.interface.json\";\nimport ITEM_MIRAGE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/mirage.interface.json\";\nimport ITEM_SAND_DUNE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/sand_dune.interface.json\";\nimport ITEM_DAM_CONTRACT_ABI from \"../../../contracts.v1/interfaces/dam.interface.json\";\nimport ITEM_FIREWALL_CONTRACT_ABI from \"../../../contracts.v1/interfaces/firewall.interface.json\";\nimport ITEM_BARRICADE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/barricade.interface.json\";\nimport ITEM_PLATEAU_CONTRACT_ABI from \"../../../contracts.v1/interfaces/plateau.interface.json\";\nimport ITEM_POND_CONTRACT_ABI from \"../../../contracts.v1/interfaces/pond.interface.json\";\nimport ITEM_AROMAS_CONTRACT_ABI from \"../../../contracts.v1/interfaces/aromas.interface.json\";\nimport ITEM_FLOWER_CONTRACT_ABI from \"../../../contracts.v1/interfaces/flower.interface.json\";\nimport ITEM_SPORE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/spore.interface.json\";\nimport ITEM_SPREAD_CONTRACT_ABI from \"../../../contracts.v1/interfaces/spread.interface.json\";\nimport ITEM_FERTILE_LAND_CONTRACT_ABI from \"../../../contracts.v1/interfaces/fertile_land.interface.json\";\nimport ITEM_WETLAND_CONTRACT_ABI from \"../../../contracts.v1/interfaces/wetland.interface.json\";\nimport ITEM_PEAT_CONTRACT_ABI from \"../../../contracts.v1/interfaces/peat.interface.json\";\nimport ITEM_REEDS_CONTRACT_ABI from \"../../../contracts.v1/interfaces/reeds.interface.json\";\nimport ITEM_VALLEY_CONTRACT_ABI from \"../../../contracts.v1/interfaces/valley.interface.json\";\nimport ITEM_RIVER_CONTRACT_ABI from \"../../../contracts.v1/interfaces/river.interface.json\";\nimport ITEM_SCORCHED_EARTH_CONTRACT_ABI from \"../../../contracts.v1/interfaces/scorched_earth.interface.json\";\nimport ITEM_DELTA_CONTRACT_ABI from \"../../../contracts.v1/interfaces/delta.interface.json\";\nimport ITEM_ESTUARY_CONTRACT_ABI from \"../../../contracts.v1/interfaces/estuary.interface.json\";\nimport ITEM_FIRE_SWAMP_CONTRACT_ABI from \"../../../contracts.v1/interfaces/fire_swamp.interface.json\";\nimport ITEM_RIVERBANK_CONTRACT_ABI from \"../../../contracts.v1/interfaces/riverbank.interface.json\";\nimport ITEM_RAVINE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/ravine.interface.json\";\nimport ITEM_GORGE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/gorge.interface.json\";\nimport ITEM_CHARRED_RAVINE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/charred_ravine.interface.json\";\nimport ITEM_ECHO_CONTRACT_ABI from \"../../../contracts.v1/interfaces/echo.interface.json\";\nimport ITEM_CAVE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/cave.interface.json\";\nimport ITEM_UNDERGROUND_LAKE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/underground_lake.interface.json\";\nimport ITEM_LAVA_CAVE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/lava_cave.interface.json\";\nimport ITEM_WHISPERING_CAVE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/whispering_cave.interface.json\";\nimport ITEM_SUBTERRANEAN_POOL_CONTRACT_ABI from \"../../../contracts.v1/interfaces/subterranean_pool.interface.json\";\nimport ITEM_SPRING_CONTRACT_ABI from \"../../../contracts.v1/interfaces/spring.interface.json\";\nimport ITEM_HOT_SPRING_CONTRACT_ABI from \"../../../contracts.v1/interfaces/hot_spring.interface.json\";\nimport ITEM_GROTTO_CONTRACT_ABI from \"../../../contracts.v1/interfaces/grotto.interface.json\";\nimport ITEM_FOUNTAIN_CONTRACT_ABI from \"../../../contracts.v1/interfaces/fountain.interface.json\";\nimport ITEM_STEAM_VENT_CONTRACT_ABI from \"../../../contracts.v1/interfaces/steam_vent.interface.json\";\nimport ITEM_COOL_BREEZE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/cool_breeze.interface.json\";\nimport ITEM_MONUMENT_CONTRACT_ABI from \"../../../contracts.v1/interfaces/monument.interface.json\";\nimport ITEM_WATERFALL_CONTRACT_ABI from \"../../../contracts.v1/interfaces/waterfall.interface.json\";\nimport ITEM_ETERNAL_FLAME_CONTRACT_ABI from \"../../../contracts.v1/interfaces/eternal_flame.interface.json\";\nimport ITEM_PILLAR_OF_WIND_CONTRACT_ABI from \"../../../contracts.v1/interfaces/pillar_of_wind.interface.json\";\nimport ITEM_STREAM_CONTRACT_ABI from \"../../../contracts.v1/interfaces/stream.interface.json\";\nimport ITEM_ZEPHYR_CONTRACT_ABI from \"../../../contracts.v1/interfaces/zephyr.interface.json\";\nimport ITEM_CREEK_CONTRACT_ABI from \"../../../contracts.v1/interfaces/creek.interface.json\";\nimport ITEM_BROOK_CONTRACT_ABI from \"../../../contracts.v1/interfaces/brook.interface.json\";\nimport ITEM_WHISPER_CONTRACT_ABI from \"../../../contracts.v1/interfaces/whisper.interface.json\";\nimport ITEM_RIVULET_CONTRACT_ABI from \"../../../contracts.v1/interfaces/rivulet.interface.json\";\nimport ITEM_TRIBUTARY_CONTRACT_ABI from \"../../../contracts.v1/interfaces/tributary.interface.json\";\nimport ITEM_MURMUR_CONTRACT_ABI from \"../../../contracts.v1/interfaces/murmur.interface.json\";\nimport ITEM_WATERSHED_CONTRACT_ABI from \"../../../contracts.v1/interfaces/watershed.interface.json\";\nimport ITEM_AQUIFER_CONTRACT_ABI from \"../../../contracts.v1/interfaces/aquifer.interface.json\";\nimport ITEM_PARCHED_EARTH_CONTRACT_ABI from \"../../../contracts.v1/interfaces/parched_earth.interface.json\";\nimport ITEM_FRESH_BREEZE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/fresh_breeze.interface.json\";\nimport ITEM_GROUNDWATER_CONTRACT_ABI from \"../../../contracts.v1/interfaces/groundwater.interface.json\";\nimport ITEM_RESERVOIR_CONTRACT_ABI from \"../../../contracts.v1/interfaces/reservoir.interface.json\";\nimport ITEM_GEOTHERMAL_SPRING_CONTRACT_ABI from \"../../../contracts.v1/interfaces/geothermal_spring.interface.json\";\nimport ITEM_ARTESIAN_WELL_CONTRACT_ABI from \"../../../contracts.v1/interfaces/artesian_well.interface.json\";\nimport ITEM_BASIN_CONTRACT_ABI from \"../../../contracts.v1/interfaces/basin.interface.json\";\nimport ITEM_LAKE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/lake.interface.json\";\nimport ITEM_DRY_BASIN_CONTRACT_ABI from \"../../../contracts.v1/interfaces/dry_basin.interface.json\";\nimport ITEM_DEPRESSION_CONTRACT_ABI from \"../../../contracts.v1/interfaces/depression.interface.json\";\nimport ITEM_ISLAND_CONTRACT_ABI from \"../../../contracts.v1/interfaces/island.interface.json\";\nimport ITEM_LAGOON_CONTRACT_ABI from \"../../../contracts.v1/interfaces/lagoon.interface.json\";\nimport ITEM_WAVE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/wave.interface.json\";\nimport ITEM_REEF_CONTRACT_ABI from \"../../../contracts.v1/interfaces/reef.interface.json\";\nimport ITEM_CORAL_CONTRACT_ABI from \"../../../contracts.v1/interfaces/coral.interface.json\";\nimport ITEM_WHIRL_CONTRACT_ABI from \"../../../contracts.v1/interfaces/whirl.interface.json\";\nimport ITEM_LIMESTONE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/limestone.interface.json\";\nimport ITEM_KARST_CONTRACT_ABI from \"../../../contracts.v1/interfaces/karst.interface.json\";\nimport ITEM_QUICKLIME_CONTRACT_ABI from \"../../../contracts.v1/interfaces/quicklime.interface.json\";\nimport ITEM_BLOWHOLE_CONTRACT_ABI from \"../../../contracts.v1/interfaces/blowhole.interface.json\";\n\nimport GAME_UNIFIERS_CONTRACT_ABI from \"../../../contracts.v1/interfaces/unifiers.interface.json\";\n\nexport const ITEM_MONKEY: IItem = {\n    id: 0,\n    name: 'Monkey',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_MONKEY_CONTRACT_ABI,\n};\nexport const ITEM_GIRAFFE: IItem = {\n    id: 1,\n    name: 'Giraffe',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_GIRAFFE_CONTRACT_ABI,\n};\nexport const ITEM_BEE: IItem = {\n    id: 2,\n    name: 'Bee',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_BEE_CONTRACT_ABI,\n};\nexport const ITEM_COIN: IItem = {\n    id: 3,\n    name: 'Coin',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_COIN_CONTRACT_ABI,\n};\nexport const ITEM_SWARM: IItem = {\n    id: 4,\n    name: 'Swarm',\n    description: 'We need a description here',\n    tier: 2,\n    contractAbi: ITEM_SWARM_CONTRACT_ABI,\n};\nexport const ITEM_HYDRA: IItem = {\n    id: 5,\n    name: 'Hydra',\n    description: 'We need a description here',\n    tier: 2,\n    contractAbi: ITEM_HYDRA_CONTRACT_ABI,\n};\nexport const ITEM_MONKEY_BRANCH: IItem = {\n    id: 6,\n    name: 'Monkey Branch',\n    description: 'We need a description here',\n    tier: 2,\n    contractAbi: ITEM_MONKEY_BRANCH_CONTRACT_ABI,\n};\nexport const ITEM_BRIDGE: IItem = {\n    id: 7,\n    name: 'Bridge',\n    description: 'We need a description here',\n    tier: 2,\n    contractAbi: ITEM_BRIDGE_CONTRACT_ABI,\n};\nexport const ITEM_GOLDEN_GATE: IItem = {\n    id: 8,\n    name: 'Golden Gate',\n    description: 'We need a description here',\n    tier: 2,\n    contractAbi: ITEM_GOLDEN_GATE_CONTRACT_ABI,\n};\nexport const ITEM_GOLD: IItem = {\n    id: 9,\n    name: 'Gold',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_GOLD_CONTRACT_ABI,\n};\nexport const ITEM_SILVER: IItem = {\n    id: 10,\n    name: 'Silver',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SILVER_CONTRACT_ABI,\n};\nexport const ITEM_RHODIUM: IItem = {\n    id: 11,\n    name: 'Rhodium',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_RHODIUM_CONTRACT_ABI,\n};\nexport const ITEM_HIVE: IItem = {\n    id: 12,\n    name: 'Hive',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_HIVE_CONTRACT_ABI,\n};\nexport const ITEM_TRANSACTION: IItem = {\n    id: 13,\n    name: 'Transaction',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_TRANSACTION_CONTRACT_ABI,\n};\nexport const ITEM_BLOCK: IItem = {\n    id: 14,\n    name: 'Block',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_BLOCK_CONTRACT_ABI,\n};\nexport const ITEM_BLOCKCHAIN: IItem = {\n    id: 15,\n    name: 'Blockchain',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_BLOCKCHAIN_CONTRACT_ABI,\n};\nexport const ITEM_POLKADOT: IItem = {\n    id: 16,\n    name: 'Polkadot',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_POLKADOT_CONTRACT_ABI,\n};\nexport const ITEM_PEER_REVIEW: IItem = {\n    id: 17,\n    name: 'Peer Review',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_PEER_REVIEW_CONTRACT_ABI,\n};\nexport const ITEM_CARDANO: IItem = {\n    id: 18,\n    name: 'Cardano',\n    description: 'We need a description here',\n    tier: 2,\n    contractAbi: ITEM_CARDANO_CONTRACT_ABI,\n};\nexport const ITEM_BEAR: IItem = {\n    id: 19,\n    name: 'Bear',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_BEAR_CONTRACT_ABI,\n};\nexport const ITEM_BEER: IItem = {\n    id: 20,\n    name: 'Beer',\n    description: 'We need a description here',\n    tier: 2,\n    contractAbi: ITEM_BEER_CONTRACT_ABI,\n};\nexport const ITEM_LOCK: IItem = {\n    id: 21,\n    name: 'Lock',\n    description: 'We need a description here',\n    tier: 2,\n    contractAbi: ITEM_LOCK_CONTRACT_ABI,\n};\nexport const ITEM_MARMALADE: IItem = {\n    id: 22,\n    name: 'Marmalade',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_MARMALADE_CONTRACT_ABI,\n};\nexport const ITEM_SUPER_MARMALADE: IItem = {\n    id: 23,\n    name: 'Super Marmalade',\n    description: 'We need a description here',\n    tier: 2,\n    contractAbi: ITEM_SUPER_MARMALADE_CONTRACT_ABI,\n};\nexport const ITEM_HYPER_MARMALADE: IItem = {\n    id: 24,\n    name: 'Hyper Marmalade',\n    description: 'We need a description here',\n    tier: 2,\n    contractAbi: ITEM_HYPER_MARMALADE_CONTRACT_ABI,\n};\nexport const ITEM_WATER: IItem = {\n    id: 25,\n    name: 'Water',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_WATER_CONTRACT_ABI,\n};\nexport const ITEM_FIRE: IItem = {\n    id: 26,\n    name: 'Fire',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_FIRE_CONTRACT_ABI,\n};\nexport const ITEM_STEAM: IItem = {\n    id: 27,\n    name: 'Steam',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_STEAM_CONTRACT_ABI,\n};\nexport const ITEM_EARTH: IItem = {\n    id: 28,\n    name: 'Earth',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_EARTH_CONTRACT_ABI,\n};\nexport const ITEM_MUD: IItem = {\n    id: 29,\n    name: 'Mud',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_MUD_CONTRACT_ABI,\n};\nexport const ITEM_LAVA: IItem = {\n    id: 30,\n    name: 'Lava',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_LAVA_CONTRACT_ABI,\n};\nexport const ITEM_WIND: IItem = {\n    id: 31,\n    name: 'Wind',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_WIND_CONTRACT_ABI,\n};\nexport const ITEM_DUST: IItem = {\n    id: 32,\n    name: 'Dust',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_DUST_CONTRACT_ABI,\n};\nexport const ITEM_RAIN: IItem = {\n    id: 33,\n    name: 'Rain',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_RAIN_CONTRACT_ABI,\n};\nexport const ITEM_SMOKE: IItem = {\n    id: 34,\n    name: 'Smoke',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SMOKE_CONTRACT_ABI,\n};\nexport const ITEM_GEYSER: IItem = {\n    id: 35,\n    name: 'Geyser',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_GEYSER_CONTRACT_ABI,\n};\nexport const ITEM_CLAY: IItem = {\n    id: 36,\n    name: 'Clay',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_CLAY_CONTRACT_ABI,\n};\nexport const ITEM_SAND: IItem = {\n    id: 37,\n    name: 'Sand',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SAND_CONTRACT_ABI,\n};\nexport const ITEM_PLANT: IItem = {\n    id: 38,\n    name: 'Plant',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_PLANT_CONTRACT_ABI,\n};\nexport const ITEM_RAINBOW: IItem = {\n    id: 39,\n    name: 'Rainbow',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_RAINBOW_CONTRACT_ABI,\n};\nexport const ITEM_STORM: IItem = {\n    id: 40,\n    name: 'Storm',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_STORM_CONTRACT_ABI,\n};\nexport const ITEM_OBSIDIAN: IItem = {\n    id: 41,\n    name: 'Obsidian',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_OBSIDIAN_CONTRACT_ABI,\n};\nexport const ITEM_ASH: IItem = {\n    id: 42,\n    name: 'Ash',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_ASH_CONTRACT_ABI,\n};\nexport const ITEM_VOLCANO: IItem = {\n    id: 43,\n    name: 'Volcano',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_VOLCANO_CONTRACT_ABI,\n};\nexport const ITEM_SANDSTORM: IItem = {\n    id: 44,\n    name: 'Sandstorm',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SANDSTORM_CONTRACT_ABI,\n};\nexport const ITEM_CLOUD: IItem = {\n    id: 45,\n    name: 'Cloud',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_CLOUD_CONTRACT_ABI,\n};\nexport const ITEM_FOG: IItem = {\n    id: 46,\n    name: 'Fog',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_FOG_CONTRACT_ABI,\n};\nexport const ITEM_TREE: IItem = {\n    id: 47,\n    name: 'Tree',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_TREE_CONTRACT_ABI,\n};\nexport const ITEM_FOREST: IItem = {\n    id: 48,\n    name: 'Forest',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_FOREST_CONTRACT_ABI,\n};\nexport const ITEM_SEEDS: IItem = {\n    id: 49,\n    name: 'Seeds',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SEEDS_CONTRACT_ABI,\n};\nexport const ITEM_POTTERY: IItem = {\n    id: 50,\n    name: 'Pottery',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_POTTERY_CONTRACT_ABI,\n};\nexport const ITEM_BRICK: IItem = {\n    id: 51,\n    name: 'Brick',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_BRICK_CONTRACT_ABI,\n};\nexport const ITEM_QUICKSAND: IItem = {\n    id: 52,\n    name: 'Quicksand',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_QUICKSAND_CONTRACT_ABI,\n};\nexport const ITEM_GLASS: IItem = {\n    id: 53,\n    name: 'Glass',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_GLASS_CONTRACT_ABI,\n};\nexport const ITEM_DUNE: IItem = {\n    id: 54,\n    name: 'Dune',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_DUNE_CONTRACT_ABI,\n};\nexport const ITEM_CHARCOAL: IItem = {\n    id: 55,\n    name: 'Charcoal',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_CHARCOAL_CONTRACT_ABI,\n};\nexport const ITEM_LEAVES: IItem = {\n    id: 56,\n    name: 'Leaves',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_LEAVES_CONTRACT_ABI,\n};\nexport const ITEM_WILDFIRE: IItem = {\n    id: 57,\n    name: 'Wildfire',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_WILDFIRE_CONTRACT_ABI,\n};\nexport const ITEM_JUNGLE: IItem = {\n    id: 58,\n    name: 'Jungle',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_JUNGLE_CONTRACT_ABI,\n};\nexport const ITEM_FROSTED_GLASS: IItem = {\n    id: 59,\n    name: 'Frosted Glass',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_FROSTED_GLASS_CONTRACT_ABI,\n};\nexport const ITEM_CRYSTAL: IItem = {\n    id: 60,\n    name: 'Crystal',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_CRYSTAL_CONTRACT_ABI,\n};\nexport const ITEM_MAGMA: IItem = {\n    id: 61,\n    name: 'Magma',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_MAGMA_CONTRACT_ABI,\n};\nexport const ITEM_ROCK: IItem = {\n    id: 62,\n    name: 'Rock',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_ROCK_CONTRACT_ABI,\n};\nexport const ITEM_SHARD: IItem = {\n    id: 63,\n    name: 'Shard',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SHARD_CONTRACT_ABI,\n};\nexport const ITEM_PEBBLE: IItem = {\n    id: 64,\n    name: 'Pebble',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_PEBBLE_CONTRACT_ABI,\n};\nexport const ITEM_MOUNTAIN: IItem = {\n    id: 65,\n    name: 'Mountain',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_MOUNTAIN_CONTRACT_ABI,\n};\nexport const ITEM_FERTILIZER: IItem = {\n    id: 66,\n    name: 'Fertilizer',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_FERTILIZER_CONTRACT_ABI,\n};\nexport const ITEM_SOOT: IItem = {\n    id: 67,\n    name: 'Soot',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SOOT_CONTRACT_ABI,\n};\nexport const ITEM_LIGHTNING: IItem = {\n    id: 68,\n    name: 'Lightning',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_LIGHTNING_CONTRACT_ABI,\n};\nexport const ITEM_MIST: IItem = {\n    id: 69,\n    name: 'Mist',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_MIST_CONTRACT_ABI,\n};\nexport const ITEM_HAZE: IItem = {\n    id: 70,\n    name: 'Haze',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_HAZE_CONTRACT_ABI,\n};\nexport const ITEM_FLOOD: IItem = {\n    id: 71,\n    name: 'Flood',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_FLOOD_CONTRACT_ABI,\n};\nexport const ITEM_LANDSLIDE: IItem = {\n    id: 72,\n    name: 'Landslide',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_LANDSLIDE_CONTRACT_ABI,\n};\nexport const ITEM_THUNDER: IItem = {\n    id: 73,\n    name: 'Thunder',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_THUNDER_CONTRACT_ABI,\n};\nexport const ITEM_TORNADO: IItem = {\n    id: 74,\n    name: 'Tornado',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_TORNADO_CONTRACT_ABI,\n};\nexport const ITEM_GARDEN: IItem = {\n    id: 75,\n    name: 'Garden',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_GARDEN_CONTRACT_ABI,\n};\nexport const ITEM_EMBER: IItem = {\n    id: 76,\n    name: 'Ember',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_EMBER_CONTRACT_ABI,\n};\nexport const ITEM_KILN: IItem = {\n    id: 77,\n    name: 'Kiln',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_KILN_CONTRACT_ABI,\n};\nexport const ITEM_POLLINATION: IItem = {\n    id: 78,\n    name: 'Pollination',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_POLLINATION_CONTRACT_ABI,\n};\nexport const ITEM_SINKHOLE: IItem = {\n    id: 79,\n    name: 'Sinkhole',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SINKHOLE_CONTRACT_ABI,\n};\nexport const ITEM_BEACH: IItem = {\n    id: 80,\n    name: 'Beach',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_BEACH_CONTRACT_ABI,\n};\nexport const ITEM_WETSTONE: IItem = {\n    id: 81,\n    name: 'Wetstone',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_WETSTONE_CONTRACT_ABI,\n};\nexport const ITEM_EROSION: IItem = {\n    id: 82,\n    name: 'Erosion',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_EROSION_CONTRACT_ABI,\n};\nexport const ITEM_BASALT: IItem = {\n    id: 83,\n    name: 'Basalt',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_BASALT_CONTRACT_ABI,\n};\nexport const ITEM_MAGMA_CHAMBER: IItem = {\n    id: 84,\n    name: 'Magma Chamber',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_MAGMA_CHAMBER_CONTRACT_ABI,\n};\nexport const ITEM_BREEZE: IItem = {\n    id: 85,\n    name: 'Breeze',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_BREEZE_CONTRACT_ABI,\n};\nexport const ITEM_WARM_BREEZE: IItem = {\n    id: 86,\n    name: 'Warm Breeze',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_WARM_BREEZE_CONTRACT_ABI,\n};\nexport const ITEM_SOIL: IItem = {\n    id: 87,\n    name: 'Soil',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SOIL_CONTRACT_ABI,\n};\nexport const ITEM_CANYON: IItem = {\n    id: 88,\n    name: 'Canyon',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_CANYON_CONTRACT_ABI,\n};\nexport const ITEM_WINDMILL: IItem = {\n    id: 89,\n    name: 'Windmill',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_WINDMILL_CONTRACT_ABI,\n};\nexport const ITEM_ADOBE: IItem = {\n    id: 90,\n    name: 'Adobe',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_ADOBE_CONTRACT_ABI,\n};\nexport const ITEM_WALL: IItem = {\n    id: 91,\n    name: 'Wall',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_WALL_CONTRACT_ABI,\n};\nexport const ITEM_PUMICE: IItem = {\n    id: 92,\n    name: 'Pumice',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_PUMICE_CONTRACT_ABI,\n};\nexport const ITEM_BARBECUE: IItem = {\n    id: 93,\n    name: 'Barbecue',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_BARBECUE_CONTRACT_ABI,\n};\nexport const ITEM_FARM: IItem = {\n    id: 94,\n    name: 'Farm',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_FARM_CONTRACT_ABI,\n};\nexport const ITEM_SHARDS: IItem = {\n    id: 95,\n    name: 'Shards',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SHARDS_CONTRACT_ABI,\n};\nexport const ITEM_MOLTEN_GLASS: IItem = {\n    id: 96,\n    name: 'Molten Glass',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_MOLTEN_GLASS_CONTRACT_ABI,\n};\nexport const ITEM_PRISM: IItem = {\n    id: 97,\n    name: 'Prism',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_PRISM_CONTRACT_ABI,\n};\nexport const ITEM_SPARKLE: IItem = {\n    id: 98,\n    name: 'Sparkle',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SPARKLE_CONTRACT_ABI,\n};\nexport const ITEM_DESERT: IItem = {\n    id: 99,\n    name: 'Desert',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_DESERT_CONTRACT_ABI,\n};\nexport const ITEM_OASIS: IItem = {\n    id: 100,\n    name: 'Oasis',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_OASIS_CONTRACT_ABI,\n};\nexport const ITEM_MIRAGE: IItem = {\n    id: 101,\n    name: 'Mirage',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_MIRAGE_CONTRACT_ABI,\n};\nexport const ITEM_SAND_DUNE: IItem = {\n    id: 102,\n    name: 'Sand Dune',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SAND_DUNE_CONTRACT_ABI,\n};\nexport const ITEM_DAM: IItem = {\n    id: 103,\n    name: 'Dam',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_DAM_CONTRACT_ABI,\n};\nexport const ITEM_FIREWALL: IItem = {\n    id: 104,\n    name: 'Firewall',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_FIREWALL_CONTRACT_ABI,\n};\nexport const ITEM_BARRICADE: IItem = {\n    id: 105,\n    name: 'Barricade',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_BARRICADE_CONTRACT_ABI,\n};\nexport const ITEM_PLATEAU: IItem = {\n    id: 106,\n    name: 'Plateau',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_PLATEAU_CONTRACT_ABI,\n};\nexport const ITEM_POND: IItem = {\n    id: 107,\n    name: 'Pond',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_POND_CONTRACT_ABI,\n};\nexport const ITEM_AROMAS: IItem = {\n    id: 108,\n    name: 'Aromas',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_AROMAS_CONTRACT_ABI,\n};\nexport const ITEM_FLOWER: IItem = {\n    id: 109,\n    name: 'Flower',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_FLOWER_CONTRACT_ABI,\n};\nexport const ITEM_SPORE: IItem = {\n    id: 110,\n    name: 'Spore',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SPORE_CONTRACT_ABI,\n};\nexport const ITEM_SPREAD: IItem = {\n    id: 111,\n    name: 'Spread',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SPREAD_CONTRACT_ABI,\n};\nexport const ITEM_FERTILE_LAND: IItem = {\n    id: 112,\n    name: 'Fertile Land',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_FERTILE_LAND_CONTRACT_ABI,\n};\nexport const ITEM_WETLAND: IItem = {\n    id: 113,\n    name: 'Wetland',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_WETLAND_CONTRACT_ABI,\n};\nexport const ITEM_PEAT: IItem = {\n    id: 114,\n    name: 'Peat',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_PEAT_CONTRACT_ABI,\n};\nexport const ITEM_REEDS: IItem = {\n    id: 115,\n    name: 'Reeds',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_REEDS_CONTRACT_ABI,\n};\nexport const ITEM_VALLEY: IItem = {\n    id: 116,\n    name: 'Valley',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_VALLEY_CONTRACT_ABI,\n};\nexport const ITEM_RIVER: IItem = {\n    id: 117,\n    name: 'River',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_RIVER_CONTRACT_ABI,\n};\nexport const ITEM_SCORCHED_EARTH: IItem = {\n    id: 118,\n    name: 'Scorched Earth',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SCORCHED_EARTH_CONTRACT_ABI,\n};\nexport const ITEM_DELTA: IItem = {\n    id: 119,\n    name: 'Delta',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_DELTA_CONTRACT_ABI,\n};\nexport const ITEM_ESTUARY: IItem = {\n    id: 120,\n    name: 'Estuary',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_ESTUARY_CONTRACT_ABI,\n};\nexport const ITEM_FIRE_SWAMP: IItem = {\n    id: 121,\n    name: 'Fire Swamp',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_FIRE_SWAMP_CONTRACT_ABI,\n};\nexport const ITEM_RIVERBANK: IItem = {\n    id: 122,\n    name: 'Riverbank',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_RIVERBANK_CONTRACT_ABI,\n};\nexport const ITEM_RAVINE: IItem = {\n    id: 123,\n    name: 'Ravine',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_RAVINE_CONTRACT_ABI,\n};\nexport const ITEM_GORGE: IItem = {\n    id: 124,\n    name: 'Gorge',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_GORGE_CONTRACT_ABI,\n};\nexport const ITEM_CHARRED_RAVINE: IItem = {\n    id: 125,\n    name: 'Charred Ravine',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_CHARRED_RAVINE_CONTRACT_ABI,\n};\nexport const ITEM_ECHO: IItem = {\n    id: 126,\n    name: 'Echo',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_ECHO_CONTRACT_ABI,\n};\nexport const ITEM_CAVE: IItem = {\n    id: 127,\n    name: 'Cave',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_CAVE_CONTRACT_ABI,\n};\nexport const ITEM_UNDERGROUND_LAKE: IItem = {\n    id: 128,\n    name: 'Underground Lake',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_UNDERGROUND_LAKE_CONTRACT_ABI,\n};\nexport const ITEM_LAVA_CAVE: IItem = {\n    id: 129,\n    name: 'Lava Cave',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_LAVA_CAVE_CONTRACT_ABI,\n};\nexport const ITEM_WHISPERING_CAVE: IItem = {\n    id: 130,\n    name: 'Whispering Cave',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_WHISPERING_CAVE_CONTRACT_ABI,\n};\nexport const ITEM_SUBTERRANEAN_POOL: IItem = {\n    id: 131,\n    name: 'Subterranean Pool',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SUBTERRANEAN_POOL_CONTRACT_ABI,\n};\nexport const ITEM_SPRING: IItem = {\n    id: 132,\n    name: 'Spring',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_SPRING_CONTRACT_ABI,\n};\nexport const ITEM_HOT_SPRING: IItem = {\n    id: 133,\n    name: 'Hot Spring',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_HOT_SPRING_CONTRACT_ABI,\n};\nexport const ITEM_GROTTO: IItem = {\n    id: 134,\n    name: 'Grotto',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_GROTTO_CONTRACT_ABI,\n};\nexport const ITEM_FOUNTAIN: IItem = {\n    id: 135,\n    name: 'Fountain',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_FOUNTAIN_CONTRACT_ABI,\n};\nexport const ITEM_STEAM_VENT: IItem = {\n    id: 136,\n    name: 'Steam Vent',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_STEAM_VENT_CONTRACT_ABI,\n};\nexport const ITEM_COOL_BREEZE: IItem = {\n    id: 137,\n    name: 'Cool Breeze',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_COOL_BREEZE_CONTRACT_ABI,\n};\nexport const ITEM_MONUMENT: IItem = {\n    id: 138,\n    name: 'Monument',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_MONUMENT_CONTRACT_ABI,\n};\nexport const ITEM_WATERFALL: IItem = {\n    id: 139,\n    name: 'Waterfall',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_WATERFALL_CONTRACT_ABI,\n};\nexport const ITEM_ETERNAL_FLAME: IItem = {\n    id: 140,\n    name: 'Eternal Flame',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_ETERNAL_FLAME_CONTRACT_ABI,\n};\nexport const ITEM_PILLAR_OF_WIND: IItem = {\n    id: 141,\n    name: 'Pillar Of Wind',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_PILLAR_OF_WIND_CONTRACT_ABI,\n};\nexport const ITEM_STREAM: IItem = {\n    id: 142,\n    name: 'Stream',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_STREAM_CONTRACT_ABI,\n};\nexport const ITEM_ZEPHYR: IItem = {\n    id: 143,\n    name: 'Zephyr',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_ZEPHYR_CONTRACT_ABI,\n};\nexport const ITEM_CREEK: IItem = {\n    id: 144,\n    name: 'Creek',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_CREEK_CONTRACT_ABI,\n};\nexport const ITEM_BROOK: IItem = {\n    id: 145,\n    name: 'Brook',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_BROOK_CONTRACT_ABI,\n};\nexport const ITEM_WHISPER: IItem = {\n    id: 146,\n    name: 'Whisper',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_WHISPER_CONTRACT_ABI,\n};\nexport const ITEM_RIVULET: IItem = {\n    id: 147,\n    name: 'Rivulet',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_RIVULET_CONTRACT_ABI,\n};\nexport const ITEM_TRIBUTARY: IItem = {\n    id: 148,\n    name: 'Tributary',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_TRIBUTARY_CONTRACT_ABI,\n};\nexport const ITEM_MURMUR: IItem = {\n    id: 149,\n    name: 'Murmur',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_MURMUR_CONTRACT_ABI,\n};\nexport const ITEM_WATERSHED: IItem = {\n    id: 150,\n    name: 'Watershed',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_WATERSHED_CONTRACT_ABI,\n};\nexport const ITEM_AQUIFER: IItem = {\n    id: 151,\n    name: 'Aquifer',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_AQUIFER_CONTRACT_ABI,\n};\nexport const ITEM_PARCHED_EARTH: IItem = {\n    id: 152,\n    name: 'Parched Earth',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_PARCHED_EARTH_CONTRACT_ABI,\n};\nexport const ITEM_FRESH_BREEZE: IItem = {\n    id: 153,\n    name: 'Fresh Breeze',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_FRESH_BREEZE_CONTRACT_ABI,\n};\nexport const ITEM_GROUNDWATER: IItem = {\n    id: 154,\n    name: 'Groundwater',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_GROUNDWATER_CONTRACT_ABI,\n};\nexport const ITEM_RESERVOIR: IItem = {\n    id: 155,\n    name: 'Reservoir',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_RESERVOIR_CONTRACT_ABI,\n};\nexport const ITEM_GEOTHERMAL_SPRING: IItem = {\n    id: 156,\n    name: 'Geothermal Spring',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_GEOTHERMAL_SPRING_CONTRACT_ABI,\n};\nexport const ITEM_ARTESIAN_WELL: IItem = {\n    id: 157,\n    name: 'Artesian Well',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_ARTESIAN_WELL_CONTRACT_ABI,\n};\nexport const ITEM_BASIN: IItem = {\n    id: 158,\n    name: 'Basin',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_BASIN_CONTRACT_ABI,\n};\nexport const ITEM_LAKE: IItem = {\n    id: 159,\n    name: 'Lake',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_LAKE_CONTRACT_ABI,\n};\nexport const ITEM_DRY_BASIN: IItem = {\n    id: 160,\n    name: 'Dry Basin',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_DRY_BASIN_CONTRACT_ABI,\n};\nexport const ITEM_DEPRESSION: IItem = {\n    id: 161,\n    name: 'Depression',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_DEPRESSION_CONTRACT_ABI,\n};\nexport const ITEM_ISLAND: IItem = {\n    id: 162,\n    name: 'Island',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_ISLAND_CONTRACT_ABI,\n};\nexport const ITEM_LAGOON: IItem = {\n    id: 163,\n    name: 'Lagoon',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_LAGOON_CONTRACT_ABI,\n};\nexport const ITEM_WAVE: IItem = {\n    id: 164,\n    name: 'Wave',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_WAVE_CONTRACT_ABI,\n};\nexport const ITEM_REEF: IItem = {\n    id: 165,\n    name: 'Reef',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_REEF_CONTRACT_ABI,\n};\nexport const ITEM_CORAL: IItem = {\n    id: 166,\n    name: 'Coral',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_CORAL_CONTRACT_ABI,\n};\nexport const ITEM_WHIRL: IItem = {\n    id: 167,\n    name: 'Whirl',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_WHIRL_CONTRACT_ABI,\n};\nexport const ITEM_LIMESTONE: IItem = {\n    id: 168,\n    name: 'Limestone',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_LIMESTONE_CONTRACT_ABI,\n};\nexport const ITEM_KARST: IItem = {\n    id: 169,\n    name: 'Karst',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_KARST_CONTRACT_ABI,\n};\nexport const ITEM_QUICKLIME: IItem = {\n    id: 170,\n    name: 'Quicklime',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_QUICKLIME_CONTRACT_ABI,\n};\nexport const ITEM_BLOWHOLE: IItem = {\n    id: 171,\n    name: 'Blowhole',\n    description: 'We need a description here',\n    tier: 1,\n    contractAbi: ITEM_BLOWHOLE_CONTRACT_ABI,\n};\n\nexport const ALL_ITEMS: IItem[] = [\n    ITEM_MONKEY,\n    ITEM_GIRAFFE,\n    ITEM_BEE,\n    ITEM_COIN,\n    ITEM_SWARM,\n    ITEM_HYDRA,\n    ITEM_MONKEY_BRANCH,\n    ITEM_BRIDGE,\n    ITEM_GOLDEN_GATE,\n    ITEM_GOLD,\n    ITEM_SILVER,\n    ITEM_RHODIUM,\n    ITEM_HIVE,\n    ITEM_TRANSACTION,\n    ITEM_BLOCK,\n    ITEM_BLOCKCHAIN,\n    ITEM_POLKADOT,\n    ITEM_PEER_REVIEW,\n    ITEM_CARDANO,\n    ITEM_BEAR,\n    ITEM_BEER,\n    ITEM_LOCK,\n    ITEM_MARMALADE,\n    ITEM_SUPER_MARMALADE,\n    ITEM_HYPER_MARMALADE,\n    ITEM_WATER,\n    ITEM_FIRE,\n    ITEM_STEAM,\n    ITEM_EARTH,\n    ITEM_MUD,\n    ITEM_LAVA,\n    ITEM_WIND,\n    ITEM_DUST,\n    ITEM_RAIN,\n    ITEM_SMOKE,\n    ITEM_GEYSER,\n    ITEM_CLAY,\n    ITEM_SAND,\n    ITEM_PLANT,\n    ITEM_RAINBOW,\n    ITEM_STORM,\n    ITEM_OBSIDIAN,\n    ITEM_ASH,\n    ITEM_VOLCANO,\n    ITEM_SANDSTORM,\n    ITEM_CLOUD,\n    ITEM_FOG,\n    ITEM_TREE,\n    ITEM_FOREST,\n    ITEM_SEEDS,\n    ITEM_POTTERY,\n    ITEM_BRICK,\n    ITEM_QUICKSAND,\n    ITEM_GLASS,\n    ITEM_DUNE,\n    ITEM_CHARCOAL,\n    ITEM_LEAVES,\n    ITEM_WILDFIRE,\n    ITEM_JUNGLE,\n    ITEM_FROSTED_GLASS,\n    ITEM_CRYSTAL,\n    ITEM_MAGMA,\n    ITEM_ROCK,\n    ITEM_SHARD,\n    ITEM_PEBBLE,\n    ITEM_MOUNTAIN,\n    ITEM_FERTILIZER,\n    ITEM_SOOT,\n    ITEM_LIGHTNING,\n    ITEM_MIST,\n    ITEM_HAZE,\n    ITEM_FLOOD,\n    ITEM_LANDSLIDE,\n    ITEM_THUNDER,\n    ITEM_TORNADO,\n    ITEM_GARDEN,\n    ITEM_EMBER,\n    ITEM_KILN,\n    ITEM_POLLINATION,\n    ITEM_SINKHOLE,\n    ITEM_BEACH,\n    ITEM_WETSTONE,\n    ITEM_EROSION,\n    ITEM_BASALT,\n    ITEM_MAGMA_CHAMBER,\n    ITEM_BREEZE,\n    ITEM_WARM_BREEZE,\n    ITEM_SOIL,\n    ITEM_CANYON,\n    ITEM_WINDMILL,\n    ITEM_ADOBE,\n    ITEM_WALL,\n    ITEM_PUMICE,\n    ITEM_BARBECUE,\n    ITEM_FARM,\n    ITEM_SHARDS,\n    ITEM_MOLTEN_GLASS,\n    ITEM_PRISM,\n    ITEM_SPARKLE,\n    ITEM_DESERT,\n    ITEM_OASIS,\n    ITEM_MIRAGE,\n    ITEM_SAND_DUNE,\n    ITEM_DAM,\n    ITEM_FIREWALL,\n    ITEM_BARRICADE,\n    ITEM_PLATEAU,\n    ITEM_POND,\n    ITEM_AROMAS,\n    ITEM_FLOWER,\n    ITEM_SPORE,\n    ITEM_SPREAD,\n    ITEM_FERTILE_LAND,\n    ITEM_WETLAND,\n    ITEM_PEAT,\n    ITEM_REEDS,\n    ITEM_VALLEY,\n    ITEM_RIVER,\n    ITEM_SCORCHED_EARTH,\n    ITEM_DELTA,\n    ITEM_ESTUARY,\n    ITEM_FIRE_SWAMP,\n    ITEM_RIVERBANK,\n    ITEM_RAVINE,\n    ITEM_GORGE,\n    ITEM_CHARRED_RAVINE,\n    ITEM_ECHO,\n    ITEM_CAVE,\n    ITEM_UNDERGROUND_LAKE,\n    ITEM_LAVA_CAVE,\n    ITEM_WHISPERING_CAVE,\n    ITEM_SUBTERRANEAN_POOL,\n    ITEM_SPRING,\n    ITEM_HOT_SPRING,\n    ITEM_GROTTO,\n    ITEM_FOUNTAIN,\n    ITEM_STEAM_VENT,\n    ITEM_COOL_BREEZE,\n    ITEM_MONUMENT,\n    ITEM_WATERFALL,\n    ITEM_ETERNAL_FLAME,\n    ITEM_PILLAR_OF_WIND,\n    ITEM_STREAM,\n    ITEM_ZEPHYR,\n    ITEM_CREEK,\n    ITEM_BROOK,\n    ITEM_WHISPER,\n    ITEM_RIVULET,\n    ITEM_TRIBUTARY,\n    ITEM_MURMUR,\n    ITEM_WATERSHED,\n    ITEM_AQUIFER,\n    ITEM_PARCHED_EARTH,\n    ITEM_FRESH_BREEZE,\n    ITEM_GROUNDWATER,\n    ITEM_RESERVOIR,\n    ITEM_GEOTHERMAL_SPRING,\n    ITEM_ARTESIAN_WELL,\n    ITEM_BASIN,\n    ITEM_LAKE,\n    ITEM_DRY_BASIN,\n    ITEM_DEPRESSION,\n    ITEM_ISLAND,\n    ITEM_LAGOON,\n    ITEM_WAVE,\n    ITEM_REEF,\n    ITEM_CORAL,\n    ITEM_WHIRL,\n    ITEM_LIMESTONE,\n    ITEM_KARST,\n    ITEM_QUICKLIME,\n    ITEM_BLOWHOLE,\n];\n\nexport const RECIPE_MAKE_SWARM: IRecipe = {\n    id: 0,\n    a: ITEM_BEE,\n    b: ITEM_BEE,\n    result: ITEM_SWARM,\n};\nexport const RECIPE_MAKE_HYDRA: IRecipe = {\n    id: 1,\n    a: ITEM_GIRAFFE,\n    b: ITEM_GIRAFFE,\n    result: ITEM_HYDRA,\n};\nexport const RECIPE_MAKE_MONKEYBRANCH: IRecipe = {\n    id: 2,\n    a: ITEM_MONKEY,\n    b: ITEM_HYDRA,\n    result: ITEM_MONKEY_BRANCH,\n};\nexport const RECIPE_MAKE_BRIDGE: IRecipe = {\n    id: 3,\n    a: ITEM_MONKEY_BRANCH,\n    b: ITEM_MONKEY_BRANCH,\n    result: ITEM_BRIDGE,\n};\nexport const RECIPE_MAKE_GOLDENGATE: IRecipe = {\n    id: 4,\n    a: ITEM_COIN,\n    b: ITEM_BRIDGE,\n    result: ITEM_GOLDEN_GATE,\n};\nexport const RECIPE_MAKE_CARDANO: IRecipe = {\n    id: 5,\n    a: ITEM_BLOCKCHAIN,\n    b: ITEM_PEER_REVIEW,\n    result: ITEM_CARDANO,\n};\nexport const RECIPE_MAKE_BEER: IRecipe = {\n    id: 6,\n    a: ITEM_BEE,\n    b: ITEM_BEAR,\n    result: ITEM_BEER,\n};\nexport const RECIPE_MAKE_LOCK: IRecipe = {\n    id: 7,\n    a: ITEM_SILVER,\n    b: ITEM_SILVER,\n    result: ITEM_LOCK,\n};\nexport const RECIPE_MAKE_SUPERMARMALADE: IRecipe = {\n    id: 8,\n    a: ITEM_MARMALADE,\n    b: ITEM_MARMALADE,\n    result: ITEM_SUPER_MARMALADE,\n};\nexport const RECIPE_MAKE_HYPERMARMALADE: IRecipe = {\n    id: 9,\n    a: ITEM_SUPER_MARMALADE,\n    b: ITEM_SUPER_MARMALADE,\n    result: ITEM_HYPER_MARMALADE,\n};\n\nexport const ALL_RECIPES: IRecipe[] = [\n    RECIPE_MAKE_SWARM,\n    RECIPE_MAKE_HYDRA,\n    RECIPE_MAKE_MONKEYBRANCH,\n    RECIPE_MAKE_BRIDGE,\n    RECIPE_MAKE_GOLDENGATE,\n    RECIPE_MAKE_CARDANO,\n    RECIPE_MAKE_BEER,\n    RECIPE_MAKE_LOCK,\n    RECIPE_MAKE_SUPERMARMALADE,\n    RECIPE_MAKE_HYPERMARMALADE,\n];\n\nexport const GAME_UNIFIERS_ITEMS: Array<IItem> = [\n    ITEM_MONKEY,\n    ITEM_GIRAFFE,\n    ITEM_BEE,\n    ITEM_COIN,\n    ITEM_SWARM,\n    ITEM_HYDRA,\n    ITEM_MONKEY_BRANCH,\n    ITEM_BRIDGE,\n    ITEM_GOLDEN_GATE,\n    ITEM_GOLD,\n    ITEM_SILVER,\n    ITEM_RHODIUM,\n    ITEM_HIVE,\n    ITEM_TRANSACTION,\n    ITEM_BLOCK,\n    ITEM_BLOCKCHAIN,\n    ITEM_POLKADOT,\n    ITEM_PEER_REVIEW,\n    ITEM_CARDANO,\n    ITEM_BEAR,\n    ITEM_BEER,\n    ITEM_LOCK,\n    ITEM_MARMALADE,\n    ITEM_SUPER_MARMALADE,\n    ITEM_HYPER_MARMALADE,\n];\nexport const GAME_UNIFIERS_RECIPES: Array<IRecipe> = [\n    RECIPE_MAKE_SWARM,\n    RECIPE_MAKE_HYDRA,\n    RECIPE_MAKE_MONKEYBRANCH,\n    RECIPE_MAKE_BRIDGE,\n    RECIPE_MAKE_GOLDENGATE,\n    RECIPE_MAKE_CARDANO,\n    RECIPE_MAKE_BEER,\n    RECIPE_MAKE_LOCK,\n    RECIPE_MAKE_SUPERMARMALADE,\n    RECIPE_MAKE_HYPERMARMALADE,\n];\nexport const GAME_UNIFIERS: IGameContent = {\n    name: \"Unifiers\",\n    description: \"A game created with the help of the Unifiers group\",\n    items: GAME_UNIFIERS_ITEMS,\n    recipes: GAME_UNIFIERS_RECIPES,\n    contractAbi: GAME_UNIFIERS_CONTRACT_ABI,\n};\nexport const ALL_GAMES: Array<IGameContent> = [\n    GAME_UNIFIERS,\n];",
      "contentHash": "193779610ae6ee9412d865f53cf505e9cca38a2c069cbe98431afd8dc5e05777",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IAdobeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Adobe' */\nexport interface IAdobeContract extends IElementContract {\n}",
      "contentHash": "0c6d59bd7d60049dbc6c07f3a6031ce75840a89209347ac181f875eb18e578b1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IAquiferContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Aquifer' */\nexport interface IAquiferContract extends IElementContract {\n}",
      "contentHash": "8622bc73813c1826336521be557ccb6f640e2a89e570444770a8b98059e7d2f5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IAromasContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Aromas' */\nexport interface IAromasContract extends IElementContract {\n}",
      "contentHash": "302668e7396138e70d3051c711d17b2bd18126d5d2fd14ee7d087e257ee17f3d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IArtesianWellContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Artesian Well' */\nexport interface IArtesianWellContract extends IElementContract {\n}",
      "contentHash": "0a448604c8042ba83198545fa55e7394d2ba4d8a674d5d528fcd210dcd8a306d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IAshContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Ash' */\nexport interface IAshContract extends IElementContract {\n}",
      "contentHash": "3433149198e9d5e5bf1cb2781cb49dbe5092f2ec8bd76260563e1acdeb3c24f6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBarbecueContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Barbecue' */\nexport interface IBarbecueContract extends IElementContract {\n}",
      "contentHash": "897e90bd5101f3117a759753da45230be6daebdf565369da3c95f8d3e4c44edc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBarricadeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Barricade' */\nexport interface IBarricadeContract extends IElementContract {\n}",
      "contentHash": "bbff65d37252d045de653a745318fbd6366399f38a99e3da6d987a0fa41f5b5f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBasaltContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Basalt' */\nexport interface IBasaltContract extends IElementContract {\n}",
      "contentHash": "b39130fdb93237fad2b477b9afb0bf703c595a73d034888b7b6ad1ecd6ceca17",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBasinContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Basin' */\nexport interface IBasinContract extends IElementContract {\n}",
      "contentHash": "b594b0d6a313c52e546b829944fc80d3a2fa2d2d53ff6d77ed6420caa8ad85dc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBeachContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Beach' */\nexport interface IBeachContract extends IElementContract {\n}",
      "contentHash": "eb3f340619b568af4e7562e1112e508902c09ec86c8e4f59a67de6c1688864ab",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBearContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Bear' */\nexport interface IBearContract extends IElementContract {\n}",
      "contentHash": "dbc7dce70d8590a162d8f1b061e33b71f7c3da8ee38e2d9be07d32bb87aff29b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBeeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Bee' */\nexport interface IBeeContract extends IElementContract {\n}",
      "contentHash": "e599bf6fbde7ef15a9e9e60771f8088870672b688a2944ee801634b35c40e814",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBeerContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Beer' */\nexport interface IBeerContract extends IElementContract {\n}",
      "contentHash": "c82126140d3e69e303de5acc77108515296d835e4c250b36e709c2977b8a725f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBlockchainContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Blockchain' */\nexport interface IBlockchainContract extends IElementContract {\n}",
      "contentHash": "04b54c84c1d47da99b9987c6c473c1134e694863bdfb49c27b3be53965730a15",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBlockContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Block' */\nexport interface IBlockContract extends IElementContract {\n}",
      "contentHash": "ed053882f8170fc6132db1e82e19bb6970896f8c09384ed9d87f81c7f814b8dd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBlowholeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Blowhole' */\nexport interface IBlowholeContract extends IElementContract {\n}",
      "contentHash": "29b8fed151d6e7f7c9f60891ffdd69b5282032c3a1223e03726fb64f6753fd6d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBreezeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Breeze' */\nexport interface IBreezeContract extends IElementContract {\n}",
      "contentHash": "b265ceb7f5fd52c0e51e8472db3489d5bdea10eafabda6f7aa848b28b9eb4e60",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBrickContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Brick' */\nexport interface IBrickContract extends IElementContract {\n}",
      "contentHash": "df2663cdb74842efde0c42b045641f81b9989cdce77a71f900bb051e12625a82",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBridgeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Bridge' */\nexport interface IBridgeContract extends IElementContract {\n}",
      "contentHash": "1933ae9c360f56d6ed47adad7d6fcfac7ba9de44cddf546d1458e412b201df1f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IBrookContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Brook' */\nexport interface IBrookContract extends IElementContract {\n}",
      "contentHash": "508a8b1af028ca94c37ee741d1b0e123a459ac6fd9d066a991e0ed1327359153",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ICanyonContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Canyon' */\nexport interface ICanyonContract extends IElementContract {\n}",
      "contentHash": "6389896787495ce4740b703c8e9efcc60319ece93105f5858cbf2988e9f50378",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ICardanoContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Cardano' */\nexport interface ICardanoContract extends IElementContract {\n}",
      "contentHash": "23176866b2c544cd25b2bb81a57a2b568027aece572378d50f1921fb48b24673",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ICaveContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Cave' */\nexport interface ICaveContract extends IElementContract {\n}",
      "contentHash": "ee4d4fe3fc36c84b770bc3c6a5155c7cfdc78dc02c2d5abc0915c43c3d377675",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ICharcoalContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Charcoal' */\nexport interface ICharcoalContract extends IElementContract {\n}",
      "contentHash": "72c31bc81d3ad8ea4dbdf1a0ca23b564c337d6aa0843db7fb6784900b413bf42",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ICharredRavineContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Charred Ravine' */\nexport interface ICharredRavineContract extends IElementContract {\n}",
      "contentHash": "6bf1e7bbf225632bca19dab8efb4cae698e01abe453e951cfb593c5d295d9a3f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IClayContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Clay' */\nexport interface IClayContract extends IElementContract {\n}",
      "contentHash": "4f90e6dd7c87ac5b51190f8fb04061d5ab6c7970e3007ccbe101db74ebac08a2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ICloudContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Cloud' */\nexport interface ICloudContract extends IElementContract {\n}",
      "contentHash": "af66552fa8bfef050d65c77f76aaff57f69cee834b3b597c570012897a761771",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ICoinContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Coin' */\nexport interface ICoinContract extends IElementContract {\n}",
      "contentHash": "40857b349a34d90f452862672364e20be00e652d3fcaa81c4912d027bee3106f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ICoolBreezeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Cool Breeze' */\nexport interface ICoolBreezeContract extends IElementContract {\n}",
      "contentHash": "9df03b00e9e2439c7a9093c26855fb7f28a88be9c8f85c041df501579e89672b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ICoralContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Coral' */\nexport interface ICoralContract extends IElementContract {\n}",
      "contentHash": "fcfbd8e2c3405be6e4713e3e5680493c410945718bf542cfd66fa16f93832f49",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ICreekContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Creek' */\nexport interface ICreekContract extends IElementContract {\n}",
      "contentHash": "4987021ebf8bf10350e858e988607cadd4b17be63e51b02064d180b82d10a54a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ICrystalContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Crystal' */\nexport interface ICrystalContract extends IElementContract {\n}",
      "contentHash": "63e237b2123d859b622ebfcea3fe8b9c85913f31324ebf6dad4d5b1554af39d6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IDamContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Dam' */\nexport interface IDamContract extends IElementContract {\n}",
      "contentHash": "390412ffabb3ce45528dc21bf9fc670317bca6e8254513b1075ace96d0981852",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IDeltaContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Delta' */\nexport interface IDeltaContract extends IElementContract {\n}",
      "contentHash": "d0b8fcd3ff31082addb2371601584e08966ad2f5cb1702b456b1781261b882e4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IDepressionContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Depression' */\nexport interface IDepressionContract extends IElementContract {\n}",
      "contentHash": "60cc6534be92d0a9378b43bd626ca96d510fd9dd4c5702fcbce8a7a207208abe",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IDesertContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Desert' */\nexport interface IDesertContract extends IElementContract {\n}",
      "contentHash": "77723dc1ea20a37d4332c4589520de2653bcef8e855373c62d744b047cbb059c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IDryBasinContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Dry Basin' */\nexport interface IDryBasinContract extends IElementContract {\n}",
      "contentHash": "5f98a3c7afdf15c55a81a5b8cdacf85091e052ff7b98e7719acc81984904ba99",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IDuneContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Dune' */\nexport interface IDuneContract extends IElementContract {\n}",
      "contentHash": "ecce00680bdff51ad05c6a3ca187b208503d8fd9b92fa37cd60d28abf427de63",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IDustContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Dust' */\nexport interface IDustContract extends IElementContract {\n}",
      "contentHash": "143f8ed6f427e30c54798bd29e7e08325cf863a2671ede6c443c0ecd56241905",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IEarthContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Earth' */\nexport interface IEarthContract extends IElementContract {\n}",
      "contentHash": "ab79b56dbe0d4682f3b1f1c261db56d28a93fa7a405f5f31ec17b7cffa4ab1f7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IEchoContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Echo' */\nexport interface IEchoContract extends IElementContract {\n}",
      "contentHash": "a225549d944b4d42cb62afcf3136bc0e56cfa94bdeeb2bae15aae15b0aa3e8eb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IEmberContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Ember' */\nexport interface IEmberContract extends IElementContract {\n}",
      "contentHash": "59f2034a5fcca34aa8550b46c86ff69c974830eb752b13b90d55800b119d3448",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IErosionContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Erosion' */\nexport interface IErosionContract extends IElementContract {\n}",
      "contentHash": "ac7cc131b736b521e90c21c1c8c941485712e3fa438681d3c980d2e198c79e78",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IEstuaryContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Estuary' */\nexport interface IEstuaryContract extends IElementContract {\n}",
      "contentHash": "c163ee261ceb277d7c608f87e158e30415fd856502e4243f6dc37171cd0d2cad",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IEternalFlameContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Eternal Flame' */\nexport interface IEternalFlameContract extends IElementContract {\n}",
      "contentHash": "3bc816dea60242cca47691d67fdc0c7495acf881970ba239ed24649cfb6ef797",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IFarmContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Farm' */\nexport interface IFarmContract extends IElementContract {\n}",
      "contentHash": "e27fd255e4d79e255df12ed1dfe6f4364ce2708ba3717daf1665ae60c0a62021",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IFertileLandContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Fertile Land' */\nexport interface IFertileLandContract extends IElementContract {\n}",
      "contentHash": "8dd2131969ab971c99c5aa7875308db9b8488d96df305c739c92b999f09b3da9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IFertilizerContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Fertilizer' */\nexport interface IFertilizerContract extends IElementContract {\n}",
      "contentHash": "c03a378f5c23d7dea1426d0413b2bb92353e45d0fcb29b25d5215b4533f27dc6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IFireContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Fire' */\nexport interface IFireContract extends IElementContract {\n}",
      "contentHash": "040ef5a70fbce7053578d9f1159292ce1668947a8ff2de32a2b9428a21748b4b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IFireSwampContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Fire Swamp' */\nexport interface IFireSwampContract extends IElementContract {\n}",
      "contentHash": "2ffae5ce226b8058268689d019d4e12a4f70e78303fe607542e3c69393580ce6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IFirewallContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Firewall' */\nexport interface IFirewallContract extends IElementContract {\n}",
      "contentHash": "0bc46a8d50ac75a2ad775aaad0e3c8a3d63b804020dca0d3fc465174f7f23000",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IFloodContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Flood' */\nexport interface IFloodContract extends IElementContract {\n}",
      "contentHash": "ca0961231fa0c83f07598a4de9c5a21b977d81c451bd2c8b243729cfc29f6b98",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IFlowerContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Flower' */\nexport interface IFlowerContract extends IElementContract {\n}",
      "contentHash": "320d6a76cc53432635b42b51c5bfbe8027a5a4dd9bac9c3efe90a939121d3fd5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IFogContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Fog' */\nexport interface IFogContract extends IElementContract {\n}",
      "contentHash": "6e79af634726c736b309e95bac2aacecad60ac5390e6cac83049eb5bdcd08c43",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IForestContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Forest' */\nexport interface IForestContract extends IElementContract {\n}",
      "contentHash": "b4b87384b76b65611902cd3f35b6b372889b0f68483eaff4d68467143843072b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IFountainContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Fountain' */\nexport interface IFountainContract extends IElementContract {\n}",
      "contentHash": "6f8a94c310ec0fa877f7bdece7e6ce02f01889b98746c0d142c18e939ba12630",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IFreshBreezeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Fresh Breeze' */\nexport interface IFreshBreezeContract extends IElementContract {\n}",
      "contentHash": "7dfd57f89b3ca37de994c1d84ed0bb06b443d8de1e3e4e2701a5dada7237f857",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IFrostedGlassContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Frosted Glass' */\nexport interface IFrostedGlassContract extends IElementContract {\n}",
      "contentHash": "45d1295c967ca3e84167cba494bf98c9b5ff81c1409390ced9b9a01f6b679688",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IGardenContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Garden' */\nexport interface IGardenContract extends IElementContract {\n}",
      "contentHash": "fcd353ea0448e5d18520eaf244ff11b1cdc2f80beb3c29199eaf0785ee5e9036",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IGeothermalSpringContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Geothermal Spring' */\nexport interface IGeothermalSpringContract extends IElementContract {\n}",
      "contentHash": "7690fbaefbcd7f9834b37134359fe507ca7f7013bf1297f534f5a66b169750ba",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IGeyserContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Geyser' */\nexport interface IGeyserContract extends IElementContract {\n}",
      "contentHash": "377d93fe51442dadddac78f155652b718f087c6705e16942b98bec4b8c568e05",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IGiraffeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Giraffe' */\nexport interface IGiraffeContract extends IElementContract {\n}",
      "contentHash": "b0f132f7ec57e8b1a27e253388da29a87729a955b200b3c83729ee2b3f5f1c97",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IGlassContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Glass' */\nexport interface IGlassContract extends IElementContract {\n}",
      "contentHash": "e812ed2cfc2c83c46626ed7cd624a93ad70856ba773218aead5053a398c24359",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IGoldContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Gold' */\nexport interface IGoldContract extends IElementContract {\n}",
      "contentHash": "0a6a7d8b7d8cb1c99cf77533d3d8d3aa4c2df967a9b1ecd398c8bc0a8cc7211e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IGoldenGateContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'GoldenGate' */\nexport interface IGoldenGateContract extends IElementContract {\n}",
      "contentHash": "4a8b2b8ebda9af7326a8060db985e25a7e7c70618a5f0e9c5cd9896a634d3cb0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IGorgeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Gorge' */\nexport interface IGorgeContract extends IElementContract {\n}",
      "contentHash": "c1782160a581e2b3e08d47741efec4b9f8bf749711859b486bda1a6ce0c80311",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IGrottoContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Grotto' */\nexport interface IGrottoContract extends IElementContract {\n}",
      "contentHash": "f07bc2c3791d6b3be21abc6b2f2292724e5c01980407b2b43a562e6f669382ff",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IGroundwaterContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Groundwater' */\nexport interface IGroundwaterContract extends IElementContract {\n}",
      "contentHash": "d54e3a7fb338e9b89bd158f124b43ab42bfcea30916e97844705e0e45f94c249",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IHazeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Haze' */\nexport interface IHazeContract extends IElementContract {\n}",
      "contentHash": "8bbcb1b8eee93a4642c96ecba45d3072b2dd059b1b2a9f7a84fa3604ef8322b1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IHiveContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Hive' */\nexport interface IHiveContract extends IElementContract {\n}",
      "contentHash": "08012832365dfcce94d28349d84b262d7c6defcee4e8794c955954fdf3f9f995",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IHotSpringContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Hot Spring' */\nexport interface IHotSpringContract extends IElementContract {\n}",
      "contentHash": "63ba32a1d33996a64b7a7d216155cf9fccf54fd2c079edeaa1f5df8ee0bd1fe6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IHydraContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Hydra' */\nexport interface IHydraContract extends IElementContract {\n}",
      "contentHash": "f85c3b6aee34bd315923d09ba262c6f3f257c271b416d6ba2677eccd50266175",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IHyperMarmaladeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'HyperMarmalade' */\nexport interface IHyperMarmaladeContract extends IElementContract {\n}",
      "contentHash": "c5f7a11fb98aa73dc04dbb7e0fbf3fbde0f22051db780788ffe59bf23ccf3a97",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IIslandContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Island' */\nexport interface IIslandContract extends IElementContract {\n}",
      "contentHash": "290b832a24bc3c80b2edcff4a5b5195d115a8f96f9944be0adda1746bbf4f6e8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IJungleContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Jungle' */\nexport interface IJungleContract extends IElementContract {\n}",
      "contentHash": "2495b411b28f8f5ea3f93d21837126684cda0f1c30cf130311dc434e9d5098ac",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IKarstContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Karst' */\nexport interface IKarstContract extends IElementContract {\n}",
      "contentHash": "45cb6826519794eaffca1d1011a6d07b786ae7403a489b0c0dd66ac60bb85746",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IKilnContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Kiln' */\nexport interface IKilnContract extends IElementContract {\n}",
      "contentHash": "1774f6cb4260d5ab4e2b397d7d276900440ddccf00352954545d38ab79122cad",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ILagoonContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Lagoon' */\nexport interface ILagoonContract extends IElementContract {\n}",
      "contentHash": "26c0851c8679c18227e18674bacac147e0e58320e038b00dda565e22a881e5ad",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ILakeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Lake' */\nexport interface ILakeContract extends IElementContract {\n}",
      "contentHash": "c3f78e5f14a5d5ad840f18b6314cb4548ab8d352dc2808a3734230080a9597bc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ILandslideContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Landslide' */\nexport interface ILandslideContract extends IElementContract {\n}",
      "contentHash": "63ea99ab83447cae67e179bc8ca6721b83e5a6d6f55e367d88f348234a574ad3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ILavaCaveContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Lava Cave' */\nexport interface ILavaCaveContract extends IElementContract {\n}",
      "contentHash": "df63ae0a743139b28a2fc66a4dc2d81a70c4f0c1cb95114834a551642ca733b6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ILavaContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Lava' */\nexport interface ILavaContract extends IElementContract {\n}",
      "contentHash": "45a3bc8a3354770a748c80c68370d658eb92809e340e4ab5d2fb0272bd7af77e",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ILeavesContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Leaves' */\nexport interface ILeavesContract extends IElementContract {\n}",
      "contentHash": "ec133b3e9d4f81d9ac5b6d99cd03ed475ff5cd8c70c525c50de2795267dd4b94",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ILightningContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Lightning' */\nexport interface ILightningContract extends IElementContract {\n}",
      "contentHash": "a18f28018780b2dcfd83e92fc4097d424f4242f651737ad6494611ca4f23f38b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ILimestoneContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Limestone' */\nexport interface ILimestoneContract extends IElementContract {\n}",
      "contentHash": "5f53400ad9d3123b8227159fdd1f367a21f31ceddd914ecf6b1b8424e3ee9f42",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ILockContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Lock' */\nexport interface ILockContract extends IElementContract {\n}",
      "contentHash": "5abbfe49063e89c4a18b0dee309fa6df2195942bc44aa293118326a2635e6be9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IMagmaChamberContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Magma Chamber' */\nexport interface IMagmaChamberContract extends IElementContract {\n}",
      "contentHash": "6ecbd0450a3fff1468d67f757fd678703a9c9d1b9f02b0a0f410195a9a846d73",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IMagmaContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Magma' */\nexport interface IMagmaContract extends IElementContract {\n}",
      "contentHash": "095eb2a56f38ffeccc5585567e10c1b7b22611bad94675da5868019df9a16172",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IMarmaladeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Marmalade' */\nexport interface IMarmaladeContract extends IElementContract {\n}",
      "contentHash": "b2a62c8f54e74767f5e19b10f3c62427d6e817f3fb9514b5fe775329eec3fc9a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IMirageContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Mirage' */\nexport interface IMirageContract extends IElementContract {\n}",
      "contentHash": "b4fe7769bac3f271e74d5c73bee733975e3c0eb3b434b0842a50db90e873476d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IMistContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Mist' */\nexport interface IMistContract extends IElementContract {\n}",
      "contentHash": "c998458f762ac0e7578a6e707bbec4a179d60167d7d318547a9bc85e130f2496",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IMoltenGlassContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Molten Glass' */\nexport interface IMoltenGlassContract extends IElementContract {\n}",
      "contentHash": "c67922ef95794dd0df5e64df06e3dec79ac59a22f93b2b74c0965202c9e2aca3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IMonkeyBranchContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'MonkeyBranch' */\nexport interface IMonkeyBranchContract extends IElementContract {\n}",
      "contentHash": "3e89ed2ce9c367c8a78ed90b65baca703207d8f60495a354d6d7910af2562cef",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IMonkeyContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Monkey' */\nexport interface IMonkeyContract extends IElementContract {\n}",
      "contentHash": "baaa2ad1dfc9777ef7d05b76d2e17ab4f547235452a982b095d295df3e471574",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IMonumentContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Monument' */\nexport interface IMonumentContract extends IElementContract {\n}",
      "contentHash": "1d4889f46aa336109e6eafa61ab2644eec53ef79ad680c11d07c2ba1331311ed",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IMountainContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Mountain' */\nexport interface IMountainContract extends IElementContract {\n}",
      "contentHash": "bce207d8c97faaae90d5b6fafab232a317ba5ef18ae8fc9796c1d9cb91acdeb3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IMudContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Mud' */\nexport interface IMudContract extends IElementContract {\n}",
      "contentHash": "9df02fabcb723222856838b7fc30ba793e56b24e2c3e7f503f29bb084ce1bafb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IMurmurContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Murmur' */\nexport interface IMurmurContract extends IElementContract {\n}",
      "contentHash": "232597e534044f5d046447d49a8f678b0df107c9a1f2c21dd3a86d1251437ec6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/index.ts",
      "content": "export * from './IGameContract';\nexport * from './IMonkeyContract';\nexport * from './IGiraffeContract';\nexport * from './IBeeContract';\nexport * from './ICoinContract';\nexport * from './ISwarmContract';\nexport * from './IHydraContract';\nexport * from './IMonkeyBranchContract';\nexport * from './IBridgeContract';\nexport * from './IGoldenGateContract';\nexport * from './IGoldContract';\nexport * from './ISilverContract';\nexport * from './IRhodiumContract';\nexport * from './IHiveContract';\nexport * from './ITransactionContract';\nexport * from './IBlockContract';\nexport * from './IBlockchainContract';\nexport * from './IPolkadotContract';\nexport * from './IPeerReviewContract';\nexport * from './ICardanoContract';\nexport * from './IBearContract';\nexport * from './IBeerContract';\nexport * from './ILockContract';\nexport * from './IMarmaladeContract';\nexport * from './ISuperMarmaladeContract';\nexport * from './IHyperMarmaladeContract';\nexport * from './IWaterContract';\nexport * from './IFireContract';\nexport * from './ISteamContract';\nexport * from './IEarthContract';\nexport * from './IMudContract';\nexport * from './ILavaContract';\nexport * from './IWindContract';\nexport * from './IDustContract';\nexport * from './IRainContract';\nexport * from './ISmokeContract';\nexport * from './IGeyserContract';\nexport * from './IClayContract';\nexport * from './ISandContract';\nexport * from './IPlantContract';\nexport * from './IRainbowContract';\nexport * from './IStormContract';\nexport * from './IObsidianContract';\nexport * from './IAshContract';\nexport * from './IVolcanoContract';\nexport * from './ISandstormContract';\nexport * from './ICloudContract';\nexport * from './IFogContract';\nexport * from './ITreeContract';\nexport * from './IForestContract';\nexport * from './ISeedsContract';\nexport * from './IPotteryContract';\nexport * from './IBrickContract';\nexport * from './IQuicksandContract';\nexport * from './IGlassContract';\nexport * from './IDuneContract';\nexport * from './ICharcoalContract';\nexport * from './ILeavesContract';\nexport * from './IWildfireContract';\nexport * from './IJungleContract';\nexport * from './IFrostedGlassContract';\nexport * from './ICrystalContract';\nexport * from './IMagmaContract';\nexport * from './IRockContract';\nexport * from './IShardContract';\nexport * from './IPebbleContract';\nexport * from './IMountainContract';\nexport * from './IFertilizerContract';\nexport * from './ISootContract';\nexport * from './ILightningContract';\nexport * from './IMistContract';\nexport * from './IHazeContract';\nexport * from './IFloodContract';\nexport * from './ILandslideContract';\nexport * from './IThunderContract';\nexport * from './ITornadoContract';\nexport * from './IGardenContract';\nexport * from './IEmberContract';\nexport * from './IKilnContract';\nexport * from './IPollinationContract';\nexport * from './ISinkholeContract';\nexport * from './IBeachContract';\nexport * from './IWetstoneContract';\nexport * from './IErosionContract';\nexport * from './IBasaltContract';\nexport * from './IMagmaChamberContract';\nexport * from './IBreezeContract';\nexport * from './IWarmBreezeContract';\nexport * from './ISoilContract';\nexport * from './ICanyonContract';\nexport * from './IWindmillContract';\nexport * from './IAdobeContract';\nexport * from './IWallContract';\nexport * from './IPumiceContract';\nexport * from './IBarbecueContract';\nexport * from './IFarmContract';\nexport * from './IShardsContract';\nexport * from './IMoltenGlassContract';\nexport * from './IPrismContract';\nexport * from './ISparkleContract';\nexport * from './IDesertContract';\nexport * from './IOasisContract';\nexport * from './IMirageContract';\nexport * from './ISandDuneContract';\nexport * from './IDamContract';\nexport * from './IFirewallContract';\nexport * from './IBarricadeContract';\nexport * from './IPlateauContract';\nexport * from './IPondContract';\nexport * from './IAromasContract';\nexport * from './IFlowerContract';\nexport * from './ISporeContract';\nexport * from './ISpreadContract';\nexport * from './IFertileLandContract';\nexport * from './IWetlandContract';\nexport * from './IPeatContract';\nexport * from './IReedsContract';\nexport * from './IValleyContract';\nexport * from './IRiverContract';\nexport * from './IScorchedEarthContract';\nexport * from './IDeltaContract';\nexport * from './IEstuaryContract';\nexport * from './IFireSwampContract';\nexport * from './IRiverbankContract';\nexport * from './IRavineContract';\nexport * from './IGorgeContract';\nexport * from './ICharredRavineContract';\nexport * from './IEchoContract';\nexport * from './ICaveContract';\nexport * from './IUndergroundLakeContract';\nexport * from './ILavaCaveContract';\nexport * from './IWhisperingCaveContract';\nexport * from './ISubterraneanPoolContract';\nexport * from './ISpringContract';\nexport * from './IHotSpringContract';\nexport * from './IGrottoContract';\nexport * from './IFountainContract';\nexport * from './ISteamVentContract';\nexport * from './ICoolBreezeContract';\nexport * from './IMonumentContract';\nexport * from './IWaterfallContract';\nexport * from './IEternalFlameContract';\nexport * from './IPillarOfWindContract';\nexport * from './IStreamContract';\nexport * from './IZephyrContract';\nexport * from './ICreekContract';\nexport * from './IBrookContract';\nexport * from './IWhisperContract';\nexport * from './IRivuletContract';\nexport * from './ITributaryContract';\nexport * from './IMurmurContract';\nexport * from './IWatershedContract';\nexport * from './IAquiferContract';\nexport * from './IParchedEarthContract';\nexport * from './IFreshBreezeContract';\nexport * from './IGroundwaterContract';\nexport * from './IReservoirContract';\nexport * from './IGeothermalSpringContract';\nexport * from './IArtesianWellContract';\nexport * from './IBasinContract';\nexport * from './ILakeContract';\nexport * from './IDryBasinContract';\nexport * from './IDepressionContract';\nexport * from './IIslandContract';\nexport * from './ILagoonContract';\nexport * from './IWaveContract';\nexport * from './IReefContract';\nexport * from './ICoralContract';\nexport * from './IWhirlContract';\nexport * from './ILimestoneContract';\nexport * from './IKarstContract';\nexport * from './IQuicklimeContract';\nexport * from './IBlowholeContract';\n",
      "contentHash": "14cd8d3ac216445feec66f27b39b491cfbde6be3310c946c186dc92cce259cf1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IOasisContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Oasis' */\nexport interface IOasisContract extends IElementContract {\n}",
      "contentHash": "b194049646b3a0e32f6e34dd6cf109b048c6b94ce32e1fd12924486210b9e43a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IObsidianContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Obsidian' */\nexport interface IObsidianContract extends IElementContract {\n}",
      "contentHash": "f7bd8d7438726cd788988f292c3aac82b7ba2c9ebfdc69c129534157d4adc645",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IParchedEarthContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Parched Earth' */\nexport interface IParchedEarthContract extends IElementContract {\n}",
      "contentHash": "a94ba9702cd8648a4d00eda778a37bb713aa662518ed410daec2bd00d8c47475",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IPeatContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Peat' */\nexport interface IPeatContract extends IElementContract {\n}",
      "contentHash": "c3ff8a9aef06ae19b5ea16f418a965a34b73f61874468b279db489dbc5ee5040",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IPebbleContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Pebble' */\nexport interface IPebbleContract extends IElementContract {\n}",
      "contentHash": "d9380ed16ea16c7e63c8a485b0d8a119cea7cfd65aa98a8f1be9cfaf4baa5029",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IPeerReviewContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'PeerReview' */\nexport interface IPeerReviewContract extends IElementContract {\n}",
      "contentHash": "d0b75c0d4acf3414796ac9f63c83ad19390310ba518b18ca4623e4a2d023f611",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IPillarOfWindContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Pillar of Wind' */\nexport interface IPillarOfWindContract extends IElementContract {\n}",
      "contentHash": "df0692fbee945dfcf818873faac68c94bf1e917769213ec29e359b7d13e0148b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IPlantContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Plant' */\nexport interface IPlantContract extends IElementContract {\n}",
      "contentHash": "62e03b173c01866211c88f00e4b3514690d42707feb6d5582390cfcb6262ee2d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IPlateauContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Plateau' */\nexport interface IPlateauContract extends IElementContract {\n}",
      "contentHash": "55c3d79c6097a366bccdb80adc4f98ccf3686dc13e11504b43a8de665c835dd8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IPolkadotContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Polkadot' */\nexport interface IPolkadotContract extends IElementContract {\n}",
      "contentHash": "d59f6fab4c68fbe345e172ab165d1e662ff49bc067f14cb8af4e612aea946881",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IPollinationContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Pollination' */\nexport interface IPollinationContract extends IElementContract {\n}",
      "contentHash": "2187691dd0e5fc75286af718191588987f74e40248494eeef97d7e7a8e70bd61",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IPondContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Pond' */\nexport interface IPondContract extends IElementContract {\n}",
      "contentHash": "e5d7c421126254f5ae5cbac7888e11c8f40567995b5ea2848484312c3222e250",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IPotteryContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Pottery' */\nexport interface IPotteryContract extends IElementContract {\n}",
      "contentHash": "9fe6db27ab183e473ac59da1564347b8200ff51e2579b0b6753c8799a760c16b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IPrismContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Prism' */\nexport interface IPrismContract extends IElementContract {\n}",
      "contentHash": "24b8b54aa32a1f873b06e81efffa16691cc72a0fd25a22506b65fc99ed489f64",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IPumiceContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Pumice' */\nexport interface IPumiceContract extends IElementContract {\n}",
      "contentHash": "257163668d0886aaf279f338c3bc0d60c7351e96b62b8195aeaaf38b0875ab05",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IQuicklimeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Quicklime' */\nexport interface IQuicklimeContract extends IElementContract {\n}",
      "contentHash": "65a757ea992f6d77ce817227b893d7460ba5665311e6afe980bf68704c905638",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IQuicksandContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Quicksand' */\nexport interface IQuicksandContract extends IElementContract {\n}",
      "contentHash": "c6b1f766a297ff5c12785d6f8da5a079de076eaa99ff509f1d46b42ab3e07542",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IRainbowContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Rainbow' */\nexport interface IRainbowContract extends IElementContract {\n}",
      "contentHash": "1d82e606ad38161c8255555ec12e089749da774d2dab4038da10c13e6e6f399c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IRainContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Rain' */\nexport interface IRainContract extends IElementContract {\n}",
      "contentHash": "e0b0df056b0bae8c568a683283ab9928f441ae6b6271f813aaeca6fc22d07e99",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IRavineContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Ravine' */\nexport interface IRavineContract extends IElementContract {\n}",
      "contentHash": "5fcd60b43785b89e58810764070bfdeefa62bbd4eabef22791c68b55f0a5a1d2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IReedsContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Reeds' */\nexport interface IReedsContract extends IElementContract {\n}",
      "contentHash": "5851eadf84cd2daed9e949de4f0fc8cddb8cca4339e6cfd797a4fd56b080a59d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IReefContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Reef' */\nexport interface IReefContract extends IElementContract {\n}",
      "contentHash": "4e92152c1105247ca79b63a2ff2d5d5ddca7eddfbbbb2bba5261487f91405b81",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IReservoirContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Reservoir' */\nexport interface IReservoirContract extends IElementContract {\n}",
      "contentHash": "13642dd8d7b1c75ce6513647bd3bab9775bee82619567b01b5abc47932d2f141",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IRhodiumContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Rhodium' */\nexport interface IRhodiumContract extends IElementContract {\n}",
      "contentHash": "8e688b8436c36043bde57972c959199126d54b5ce53065e51d59b1ddce69d833",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IRiverbankContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Riverbank' */\nexport interface IRiverbankContract extends IElementContract {\n}",
      "contentHash": "03d4b2bd4b3cec4159ca29fc35d62e3efd26bc2313cbe2d7552187d18c439047",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IRiverContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'River' */\nexport interface IRiverContract extends IElementContract {\n}",
      "contentHash": "129a1b4e8ac952643f09c75a9924202609ae43b8aeebf5dfe47c594ec613476d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IRivuletContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Rivulet' */\nexport interface IRivuletContract extends IElementContract {\n}",
      "contentHash": "af9f045997f56acc0542ea724a96745121ab6a3085641149c5200db7d9afca0c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IRockContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Rock' */\nexport interface IRockContract extends IElementContract {\n}",
      "contentHash": "d708520f5e745c4026cb42e58d7b4f33d5cee14d0a18b470f0fbfae65f108992",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISandContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Sand' */\nexport interface ISandContract extends IElementContract {\n}",
      "contentHash": "3627deb075a4d19b3a1f7cf053023041a349507d5c2a105da9ccc43663521266",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISandDuneContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Sand Dune' */\nexport interface ISandDuneContract extends IElementContract {\n}",
      "contentHash": "8486f78a817f392c9f8ade4d824837cd9a345e1f20bb15b7695fd903d8be32d8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISandstormContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Sandstorm' */\nexport interface ISandstormContract extends IElementContract {\n}",
      "contentHash": "f205d7dd45e52749a823fe3c82c97d684772682481bc88b63a57455d23a3ed6d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IScorchedEarthContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Scorched Earth' */\nexport interface IScorchedEarthContract extends IElementContract {\n}",
      "contentHash": "e0f1ea71e07c8e8699f67dc071a5cd5c03bc070dc10e4ad35e29caecfd0729e7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISeedsContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Seeds' */\nexport interface ISeedsContract extends IElementContract {\n}",
      "contentHash": "817f4ecd20e39a7f464a27a28459e112000436b1f20ff073baf4dbaea163f302",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IShardContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Shard' */\nexport interface IShardContract extends IElementContract {\n}",
      "contentHash": "004804f9c28944e437be99c9528f4586a748d476e1667573565bd24ea62345be",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IShardsContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Shards' */\nexport interface IShardsContract extends IElementContract {\n}",
      "contentHash": "b298ad35f67f398179f2fc62fe2558648940a38fd3d8d6098272c6a0bc3c9f9d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISilverContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Silver' */\nexport interface ISilverContract extends IElementContract {\n}",
      "contentHash": "d62ce35a00728f18e5a0693b180acfc5f86490d01c5a394bf15d677be51780b4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISinkholeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Sinkhole' */\nexport interface ISinkholeContract extends IElementContract {\n}",
      "contentHash": "5ad53b7182d532749b8b43c10b2011e95518e7eb2259679a0e3eba6d581954cb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISmokeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Smoke' */\nexport interface ISmokeContract extends IElementContract {\n}",
      "contentHash": "ee1c824c5d5ddfce4a1745b2b11a729092a753abab5996746787714de4860b91",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISoilContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Soil' */\nexport interface ISoilContract extends IElementContract {\n}",
      "contentHash": "641e7a460eacf4fd3d09f465010c471953246e952474b8fff9a7d5152bb45ca6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISootContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Soot' */\nexport interface ISootContract extends IElementContract {\n}",
      "contentHash": "714aa5a181c84c602458e2fe834d957e7cc5d6abacff965c181d65b757de62ec",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISparkleContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Sparkle' */\nexport interface ISparkleContract extends IElementContract {\n}",
      "contentHash": "88885fc3e14acdf44cc2a406b17ddf575424aff06130f264824475d5d83d3066",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISporeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Spore' */\nexport interface ISporeContract extends IElementContract {\n}",
      "contentHash": "bb81f348b681226fd5088e8e3276c11aaa92372d588e3b67f94a9adca0081091",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISpreadContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Spread' */\nexport interface ISpreadContract extends IElementContract {\n}",
      "contentHash": "5407bb28b7f5f91204f29db61db33238956baf9f01a98245578053f871ea5102",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISpringContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Spring' */\nexport interface ISpringContract extends IElementContract {\n}",
      "contentHash": "48b4815ec2a43dc10306a0ada480564aef78ded978c77cfe4e2f4fe47e894490",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISteamContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Steam' */\nexport interface ISteamContract extends IElementContract {\n}",
      "contentHash": "af72b196861e596d7c3c03073536beb62dfbc67b63fa4f0d3a842b39aeedb21f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISteamVentContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Steam Vent' */\nexport interface ISteamVentContract extends IElementContract {\n}",
      "contentHash": "270d32d1f2144c32acd254dfcac778e1fb93c8ade4e2946020c00f38aaa2588c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IStormContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Storm' */\nexport interface IStormContract extends IElementContract {\n}",
      "contentHash": "c3033e1a701c3335848257599b9b6e0476719d1892599662061ef7a17bb7d020",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IStreamContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Stream' */\nexport interface IStreamContract extends IElementContract {\n}",
      "contentHash": "6558b970e82eb9252f62c811973d0f82f762431506eacb0285a7cee1986a06fa",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISubterraneanPoolContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Subterranean Pool' */\nexport interface ISubterraneanPoolContract extends IElementContract {\n}",
      "contentHash": "51b515f4645d2e4ca711c73abf92248bc5f8cef59f5a397585c244902c44ef29",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISuperMarmaladeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'SuperMarmalade' */\nexport interface ISuperMarmaladeContract extends IElementContract {\n}",
      "contentHash": "66a3b3529321223ab59de2801d7a39350680af4d45938486105887b390c5f77c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISwarmContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'SWARM' */\nexport interface ISwarmContract extends IElementContract {\n}",
      "contentHash": "9d2fa8eb888255c648fd9f8a409e3ceff1530082a2a17ae267af954f286dbfee",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IThunderContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Thunder' */\nexport interface IThunderContract extends IElementContract {\n}",
      "contentHash": "8de31f704dbbdb36824cd8629ced5507ac86672c586855bf5ea6773a758c5b97",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ITornadoContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Tornado' */\nexport interface ITornadoContract extends IElementContract {\n}",
      "contentHash": "4f3adb9919c3c64dd0724ea1faa1fbd04cb8ac2bc4e52e1f4da20eac9bb7acf5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ITransactionContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Transaction' */\nexport interface ITransactionContract extends IElementContract {\n}",
      "contentHash": "89f93a898dc4d37458bfe21b94c5748b59b8a68700fc9ca61f94818700429afe",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ITreeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Tree' */\nexport interface ITreeContract extends IElementContract {\n}",
      "contentHash": "ef4e5a185f0d568032ca72a675c341c58feb15b65d6bf6a391802a6a7fb74fcd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ITributaryContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Tributary' */\nexport interface ITributaryContract extends IElementContract {\n}",
      "contentHash": "664aa29a9ea2a6aaa21f089fb2cdf17dc68c11fc86ac7af8bf5adb0608a38449",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IUndergroundLakeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Underground Lake' */\nexport interface IUndergroundLakeContract extends IElementContract {\n}",
      "contentHash": "fb40838642919b0f0439e05c4127e18fed764e5426b25ff54959eb11fe38058c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IValleyContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Valley' */\nexport interface IValleyContract extends IElementContract {\n}",
      "contentHash": "18688ad5668606f2ab759c0bb7e4925bc8261c1bca56c36405da4b443d4eaac8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IVolcanoContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Volcano' */\nexport interface IVolcanoContract extends IElementContract {\n}",
      "contentHash": "1f3cb34d51de88c740687c4a17ba8015878f236850da821186f857e4fff00344",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IWallContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Wall' */\nexport interface IWallContract extends IElementContract {\n}",
      "contentHash": "63006d1f0537a6f29f725f867d9a89e1377c168795b5100d1cdc2fb825f89a51",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IWarmBreezeContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Warm Breeze' */\nexport interface IWarmBreezeContract extends IElementContract {\n}",
      "contentHash": "cbbe36fcd8c50416b05f6d3a5da7e2fbbc4699571898db7c4eec35a1586e8a28",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IWaterContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Water' */\nexport interface IWaterContract extends IElementContract {\n}",
      "contentHash": "b8e0c9e303e12976dede5d7fb5578ccc5c6391c6dfe082ec9d72f8749907f72b",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IWaterfallContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Waterfall' */\nexport interface IWaterfallContract extends IElementContract {\n}",
      "contentHash": "3567f8639241447f58f87dc2f9b6ea13fd823a32ff9b74514225e773b69707e3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IWatershedContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Watershed' */\nexport interface IWatershedContract extends IElementContract {\n}",
      "contentHash": "a00b7b01f2739538567350d021c991e02c122dd2e96bdd21e036610f074b298d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IWaveContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Wave' */\nexport interface IWaveContract extends IElementContract {\n}",
      "contentHash": "b828dc0babdbf8dc655903a86d056fc3181f73c5cca1f1cd58e9da1450509a6f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IWetlandContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Wetland' */\nexport interface IWetlandContract extends IElementContract {\n}",
      "contentHash": "760cbf34c6858847ebda2df99601768a0fbb96453e8e1381b10243ea86795132",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IWetstoneContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Wetstone' */\nexport interface IWetstoneContract extends IElementContract {\n}",
      "contentHash": "672938cd71d4aa4a52d6f76710be8799d4396df4cc6fa5240c87607443fa4fdd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IWhirlContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Whirl' */\nexport interface IWhirlContract extends IElementContract {\n}",
      "contentHash": "f9119d53f317577cd6bb1810831e89740803de36b317e5591c45138977dd0f7a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IWhisperContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Whisper' */\nexport interface IWhisperContract extends IElementContract {\n}",
      "contentHash": "a771b8f5e716c5e57f920a864db1e240d48f764de3e9711b97d6240e8960739a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IWhisperingCaveContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Whispering Cave' */\nexport interface IWhisperingCaveContract extends IElementContract {\n}",
      "contentHash": "a24a77797adf2e1f1e5b89a2b76de9c7bdcb733814254fe4173c2a7f32d29c0d",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IWildfireContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Wildfire' */\nexport interface IWildfireContract extends IElementContract {\n}",
      "contentHash": "b8cf7486b7a77a254157284417ed9578009e5cba4a5dcddd0068008e1b27a8ac",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IWindContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Wind' */\nexport interface IWindContract extends IElementContract {\n}",
      "contentHash": "ea61d47764032edf12a318502541f5bd2519911c5a8294a32babd83786253538",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IWindmillContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Windmill' */\nexport interface IWindmillContract extends IElementContract {\n}",
      "contentHash": "a7f063396e4b55861da6710688b54a6dc01d73513c5d7fa6ac62bb5db763ca54",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IZephyrContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'Zephyr' */\nexport interface IZephyrContract extends IElementContract {\n}",
      "contentHash": "e9447be30237bb8f2610045dbac02985bbc7ef96f4fb52091d9732f1668ac2c2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/unifiers.singleplayer.game.ts",
      "content": "import { GAME_UNIFIERS } from '@not-a-bird/model';\nimport {\n    registerUsableGame\n} from './use-game';\nimport {\n    createSinglePlayerGame\n} from './create-game';\n\nregisterUsableGame(\n    'unifiers.singleplayer',\n    {\n        name: 'Unifiers Singleplayer',\n        description: 'A game created with the help of the Unifiers group',\n        chainInfo: 'Singleplayer, no chain'\n    },\n    createSinglePlayerGame(GAME_UNIFIERS)\n);",
      "contentHash": "aa0daea88b8aa7e180c2bdc004d04e848a42fb403c765d61bc188907ac4616fd",
      "noWriteIfExists": false
    }
  ]
}