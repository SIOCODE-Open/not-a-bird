{
  "generatedSource": [
    {
      "filename": "Cargo.toml",
      "content": "[workspace]\n\nresolver = \"2\"\nmembers = [\n  \"packages/contract-water/src\",\n  \"packages/contract-fire/src\",\n  \"packages/contract-earth/src\",\n  \"packages/contract-air/src\",\n  \"packages/contract-steam/src\",\n  \"packages/contract-lava/src\",\n  \"packages/contract-game/src\",\n]\nexclude = [\n  \".cargo\",\n  \"target\"\n]\n\n[workspace.dependencies]\nink = { version = \"5.0.0\", default-features = false }",
      "contentHash": "d42775f49305de3a494e76ff9c37d0a6d9226b516776809cbb8c826df8fac9dd",
      "noWriteIfExists": false
    },
    {
      "filename": "ITEMS.md",
      "content": "# Items\n\nIn this document we list all **items** (or _elements_) and **recipes** that can be found in the game. We also provide some explanation of the most important game mechanics revolving around items and recipes.\n\n## Buying\n\n**Buying an item**: Players may at any time call the game contract, transfer some value in the call, and receive items equal to the value transferred. The price of an item is calculated as follows:\n\nFor starters, each **item** has a **tier**. The item tier is a **positive integer number**. The game always has a **buy offer**, which is a tuple of (**native token price**, **received tier points**). When the player **buys**, they indirectly buy tier points, and may receive `floor(received_tier_points / tier)` items. The game only considers `floor(transfered_value / native_token_price)` amount of money transfered in, and the remainder is lost (or donated to the contract, however you want to see it).\n\n## Items\n\n* **Water** (`1`): Water is a liquid with formula H~2~O\n* **Fire** (`1`): Fire is a chemical reaction that releases heat and light\n* **Earth** (`1`): Earth is the solid material that makes up the surface of the planet\n* **Air** (`1`): Air is a mixture of gases that make up the atmosphere\n* **Steam** (`2`): Steam is the gaseous form of water with formula H~2~O\n* **Lava** (`2`): Lava is molten rock that flows from a volcano\n\n## Recipes\n\n* **Create Steam** (`1 + 1 -> 2`) - **Water** + **Fire** -> **Steam**: Combining **water** and **fire** creates **steam**\n* **Create Lava** (`1 + 1 -> 2`) - **Earth** + **Fire** -> **Lava**: Lava is created when a volcano errupts, combining **earth** and **fire**\n",
      "contentHash": "cd33f1ecdf0a17382b5c7d4b802697f24f4c27836af7f74c35d463d5fe060dfc",
      "noWriteIfExists": false
    },
    {
      "filename": "package.json",
      "content": "{\n  \"name\": \"@siocode/not-a-bird\",\n  \"version\": \"0.0.1\",\n  \"private\": true,\n  \"workspaces\": [\n    \"packages/*\"\n  ],\n  \"dependencies\": {\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\",\n    \"rxjs\": \"7.8.1\",\n    \"@polkadot/api\": \"11.0.2\",\n    \"@polkadot/api-contract\": \"11.0.2\",\n    \"leva\": \"0.9.35\",\n    \"@unique-nft/accounts\": \"^0.3.7\",\n    \"@unique-nft/sdk\": \"^0.7.4\"\n  },\n  \"devDependencies\": {\n    \"@types/react\": \"18.2.79\",\n    \"@types/react-dom\": \"18.2.25\",\n    \"chalk\": \"4\",\n    \"chokidar\": \"3.6.0\",\n    \"concurrently\": \"8.2.2\",\n    \"esbuild\": \"0.20.2\",\n    \"fs-extra\": \"11.2.0\",\n    \"sass\": \"1.75.0\",\n    \"typescript\": \"5.4.5\",\n    \"prettier\": \"^3.2.5\"\n  },\n  \"scripts\": {\n    \"c:water\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-water/src/Cargo.toml\",\n    \"c:fire\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-fire/src/Cargo.toml\",\n    \"c:earth\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-earth/src/Cargo.toml\",\n    \"c:air\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-air/src/Cargo.toml\",\n    \"c:steam\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-steam/src/Cargo.toml\",\n    \"c:lava\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-lava/src/Cargo.toml\",\n    \"c:game\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-game/src/Cargo.toml\",\n    \"build:contracts\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-game/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-water/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-fire/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-earth/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-air/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-steam/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-lava/src/Cargo.toml\",\n    \"build\": \"npm run -w @not-a-bird/app-game build\",\n    \"serve\": \"npm run -w @not-a-bird/app-game serve\"\n  }\n}",
      "contentHash": "27b9f2bea11a1ea211d8b0552904ea7a72f359dee8bf9a845a7aaebe05ffd781",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-air/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-air/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-air\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'air'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "e9655f46dd82755a4e38ce8d5625f1a5e36ab94ae454210c9369ccb1b04a5848",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-air/README.md",
      "content": "# air - Contract\n\nThis is a air contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "1ffa2e37292feb468d280b8616e0062a32e48cdfdeca123657db3a8f7215ed3c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-air/src/Cargo.toml",
      "content": "[package]\nname = \"air\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "c18c5b1484dc6cf565ce189432ca77e822e386dc35de008857b077c47641335a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-air/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod air {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'air' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct AirContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for AirContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl AirContract {\n        /// Creates a new PSP-22 compatible Air Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Air\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MAIR\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            }\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            }\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "5752378b9183564c2b8c064e838b57708bcd41335f43ce93516ab036da7d462f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-earth/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-earth/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-earth\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'earth'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "148c02fbca356ac90f5edd1de72f03b78a7b4cf602cceb490926b1ecc11c4ded",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-earth/README.md",
      "content": "# earth - Contract\n\nThis is a earth contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "9b504c2f0be8f658529c7f629dee7b1fbbbd9dc85bf7d697e8fde144a2a789f7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-earth/src/Cargo.toml",
      "content": "[package]\nname = \"earth\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "ca9d5007293a66afc8cdb1b691f90b51d9e8f2aa9ba074c730fa25ab1e456ca2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-earth/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod earth {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'earth' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct EarthContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for EarthContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl EarthContract {\n        /// Creates a new PSP-22 compatible Earth Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Earth\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MEARTH\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            }\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            }\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "8c6f7d3803394f787ee69116178bc897496ae9c111d248ce66ba07a05b5c60fb",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fire/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fire/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-fire\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'fire'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "3405f6a2335d729c1cd168a53d66e2de75acd64603186b9c82fa42bc796442dc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fire/README.md",
      "content": "# fire - Contract\n\nThis is a fire contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "f1262d7654055a0ec75222997c4397333c9a1dccfb732de7a55cef533bc89058",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fire/src/Cargo.toml",
      "content": "[package]\nname = \"fire\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "9520e61b9f13f56d2ba329c527b622fda115a62c838d3a98a45336964f2f38e2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fire/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod fire {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'fire' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct FireContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for FireContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl FireContract {\n        /// Creates a new PSP-22 compatible Fire Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Fire\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MFIRE\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            }\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            }\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "af2ab102c96d732cd2e0b875799066af43d134c01187bcecb5777dd7195d8e5a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lava/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lava/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-lava\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'lava'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "ff5cd696d66f0401b84905ebcda5d0906c213cb89f125d23ca2f4c9c5e5e709c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lava/README.md",
      "content": "# lava - Contract\n\nThis is a lava contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "d73494ff86fb36e073389141d7e8ef5204479507eaf6a864a8d9755a4837b126",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lava/src/Cargo.toml",
      "content": "[package]\nname = \"lava\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "cf4e4458d2d341a7314d99f5f2bb600b3ecfb6d3ec4a650d0f7dd203873364c7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lava/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod lava {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'lava' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct LavaContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for LavaContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl LavaContract {\n        /// Creates a new PSP-22 compatible Lava Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Lava\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MLAVA\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            }\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            }\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "705f94c1e6c39f84c5d1b4f99e61531c4f9b339c9cfd9e2e921516754160eef9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-steam/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-steam/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-steam\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'steam'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "d1d5338bf2c97324ccbbd9a8b8908a78c00f68c292e1ffa9970ddb485e06a1f3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-steam/README.md",
      "content": "# steam - Contract\n\nThis is a steam contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "e292c73fc97f0b5240e332791c64aa8cfcc5225dde80785e999385684518eab1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-steam/src/Cargo.toml",
      "content": "[package]\nname = \"steam\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "2d3f08718a123afbdc37359cedcf6ef1d0508a8b2724d284dbfc2824fa6a95b9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-steam/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod steam {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'steam' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SteamContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SteamContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SteamContract {\n        /// Creates a new PSP-22 compatible Steam Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Steam\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSTEAM\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            }\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            }\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "da2bf00571c8af0e9af11918eb209401daec655958df0e84e571afb1033ab9fc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-water/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-water/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-water\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'water'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "73e554672fbc18b041d4a04e9907550b6689ab8baac63e60ca001740d5a15dd5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-water/README.md",
      "content": "# water - Contract\n\nThis is a water contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "c200163fc1b429eb7c394da7d435ffcb2504ba7b69e88719fe6c060342b402d0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-water/src/Cargo.toml",
      "content": "[package]\nname = \"water\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "abfd355630ccda731ba36c9d63cb728037ba4c3557041154e1e23ed0202a2032",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-water/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod water {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'water' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct WaterContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for WaterContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl WaterContract {\n        /// Creates a new PSP-22 compatible Water Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message, selector = 0x3d261bd4)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Water\")\n        }\n\n        #[ink(message, selector = 0x34205be5)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MWATER\")\n        }\n        \n        #[ink(message, selector = 0x7271b782)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message, selector = 0x162df8c2)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message, selector = 0x6568382f)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message, selector = 0x4d47d921)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::claim_ownership\")\n        #[ink(message, selector = 0x77557f05)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::lock_game_contract\")\n        #[ink(message, selector = 0x6386465e)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            }\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::mint\")\n        #[ink(message, selector = 0x21615d0f)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            /* if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            } */\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        // Selector is first 4 bytes of blake2b_256(\"ElementContract::burn\")\n        #[ink(message, selector = 0x100fa9ca)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            }\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xdb20f9f5)]\n        pub fn transfer(&mut self, to: AccountId, value: u128) -> Result<(), Error> {\n            let from = self.env().caller();\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xb20f1bbd)]\n        pub fn approve(&mut self, spender: AccountId, value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), &value);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x54b3c76e)]\n        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, value: u128) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let allowance = self.allowances.get((from, caller)).unwrap_or_default();\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let from_balance = self.balances.get(from).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), &allowance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            self.balances.insert(from, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow transferring tokens\")))?);\n            let to_balance = self.balances.get(to).unwrap_or_default();\n            self.balances.insert(to, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow transferring tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0x96d6b57a)]\n        pub fn increase_allowance(&mut self, spender: AccountId, added_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_add(added_value).ok_or(Error::Custom(String::from(\"Overflow increasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n        #[ink(message, selector = 0xfecb57d5)]\n        pub fn decrease_allowance(&mut self, spender: AccountId, subtracted_value: u128) -> Result<(), Error> {\n            let owner = self.env().caller();\n            let allowance = self.allowances.get((owner, spender)).unwrap_or_default();\n            self.allowances.insert((owner, spender), &allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?);\n            self.env().emit_event(PSP22Approval {\n                owner,\n                spender,\n                amount: allowance.checked_sub(subtracted_value).ok_or(Error::Custom(String::from(\"Underflow decreasing allowance\")))?,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "7152d8cc0f759ef749062d0d87c6a981c7e8bfe32751c151c4e833a1e8773bb7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/model/src/items.ts",
      "content": "import { IItem } from './IItem';\n\nexport const ITEM_WATER: IItem = {\n    id: 0,\n    name: 'Water',\n    description: 'Water is a liquid with formula H~2~O',\n    tier: 1,\n};\nexport const ITEM_FIRE: IItem = {\n    id: 1,\n    name: 'Fire',\n    description: 'Fire is a chemical reaction that releases heat and light',\n    tier: 1,\n};\nexport const ITEM_EARTH: IItem = {\n    id: 2,\n    name: 'Earth',\n    description: 'Earth is the solid material that makes up the surface of the planet',\n    tier: 1,\n};\nexport const ITEM_AIR: IItem = {\n    id: 3,\n    name: 'Air',\n    description: 'Air is a mixture of gases that make up the atmosphere',\n    tier: 1,\n};\nexport const ITEM_STEAM: IItem = {\n    id: 4,\n    name: 'Steam',\n    description: 'Steam is the gaseous form of water with formula H~2~O',\n    tier: 2,\n};\nexport const ITEM_LAVA: IItem = {\n    id: 5,\n    name: 'Lava',\n    description: 'Lava is molten rock that flows from a volcano',\n    tier: 2,\n};\n\nexport const ALL_ITEMS: IItem[] = [\n    ITEM_WATER,\n    ITEM_FIRE,\n    ITEM_EARTH,\n    ITEM_AIR,\n    ITEM_STEAM,\n    ITEM_LAVA,\n];",
      "contentHash": "0d5f67380191506f37c18e21e4e3ad0aed985ad244618893b4784387abc036b1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/model/src/recipes.ts",
      "content": "import * as items from './items';\nimport { IRecipe } from './IRecipe';\n\nexport const RECIPE_CREATE_STEAM: IRecipe = {\n    id: 0,\n    a: items.ITEM_WATER,\n    b: items.ITEM_FIRE,\n    result: items.ITEM_STEAM,\n};\nexport const RECIPE_CREATE_LAVA: IRecipe = {\n    id: 1,\n    a: items.ITEM_EARTH,\n    b: items.ITEM_FIRE,\n    result: items.ITEM_LAVA,\n};\n\nexport const ALL_RECIPES: IRecipe[] = [\n    RECIPE_CREATE_STEAM,\n    RECIPE_CREATE_LAVA,\n];",
      "contentHash": "bb1510a4a63890f108feac3b1bcae6f14068e088cd8b7af99abd1b82f7063d2f",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IAirContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'air' */\nexport interface IAirContract extends IElementContract {\n}",
      "contentHash": "c0fc5f070d707fc91112a01e7ba77824051a95ca4be6e4147dfb9f4ffbf11f40",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IEarthContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'earth' */\nexport interface IEarthContract extends IElementContract {\n}",
      "contentHash": "fb149bb142e37a5c92d9e0db5bd67644e40e5838cd2fe6d90e775d492a9640c6",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IFireContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'fire' */\nexport interface IFireContract extends IElementContract {\n}",
      "contentHash": "5b672895e4966771a74ffa01f7f96263a252d701d7e959d28fe20dd2290d86c8",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ILavaContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'lava' */\nexport interface ILavaContract extends IElementContract {\n}",
      "contentHash": "f3dd7d9e8133fee4cc1db2d19e303c0bb9f27fb946118b13e0eac445f37d540c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/index.ts",
      "content": "export * from './IGameContract';\nexport * from './IWaterContract';\nexport * from './IFireContract';\nexport * from './IEarthContract';\nexport * from './IAirContract';\nexport * from './ISteamContract';\nexport * from './ILavaContract';\n",
      "contentHash": "d6a949ae059afd491625c2d65895c9cf57f322917c91380059d82f7950724887",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISteamContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'steam' */\nexport interface ISteamContract extends IElementContract {\n}",
      "contentHash": "d31169afa6fa23d3583eeb2b65196d001f2a106f10fcd766e936ffc3472c3de2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IWaterContract.ts",
      "content": "import { IElementContract } from \"./IElementContract\";\n/** PSP-22 compatible game smart contract for element 'water' */\nexport interface IWaterContract extends IElementContract {\n}",
      "contentHash": "1231aceef2afd0b7debaa19ca88d7261ae1fc43b73a20f0863908b54fca51580",
      "noWriteIfExists": false
    }
  ]
}