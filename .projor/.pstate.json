{
  "generatedSource": [
    {
      "filename": "Cargo.toml",
      "content": "[workspace]\n\nresolver = \"2\"\nmembers = [\n  \"packages/contract-water/src\",\n  \"packages/contract-fire/src\",\n  \"packages/contract-earth/src\",\n  \"packages/contract-air/src\",\n  \"packages/contract-steam/src\",\n  \"packages/contract-lava/src\",\n]\nexclude = [\n  \".cargo\",\n  \"target\"\n]\n\n[workspace.dependencies]\nink = { version = \"5.0.0\", default-features = false }",
      "contentHash": "be459cbccc3caf19458dc034ac1c7fea588d7ef55a2b788647d90c60c4f38b83",
      "noWriteIfExists": false
    },
    {
      "filename": "package.json",
      "content": "{\n  \"name\": \"@siocode/not-a-bird\",\n  \"version\": \"0.0.1\",\n  \"private\": true,\n  \"workspaces\": [\n    \"packages/*\"\n  ],\n  \"dependencies\": {\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\",\n    \"rxjs\": \"7.8.1\",\n    \"@polkadot/api\": \"11.0.2\",\n    \"@polkadot/api-contract\": \"11.0.2\",\n    \"leva\": \"0.9.35\",\n    \"@unique-nft/accounts\": \"^0.3.7\",\n    \"@unique-nft/sdk\": \"^0.7.4\"\n  },\n  \"devDependencies\": {\n    \"@types/react\": \"18.2.79\",\n    \"@types/react-dom\": \"18.2.25\",\n    \"chalk\": \"4\",\n    \"chokidar\": \"3.6.0\",\n    \"concurrently\": \"8.2.2\",\n    \"esbuild\": \"0.20.2\",\n    \"fs-extra\": \"11.2.0\",\n    \"sass\": \"1.75.0\",\n    \"typescript\": \"5.4.5\",\n    \"prettier\": \"^3.2.5\"\n  },\n  \"scripts\": {\n    \"build:water\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-water/src/Cargo.toml\",\n    \"build:fire\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-fire/src/Cargo.toml\",\n    \"build:earth\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-earth/src/Cargo.toml\",\n    \"build:air\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-air/src/Cargo.toml\",\n    \"build:steam\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-steam/src/Cargo.toml\",\n    \"build:lava\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-lava/src/Cargo.toml\",\n    \"build:contracts\": \"cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-water/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-fire/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-earth/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-air/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-steam/src/Cargo.toml && cargo contract build --optimization-passes 0 --generate all --manifest-path packages/contract-lava/src/Cargo.toml\",\n    \"build\": \"npm run -w @not-a-bird/app-game build\",\n    \"serve\": \"npm run -w @not-a-bird/app-game serve\"\n  }\n}",
      "contentHash": "5b7a9422ed63a1db42fb026015618cb8733309e7d27b078ba643752628ddf1bd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-air/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-air/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-air\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'air'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "e9655f46dd82755a4e38ce8d5625f1a5e36ab94ae454210c9369ccb1b04a5848",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-air/README.md",
      "content": "# air - Contract\n\nThis is a air contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "1ffa2e37292feb468d280b8616e0062a32e48cdfdeca123657db3a8f7215ed3c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-air/src/Cargo.toml",
      "content": "[package]\nname = \"air\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "c18c5b1484dc6cf565ce189432ca77e822e386dc35de008857b077c47641335a",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-air/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod air {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'air' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct AirContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for AirContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl AirContract {\n        /// Creates a new PSP-22 compatible Air Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Air\")\n        }\n\n        #[ink(message)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MAIR\")\n        }\n        \n        #[ink(message)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        #[ink(message)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            }\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            }\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "640cb96a02be6b8aef07194a314f3c5f1af9550d033a5cd7181bcf71dd47ba6c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-earth/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-earth/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-earth\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'earth'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "148c02fbca356ac90f5edd1de72f03b78a7b4cf602cceb490926b1ecc11c4ded",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-earth/README.md",
      "content": "# earth - Contract\n\nThis is a earth contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "9b504c2f0be8f658529c7f629dee7b1fbbbd9dc85bf7d697e8fde144a2a789f7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-earth/src/Cargo.toml",
      "content": "[package]\nname = \"earth\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "ca9d5007293a66afc8cdb1b691f90b51d9e8f2aa9ba074c730fa25ab1e456ca2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-earth/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod earth {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'earth' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct EarthContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for EarthContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl EarthContract {\n        /// Creates a new PSP-22 compatible Earth Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Earth\")\n        }\n\n        #[ink(message)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MEARTH\")\n        }\n        \n        #[ink(message)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        #[ink(message)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            }\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            }\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "b7f605ed8d9c0bcbdd916a35759aaa1b88848a658ca3f0201ea35f04afd5bde2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fire/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fire/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-fire\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'fire'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "3405f6a2335d729c1cd168a53d66e2de75acd64603186b9c82fa42bc796442dc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fire/README.md",
      "content": "# fire - Contract\n\nThis is a fire contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "f1262d7654055a0ec75222997c4397333c9a1dccfb732de7a55cef533bc89058",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fire/src/Cargo.toml",
      "content": "[package]\nname = \"fire\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "9520e61b9f13f56d2ba329c527b622fda115a62c838d3a98a45336964f2f38e2",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-fire/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod fire {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'fire' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct FireContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for FireContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl FireContract {\n        /// Creates a new PSP-22 compatible Fire Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Fire\")\n        }\n\n        #[ink(message)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MFIRE\")\n        }\n        \n        #[ink(message)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        #[ink(message)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            }\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            }\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "69d033a5ea2faf08b957cd984b30f09206ba9b30bb580ca087fef4778506f5dc",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lava/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lava/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-lava\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'lava'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "ff5cd696d66f0401b84905ebcda5d0906c213cb89f125d23ca2f4c9c5e5e709c",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lava/README.md",
      "content": "# lava - Contract\n\nThis is a lava contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "d73494ff86fb36e073389141d7e8ef5204479507eaf6a864a8d9755a4837b126",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lava/src/Cargo.toml",
      "content": "[package]\nname = \"lava\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "cf4e4458d2d341a7314d99f5f2bb600b3ecfb6d3ec4a650d0f7dd203873364c7",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-lava/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod lava {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'lava' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct LavaContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for LavaContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl LavaContract {\n        /// Creates a new PSP-22 compatible Lava Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Lava\")\n        }\n\n        #[ink(message)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MLAVA\")\n        }\n        \n        #[ink(message)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        #[ink(message)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            }\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            }\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "62de37f6a92fd92ca62c7c6b3a00ed5175f20fd1b69c929a5adde1f1fb8260ce",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-steam/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-steam/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-steam\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'steam'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "d1d5338bf2c97324ccbbd9a8b8908a78c00f68c292e1ffa9970ddb485e06a1f3",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-steam/README.md",
      "content": "# steam - Contract\n\nThis is a steam contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "e292c73fc97f0b5240e332791c64aa8cfcc5225dde80785e999385684518eab1",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-steam/src/Cargo.toml",
      "content": "[package]\nname = \"steam\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "2d3f08718a123afbdc37359cedcf6ef1d0508a8b2724d284dbfc2824fa6a95b9",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-steam/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod steam {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'steam' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct SteamContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for SteamContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl SteamContract {\n        /// Creates a new PSP-22 compatible Steam Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Steam\")\n        }\n\n        #[ink(message)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MSTEAM\")\n        }\n        \n        #[ink(message)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        #[ink(message)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            }\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            }\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "e85662dfb4d6648c707bb959950e16587afb723100a7e75978b3cf16021456de",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-water/.gitignore",
      "content": "target/",
      "contentHash": "91e32e7c7446da0e17ef5bc0a3a783065c4476613ea4a7c24dee14aa889c6ddd",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-water/package.json",
      "content": "{\n    \"name\": \"@not-a-bird/contract-water\",\n    \"description\": \"PSP-22 compatible game smart contract for element 'water'\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"dependencies\": {},\n    \"scripts\": {\n        \"build\": \"cargo contract build --target wasm --release --manifest-path src/Cargo.toml\"\n    }\n}",
      "contentHash": "73e554672fbc18b041d4a04e9907550b6689ab8baac63e60ca001740d5a15dd5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-water/README.md",
      "content": "# water - Contract\n\nThis is a water contract.\n\n### Quickstart\n\n- `npm run build`",
      "contentHash": "c200163fc1b429eb7c394da7d435ffcb2504ba7b69e88719fe6c060342b402d0",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-water/src/Cargo.toml",
      "content": "[package]\nname = \"water\"\nversion = \"0.0.1\"\nauthors = [\"SIOCODE Llc. <info@siocode.hu>\"]\nedition = \"2021\"\n\n[dependencies]\nink = { workspace = true }\n\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\"]\nink-as-dependency = []",
      "contentHash": "abfd355630ccda731ba36c9d63cb728037ba4c3557041154e1e23ed0202a2032",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/contract-water/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod water {\n    pub use ink::prelude::string::String;\n    pub use ink::storage::Mapping;\n\n    // Begin borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n    /// Event emitted when allowance by `owner` to `spender` changes.\n    #[ink::event]\n    pub struct PSP22Approval {\n        /// Account providing allowance.\n        #[ink(topic)]\n        pub owner: AccountId,\n        /// Allowance beneficiary.\n        #[ink(topic)]\n        pub spender: AccountId,\n        /// New allowance amount.\n        pub amount: u128,\n    }\n\n    /// Event emitted when transfer of tokens occurs.\n    #[ink::event]\n    pub struct PSP22Transfer {\n        /// Transfer sender. `None` in case of minting new tokens.\n        #[ink(topic)]\n        pub from: Option<AccountId>,\n        /// Transfer recipient. `None` in case of burning tokens.\n        #[ink(topic)]\n        pub to: Option<AccountId>,\n        /// Amount of tokens transferred (or minted/burned).\n        pub value: u128,\n    }\n    // End borrowed code: https://github.com/Cardinal-Cryptography/PSP22/blob/main/events.rs\n\n    /** Error type for PSP-22 compatible contract for element 'water' */\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        // Begin borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n        /// Custom error type for implementation-based errors.\n        Custom(String),\n        /// Returned when an account does not have enough tokens to complete the operation.\n        InsufficientBalance,\n        /// Returned if there is not enough allowance to complete the operation.\n        InsufficientAllowance,\n        // End borrowed code from https://github.com/Cardinal-Cryptography/PSP22/blob/main/errors.rs\n    }\n\n    #[ink(storage)]\n    pub struct WaterContract {\n        total_supply: u128,\n        balances: Mapping<AccountId, u128>,\n        allowances: Mapping<(AccountId, AccountId), u128>,\n        owner_account_id: AccountId,\n        owner_is_set: bool,\n        game_contract_id: AccountId,\n        game_contract_is_set: bool,\n    }\n\n    impl Default for WaterContract {\n        fn default() -> Self {\n            let balances = Mapping::new();\n            let allowances = Mapping::new();\n            Self {\n                total_supply: 0,\n                balances,\n                allowances,\n                owner_account_id: AccountId::from([0xFF; 32]),\n                owner_is_set: false,\n                game_contract_id: AccountId::from([0xFF; 32]),\n                game_contract_is_set: false,\n            }\n        }\n    }\n\n    impl WaterContract {\n        /// Creates a new PSP-22 compatible Water Element contract\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self::default()\n        }\n\n        #[ink(message)]\n        pub fn token_name(&self)-> String {\n            String::from(\"Water\")\n        }\n\n        #[ink(message)]\n        pub fn token_symbol(&self)-> String {\n            String::from(\"MWATER\")\n        }\n        \n        #[ink(message)]\n        pub fn token_decimals(&self)-> u8 {\n            0\n        }\n\n        #[ink(message)]\n        pub fn total_supply(&self) -> u128 {\n            self.total_supply\n        }\n\n        #[ink(message)]\n        pub fn balance_of(&self, owner: AccountId) -> u128 {\n            self.balances.get(owner).unwrap_or_default()\n        }\n        \n        #[ink(message)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        #[ink(message)]\n        pub fn claim_ownership(&mut self) -> Result<(), Error> {\n            if self.owner_is_set {\n                return Err(Error::Custom(String::from(\"Owner already set\")));\n            }\n            self.owner_account_id = self.env().caller();\n            self.owner_is_set = true;\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn lock_game_contract(&mut self, game_contract_id: AccountId) -> Result<(), Error> {\n            if self.game_contract_is_set {\n                return Err(Error::Custom(String::from(\"Game contract already set\")));\n            }\n            if self.owner_account_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the owner can lock the game contract\")));\n            }\n            self.game_contract_id = game_contract_id;\n            self.game_contract_is_set = true;\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn mint(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can mint tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?;\n            let to_balance = self.balances.get(owner).unwrap_or_default();\n            self.balances.insert(owner, &to_balance.checked_add(value).ok_or(Error::Custom(String::from(\"Overflow minting tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: None,\n                to: Some(owner),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn burn(&mut self, owner: AccountId, value: u128) -> Result<(), Error> {\n            if self.game_contract_id != self.env().caller() {\n                return Err(Error::Custom(String::from(\"Only the game contract can burn tokens\")));\n            }\n            let from_balance = self.balances.get(owner).unwrap_or_default();\n            if from_balance < value {\n                return Err(Error::Custom(String::from(\"Insufficient balance to burn tokens\")));\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?;\n            self.balances.insert(owner, &from_balance.checked_sub(value).ok_or(Error::Custom(String::from(\"Underflow burning tokens\")))?);\n            self.env().emit_event(PSP22Transfer {\n                from: Some(owner),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n\n    }\n\n}",
      "contentHash": "a6f13e83c76e5c5958a90193d40ec6848746a59da65f825e351a50b9f7b948f4",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IAirContract.ts",
      "content": "/** PSP-22 compatible game smart contract for element 'air' */\nexport interface IAirContract {\n    /** PSP-22 total_supply method */\n    totalSupply(): Promise<number>;\n\n    /** PSP-22 balance_of method */\n    balanceOf(owner: string): Promise<number>;\n\n    /** PSP-22 allowance method */\n    allowance(owner: string, spender: string): Promise<number>;\n\n    /** PSP-22 transfer method */\n    transfer(to: string, value: number, data: string): Promise<void>;\n\n    /** PSP-22 transfer_from method */\n    transferFrom(from: string, to: string, value: number, data: string): Promise<void>;\n\n    /** PSP-22 approve method */\n    approve(spender: string, value: number): Promise<void>;\n\n    /** PSP-22 increase_allowance method */\n    increaseAllowance(spender: string, deltaValue: number): Promise<void>;\n\n    /** PSP-22 decrease_allowance method */\n    decreaseAllowance(spender: string, deltaValue: number): Promise<void>;\n\n    /** PSP-22 Metadata token_name method */\n    tokenName(): Promise<string>;\n\n    /** PSP-22 Metadata token_symbol method */\n    tokenSymbol(): Promise<string>;\n\n    /** PSP-22 Metadata token_decimals method */\n    tokenDecimals(): Promise<number>;\n\n    /** Element Contract claim_ownership method */\n    claimOwnership(): Promise<void>;\n\n    /** Element Contract lock_game_contract method */\n    lockGameContract(gameContract: string): Promise<void>;\n}",
      "contentHash": "ca6f8ffbb012a5313b46ff479bfc643dcfef5336cab8efff749f79e5023463e5",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IEarthContract.ts",
      "content": "/** PSP-22 compatible game smart contract for element 'earth' */\nexport interface IEarthContract {\n    /** PSP-22 total_supply method */\n    totalSupply(): Promise<number>;\n\n    /** PSP-22 balance_of method */\n    balanceOf(owner: string): Promise<number>;\n\n    /** PSP-22 allowance method */\n    allowance(owner: string, spender: string): Promise<number>;\n\n    /** PSP-22 transfer method */\n    transfer(to: string, value: number, data: string): Promise<void>;\n\n    /** PSP-22 transfer_from method */\n    transferFrom(from: string, to: string, value: number, data: string): Promise<void>;\n\n    /** PSP-22 approve method */\n    approve(spender: string, value: number): Promise<void>;\n\n    /** PSP-22 increase_allowance method */\n    increaseAllowance(spender: string, deltaValue: number): Promise<void>;\n\n    /** PSP-22 decrease_allowance method */\n    decreaseAllowance(spender: string, deltaValue: number): Promise<void>;\n\n    /** PSP-22 Metadata token_name method */\n    tokenName(): Promise<string>;\n\n    /** PSP-22 Metadata token_symbol method */\n    tokenSymbol(): Promise<string>;\n\n    /** PSP-22 Metadata token_decimals method */\n    tokenDecimals(): Promise<number>;\n\n    /** Element Contract claim_ownership method */\n    claimOwnership(): Promise<void>;\n\n    /** Element Contract lock_game_contract method */\n    lockGameContract(gameContract: string): Promise<void>;\n}",
      "contentHash": "c19b2ea89c941fa2fc3c24413c50fc20790b7a727675edad6a9f4cb5012c8756",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IFireContract.ts",
      "content": "/** PSP-22 compatible game smart contract for element 'fire' */\nexport interface IFireContract {\n    /** PSP-22 total_supply method */\n    totalSupply(): Promise<number>;\n\n    /** PSP-22 balance_of method */\n    balanceOf(owner: string): Promise<number>;\n\n    /** PSP-22 allowance method */\n    allowance(owner: string, spender: string): Promise<number>;\n\n    /** PSP-22 transfer method */\n    transfer(to: string, value: number, data: string): Promise<void>;\n\n    /** PSP-22 transfer_from method */\n    transferFrom(from: string, to: string, value: number, data: string): Promise<void>;\n\n    /** PSP-22 approve method */\n    approve(spender: string, value: number): Promise<void>;\n\n    /** PSP-22 increase_allowance method */\n    increaseAllowance(spender: string, deltaValue: number): Promise<void>;\n\n    /** PSP-22 decrease_allowance method */\n    decreaseAllowance(spender: string, deltaValue: number): Promise<void>;\n\n    /** PSP-22 Metadata token_name method */\n    tokenName(): Promise<string>;\n\n    /** PSP-22 Metadata token_symbol method */\n    tokenSymbol(): Promise<string>;\n\n    /** PSP-22 Metadata token_decimals method */\n    tokenDecimals(): Promise<number>;\n\n    /** Element Contract claim_ownership method */\n    claimOwnership(): Promise<void>;\n\n    /** Element Contract lock_game_contract method */\n    lockGameContract(gameContract: string): Promise<void>;\n}",
      "contentHash": "36f2293e10fb93f0df07534f0f15acc788a0ac1c2c9d31133b5bb0216eeebded",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ILavaContract.ts",
      "content": "/** PSP-22 compatible game smart contract for element 'lava' */\nexport interface ILavaContract {\n    /** PSP-22 total_supply method */\n    totalSupply(): Promise<number>;\n\n    /** PSP-22 balance_of method */\n    balanceOf(owner: string): Promise<number>;\n\n    /** PSP-22 allowance method */\n    allowance(owner: string, spender: string): Promise<number>;\n\n    /** PSP-22 transfer method */\n    transfer(to: string, value: number, data: string): Promise<void>;\n\n    /** PSP-22 transfer_from method */\n    transferFrom(from: string, to: string, value: number, data: string): Promise<void>;\n\n    /** PSP-22 approve method */\n    approve(spender: string, value: number): Promise<void>;\n\n    /** PSP-22 increase_allowance method */\n    increaseAllowance(spender: string, deltaValue: number): Promise<void>;\n\n    /** PSP-22 decrease_allowance method */\n    decreaseAllowance(spender: string, deltaValue: number): Promise<void>;\n\n    /** PSP-22 Metadata token_name method */\n    tokenName(): Promise<string>;\n\n    /** PSP-22 Metadata token_symbol method */\n    tokenSymbol(): Promise<string>;\n\n    /** PSP-22 Metadata token_decimals method */\n    tokenDecimals(): Promise<number>;\n\n    /** Element Contract claim_ownership method */\n    claimOwnership(): Promise<void>;\n\n    /** Element Contract lock_game_contract method */\n    lockGameContract(gameContract: string): Promise<void>;\n}",
      "contentHash": "77be1648f8ca37e955c3cad87ef61a546a8b1b4ce8683547178a062f0c8c4551",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/index.ts",
      "content": "export * from './IGameContract';\nexport * from './IWaterContract';\nexport * from './IFireContract';\nexport * from './IEarthContract';\nexport * from './IAirContract';\nexport * from './ISteamContract';\nexport * from './ILavaContract';\n",
      "contentHash": "d6a949ae059afd491625c2d65895c9cf57f322917c91380059d82f7950724887",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/ISteamContract.ts",
      "content": "/** PSP-22 compatible game smart contract for element 'steam' */\nexport interface ISteamContract {\n    /** PSP-22 total_supply method */\n    totalSupply(): Promise<number>;\n\n    /** PSP-22 balance_of method */\n    balanceOf(owner: string): Promise<number>;\n\n    /** PSP-22 allowance method */\n    allowance(owner: string, spender: string): Promise<number>;\n\n    /** PSP-22 transfer method */\n    transfer(to: string, value: number, data: string): Promise<void>;\n\n    /** PSP-22 transfer_from method */\n    transferFrom(from: string, to: string, value: number, data: string): Promise<void>;\n\n    /** PSP-22 approve method */\n    approve(spender: string, value: number): Promise<void>;\n\n    /** PSP-22 increase_allowance method */\n    increaseAllowance(spender: string, deltaValue: number): Promise<void>;\n\n    /** PSP-22 decrease_allowance method */\n    decreaseAllowance(spender: string, deltaValue: number): Promise<void>;\n\n    /** PSP-22 Metadata token_name method */\n    tokenName(): Promise<string>;\n\n    /** PSP-22 Metadata token_symbol method */\n    tokenSymbol(): Promise<string>;\n\n    /** PSP-22 Metadata token_decimals method */\n    tokenDecimals(): Promise<number>;\n\n    /** Element Contract claim_ownership method */\n    claimOwnership(): Promise<void>;\n\n    /** Element Contract lock_game_contract method */\n    lockGameContract(gameContract: string): Promise<void>;\n}",
      "contentHash": "f367baa77910330dc627f99d166928ef2e23deae6e3d1e77bc5ec17c22fae618",
      "noWriteIfExists": false
    },
    {
      "filename": "packages/on-chain-game/src/contracts/IWaterContract.ts",
      "content": "/** PSP-22 compatible game smart contract for element 'water' */\nexport interface IWaterContract {\n    /** PSP-22 total_supply method */\n    totalSupply(): Promise<number>;\n\n    /** PSP-22 balance_of method */\n    balanceOf(owner: string): Promise<number>;\n\n    /** PSP-22 allowance method */\n    allowance(owner: string, spender: string): Promise<number>;\n\n    /** PSP-22 transfer method */\n    transfer(to: string, value: number, data: string): Promise<void>;\n\n    /** PSP-22 transfer_from method */\n    transferFrom(from: string, to: string, value: number, data: string): Promise<void>;\n\n    /** PSP-22 approve method */\n    approve(spender: string, value: number): Promise<void>;\n\n    /** PSP-22 increase_allowance method */\n    increaseAllowance(spender: string, deltaValue: number): Promise<void>;\n\n    /** PSP-22 decrease_allowance method */\n    decreaseAllowance(spender: string, deltaValue: number): Promise<void>;\n\n    /** PSP-22 Metadata token_name method */\n    tokenName(): Promise<string>;\n\n    /** PSP-22 Metadata token_symbol method */\n    tokenSymbol(): Promise<string>;\n\n    /** PSP-22 Metadata token_decimals method */\n    tokenDecimals(): Promise<number>;\n\n    /** Element Contract claim_ownership method */\n    claimOwnership(): Promise<void>;\n\n    /** Element Contract lock_game_contract method */\n    lockGameContract(gameContract: string): Promise<void>;\n}",
      "contentHash": "20ec2b07a2134421021478bc713d41543528e0ec5053d5c18ea348600ef8d929",
      "noWriteIfExists": false
    }
  ]
}